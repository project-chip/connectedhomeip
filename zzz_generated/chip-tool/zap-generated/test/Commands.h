/*
 *
 *    Copyright (c) 2022 Project CHIP Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

// THIS FILE IS GENERATED BY ZAP

#pragma once

#include <commands/common/CommandInvoker.h>
#include <commands/tests/TestCommand.h>
#include <lib/core/Optional.h>
#include <lib/support/CHIPListUtils.h>
#include <system/SystemClock.h>

#include <math.h> // For INFINITY

class TestList : public Command
{
public:
    TestList() : Command("list"){};
    CHIP_ERROR Run() override
    {
        printf("TestAccessControlCluster\n");
        printf("Test_TC_BI_1_1\n");
        printf("Test_TC_BI_2_1\n");
        printf("Test_TC_BI_2_2\n");
        printf("Test_TC_BOOL_1_1\n");
        printf("Test_TC_BOOL_2_1\n");
        printf("Test_TC_BRAC_1_1\n");
        printf("Test_TC_CC_1_1\n");
        printf("Test_TC_CC_2_1\n");
        printf("Test_TC_CC_3_1\n");
        printf("Test_TC_CC_3_2\n");
        printf("Test_TC_CC_3_3\n");
        printf("Test_TC_CC_4_1\n");
        printf("Test_TC_CC_4_2\n");
        printf("Test_TC_CC_4_3\n");
        printf("Test_TC_CC_4_4\n");
        printf("Test_TC_CC_5_1\n");
        printf("Test_TC_CC_5_2\n");
        printf("Test_TC_CC_5_3\n");
        printf("Test_TC_CC_6_1\n");
        printf("Test_TC_CC_6_2\n");
        printf("Test_TC_CC_6_3\n");
        printf("Test_TC_CC_7_1\n");
        printf("Test_TC_CC_7_2\n");
        printf("Test_TC_CC_7_3\n");
        printf("Test_TC_CC_7_4\n");
        printf("Test_TC_CC_8_1\n");
        printf("Test_TC_CC_9_1\n");
        printf("Test_TC_CC_9_2\n");
        printf("Test_TC_CC_9_3\n");
        printf("Test_TC_DM_1_1\n");
        printf("Test_TC_DM_3_1\n");
        printf("Test_TC_DM_2_2\n");
        printf("Test_TC_EMR_1_1\n");
        printf("Test_TC_ETHDIAG_1_1\n");
        printf("Test_TC_ETHDIAG_2_1\n");
        printf("Test_TC_FLW_1_1\n");
        printf("Test_TC_FLW_2_1\n");
        printf("Test_TC_FLW_2_2\n");
        printf("Test_TC_ILL_1_1\n");
        printf("Test_TC_LVL_1_1\n");
        printf("Test_TC_LVL_2_1\n");
        printf("Test_TC_LVL_2_2\n");
        printf("Test_TC_LVL_3_1\n");
        printf("Test_TC_LVL_4_1\n");
        printf("Test_TC_LVL_5_1\n");
        printf("Test_TC_LVL_6_1\n");
        printf("Test_TC_MC_1_1\n");
        printf("Test_TC_MC_2_1\n");
        printf("Test_TC_MC_3_1\n");
        printf("Test_TC_MC_3_2\n");
        printf("Test_TC_MC_3_3\n");
        printf("Test_TC_MC_3_4\n");
        printf("Test_TC_MC_3_5\n");
        printf("Test_TC_MC_3_6\n");
        printf("Test_TC_MC_3_7\n");
        printf("Test_TC_MC_3_8\n");
        printf("Test_TC_MC_3_9\n");
        printf("Test_TC_MC_3_10\n");
        printf("Test_TC_MC_3_11\n");
        printf("Test_TC_MC_5_1\n");
        printf("Test_TC_MC_5_2\n");
        printf("Test_TC_MC_5_3\n");
        printf("Test_TC_MC_6_1\n");
        printf("Test_TC_MC_6_2\n");
        printf("Test_TC_MC_6_3\n");
        printf("Test_TC_MC_6_4\n");
        printf("Test_TC_MC_7_1\n");
        printf("Test_TC_MC_7_2\n");
        printf("Test_TC_MC_8_1\n");
        printf("Test_TC_MC_9_1\n");
        printf("Test_TC_OCC_1_1\n");
        printf("Test_TC_OCC_2_1\n");
        printf("Test_TC_OCC_2_2\n");
        printf("Test_TC_OO_1_1\n");
        printf("Test_TC_OO_2_1\n");
        printf("Test_TC_OO_2_2\n");
        printf("Test_TC_OO_2_3\n");
        printf("Test_TC_PS_1_1\n");
        printf("Test_TC_PRS_1_1\n");
        printf("Test_TC_PRS_2_1\n");
        printf("Test_TC_PCC_1_1\n");
        printf("Test_TC_PCC_2_1\n");
        printf("Test_TC_PCC_2_2\n");
        printf("Test_TC_PCC_2_3\n");
        printf("Test_TC_RH_1_1\n");
        printf("Test_TC_RH_2_1\n");
        printf("Test_TC_RH_2_2\n");
        printf("Test_TC_SWTCH_2_1\n");
        printf("Test_TC_SWTCH_2_2\n");
        printf("Test_TC_TM_1_1\n");
        printf("Test_TC_TM_2_1\n");
        printf("Test_TC_TM_2_2\n");
        printf("Test_TC_TSTAT_1_1\n");
        printf("Test_TC_TSTAT_2_1\n");
        printf("Test_TC_TSTAT_2_2\n");
        printf("Test_TC_TSUIC_1_1\n");
        printf("Test_TC_TSUIC_2_1\n");
        printf("Test_TC_TSUIC_2_2\n");
        printf("Test_TC_DIAG_TH_NW_1_1\n");
        printf("Test_TC_WIFIDIAG_1_1\n");
        printf("Test_TC_WIFIDIAG_3_1\n");
        printf("Test_TC_WNCV_1_1\n");
        printf("Test_TC_WNCV_2_1\n");
        printf("Test_TC_WNCV_2_2\n");
        printf("Test_TC_WNCV_2_4\n");
        printf("Test_TC_WNCV_2_5\n");
        printf("Test_TC_WNCV_3_1\n");
        printf("Test_TC_WNCV_3_2\n");
        printf("Test_TC_WNCV_3_3\n");
        printf("Test_TC_WNCV_3_4\n");
        printf("Test_TC_WNCV_3_5\n");
        printf("Test_TC_WNCV_4_3\n");
        printf("Test_TC_WNCV_4_4\n");
        printf("TV_TargetNavigatorCluster\n");
        printf("TV_AudioOutputCluster\n");
        printf("TV_ApplicationLauncherCluster\n");
        printf("TV_KeypadInputCluster\n");
        printf("TV_AccountLoginCluster\n");
        printf("TV_WakeOnLanCluster\n");
        printf("TV_ApplicationBasicCluster\n");
        printf("TV_MediaPlaybackCluster\n");
        printf("TV_ChannelCluster\n");
        printf("TV_LowPowerCluster\n");
        printf("TV_ContentLauncherCluster\n");
        printf("TV_MediaInputCluster\n");
        printf("TestCluster\n");
        printf("TestClusterComplexTypes\n");
        printf("TestConstraints\n");
        printf("TestDelayCommands\n");
        printf("TestDiscovery\n");
        printf("TestLogCommands\n");
        printf("TestSaveAs\n");
        printf("TestConfigVariables\n");
        printf("TestDescriptorCluster\n");
        printf("TestBasicInformation\n");
        printf("TestIdentifyCluster\n");
        printf("TestOperationalCredentialsCluster\n");
        printf("TestModeSelectCluster\n");
        printf("TestSystemCommands\n");
        printf("TestBinding\n");
        printf("Test_TC_SWDIAG_1_1\n");
        printf("Test_TC_SWDIAG_2_1\n");
        printf("Test_TC_SWDIAG_3_1\n");
        printf("TestSubscribe_OnOff\n");
        printf("DL_UsersAndCredentials\n");
        printf("DL_LockUnlock\n");
        printf("DL_Schedules\n");
        printf("TestGroupMessaging\n");
        printf("TestGroupsCluster\n");
        printf("TestGroupKeyManagementCluster\n");

        return CHIP_NO_ERROR;
    }
};

class ManualTestList : public Command
{
public:
    ManualTestList() : Command("list-manual"){};
    CHIP_ERROR Run() override
    {
        printf("Test_TC_DD_1_5\n");
        printf("Test_TC_DD_1_6\n");
        printf("Test_TC_DD_1_7\n");
        printf("Test_TC_DD_1_8\n");
        printf("Test_TC_DD_1_9\n");
        printf("Test_TC_DD_1_10\n");
        printf("Test_TC_DD_2_1\n");
        printf("Test_TC_DD_2_2\n");
        printf("Test_TC_DD_3_1\n");
        printf("Test_TC_DD_3_2\n");
        printf("Test_TC_DD_3_5\n");
        printf("Test_TC_DD_3_6\n");
        printf("Test_TC_DD_3_9\n");
        printf("Test_TC_DD_3_10\n");
        printf("Test_TC_DD_4_1\n");
        printf("TestGroupDemoCommand\n");
        printf("TestGroupDemoConfig\n");
        printf("Test_TC_BDX_1_1\n");
        printf("Test_TC_BDX_1_2\n");
        printf("Test_TC_BDX_1_3\n");
        printf("Test_TC_BDX_1_5\n");
        printf("Test_TC_BDX_1_6\n");
        printf("Test_TC_BDX_2_1\n");
        printf("Test_TC_BDX_2_2\n");
        printf("Test_TC_BDX_2_3\n");
        printf("Test_TC_BDX_2_4\n");
        printf("Test_TC_BDX_2_5\n");
        printf("Test_TC_BR_1\n");
        printf("Test_TC_BR_2\n");
        printf("Test_TC_BR_3\n");
        printf("Test_TC_BRAC_2_1\n");
        printf("Test_TC_BRAC_2_2\n");
        printf("Test_TC_DM_1_2\n");
        printf("Test_TC_DM_2_3\n");
        printf("Test_TC_DM_3_2\n");
        printf("Test_TC_DIAG_LOG_1_1\n");
        printf("Test_TC_DIAG_LOG_1_2\n");
        printf("Test_TC_DIAG_LOG_1_3\n");
        printf("Test_TC_DESC_1_1\n");
        printf("Test_TC_ETHDIAG_1_2\n");
        printf("Test_TC_GC_1_1\n");
        printf("Test_TC_GC_1_2\n");
        printf("Test_TC_GC_1_3\n");
        printf("Test_TC_GENDIAG_1_1\n");
        printf("Test_TC_GENDIAG_1_2\n");
        printf("Test_TC_I_1_1\n");
        printf("Test_TC_I_2_1\n");
        printf("Test_TC_I_2_2\n");
        printf("Test_TC_I_2_3\n");
        printf("Test_TC_ILL_2_1\n");
        printf("Test_TC_IDM_1_1\n");
        printf("Test_TC_IDM_1_2\n");
        printf("Test_TC_IDM_2_1\n");
        printf("Test_TC_IDM_2_2\n");
        printf("Test_TC_IDM_3_1\n");
        printf("Test_TC_IDM_3_2\n");
        printf("Test_TC_IDM_4_1\n");
        printf("Test_TC_IDM_4_2\n");
        printf("Test_TC_IDM_5_1\n");
        printf("Test_TC_IDM_5_2\n");
        printf("Test_TC_IDM_6_1\n");
        printf("Test_TC_IDM_6_2\n");
        printf("Test_TC_MC_3_12\n");
        printf("Test_TC_MC_4_1\n");
        printf("Test_TC_MC_8_2\n");
        printf("Test_TC_MC_9_2\n");
        printf("Test_TC_MC_10_1\n");
        printf("Test_TC_MC_10_2\n");
        printf("Test_TC_MC_10_3\n");
        printf("Test_TC_MC_10_4\n");
        printf("Test_TC_MC_10_5\n");
        printf("Test_TC_MC_10_6\n");
        printf("Test_TC_MF_1_1\n");
        printf("Test_TC_MF_1_2\n");
        printf("Test_TC_MF_1_3\n");
        printf("Test_TC_MF_1_4\n");
        printf("Test_TC_MF_1_5\n");
        printf("Test_TC_MF_1_6\n");
        printf("Test_TC_MF_1_7\n");
        printf("Test_TC_MF_1_8\n");
        printf("Test_TC_MF_1_9\n");
        printf("Test_TC_MF_1_10\n");
        printf("Test_TC_MF_1_11\n");
        printf("Test_TC_MF_1_12\n");
        printf("Test_TC_MF_1_13\n");
        printf("Test_TC_MF_1_14\n");
        printf("Test_TC_MF_1_15\n");
        printf("Test_TC_MF_1_16\n");
        printf("Test_TC_MF_1_17\n");
        printf("Test_TC_MF_1_18\n");
        printf("Test_TC_MF_1_19\n");
        printf("Test_TC_MF_1_20\n");
        printf("Test_TC_MF_1_21\n");
        printf("Test_TC_MF_1_22\n");
        printf("Test_TC_MF_1_23\n");
        printf("Test_TC_MF_1_24\n");
        printf("Test_TC_MOD_1_1\n");
        printf("Test_TC_MOD_1_2\n");
        printf("Test_TC_MOD_2_1\n");
        printf("Test_TC_SU_1_1\n");
        printf("Test_TC_SU_2_1\n");
        printf("Test_TC_SU_2_2\n");
        printf("Test_TC_SU_2_3\n");
        printf("Test_TC_SU_2_4\n");
        printf("Test_TC_SU_2_5\n");
        printf("Test_TC_SU_2_6\n");
        printf("Test_TC_SU_2_7\n");
        printf("Test_TC_SU_3_1\n");
        printf("Test_TC_SU_3_2\n");
        printf("Test_TC_SU_3_3\n");
        printf("Test_TC_SU_3_4\n");
        printf("Test_TC_PSCFG_1_1\n");
        printf("Test_TC_PSCFG_2_1\n");
        printf("Test_TC_SC_4_5\n");
        printf("Test_TC_SC_4_6\n");
        printf("Test_TC_SC_4_7\n");
        printf("Test_TC_SC_4_8\n");
        printf("Test_TC_SC_4_9\n");
        printf("Test_TC_SWDIAG_1_2\n");
        printf("Test_TC_WIFIDIAG_1_2\n");
        printf("Test_TC_WIFIDIAG_2_1\n");
        printf("Test_TC_WNCV_2_3\n");

        return CHIP_NO_ERROR;
    }
};

class TestAccessControlClusterSuite : public TestCommand
{
public:
    TestAccessControlClusterSuite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("TestAccessControlCluster", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~TestAccessControlClusterSuite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestAccessControlCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestAccessControlCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for commissionee\n");
            err = TestWaitForCommissionee_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Write three entries\n");
            err = TestWriteThreeEntries_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read three entries\n");
            err = TestReadThreeEntries_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Write two entries\n");
            err = TestWriteTwoEntries_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Read two entries\n");
            err = TestReadTwoEntries_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Write one entry\n");
            err = TestWriteOneEntry_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Read one entry\n");
            err = TestReadOneEntry_6();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 7;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_1(void * context, CHIP_ERROR error)
    {
        (static_cast<TestAccessControlClusterSuite *>(context))->OnFailureResponse_1(error);
    }

    static void OnSuccessCallback_1(void * context)
    {
        (static_cast<TestAccessControlClusterSuite *>(context))->OnSuccessResponse_1();
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<TestAccessControlClusterSuite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(
        void * context,
        const chip::app::DataModel::DecodableList<chip::app::Clusters::AccessControl::Structs::AccessControlEntry::DecodableType> &
            acl)
    {
        (static_cast<TestAccessControlClusterSuite *>(context))->OnSuccessResponse_2(acl);
    }

    static void OnFailureCallback_3(void * context, CHIP_ERROR error)
    {
        (static_cast<TestAccessControlClusterSuite *>(context))->OnFailureResponse_3(error);
    }

    static void OnSuccessCallback_3(void * context)
    {
        (static_cast<TestAccessControlClusterSuite *>(context))->OnSuccessResponse_3();
    }

    static void OnFailureCallback_4(void * context, CHIP_ERROR error)
    {
        (static_cast<TestAccessControlClusterSuite *>(context))->OnFailureResponse_4(error);
    }

    static void OnSuccessCallback_4(
        void * context,
        const chip::app::DataModel::DecodableList<chip::app::Clusters::AccessControl::Structs::AccessControlEntry::DecodableType> &
            acl)
    {
        (static_cast<TestAccessControlClusterSuite *>(context))->OnSuccessResponse_4(acl);
    }

    static void OnFailureCallback_5(void * context, CHIP_ERROR error)
    {
        (static_cast<TestAccessControlClusterSuite *>(context))->OnFailureResponse_5(error);
    }

    static void OnSuccessCallback_5(void * context)
    {
        (static_cast<TestAccessControlClusterSuite *>(context))->OnSuccessResponse_5();
    }

    static void OnFailureCallback_6(void * context, CHIP_ERROR error)
    {
        (static_cast<TestAccessControlClusterSuite *>(context))->OnFailureResponse_6(error);
    }

    static void OnSuccessCallback_6(
        void * context,
        const chip::app::DataModel::DecodableList<chip::app::Clusters::AccessControl::Structs::AccessControlEntry::DecodableType> &
            acl)
    {
        (static_cast<TestAccessControlClusterSuite *>(context))->OnSuccessResponse_6(acl);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForCommissionee_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestWriteThreeEntries_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        chip::Controller::AccessControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ListFreer listFreer;
        chip::app::DataModel::List<const chip::app::Clusters::AccessControl::Structs::AccessControlEntry::Type> aclArgument;

        {
            auto * listHolder_0 = new ListHolder<chip::app::Clusters::AccessControl::Structs::AccessControlEntry::Type>(3);
            listFreer.add(listHolder_0);

            listHolder_0->mList[0].fabricIndex = 0;
            listHolder_0->mList[0].privilege   = static_cast<chip::app::Clusters::AccessControl::Privilege>(5);
            listHolder_0->mList[0].authMode    = static_cast<chip::app::Clusters::AccessControl::AuthMode>(2);
            listHolder_0->mList[0].subjects.SetNull();
            listHolder_0->mList[0].targets.SetNonNull();

            {
                auto * listHolder_3 = new ListHolder<chip::app::Clusters::AccessControl::Structs::Target::Type>(3);
                listFreer.add(listHolder_3);

                listHolder_3->mList[0].cluster.SetNull();
                listHolder_3->mList[0].endpoint.SetNonNull();
                listHolder_3->mList[0].endpoint.Value() = 0U;
                listHolder_3->mList[0].deviceType.SetNull();

                listHolder_3->mList[1].cluster.SetNonNull();
                listHolder_3->mList[1].cluster.Value() = 1UL;
                listHolder_3->mList[1].endpoint.SetNull();
                listHolder_3->mList[1].deviceType.SetNull();

                listHolder_3->mList[2].cluster.SetNonNull();
                listHolder_3->mList[2].cluster.Value() = 2UL;
                listHolder_3->mList[2].endpoint.SetNonNull();
                listHolder_3->mList[2].endpoint.Value() = 3U;
                listHolder_3->mList[2].deviceType.SetNull();

                listHolder_0->mList[0].targets.Value() =
                    chip::app::DataModel::List<chip::app::Clusters::AccessControl::Structs::Target::Type>(listHolder_3->mList, 3);
            }

            listHolder_0->mList[1].fabricIndex = 0;
            listHolder_0->mList[1].privilege   = static_cast<chip::app::Clusters::AccessControl::Privilege>(1);
            listHolder_0->mList[1].authMode    = static_cast<chip::app::Clusters::AccessControl::AuthMode>(2);
            listHolder_0->mList[1].subjects.SetNonNull();

            {
                auto * listHolder_3 = new ListHolder<uint64_t>(4);
                listFreer.add(listHolder_3);
                listHolder_3->mList[0]                  = 1234ULL;
                listHolder_3->mList[1]                  = 5678ULL;
                listHolder_3->mList[2]                  = 32896ULL;
                listHolder_3->mList[3]                  = 65535ULL;
                listHolder_0->mList[1].subjects.Value() = chip::app::DataModel::List<uint64_t>(listHolder_3->mList, 4);
            }
            listHolder_0->mList[1].targets.SetNonNull();

            {
                auto * listHolder_3 = new ListHolder<chip::app::Clusters::AccessControl::Structs::Target::Type>(3);
                listFreer.add(listHolder_3);

                listHolder_3->mList[0].cluster.SetNull();
                listHolder_3->mList[0].endpoint.SetNonNull();
                listHolder_3->mList[0].endpoint.Value() = 1U;
                listHolder_3->mList[0].deviceType.SetNull();

                listHolder_3->mList[1].cluster.SetNonNull();
                listHolder_3->mList[1].cluster.Value() = 2UL;
                listHolder_3->mList[1].endpoint.SetNull();
                listHolder_3->mList[1].deviceType.SetNull();

                listHolder_3->mList[2].cluster.SetNonNull();
                listHolder_3->mList[2].cluster.Value() = 3UL;
                listHolder_3->mList[2].endpoint.SetNonNull();
                listHolder_3->mList[2].endpoint.Value() = 4U;
                listHolder_3->mList[2].deviceType.SetNull();

                listHolder_0->mList[1].targets.Value() =
                    chip::app::DataModel::List<chip::app::Clusters::AccessControl::Structs::Target::Type>(listHolder_3->mList, 3);
            }

            listHolder_0->mList[2].fabricIndex = 0;
            listHolder_0->mList[2].privilege   = static_cast<chip::app::Clusters::AccessControl::Privilege>(3);
            listHolder_0->mList[2].authMode    = static_cast<chip::app::Clusters::AccessControl::AuthMode>(3);
            listHolder_0->mList[2].subjects.SetNonNull();

            {
                auto * listHolder_3 = new ListHolder<uint64_t>(4);
                listFreer.add(listHolder_3);
                listHolder_3->mList[0]                  = 257ULL;
                listHolder_3->mList[1]                  = 258ULL;
                listHolder_3->mList[2]                  = 43690ULL;
                listHolder_3->mList[3]                  = 48059ULL;
                listHolder_0->mList[2].subjects.Value() = chip::app::DataModel::List<uint64_t>(listHolder_3->mList, 4);
            }
            listHolder_0->mList[2].targets.SetNonNull();

            {
                auto * listHolder_3 = new ListHolder<chip::app::Clusters::AccessControl::Structs::Target::Type>(3);
                listFreer.add(listHolder_3);

                listHolder_3->mList[0].cluster.SetNull();
                listHolder_3->mList[0].endpoint.SetNonNull();
                listHolder_3->mList[0].endpoint.Value() = 2U;
                listHolder_3->mList[0].deviceType.SetNull();

                listHolder_3->mList[1].cluster.SetNonNull();
                listHolder_3->mList[1].cluster.Value() = 3UL;
                listHolder_3->mList[1].endpoint.SetNull();
                listHolder_3->mList[1].deviceType.SetNull();

                listHolder_3->mList[2].cluster.SetNonNull();
                listHolder_3->mList[2].cluster.Value() = 4UL;
                listHolder_3->mList[2].endpoint.SetNonNull();
                listHolder_3->mList[2].endpoint.Value() = 5U;
                listHolder_3->mList[2].deviceType.SetNull();

                listHolder_0->mList[2].targets.Value() =
                    chip::app::DataModel::List<chip::app::Clusters::AccessControl::Structs::Target::Type>(listHolder_3->mList, 3);
            }

            aclArgument = chip::app::DataModel::List<chip::app::Clusters::AccessControl::Structs::AccessControlEntry::Type>(
                listHolder_0->mList, 3);
        }

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::AccessControl::Attributes::Acl::TypeInfo>(
            aclArgument, this, OnSuccessCallback_1, OnFailureCallback_1));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestReadThreeEntries_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        chip::Controller::AccessControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::AccessControl::Attributes::Acl::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2(
        const chip::app::DataModel::DecodableList<chip::app::Clusters::AccessControl::Structs::AccessControlEntry::DecodableType> &
            acl)
    {
        {
            auto iter_0 = acl.begin();
            VerifyOrReturn(CheckNextListItemDecodes<decltype(acl)>("acl", iter_0, 0));
            VerifyOrReturn(CheckValue("acl[0].fabricIndex", iter_0.GetValue().fabricIndex, 1));
            VerifyOrReturn(CheckValue("acl[0].privilege", iter_0.GetValue().privilege, 5));
            VerifyOrReturn(CheckValue("acl[0].authMode", iter_0.GetValue().authMode, 2));
            VerifyOrReturn(CheckValueNull("acl[0].subjects", iter_0.GetValue().subjects));
            VerifyOrReturn(CheckValueNonNull("acl[0].targets", iter_0.GetValue().targets));
            {
                auto iter_NaN = iter_0.GetValue().targets.Value().begin();
                VerifyOrReturn(
                    CheckNextListItemDecodes<decltype(iter_0.GetValue().targets.Value())>("acl[0].targets.Value()", iter_NaN, 0));
                VerifyOrReturn(CheckValueNull("acl[0].targets.Value()[0].cluster", iter_NaN.GetValue().cluster));
                VerifyOrReturn(CheckValueNonNull("acl[0].targets.Value()[0].endpoint", iter_NaN.GetValue().endpoint));
                VerifyOrReturn(CheckValue("acl[0].targets.Value()[0].endpoint.Value()", iter_NaN.GetValue().endpoint.Value(), 0U));
                VerifyOrReturn(CheckValueNull("acl[0].targets.Value()[0].deviceType", iter_NaN.GetValue().deviceType));
                VerifyOrReturn(
                    CheckNextListItemDecodes<decltype(iter_0.GetValue().targets.Value())>("acl[0].targets.Value()", iter_NaN, 1));
                VerifyOrReturn(CheckValueNonNull("acl[0].targets.Value()[1].cluster", iter_NaN.GetValue().cluster));
                VerifyOrReturn(CheckValue("acl[0].targets.Value()[1].cluster.Value()", iter_NaN.GetValue().cluster.Value(), 1UL));
                VerifyOrReturn(CheckValueNull("acl[0].targets.Value()[1].endpoint", iter_NaN.GetValue().endpoint));
                VerifyOrReturn(CheckValueNull("acl[0].targets.Value()[1].deviceType", iter_NaN.GetValue().deviceType));
                VerifyOrReturn(
                    CheckNextListItemDecodes<decltype(iter_0.GetValue().targets.Value())>("acl[0].targets.Value()", iter_NaN, 2));
                VerifyOrReturn(CheckValueNonNull("acl[0].targets.Value()[2].cluster", iter_NaN.GetValue().cluster));
                VerifyOrReturn(CheckValue("acl[0].targets.Value()[2].cluster.Value()", iter_NaN.GetValue().cluster.Value(), 2UL));
                VerifyOrReturn(CheckValueNonNull("acl[0].targets.Value()[2].endpoint", iter_NaN.GetValue().endpoint));
                VerifyOrReturn(CheckValue("acl[0].targets.Value()[2].endpoint.Value()", iter_NaN.GetValue().endpoint.Value(), 3U));
                VerifyOrReturn(CheckValueNull("acl[0].targets.Value()[2].deviceType", iter_NaN.GetValue().deviceType));
                VerifyOrReturn(
                    CheckNoMoreListItems<decltype(iter_0.GetValue().targets.Value())>("acl[0].targets.Value()", iter_NaN, 3));
            }
            VerifyOrReturn(CheckNextListItemDecodes<decltype(acl)>("acl", iter_0, 1));
            VerifyOrReturn(CheckValue("acl[1].fabricIndex", iter_0.GetValue().fabricIndex, 1));
            VerifyOrReturn(CheckValue("acl[1].privilege", iter_0.GetValue().privilege, 1));
            VerifyOrReturn(CheckValue("acl[1].authMode", iter_0.GetValue().authMode, 2));
            VerifyOrReturn(CheckValueNonNull("acl[1].subjects", iter_0.GetValue().subjects));
            {
                auto iter_NaN = iter_0.GetValue().subjects.Value().begin();
                VerifyOrReturn(
                    CheckNextListItemDecodes<decltype(iter_0.GetValue().subjects.Value())>("acl[1].subjects.Value()", iter_NaN, 0));
                VerifyOrReturn(CheckValue("acl[1].subjects.Value()[0]", iter_NaN.GetValue(), 1234ULL));
                VerifyOrReturn(
                    CheckNextListItemDecodes<decltype(iter_0.GetValue().subjects.Value())>("acl[1].subjects.Value()", iter_NaN, 1));
                VerifyOrReturn(CheckValue("acl[1].subjects.Value()[1]", iter_NaN.GetValue(), 5678ULL));
                VerifyOrReturn(
                    CheckNextListItemDecodes<decltype(iter_0.GetValue().subjects.Value())>("acl[1].subjects.Value()", iter_NaN, 2));
                VerifyOrReturn(CheckValue("acl[1].subjects.Value()[2]", iter_NaN.GetValue(), 32896ULL));
                VerifyOrReturn(
                    CheckNextListItemDecodes<decltype(iter_0.GetValue().subjects.Value())>("acl[1].subjects.Value()", iter_NaN, 3));
                VerifyOrReturn(CheckValue("acl[1].subjects.Value()[3]", iter_NaN.GetValue(), 65535ULL));
                VerifyOrReturn(
                    CheckNoMoreListItems<decltype(iter_0.GetValue().subjects.Value())>("acl[1].subjects.Value()", iter_NaN, 4));
            }
            VerifyOrReturn(CheckValueNonNull("acl[1].targets", iter_0.GetValue().targets));
            {
                auto iter_NaN = iter_0.GetValue().targets.Value().begin();
                VerifyOrReturn(
                    CheckNextListItemDecodes<decltype(iter_0.GetValue().targets.Value())>("acl[1].targets.Value()", iter_NaN, 0));
                VerifyOrReturn(CheckValueNull("acl[1].targets.Value()[0].cluster", iter_NaN.GetValue().cluster));
                VerifyOrReturn(CheckValueNonNull("acl[1].targets.Value()[0].endpoint", iter_NaN.GetValue().endpoint));
                VerifyOrReturn(CheckValue("acl[1].targets.Value()[0].endpoint.Value()", iter_NaN.GetValue().endpoint.Value(), 1U));
                VerifyOrReturn(CheckValueNull("acl[1].targets.Value()[0].deviceType", iter_NaN.GetValue().deviceType));
                VerifyOrReturn(
                    CheckNextListItemDecodes<decltype(iter_0.GetValue().targets.Value())>("acl[1].targets.Value()", iter_NaN, 1));
                VerifyOrReturn(CheckValueNonNull("acl[1].targets.Value()[1].cluster", iter_NaN.GetValue().cluster));
                VerifyOrReturn(CheckValue("acl[1].targets.Value()[1].cluster.Value()", iter_NaN.GetValue().cluster.Value(), 2UL));
                VerifyOrReturn(CheckValueNull("acl[1].targets.Value()[1].endpoint", iter_NaN.GetValue().endpoint));
                VerifyOrReturn(CheckValueNull("acl[1].targets.Value()[1].deviceType", iter_NaN.GetValue().deviceType));
                VerifyOrReturn(
                    CheckNextListItemDecodes<decltype(iter_0.GetValue().targets.Value())>("acl[1].targets.Value()", iter_NaN, 2));
                VerifyOrReturn(CheckValueNonNull("acl[1].targets.Value()[2].cluster", iter_NaN.GetValue().cluster));
                VerifyOrReturn(CheckValue("acl[1].targets.Value()[2].cluster.Value()", iter_NaN.GetValue().cluster.Value(), 3UL));
                VerifyOrReturn(CheckValueNonNull("acl[1].targets.Value()[2].endpoint", iter_NaN.GetValue().endpoint));
                VerifyOrReturn(CheckValue("acl[1].targets.Value()[2].endpoint.Value()", iter_NaN.GetValue().endpoint.Value(), 4U));
                VerifyOrReturn(CheckValueNull("acl[1].targets.Value()[2].deviceType", iter_NaN.GetValue().deviceType));
                VerifyOrReturn(
                    CheckNoMoreListItems<decltype(iter_0.GetValue().targets.Value())>("acl[1].targets.Value()", iter_NaN, 3));
            }
            VerifyOrReturn(CheckNextListItemDecodes<decltype(acl)>("acl", iter_0, 2));
            VerifyOrReturn(CheckValue("acl[2].fabricIndex", iter_0.GetValue().fabricIndex, 1));
            VerifyOrReturn(CheckValue("acl[2].privilege", iter_0.GetValue().privilege, 3));
            VerifyOrReturn(CheckValue("acl[2].authMode", iter_0.GetValue().authMode, 3));
            VerifyOrReturn(CheckValueNonNull("acl[2].subjects", iter_0.GetValue().subjects));
            {
                auto iter_NaN = iter_0.GetValue().subjects.Value().begin();
                VerifyOrReturn(
                    CheckNextListItemDecodes<decltype(iter_0.GetValue().subjects.Value())>("acl[2].subjects.Value()", iter_NaN, 0));
                VerifyOrReturn(CheckValue("acl[2].subjects.Value()[0]", iter_NaN.GetValue(), 257ULL));
                VerifyOrReturn(
                    CheckNextListItemDecodes<decltype(iter_0.GetValue().subjects.Value())>("acl[2].subjects.Value()", iter_NaN, 1));
                VerifyOrReturn(CheckValue("acl[2].subjects.Value()[1]", iter_NaN.GetValue(), 258ULL));
                VerifyOrReturn(
                    CheckNextListItemDecodes<decltype(iter_0.GetValue().subjects.Value())>("acl[2].subjects.Value()", iter_NaN, 2));
                VerifyOrReturn(CheckValue("acl[2].subjects.Value()[2]", iter_NaN.GetValue(), 43690ULL));
                VerifyOrReturn(
                    CheckNextListItemDecodes<decltype(iter_0.GetValue().subjects.Value())>("acl[2].subjects.Value()", iter_NaN, 3));
                VerifyOrReturn(CheckValue("acl[2].subjects.Value()[3]", iter_NaN.GetValue(), 48059ULL));
                VerifyOrReturn(
                    CheckNoMoreListItems<decltype(iter_0.GetValue().subjects.Value())>("acl[2].subjects.Value()", iter_NaN, 4));
            }
            VerifyOrReturn(CheckValueNonNull("acl[2].targets", iter_0.GetValue().targets));
            {
                auto iter_NaN = iter_0.GetValue().targets.Value().begin();
                VerifyOrReturn(
                    CheckNextListItemDecodes<decltype(iter_0.GetValue().targets.Value())>("acl[2].targets.Value()", iter_NaN, 0));
                VerifyOrReturn(CheckValueNull("acl[2].targets.Value()[0].cluster", iter_NaN.GetValue().cluster));
                VerifyOrReturn(CheckValueNonNull("acl[2].targets.Value()[0].endpoint", iter_NaN.GetValue().endpoint));
                VerifyOrReturn(CheckValue("acl[2].targets.Value()[0].endpoint.Value()", iter_NaN.GetValue().endpoint.Value(), 2U));
                VerifyOrReturn(CheckValueNull("acl[2].targets.Value()[0].deviceType", iter_NaN.GetValue().deviceType));
                VerifyOrReturn(
                    CheckNextListItemDecodes<decltype(iter_0.GetValue().targets.Value())>("acl[2].targets.Value()", iter_NaN, 1));
                VerifyOrReturn(CheckValueNonNull("acl[2].targets.Value()[1].cluster", iter_NaN.GetValue().cluster));
                VerifyOrReturn(CheckValue("acl[2].targets.Value()[1].cluster.Value()", iter_NaN.GetValue().cluster.Value(), 3UL));
                VerifyOrReturn(CheckValueNull("acl[2].targets.Value()[1].endpoint", iter_NaN.GetValue().endpoint));
                VerifyOrReturn(CheckValueNull("acl[2].targets.Value()[1].deviceType", iter_NaN.GetValue().deviceType));
                VerifyOrReturn(
                    CheckNextListItemDecodes<decltype(iter_0.GetValue().targets.Value())>("acl[2].targets.Value()", iter_NaN, 2));
                VerifyOrReturn(CheckValueNonNull("acl[2].targets.Value()[2].cluster", iter_NaN.GetValue().cluster));
                VerifyOrReturn(CheckValue("acl[2].targets.Value()[2].cluster.Value()", iter_NaN.GetValue().cluster.Value(), 4UL));
                VerifyOrReturn(CheckValueNonNull("acl[2].targets.Value()[2].endpoint", iter_NaN.GetValue().endpoint));
                VerifyOrReturn(CheckValue("acl[2].targets.Value()[2].endpoint.Value()", iter_NaN.GetValue().endpoint.Value(), 5U));
                VerifyOrReturn(CheckValueNull("acl[2].targets.Value()[2].deviceType", iter_NaN.GetValue().deviceType));
                VerifyOrReturn(
                    CheckNoMoreListItems<decltype(iter_0.GetValue().targets.Value())>("acl[2].targets.Value()", iter_NaN, 3));
            }
            VerifyOrReturn(CheckNoMoreListItems<decltype(acl)>("acl", iter_0, 3));
        }

        NextTest();
    }

    CHIP_ERROR TestWriteTwoEntries_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        chip::Controller::AccessControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ListFreer listFreer;
        chip::app::DataModel::List<const chip::app::Clusters::AccessControl::Structs::AccessControlEntry::Type> aclArgument;

        {
            auto * listHolder_0 = new ListHolder<chip::app::Clusters::AccessControl::Structs::AccessControlEntry::Type>(2);
            listFreer.add(listHolder_0);

            listHolder_0->mList[0].fabricIndex = 0;
            listHolder_0->mList[0].privilege   = static_cast<chip::app::Clusters::AccessControl::Privilege>(5);
            listHolder_0->mList[0].authMode    = static_cast<chip::app::Clusters::AccessControl::AuthMode>(2);
            listHolder_0->mList[0].subjects.SetNull();
            listHolder_0->mList[0].targets.SetNonNull();

            {
                auto * listHolder_3 = new ListHolder<chip::app::Clusters::AccessControl::Structs::Target::Type>(3);
                listFreer.add(listHolder_3);

                listHolder_3->mList[0].cluster.SetNull();
                listHolder_3->mList[0].endpoint.SetNonNull();
                listHolder_3->mList[0].endpoint.Value() = 0U;
                listHolder_3->mList[0].deviceType.SetNull();

                listHolder_3->mList[1].cluster.SetNonNull();
                listHolder_3->mList[1].cluster.Value() = 1UL;
                listHolder_3->mList[1].endpoint.SetNull();
                listHolder_3->mList[1].deviceType.SetNull();

                listHolder_3->mList[2].cluster.SetNonNull();
                listHolder_3->mList[2].cluster.Value() = 2UL;
                listHolder_3->mList[2].endpoint.SetNonNull();
                listHolder_3->mList[2].endpoint.Value() = 3U;
                listHolder_3->mList[2].deviceType.SetNull();

                listHolder_0->mList[0].targets.Value() =
                    chip::app::DataModel::List<chip::app::Clusters::AccessControl::Structs::Target::Type>(listHolder_3->mList, 3);
            }

            listHolder_0->mList[1].fabricIndex = 0;
            listHolder_0->mList[1].privilege   = static_cast<chip::app::Clusters::AccessControl::Privilege>(1);
            listHolder_0->mList[1].authMode    = static_cast<chip::app::Clusters::AccessControl::AuthMode>(2);
            listHolder_0->mList[1].subjects.SetNonNull();

            {
                auto * listHolder_3 = new ListHolder<uint64_t>(2);
                listFreer.add(listHolder_3);
                listHolder_3->mList[0]                  = 52428ULL;
                listHolder_3->mList[1]                  = 56797ULL;
                listHolder_0->mList[1].subjects.Value() = chip::app::DataModel::List<uint64_t>(listHolder_3->mList, 2);
            }
            listHolder_0->mList[1].targets.SetNonNull();

            {
                auto * listHolder_3 = new ListHolder<chip::app::Clusters::AccessControl::Structs::Target::Type>(1);
                listFreer.add(listHolder_3);

                listHolder_3->mList[0].cluster.SetNonNull();
                listHolder_3->mList[0].cluster.Value() = 5UL;
                listHolder_3->mList[0].endpoint.SetNonNull();
                listHolder_3->mList[0].endpoint.Value() = 6U;
                listHolder_3->mList[0].deviceType.SetNull();

                listHolder_0->mList[1].targets.Value() =
                    chip::app::DataModel::List<chip::app::Clusters::AccessControl::Structs::Target::Type>(listHolder_3->mList, 1);
            }

            aclArgument = chip::app::DataModel::List<chip::app::Clusters::AccessControl::Structs::AccessControlEntry::Type>(
                listHolder_0->mList, 2);
        }

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::AccessControl::Attributes::Acl::TypeInfo>(
            aclArgument, this, OnSuccessCallback_3, OnFailureCallback_3));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestReadTwoEntries_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        chip::Controller::AccessControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::AccessControl::Attributes::Acl::TypeInfo>(
            this, OnSuccessCallback_4, OnFailureCallback_4, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_4(
        const chip::app::DataModel::DecodableList<chip::app::Clusters::AccessControl::Structs::AccessControlEntry::DecodableType> &
            acl)
    {
        {
            auto iter_0 = acl.begin();
            VerifyOrReturn(CheckNextListItemDecodes<decltype(acl)>("acl", iter_0, 0));
            VerifyOrReturn(CheckValue("acl[0].fabricIndex", iter_0.GetValue().fabricIndex, 1));
            VerifyOrReturn(CheckValue("acl[0].privilege", iter_0.GetValue().privilege, 5));
            VerifyOrReturn(CheckValue("acl[0].authMode", iter_0.GetValue().authMode, 2));
            VerifyOrReturn(CheckValueNull("acl[0].subjects", iter_0.GetValue().subjects));
            VerifyOrReturn(CheckValueNonNull("acl[0].targets", iter_0.GetValue().targets));
            {
                auto iter_NaN = iter_0.GetValue().targets.Value().begin();
                VerifyOrReturn(
                    CheckNextListItemDecodes<decltype(iter_0.GetValue().targets.Value())>("acl[0].targets.Value()", iter_NaN, 0));
                VerifyOrReturn(CheckValueNull("acl[0].targets.Value()[0].cluster", iter_NaN.GetValue().cluster));
                VerifyOrReturn(CheckValueNonNull("acl[0].targets.Value()[0].endpoint", iter_NaN.GetValue().endpoint));
                VerifyOrReturn(CheckValue("acl[0].targets.Value()[0].endpoint.Value()", iter_NaN.GetValue().endpoint.Value(), 0U));
                VerifyOrReturn(CheckValueNull("acl[0].targets.Value()[0].deviceType", iter_NaN.GetValue().deviceType));
                VerifyOrReturn(
                    CheckNextListItemDecodes<decltype(iter_0.GetValue().targets.Value())>("acl[0].targets.Value()", iter_NaN, 1));
                VerifyOrReturn(CheckValueNonNull("acl[0].targets.Value()[1].cluster", iter_NaN.GetValue().cluster));
                VerifyOrReturn(CheckValue("acl[0].targets.Value()[1].cluster.Value()", iter_NaN.GetValue().cluster.Value(), 1UL));
                VerifyOrReturn(CheckValueNull("acl[0].targets.Value()[1].endpoint", iter_NaN.GetValue().endpoint));
                VerifyOrReturn(CheckValueNull("acl[0].targets.Value()[1].deviceType", iter_NaN.GetValue().deviceType));
                VerifyOrReturn(
                    CheckNextListItemDecodes<decltype(iter_0.GetValue().targets.Value())>("acl[0].targets.Value()", iter_NaN, 2));
                VerifyOrReturn(CheckValueNonNull("acl[0].targets.Value()[2].cluster", iter_NaN.GetValue().cluster));
                VerifyOrReturn(CheckValue("acl[0].targets.Value()[2].cluster.Value()", iter_NaN.GetValue().cluster.Value(), 2UL));
                VerifyOrReturn(CheckValueNonNull("acl[0].targets.Value()[2].endpoint", iter_NaN.GetValue().endpoint));
                VerifyOrReturn(CheckValue("acl[0].targets.Value()[2].endpoint.Value()", iter_NaN.GetValue().endpoint.Value(), 3U));
                VerifyOrReturn(CheckValueNull("acl[0].targets.Value()[2].deviceType", iter_NaN.GetValue().deviceType));
                VerifyOrReturn(
                    CheckNoMoreListItems<decltype(iter_0.GetValue().targets.Value())>("acl[0].targets.Value()", iter_NaN, 3));
            }
            VerifyOrReturn(CheckNextListItemDecodes<decltype(acl)>("acl", iter_0, 1));
            VerifyOrReturn(CheckValue("acl[1].fabricIndex", iter_0.GetValue().fabricIndex, 1));
            VerifyOrReturn(CheckValue("acl[1].privilege", iter_0.GetValue().privilege, 1));
            VerifyOrReturn(CheckValue("acl[1].authMode", iter_0.GetValue().authMode, 2));
            VerifyOrReturn(CheckValueNonNull("acl[1].subjects", iter_0.GetValue().subjects));
            {
                auto iter_NaN = iter_0.GetValue().subjects.Value().begin();
                VerifyOrReturn(
                    CheckNextListItemDecodes<decltype(iter_0.GetValue().subjects.Value())>("acl[1].subjects.Value()", iter_NaN, 0));
                VerifyOrReturn(CheckValue("acl[1].subjects.Value()[0]", iter_NaN.GetValue(), 52428ULL));
                VerifyOrReturn(
                    CheckNextListItemDecodes<decltype(iter_0.GetValue().subjects.Value())>("acl[1].subjects.Value()", iter_NaN, 1));
                VerifyOrReturn(CheckValue("acl[1].subjects.Value()[1]", iter_NaN.GetValue(), 56797ULL));
                VerifyOrReturn(
                    CheckNoMoreListItems<decltype(iter_0.GetValue().subjects.Value())>("acl[1].subjects.Value()", iter_NaN, 2));
            }
            VerifyOrReturn(CheckValueNonNull("acl[1].targets", iter_0.GetValue().targets));
            {
                auto iter_NaN = iter_0.GetValue().targets.Value().begin();
                VerifyOrReturn(
                    CheckNextListItemDecodes<decltype(iter_0.GetValue().targets.Value())>("acl[1].targets.Value()", iter_NaN, 0));
                VerifyOrReturn(CheckValueNonNull("acl[1].targets.Value()[0].cluster", iter_NaN.GetValue().cluster));
                VerifyOrReturn(CheckValue("acl[1].targets.Value()[0].cluster.Value()", iter_NaN.GetValue().cluster.Value(), 5UL));
                VerifyOrReturn(CheckValueNonNull("acl[1].targets.Value()[0].endpoint", iter_NaN.GetValue().endpoint));
                VerifyOrReturn(CheckValue("acl[1].targets.Value()[0].endpoint.Value()", iter_NaN.GetValue().endpoint.Value(), 6U));
                VerifyOrReturn(CheckValueNull("acl[1].targets.Value()[0].deviceType", iter_NaN.GetValue().deviceType));
                VerifyOrReturn(
                    CheckNoMoreListItems<decltype(iter_0.GetValue().targets.Value())>("acl[1].targets.Value()", iter_NaN, 1));
            }
            VerifyOrReturn(CheckNoMoreListItems<decltype(acl)>("acl", iter_0, 2));
        }

        NextTest();
    }

    CHIP_ERROR TestWriteOneEntry_5()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        chip::Controller::AccessControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ListFreer listFreer;
        chip::app::DataModel::List<const chip::app::Clusters::AccessControl::Structs::AccessControlEntry::Type> aclArgument;

        {
            auto * listHolder_0 = new ListHolder<chip::app::Clusters::AccessControl::Structs::AccessControlEntry::Type>(1);
            listFreer.add(listHolder_0);

            listHolder_0->mList[0].fabricIndex = 0;
            listHolder_0->mList[0].privilege   = static_cast<chip::app::Clusters::AccessControl::Privilege>(5);
            listHolder_0->mList[0].authMode    = static_cast<chip::app::Clusters::AccessControl::AuthMode>(2);
            listHolder_0->mList[0].subjects.SetNull();
            listHolder_0->mList[0].targets.SetNull();

            aclArgument = chip::app::DataModel::List<chip::app::Clusters::AccessControl::Structs::AccessControlEntry::Type>(
                listHolder_0->mList, 1);
        }

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::AccessControl::Attributes::Acl::TypeInfo>(
            aclArgument, this, OnSuccessCallback_5, OnFailureCallback_5));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_5() { NextTest(); }

    CHIP_ERROR TestReadOneEntry_6()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        chip::Controller::AccessControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::AccessControl::Attributes::Acl::TypeInfo>(
            this, OnSuccessCallback_6, OnFailureCallback_6, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_6(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_6(
        const chip::app::DataModel::DecodableList<chip::app::Clusters::AccessControl::Structs::AccessControlEntry::DecodableType> &
            acl)
    {
        {
            auto iter_0 = acl.begin();
            VerifyOrReturn(CheckNextListItemDecodes<decltype(acl)>("acl", iter_0, 0));
            VerifyOrReturn(CheckValue("acl[0].fabricIndex", iter_0.GetValue().fabricIndex, 1));
            VerifyOrReturn(CheckValue("acl[0].privilege", iter_0.GetValue().privilege, 5));
            VerifyOrReturn(CheckValue("acl[0].authMode", iter_0.GetValue().authMode, 2));
            VerifyOrReturn(CheckValueNull("acl[0].subjects", iter_0.GetValue().subjects));
            VerifyOrReturn(CheckValueNull("acl[0].targets", iter_0.GetValue().targets));
            VerifyOrReturn(CheckNoMoreListItems<decltype(acl)>("acl", iter_0, 1));
        }

        NextTest();
    }
};

class Test_TC_BI_1_1Suite : public TestCommand
{
public:
    Test_TC_BI_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_BI_1_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_BI_1_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_BI_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_BI_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : read the global attribute: ClusterRevision\n");
            err = TestReadTheGlobalAttributeClusterRevision_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read the global attribute constraints: ClusterRevision\n");
            err = TestReadTheGlobalAttributeConstraintsClusterRevision_2();
            break;
        case 3:
            ChipLogProgress(chipTool,
                            " ***** Test Step 3 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : reads back global attribute: ClusterRevision\n");
            err = TestReadsBackGlobalAttributeClusterRevision_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Read the global attribute: AttributeList\n");
            err = TestReadTheGlobalAttributeAttributeList_5();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 6;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_1(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_BI_1_1Suite *>(context))->OnFailureResponse_1(error);
    }

    static void OnSuccessCallback_1(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_BI_1_1Suite *>(context))->OnSuccessResponse_1(clusterRevision);
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_BI_1_1Suite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_BI_1_1Suite *>(context))->OnSuccessResponse_2(clusterRevision);
    }

    static void OnFailureCallback_3(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_BI_1_1Suite *>(context))->OnFailureResponse_3(error);
    }

    static void OnSuccessCallback_3(void * context) { (static_cast<Test_TC_BI_1_1Suite *>(context))->OnSuccessResponse_3(); }

    static void OnFailureCallback_4(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_BI_1_1Suite *>(context))->OnFailureResponse_4(error);
    }

    static void OnSuccessCallback_4(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_BI_1_1Suite *>(context))->OnSuccessResponse_4(clusterRevision);
    }

    static void OnFailureCallback_5(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_BI_1_1Suite *>(context))->OnFailureResponse_5(error);
    }

    static void OnSuccessCallback_5(void * context, const chip::app::DataModel::DecodableList<chip::AttributeId> & attributeList)
    {
        (static_cast<Test_TC_BI_1_1Suite *>(context))->OnSuccessResponse_5(attributeList);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestReadTheGlobalAttributeClusterRevision_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::BinaryInputBasic::Attributes::ClusterRevision::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckValue("clusterRevision", clusterRevision, 1U));

        NextTest();
    }

    CHIP_ERROR TestReadTheGlobalAttributeConstraintsClusterRevision_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::BinaryInputBasic::Attributes::ClusterRevision::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckConstraintType("clusterRevision", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t clusterRevisionArgument;
        clusterRevisionArgument = 1U;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::BinaryInputBasic::Attributes::ClusterRevision::TypeInfo>(
            clusterRevisionArgument, this, OnSuccessCallback_3, OnFailureCallback_3));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_3() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackGlobalAttributeClusterRevision_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::BinaryInputBasic::Attributes::ClusterRevision::TypeInfo>(
            this, OnSuccessCallback_4, OnFailureCallback_4, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_4(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckValue("clusterRevision", clusterRevision, 1U));

        NextTest();
    }

    CHIP_ERROR TestReadTheGlobalAttributeAttributeList_5()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::BinaryInputBasic::Attributes::AttributeList::TypeInfo>(
            this, OnSuccessCallback_5, OnFailureCallback_5, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_5(const chip::app::DataModel::DecodableList<chip::AttributeId> & attributeList)
    {
        VerifyOrReturn(CheckConstraintType("attributeList", "", "list"));
        NextTest();
    }
};

class Test_TC_BI_2_1Suite : public TestCommand
{
public:
    Test_TC_BI_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_BI_2_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_BI_2_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_BI_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_BI_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read mandatory non-global attribute: OutOfService\n");
            err = TestReadMandatoryNonGlobalAttributeOutOfService_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read mandatory non-global attribute constraints: OutOfService\n");
            err = TestReadMandatoryNonGlobalAttributeConstraintsOutOfService_2();
            break;
        case 3:
            ChipLogProgress(chipTool,
                            " ***** Test Step 3 : Write the default values to mandatory non-global attribute: OutOfService\n");
            err = TestWriteTheDefaultValuesToMandatoryNonGlobalAttributeOutOfService_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Reads back the mandatory non-global attribute: OutOfService\n");
            err = TestReadsBackTheMandatoryNonGlobalAttributeOutOfService_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Read mandatory non-global attribute constraints: PresentValue\n");
            err = TestReadMandatoryNonGlobalAttributeConstraintsPresentValue_5();
            break;
        case 6:
            ChipLogProgress(chipTool,
                            " ***** Test Step 6 : Write the default values to mandatory non-global attribute: PresentValue\n");
            err = TestWriteTheDefaultValuesToMandatoryNonGlobalAttributePresentValue_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Reads back the mandatory non-global attribute: PresentValue\n");
            err = TestReadsBackTheMandatoryNonGlobalAttributePresentValue_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Read mandatory non-global attribute: StatusFlags\n");
            err = TestReadMandatoryNonGlobalAttributeStatusFlags_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Read mandatory non-global attribute constraints: StatusFlags\n");
            err = TestReadMandatoryNonGlobalAttributeConstraintsStatusFlags_9();
            break;
        case 10:
            ChipLogProgress(chipTool,
                            " ***** Test Step 10 : Write the default values to mandatory non-global attribute: StatusFlags\n");
            err = TestWriteTheDefaultValuesToMandatoryNonGlobalAttributeStatusFlags_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : Reads back the mandatory non-global attribute: StatusFlags\n");
            err = TestReadsBackTheMandatoryNonGlobalAttributeStatusFlags_11();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 12;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_1(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_BI_2_1Suite *>(context))->OnFailureResponse_1(error);
    }

    static void OnSuccessCallback_1(void * context, bool outOfService)
    {
        (static_cast<Test_TC_BI_2_1Suite *>(context))->OnSuccessResponse_1(outOfService);
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_BI_2_1Suite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context, bool outOfService)
    {
        (static_cast<Test_TC_BI_2_1Suite *>(context))->OnSuccessResponse_2(outOfService);
    }

    static void OnFailureCallback_3(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_BI_2_1Suite *>(context))->OnFailureResponse_3(error);
    }

    static void OnSuccessCallback_3(void * context) { (static_cast<Test_TC_BI_2_1Suite *>(context))->OnSuccessResponse_3(); }

    static void OnFailureCallback_4(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_BI_2_1Suite *>(context))->OnFailureResponse_4(error);
    }

    static void OnSuccessCallback_4(void * context, bool outOfService)
    {
        (static_cast<Test_TC_BI_2_1Suite *>(context))->OnSuccessResponse_4(outOfService);
    }

    static void OnFailureCallback_5(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_BI_2_1Suite *>(context))->OnFailureResponse_5(error);
    }

    static void OnSuccessCallback_5(void * context, bool presentValue)
    {
        (static_cast<Test_TC_BI_2_1Suite *>(context))->OnSuccessResponse_5(presentValue);
    }

    static void OnFailureCallback_6(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_BI_2_1Suite *>(context))->OnFailureResponse_6(error);
    }

    static void OnSuccessCallback_6(void * context) { (static_cast<Test_TC_BI_2_1Suite *>(context))->OnSuccessResponse_6(); }

    static void OnFailureCallback_7(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_BI_2_1Suite *>(context))->OnFailureResponse_7(error);
    }

    static void OnSuccessCallback_7(void * context, bool presentValue)
    {
        (static_cast<Test_TC_BI_2_1Suite *>(context))->OnSuccessResponse_7(presentValue);
    }

    static void OnFailureCallback_8(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_BI_2_1Suite *>(context))->OnFailureResponse_8(error);
    }

    static void OnSuccessCallback_8(void * context, uint8_t statusFlags)
    {
        (static_cast<Test_TC_BI_2_1Suite *>(context))->OnSuccessResponse_8(statusFlags);
    }

    static void OnFailureCallback_9(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_BI_2_1Suite *>(context))->OnFailureResponse_9(error);
    }

    static void OnSuccessCallback_9(void * context, uint8_t statusFlags)
    {
        (static_cast<Test_TC_BI_2_1Suite *>(context))->OnSuccessResponse_9(statusFlags);
    }

    static void OnFailureCallback_10(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_BI_2_1Suite *>(context))->OnFailureResponse_10(error);
    }

    static void OnSuccessCallback_10(void * context) { (static_cast<Test_TC_BI_2_1Suite *>(context))->OnSuccessResponse_10(); }

    static void OnFailureCallback_11(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_BI_2_1Suite *>(context))->OnFailureResponse_11(error);
    }

    static void OnSuccessCallback_11(void * context, uint8_t statusFlags)
    {
        (static_cast<Test_TC_BI_2_1Suite *>(context))->OnSuccessResponse_11(statusFlags);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestReadMandatoryNonGlobalAttributeOutOfService_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::BinaryInputBasic::Attributes::OutOfService::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1(bool outOfService)
    {
        VerifyOrReturn(CheckValue("outOfService", outOfService, 0));

        NextTest();
    }

    CHIP_ERROR TestReadMandatoryNonGlobalAttributeConstraintsOutOfService_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::BinaryInputBasic::Attributes::OutOfService::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2(bool outOfService)
    {
        VerifyOrReturn(CheckConstraintType("outOfService", "", "bool"));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryNonGlobalAttributeOutOfService_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        bool outOfServiceArgument;
        outOfServiceArgument = 0;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::BinaryInputBasic::Attributes::OutOfService::TypeInfo>(
            outOfServiceArgument, this, OnSuccessCallback_3, OnFailureCallback_3));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestReadsBackTheMandatoryNonGlobalAttributeOutOfService_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::BinaryInputBasic::Attributes::OutOfService::TypeInfo>(
            this, OnSuccessCallback_4, OnFailureCallback_4, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_4(bool outOfService)
    {
        VerifyOrReturn(CheckValue("outOfService", outOfService, 0));

        NextTest();
    }

    CHIP_ERROR TestReadMandatoryNonGlobalAttributeConstraintsPresentValue_5()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::BinaryInputBasic::Attributes::PresentValue::TypeInfo>(
            this, OnSuccessCallback_5, OnFailureCallback_5, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_5(bool presentValue)
    {
        VerifyOrReturn(CheckConstraintType("presentValue", "", "bool"));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryNonGlobalAttributePresentValue_6()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        bool presentValueArgument;
        presentValueArgument = 0;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::BinaryInputBasic::Attributes::PresentValue::TypeInfo>(
            presentValueArgument, this, OnSuccessCallback_6, OnFailureCallback_6));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_6(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_6() { NextTest(); }

    CHIP_ERROR TestReadsBackTheMandatoryNonGlobalAttributePresentValue_7()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::BinaryInputBasic::Attributes::PresentValue::TypeInfo>(
            this, OnSuccessCallback_7, OnFailureCallback_7, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_7(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_7(bool presentValue)
    {
        VerifyOrReturn(CheckValue("presentValue", presentValue, 0));

        NextTest();
    }

    CHIP_ERROR TestReadMandatoryNonGlobalAttributeStatusFlags_8()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::BinaryInputBasic::Attributes::StatusFlags::TypeInfo>(
            this, OnSuccessCallback_8, OnFailureCallback_8, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_8(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_8(uint8_t statusFlags)
    {
        VerifyOrReturn(CheckValue("statusFlags", statusFlags, 0));

        NextTest();
    }

    CHIP_ERROR TestReadMandatoryNonGlobalAttributeConstraintsStatusFlags_9()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::BinaryInputBasic::Attributes::StatusFlags::TypeInfo>(
            this, OnSuccessCallback_9, OnFailureCallback_9, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_9(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_9(uint8_t statusFlags)
    {
        VerifyOrReturn(CheckConstraintType("statusFlags", "", "map8"));
        VerifyOrReturn(CheckConstraintMinValue<uint8_t>("statusFlags", statusFlags, 0));
        VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("statusFlags", statusFlags, 15));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryNonGlobalAttributeStatusFlags_10()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t statusFlagsArgument;
        statusFlagsArgument = 0;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::BinaryInputBasic::Attributes::StatusFlags::TypeInfo>(
            statusFlagsArgument, this, OnSuccessCallback_10, OnFailureCallback_10));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_10(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_10() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackTheMandatoryNonGlobalAttributeStatusFlags_11()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::BinaryInputBasic::Attributes::StatusFlags::TypeInfo>(
            this, OnSuccessCallback_11, OnFailureCallback_11, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_11(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_11(uint8_t statusFlags)
    {
        VerifyOrReturn(CheckValue("statusFlags", statusFlags, 0));

        NextTest();
    }
};

class Test_TC_BI_2_2Suite : public TestCommand
{
public:
    Test_TC_BI_2_2Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_BI_2_2", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_BI_2_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_BI_2_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_BI_2_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Reads PresentValue attribute from DUT\n");
            if (ShouldSkip("A_PRESENTVALUE"))
            {
                NextTest();
                return;
            }
            err = TestReadsPresentValueAttributeFromDut_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Reads OutOfService attribute from DUT\n");
            if (ShouldSkip("A_OUTOFSERVICE"))
            {
                NextTest();
                return;
            }
            err = TestReadsOutOfServiceAttributeFromDut_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Reads StatusFlags attribute from DUT\n");
            if (ShouldSkip("A_STATUSFLAGS"))
            {
                NextTest();
                return;
            }
            err = TestReadsStatusFlagsAttributeFromDut_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Reads PresentValue attribute from DUT\n");
            if (ShouldSkip("A_PRESENTVALUE"))
            {
                NextTest();
                return;
            }
            err = TestReadsPresentValueAttributeFromDut_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Reads OutOfService attribute from DUT\n");
            if (ShouldSkip("A_OUTOFSERVICE"))
            {
                NextTest();
                return;
            }
            err = TestReadsOutOfServiceAttributeFromDut_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Reads StatusFlags attribute from DUT\n");
            if (ShouldSkip("A_STATUSFLAGS"))
            {
                NextTest();
                return;
            }
            err = TestReadsStatusFlagsAttributeFromDut_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Reads StatusFlags attribute from DUT\n");
            if (ShouldSkip("A_STATUSFLAGS"))
            {
                NextTest();
                return;
            }
            err = TestReadsStatusFlagsAttributeFromDut_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Reads StatusFlags attribute from DUT\n");
            if (ShouldSkip("A_STATUSFLAGS"))
            {
                NextTest();
                return;
            }
            err = TestReadsStatusFlagsAttributeFromDut_8();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 9;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_1(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_BI_2_2Suite *>(context))->OnFailureResponse_1(error);
    }

    static void OnSuccessCallback_1(void * context, bool presentValue)
    {
        (static_cast<Test_TC_BI_2_2Suite *>(context))->OnSuccessResponse_1(presentValue);
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_BI_2_2Suite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context, bool outOfService)
    {
        (static_cast<Test_TC_BI_2_2Suite *>(context))->OnSuccessResponse_2(outOfService);
    }

    static void OnFailureCallback_3(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_BI_2_2Suite *>(context))->OnFailureResponse_3(error);
    }

    static void OnSuccessCallback_3(void * context, uint8_t statusFlags)
    {
        (static_cast<Test_TC_BI_2_2Suite *>(context))->OnSuccessResponse_3(statusFlags);
    }

    static void OnFailureCallback_4(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_BI_2_2Suite *>(context))->OnFailureResponse_4(error);
    }

    static void OnSuccessCallback_4(void * context, bool presentValue)
    {
        (static_cast<Test_TC_BI_2_2Suite *>(context))->OnSuccessResponse_4(presentValue);
    }

    static void OnFailureCallback_5(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_BI_2_2Suite *>(context))->OnFailureResponse_5(error);
    }

    static void OnSuccessCallback_5(void * context, bool outOfService)
    {
        (static_cast<Test_TC_BI_2_2Suite *>(context))->OnSuccessResponse_5(outOfService);
    }

    static void OnFailureCallback_6(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_BI_2_2Suite *>(context))->OnFailureResponse_6(error);
    }

    static void OnSuccessCallback_6(void * context, uint8_t statusFlags)
    {
        (static_cast<Test_TC_BI_2_2Suite *>(context))->OnSuccessResponse_6(statusFlags);
    }

    static void OnFailureCallback_7(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_BI_2_2Suite *>(context))->OnFailureResponse_7(error);
    }

    static void OnSuccessCallback_7(void * context, uint8_t statusFlags)
    {
        (static_cast<Test_TC_BI_2_2Suite *>(context))->OnSuccessResponse_7(statusFlags);
    }

    static void OnFailureCallback_8(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_BI_2_2Suite *>(context))->OnFailureResponse_8(error);
    }

    static void OnSuccessCallback_8(void * context, uint8_t statusFlags)
    {
        (static_cast<Test_TC_BI_2_2Suite *>(context))->OnSuccessResponse_8(statusFlags);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestReadsPresentValueAttributeFromDut_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::BinaryInputBasic::Attributes::PresentValue::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1(bool presentValue)
    {
        VerifyOrReturn(CheckValue("presentValue", presentValue, 0));

        NextTest();
    }

    CHIP_ERROR TestReadsOutOfServiceAttributeFromDut_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::BinaryInputBasic::Attributes::OutOfService::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2(bool outOfService)
    {
        VerifyOrReturn(CheckValue("outOfService", outOfService, 0));

        NextTest();
    }

    CHIP_ERROR TestReadsStatusFlagsAttributeFromDut_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::BinaryInputBasic::Attributes::StatusFlags::TypeInfo>(
            this, OnSuccessCallback_3, OnFailureCallback_3, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3(uint8_t statusFlags)
    {
        VerifyOrReturn(CheckValue("statusFlags", statusFlags, 0));

        NextTest();
    }

    CHIP_ERROR TestReadsPresentValueAttributeFromDut_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::BinaryInputBasic::Attributes::PresentValue::TypeInfo>(
            this, OnSuccessCallback_4, OnFailureCallback_4, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_4(bool presentValue)
    {
        VerifyOrReturn(CheckValue("presentValue", presentValue, 0));

        NextTest();
    }

    CHIP_ERROR TestReadsOutOfServiceAttributeFromDut_5()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::BinaryInputBasic::Attributes::OutOfService::TypeInfo>(
            this, OnSuccessCallback_5, OnFailureCallback_5, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_5(bool outOfService)
    {
        VerifyOrReturn(CheckValue("outOfService", outOfService, 0));

        NextTest();
    }

    CHIP_ERROR TestReadsStatusFlagsAttributeFromDut_6()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::BinaryInputBasic::Attributes::StatusFlags::TypeInfo>(
            this, OnSuccessCallback_6, OnFailureCallback_6, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_6(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_6(uint8_t statusFlags)
    {
        VerifyOrReturn(CheckValue("statusFlags", statusFlags, 0));

        NextTest();
    }

    CHIP_ERROR TestReadsStatusFlagsAttributeFromDut_7()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::BinaryInputBasic::Attributes::StatusFlags::TypeInfo>(
            this, OnSuccessCallback_7, OnFailureCallback_7, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_7(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_7(uint8_t statusFlags)
    {
        VerifyOrReturn(CheckValue("statusFlags", statusFlags, 0));

        NextTest();
    }

    CHIP_ERROR TestReadsStatusFlagsAttributeFromDut_8()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::BinaryInputBasic::Attributes::StatusFlags::TypeInfo>(
            this, OnSuccessCallback_8, OnFailureCallback_8, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_8(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_8(uint8_t statusFlags)
    {
        VerifyOrReturn(CheckValue("statusFlags", statusFlags, 0));

        NextTest();
    }
};

class Test_TC_BOOL_1_1Suite : public TestCommand
{
public:
    Test_TC_BOOL_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_BOOL_1_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_BOOL_1_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_BOOL_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_BOOL_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : read the global attribute: ClusterRevision\n");
            err = TestReadTheGlobalAttributeClusterRevision_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read the global attribute constraints: ClusterRevision\n");
            err = TestReadTheGlobalAttributeConstraintsClusterRevision_2();
            break;
        case 3:
            ChipLogProgress(chipTool,
                            " ***** Test Step 3 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : reads back global attribute: ClusterRevision\n");
            err = TestReadsBackGlobalAttributeClusterRevision_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Read the global attribute: AttributeList\n");
            err = TestReadTheGlobalAttributeAttributeList_5();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 6;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_1(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_BOOL_1_1Suite *>(context))->OnFailureResponse_1(error);
    }

    static void OnSuccessCallback_1(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_BOOL_1_1Suite *>(context))->OnSuccessResponse_1(clusterRevision);
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_BOOL_1_1Suite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_BOOL_1_1Suite *>(context))->OnSuccessResponse_2(clusterRevision);
    }

    static void OnFailureCallback_3(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_BOOL_1_1Suite *>(context))->OnFailureResponse_3(error);
    }

    static void OnSuccessCallback_3(void * context) { (static_cast<Test_TC_BOOL_1_1Suite *>(context))->OnSuccessResponse_3(); }

    static void OnFailureCallback_4(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_BOOL_1_1Suite *>(context))->OnFailureResponse_4(error);
    }

    static void OnSuccessCallback_4(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_BOOL_1_1Suite *>(context))->OnSuccessResponse_4(clusterRevision);
    }

    static void OnFailureCallback_5(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_BOOL_1_1Suite *>(context))->OnFailureResponse_5(error);
    }

    static void OnSuccessCallback_5(void * context, const chip::app::DataModel::DecodableList<chip::AttributeId> & attributeList)
    {
        (static_cast<Test_TC_BOOL_1_1Suite *>(context))->OnSuccessResponse_5(attributeList);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestReadTheGlobalAttributeClusterRevision_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::BooleanStateClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::BooleanState::Attributes::ClusterRevision::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckValue("clusterRevision", clusterRevision, 1U));

        NextTest();
    }

    CHIP_ERROR TestReadTheGlobalAttributeConstraintsClusterRevision_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::BooleanStateClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::BooleanState::Attributes::ClusterRevision::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckConstraintType("clusterRevision", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::BooleanStateClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t clusterRevisionArgument;
        clusterRevisionArgument = 1U;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::BooleanState::Attributes::ClusterRevision::TypeInfo>(
            clusterRevisionArgument, this, OnSuccessCallback_3, OnFailureCallback_3));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_3() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackGlobalAttributeClusterRevision_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::BooleanStateClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::BooleanState::Attributes::ClusterRevision::TypeInfo>(
            this, OnSuccessCallback_4, OnFailureCallback_4, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_4(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckValue("clusterRevision", clusterRevision, 1U));

        NextTest();
    }

    CHIP_ERROR TestReadTheGlobalAttributeAttributeList_5()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::BooleanStateClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::BooleanState::Attributes::AttributeList::TypeInfo>(
            this, OnSuccessCallback_5, OnFailureCallback_5, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_5(const chip::app::DataModel::DecodableList<chip::AttributeId> & attributeList)
    {
        VerifyOrReturn(CheckConstraintType("attributeList", "", "list"));
        NextTest();
    }
};

class Test_TC_BOOL_2_1Suite : public TestCommand
{
public:
    Test_TC_BOOL_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_BOOL_2_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_BOOL_2_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_BOOL_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_BOOL_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read mandatory non-global attribute: StateValue\n");
            err = TestReadMandatoryNonGlobalAttributeStateValue_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read mandatory non-global attribute constraints: StateValue\n");
            err = TestReadMandatoryNonGlobalAttributeConstraintsStateValue_2();
            break;
        case 3:
            ChipLogProgress(chipTool,
                            " ***** Test Step 3 : Write the default value to mandatory non-global attribute: StateValue\n");
            err = TestWriteTheDefaultValueToMandatoryNonGlobalAttributeStateValue_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Reads back the mandatory non-global attribute: StateValue\n");
            err = TestReadsBackTheMandatoryNonGlobalAttributeStateValue_4();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 5;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_1(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_BOOL_2_1Suite *>(context))->OnFailureResponse_1(error);
    }

    static void OnSuccessCallback_1(void * context, bool stateValue)
    {
        (static_cast<Test_TC_BOOL_2_1Suite *>(context))->OnSuccessResponse_1(stateValue);
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_BOOL_2_1Suite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context, bool stateValue)
    {
        (static_cast<Test_TC_BOOL_2_1Suite *>(context))->OnSuccessResponse_2(stateValue);
    }

    static void OnFailureCallback_3(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_BOOL_2_1Suite *>(context))->OnFailureResponse_3(error);
    }

    static void OnSuccessCallback_3(void * context) { (static_cast<Test_TC_BOOL_2_1Suite *>(context))->OnSuccessResponse_3(); }

    static void OnFailureCallback_4(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_BOOL_2_1Suite *>(context))->OnFailureResponse_4(error);
    }

    static void OnSuccessCallback_4(void * context, bool stateValue)
    {
        (static_cast<Test_TC_BOOL_2_1Suite *>(context))->OnSuccessResponse_4(stateValue);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestReadMandatoryNonGlobalAttributeStateValue_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::BooleanStateClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::BooleanState::Attributes::StateValue::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1(bool stateValue)
    {
        VerifyOrReturn(CheckValue("stateValue", stateValue, 0));

        NextTest();
    }

    CHIP_ERROR TestReadMandatoryNonGlobalAttributeConstraintsStateValue_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::BooleanStateClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::BooleanState::Attributes::StateValue::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2(bool stateValue)
    {
        VerifyOrReturn(CheckConstraintType("stateValue", "", "bool"));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValueToMandatoryNonGlobalAttributeStateValue_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::BooleanStateClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        bool stateValueArgument;
        stateValueArgument = 1;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::BooleanState::Attributes::StateValue::TypeInfo>(
            stateValueArgument, this, OnSuccessCallback_3, OnFailureCallback_3));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_3() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackTheMandatoryNonGlobalAttributeStateValue_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::BooleanStateClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::BooleanState::Attributes::StateValue::TypeInfo>(
            this, OnSuccessCallback_4, OnFailureCallback_4, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_4(bool stateValue)
    {
        VerifyOrReturn(CheckValue("stateValue", stateValue, 0));

        NextTest();
    }
};

class Test_TC_BRAC_1_1Suite : public TestCommand
{
public:
    Test_TC_BRAC_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_BRAC_1_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_BRAC_1_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_BRAC_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_BRAC_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read the global attribute: ClusterRevision\n");
            err = TestReadTheGlobalAttributeClusterRevision_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read the global attribute constraints: ClusterRevision\n");
            err = TestReadTheGlobalAttributeConstraintsClusterRevision_2();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 3;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_1(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_BRAC_1_1Suite *>(context))->OnFailureResponse_1(error);
    }

    static void OnSuccessCallback_1(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_BRAC_1_1Suite *>(context))->OnSuccessResponse_1(clusterRevision);
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_BRAC_1_1Suite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_BRAC_1_1Suite *>(context))->OnSuccessResponse_2(clusterRevision);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestReadTheGlobalAttributeClusterRevision_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::BridgedActionsClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::BridgedActions::Attributes::ClusterRevision::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckValue("clusterRevision", clusterRevision, 1U));

        NextTest();
    }

    CHIP_ERROR TestReadTheGlobalAttributeConstraintsClusterRevision_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::BridgedActionsClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::BridgedActions::Attributes::ClusterRevision::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckConstraintType("clusterRevision", "", "uint16"));
        NextTest();
    }
};

class Test_TC_CC_1_1Suite : public TestCommand
{
public:
    Test_TC_CC_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_CC_1_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_CC_1_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read the global attribute constraints : ClusterRevision\n");
            err = TestReadTheGlobalAttributeConstraintsClusterRevision_1();
            break;
        case 2:
            ChipLogProgress(chipTool,
                            " ***** Test Step 2 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read the global attribute: AttributeList\n");
            err = TestReadTheGlobalAttributeAttributeList_3();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 4;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_1(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_1_1Suite *>(context))->OnFailureResponse_1(error);
    }

    static void OnSuccessCallback_1(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_CC_1_1Suite *>(context))->OnSuccessResponse_1(clusterRevision);
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_1_1Suite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context) { (static_cast<Test_TC_CC_1_1Suite *>(context))->OnSuccessResponse_2(); }

    static void OnFailureCallback_3(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_1_1Suite *>(context))->OnFailureResponse_3(error);
    }

    static void OnSuccessCallback_3(void * context, const chip::app::DataModel::DecodableList<chip::AttributeId> & attributeList)
    {
        (static_cast<Test_TC_CC_1_1Suite *>(context))->OnSuccessResponse_3(attributeList);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestReadTheGlobalAttributeConstraintsClusterRevision_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ClusterRevision::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckConstraintType("clusterRevision", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t clusterRevisionArgument;
        clusterRevisionArgument = 4U;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::ClusterRevision::TypeInfo>(
            clusterRevisionArgument, this, OnSuccessCallback_2, OnFailureCallback_2));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_2() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadTheGlobalAttributeAttributeList_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::AttributeList::TypeInfo>(
            this, OnSuccessCallback_3, OnFailureCallback_3, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3(const chip::app::DataModel::DecodableList<chip::AttributeId> & attributeList)
    {
        VerifyOrReturn(CheckConstraintType("attributeList", "", "list"));
        NextTest();
    }
};

class Test_TC_CC_2_1Suite : public TestCommand
{
public:
    Test_TC_CC_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_CC_2_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_CC_2_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Reads mandatory attribute: CurrentHue\n");
            err = TestReadsMandatoryAttributeCurrentHue_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Validate constraints of attribute: current hue\n");
            err = TestValidateConstraintsOfAttributeCurrentHue_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Write the default value to mandatory attribute: CurrentHue\n");
            err = TestWriteTheDefaultValueToMandatoryAttributeCurrentHue_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Reads back mandatory attribute: CurrentHue\n");
            err = TestReadsBackMandatoryAttributeCurrentHue_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Reads mandatory attribute: CurrentSaturation\n");
            err = TestReadsMandatoryAttributeCurrentSaturation_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Validate constraints of attribute: CurrentSaturation\n");
            err = TestValidateConstraintsOfAttributeCurrentSaturation_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Write the default value to mandatory attribute: CurrentSaturation\n");
            err = TestWriteTheDefaultValueToMandatoryAttributeCurrentSaturation_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Reads back mandatory attribute: CurrentSaturation\n");
            err = TestReadsBackMandatoryAttributeCurrentSaturation_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Read the mandatory attribute: CurrentX\n");
            err = TestReadTheMandatoryAttributeCurrentX_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Validate constraints of attribute: CurrentX\n");
            err = TestValidateConstraintsOfAttributeCurrentX_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : Write the default value to mandatory attribute: CurrentX\n");
            err = TestWriteTheDefaultValueToMandatoryAttributeCurrentX_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : Reads back mandatory attribute: CurrentX\n");
            err = TestReadsBackMandatoryAttributeCurrentX_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : Read the mandatory attribute: CurrentY\n");
            err = TestReadTheMandatoryAttributeCurrentY_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : Validate constraints of attribute: CurrentY\n");
            err = TestValidateConstraintsOfAttributeCurrentY_14();
            break;
        case 15:
            ChipLogProgress(chipTool, " ***** Test Step 15 : Write the default values to mandatory attribute: CurrentY\n");
            err = TestWriteTheDefaultValuesToMandatoryAttributeCurrentY_15();
            break;
        case 16:
            ChipLogProgress(chipTool, " ***** Test Step 16 : Reads back mandatory attribute: CurrentY\n");
            err = TestReadsBackMandatoryAttributeCurrentY_16();
            break;
        case 17:
            ChipLogProgress(chipTool, " ***** Test Step 17 : Validate constraints of attribute: ColorTemperatureMireds\n");
            err = TestValidateConstraintsOfAttributeColorTemperatureMireds_17();
            break;
        case 18:
            ChipLogProgress(chipTool, " ***** Test Step 18 : Validate constraints of attribute: ColorMode\n");
            err = TestValidateConstraintsOfAttributeColorMode_18();
            break;
        case 19:
            ChipLogProgress(chipTool, " ***** Test Step 19 : Read the mandatory attribute: Options\n");
            err = TestReadTheMandatoryAttributeOptions_19();
            break;
        case 20:
            ChipLogProgress(chipTool, " ***** Test Step 20 : Validate constraints of attribute: Options\n");
            err = TestValidateConstraintsOfAttributeOptions_20();
            break;
        case 21:
            ChipLogProgress(chipTool, " ***** Test Step 21 : Write the default values to mandatory attribute: Options\n");
            err = TestWriteTheDefaultValuesToMandatoryAttributeOptions_21();
            break;
        case 22:
            ChipLogProgress(chipTool, " ***** Test Step 22 : Reads back mandatory attribute: Options\n");
            err = TestReadsBackMandatoryAttributeOptions_22();
            break;
        case 23:
            ChipLogProgress(chipTool, " ***** Test Step 23 : Read the mandatory attribute: EnhancedCurrentHue\n");
            err = TestReadTheMandatoryAttributeEnhancedCurrentHue_23();
            break;
        case 24:
            ChipLogProgress(chipTool, " ***** Test Step 24 : Validate constraints of attribute: EnhancedCurrentHue\n");
            err = TestValidateConstraintsOfAttributeEnhancedCurrentHue_24();
            break;
        case 25:
            ChipLogProgress(chipTool,
                            " ***** Test Step 25 : Write the default values to mandatory attribute: EnhancedCurrentHue\n");
            err = TestWriteTheDefaultValuesToMandatoryAttributeEnhancedCurrentHue_25();
            break;
        case 26:
            ChipLogProgress(chipTool, " ***** Test Step 26 : Reads back mandatory attribute: EnhancedCurrentHue\n");
            err = TestReadsBackMandatoryAttributeEnhancedCurrentHue_26();
            break;
        case 27:
            ChipLogProgress(chipTool, " ***** Test Step 27 : Validate constraints of attribute: EnhancedColorMode\n");
            err = TestValidateConstraintsOfAttributeEnhancedColorMode_27();
            break;
        case 28:
            ChipLogProgress(chipTool, " ***** Test Step 28 : Read the mandatory attribute: ColorLoopActive\n");
            err = TestReadTheMandatoryAttributeColorLoopActive_28();
            break;
        case 29:
            ChipLogProgress(chipTool, " ***** Test Step 29 : Validate constraints of attribute: ColorLoopActive\n");
            err = TestValidateConstraintsOfAttributeColorLoopActive_29();
            break;
        case 30:
            ChipLogProgress(chipTool, " ***** Test Step 30 : Write the default values to mandatory attribute: ColorLoopActive\n");
            err = TestWriteTheDefaultValuesToMandatoryAttributeColorLoopActive_30();
            break;
        case 31:
            ChipLogProgress(chipTool, " ***** Test Step 31 : Reads back mandatory attribute: ColorLoopActive\n");
            err = TestReadsBackMandatoryAttributeColorLoopActive_31();
            break;
        case 32:
            ChipLogProgress(chipTool, " ***** Test Step 32 : Read the mandatory attribute: ColorLoopDirection\n");
            err = TestReadTheMandatoryAttributeColorLoopDirection_32();
            break;
        case 33:
            ChipLogProgress(chipTool, " ***** Test Step 33 : Validate constraints of attribute: ColorLoopDirection\n");
            err = TestValidateConstraintsOfAttributeColorLoopDirection_33();
            break;
        case 34:
            ChipLogProgress(chipTool,
                            " ***** Test Step 34 : Write the default values to mandatory attribute: ColorLoopDirection\n");
            err = TestWriteTheDefaultValuesToMandatoryAttributeColorLoopDirection_34();
            break;
        case 35:
            ChipLogProgress(chipTool, " ***** Test Step 35 : Reads back mandatory attribute: ColorLoopDirection\n");
            err = TestReadsBackMandatoryAttributeColorLoopDirection_35();
            break;
        case 36:
            ChipLogProgress(chipTool, " ***** Test Step 36 : Read the mandatory attribute: ColorLoopTime\n");
            err = TestReadTheMandatoryAttributeColorLoopTime_36();
            break;
        case 37:
            ChipLogProgress(chipTool, " ***** Test Step 37 : Validate constraints of attribute: ColorLoopTime\n");
            err = TestValidateConstraintsOfAttributeColorLoopTime_37();
            break;
        case 38:
            ChipLogProgress(chipTool, " ***** Test Step 38 : Write the default values to mandatory attribute: ColorLoopTime\n");
            err = TestWriteTheDefaultValuesToMandatoryAttributeColorLoopTime_38();
            break;
        case 39:
            ChipLogProgress(chipTool, " ***** Test Step 39 : Reads back mandatory attribute: ColorLoopTime\n");
            err = TestReadsBackMandatoryAttributeColorLoopTime_39();
            break;
        case 40:
            ChipLogProgress(chipTool, " ***** Test Step 40 : Read the mandatory attribute: ColorLoopStartEnhancedHue\n");
            err = TestReadTheMandatoryAttributeColorLoopStartEnhancedHue_40();
            break;
        case 41:
            ChipLogProgress(chipTool, " ***** Test Step 41 : Validate constraints of attribute: ColorLoopStartEnhancedHue\n");
            err = TestValidateConstraintsOfAttributeColorLoopStartEnhancedHue_41();
            break;
        case 42:
            ChipLogProgress(chipTool,
                            " ***** Test Step 42 : Write the default values to mandatory attribute: ColorLoopStartEnhancedHue\n");
            err = TestWriteTheDefaultValuesToMandatoryAttributeColorLoopStartEnhancedHue_42();
            break;
        case 43:
            ChipLogProgress(chipTool, " ***** Test Step 43 : Reads back mandatory attribute: ColorLoopStartEnhancedHue\n");
            err = TestReadsBackMandatoryAttributeColorLoopStartEnhancedHue_43();
            break;
        case 44:
            ChipLogProgress(chipTool, " ***** Test Step 44 : Read the mandatory attribute: ColorLoopStoredEnhancedHue\n");
            err = TestReadTheMandatoryAttributeColorLoopStoredEnhancedHue_44();
            break;
        case 45:
            ChipLogProgress(chipTool, " ***** Test Step 45 : Validate constraints of attribute: ColorLoopStoredEnhancedHue\n");
            err = TestValidateConstraintsOfAttributeColorLoopStoredEnhancedHue_45();
            break;
        case 46:
            ChipLogProgress(chipTool,
                            " ***** Test Step 46 : Write the default values to mandatory attribute: ColorLoopStoredEnhancedHue\n");
            err = TestWriteTheDefaultValuesToMandatoryAttributeColorLoopStoredEnhancedHue_46();
            break;
        case 47:
            ChipLogProgress(chipTool, " ***** Test Step 47 : Reads back mandatory attribute: ColorLoopStoredEnhancedHue\n");
            err = TestReadsBackMandatoryAttributeColorLoopStoredEnhancedHue_47();
            break;
        case 48:
            ChipLogProgress(chipTool, " ***** Test Step 48 : Read the mandatory attribute: ColorCapabilities\n");
            err = TestReadTheMandatoryAttributeColorCapabilities_48();
            break;
        case 49:
            ChipLogProgress(chipTool, " ***** Test Step 49 : Validate constraints of attribute: ColorCapabilities\n");
            err = TestValidateConstraintsOfAttributeColorCapabilities_49();
            break;
        case 50:
            ChipLogProgress(chipTool, " ***** Test Step 50 : Write the default values to mandatory attribute: ColorCapabilities\n");
            err = TestWriteTheDefaultValuesToMandatoryAttributeColorCapabilities_50();
            break;
        case 51:
            ChipLogProgress(chipTool, " ***** Test Step 51 : Reads back mandatory attribute: ColorCapabilities\n");
            err = TestReadsBackMandatoryAttributeColorCapabilities_51();
            break;
        case 52:
            ChipLogProgress(chipTool, " ***** Test Step 52 : Read the mandatory attribute: ColorTempPhysicalMinMireds\n");
            err = TestReadTheMandatoryAttributeColorTempPhysicalMinMireds_52();
            break;
        case 53:
            ChipLogProgress(chipTool, " ***** Test Step 53 : Validate constraints of attribute: ColorTempPhysicalMinMireds\n");
            err = TestValidateConstraintsOfAttributeColorTempPhysicalMinMireds_53();
            break;
        case 54:
            ChipLogProgress(chipTool,
                            " ***** Test Step 54 : Write the default values to mandatory  attribute: ColorTempPhysicalMinMireds\n");
            err = TestWriteTheDefaultValuesToMandatoryAttributeColorTempPhysicalMinMireds_54();
            break;
        case 55:
            ChipLogProgress(chipTool, " ***** Test Step 55 : Reads back mandatory attribute: ColorTempPhysicalMinMireds\n");
            err = TestReadsBackMandatoryAttributeColorTempPhysicalMinMireds_55();
            break;
        case 56:
            ChipLogProgress(chipTool, " ***** Test Step 56 : Read the mandatory attribute: ColorTempPhysicalMaxMireds\n");
            err = TestReadTheMandatoryAttributeColorTempPhysicalMaxMireds_56();
            break;
        case 57:
            ChipLogProgress(chipTool, " ***** Test Step 57 : Validate constraints of attribute: ColorTempPhysicalMaxMireds\n");
            err = TestValidateConstraintsOfAttributeColorTempPhysicalMaxMireds_57();
            break;
        case 58:
            ChipLogProgress(chipTool,
                            " ***** Test Step 58 : Write the default values to mandatory attribute: ColorTempPhysicalMaxMireds\n");
            err = TestWriteTheDefaultValuesToMandatoryAttributeColorTempPhysicalMaxMireds_58();
            break;
        case 59:
            ChipLogProgress(chipTool, " ***** Test Step 59 : Reads back mandatory attribute: ColorTempPhysicalMaxMireds\n");
            err = TestReadsBackMandatoryAttributeColorTempPhysicalMaxMireds_59();
            break;
        case 60:
            ChipLogProgress(chipTool, " ***** Test Step 60 : Read the optional attribute: CoupleColorTempToLevelMinMireds\n");
            err = TestReadTheOptionalAttributeCoupleColorTempToLevelMinMireds_60();
            break;
        case 61:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 61 : Write the default values to optional attribute: CoupleColorTempToLevelMinMireds\n");
            err = TestWriteTheDefaultValuesToOptionalAttributeCoupleColorTempToLevelMinMireds_61();
            break;
        case 62:
            ChipLogProgress(chipTool, " ***** Test Step 62 : Reads back optional attribute: CoupleColorTempToLevelMinMireds\n");
            err = TestReadsBackOptionalAttributeCoupleColorTempToLevelMinMireds_62();
            break;
        case 63:
            ChipLogProgress(chipTool, " ***** Test Step 63 : Read the optional attribute: StartUpColorTemperatureMireds\n");
            err = TestReadTheOptionalAttributeStartUpColorTemperatureMireds_63();
            break;
        case 64:
            ChipLogProgress(
                chipTool, " ***** Test Step 64 : Write the default values to optional attribute: StartUpColorTemperatureMireds\n");
            err = TestWriteTheDefaultValuesToOptionalAttributeStartUpColorTemperatureMireds_64();
            break;
        case 65:
            ChipLogProgress(chipTool, " ***** Test Step 65 : Reads back optional attribute: StartUpColorTemperatureMireds\n");
            err = TestReadsBackOptionalAttributeStartUpColorTemperatureMireds_65();
            break;
        case 66:
            ChipLogProgress(chipTool, " ***** Test Step 66 : Read the Optional attribute: RemainingTime\n");
            err = TestReadTheOptionalAttributeRemainingTime_66();
            break;
        case 67:
            ChipLogProgress(chipTool, " ***** Test Step 67 : Validate constraints of attribute: RemainingTime\n");
            err = TestValidateConstraintsOfAttributeRemainingTime_67();
            break;
        case 68:
            ChipLogProgress(chipTool, " ***** Test Step 68 : Write the default values to optional attribute: RemainingTime\n");
            err = TestWriteTheDefaultValuesToOptionalAttributeRemainingTime_68();
            break;
        case 69:
            ChipLogProgress(chipTool, " ***** Test Step 69 : Reads back optional attribute: RemainingTime\n");
            err = TestReadsBackOptionalAttributeRemainingTime_69();
            break;
        case 70:
            ChipLogProgress(chipTool, " ***** Test Step 70 : Read the optional attribute: DriftCompensation\n");
            err = TestReadTheOptionalAttributeDriftCompensation_70();
            break;
        case 71:
            ChipLogProgress(chipTool, " ***** Test Step 71 : Write the default values to optional attribute: DriftCompensation\n");
            err = TestWriteTheDefaultValuesToOptionalAttributeDriftCompensation_71();
            break;
        case 72:
            ChipLogProgress(chipTool, " ***** Test Step 72 : Reads back optional attribute: DriftCompensation\n");
            err = TestReadsBackOptionalAttributeDriftCompensation_72();
            break;
        case 73:
            ChipLogProgress(chipTool, " ***** Test Step 73 : Read the optional attribute: CompensationText\n");
            err = TestReadTheOptionalAttributeCompensationText_73();
            break;
        case 74:
            ChipLogProgress(chipTool, " ***** Test Step 74 : Write the default values to optional attribute: CompensationText\n");
            err = TestWriteTheDefaultValuesToOptionalAttributeCompensationText_74();
            break;
        case 75:
            ChipLogProgress(chipTool, " ***** Test Step 75 : Reads back optional attribute: CompensationText\n");
            err = TestReadsBackOptionalAttributeCompensationText_75();
            break;
        case 76:
            ChipLogProgress(chipTool, " ***** Test Step 76 : Read the mandatory attribute: NumberOfPrimaries\n");
            err = TestReadTheMandatoryAttributeNumberOfPrimaries_76();
            break;
        case 77:
            ChipLogProgress(chipTool, " ***** Test Step 77 : Write the default mandatory attribute: NumberOfPrimaries\n");
            err = TestWriteTheDefaultMandatoryAttributeNumberOfPrimaries_77();
            break;
        case 78:
            ChipLogProgress(chipTool, " ***** Test Step 78 : Read back the mandatory attribute: NumberOfPrimaries\n");
            err = TestReadBackTheMandatoryAttributeNumberOfPrimaries_78();
            break;
        case 79:
            ChipLogProgress(chipTool, " ***** Test Step 79 : Read the mandatory attribute: Primary1X\n");
            err = TestReadTheMandatoryAttributePrimary1X_79();
            break;
        case 80:
            ChipLogProgress(chipTool, " ***** Test Step 80 : Write the default mandatory attribute: Primary1X\n");
            err = TestWriteTheDefaultMandatoryAttributePrimary1X_80();
            break;
        case 81:
            ChipLogProgress(chipTool, " ***** Test Step 81 : Read back the mandatory attribute: Primary1X\n");
            err = TestReadBackTheMandatoryAttributePrimary1X_81();
            break;
        case 82:
            ChipLogProgress(chipTool, " ***** Test Step 82 : Read the mandatory attribute: Primary1Y\n");
            err = TestReadTheMandatoryAttributePrimary1Y_82();
            break;
        case 83:
            ChipLogProgress(chipTool, " ***** Test Step 83 : Write the default mandatory attribute: Primary1Y\n");
            err = TestWriteTheDefaultMandatoryAttributePrimary1Y_83();
            break;
        case 84:
            ChipLogProgress(chipTool, " ***** Test Step 84 : Read back the mandatory attribute: Primary1Y\n");
            err = TestReadBackTheMandatoryAttributePrimary1Y_84();
            break;
        case 85:
            ChipLogProgress(chipTool, " ***** Test Step 85 : Read the mandatory attribute: Primary1Intensity\n");
            err = TestReadTheMandatoryAttributePrimary1Intensity_85();
            break;
        case 86:
            ChipLogProgress(chipTool, " ***** Test Step 86 : Read the mandatory attribute: Primary2X\n");
            err = TestReadTheMandatoryAttributePrimary2X_86();
            break;
        case 87:
            ChipLogProgress(chipTool, " ***** Test Step 87 : Write the default mandatory attribute: Primary2X\n");
            err = TestWriteTheDefaultMandatoryAttributePrimary2X_87();
            break;
        case 88:
            ChipLogProgress(chipTool, " ***** Test Step 88 : Read back the mandatory attribute: Primary2X\n");
            err = TestReadBackTheMandatoryAttributePrimary2X_88();
            break;
        case 89:
            ChipLogProgress(chipTool, " ***** Test Step 89 : Read the mandatory attribute: Primary2Y\n");
            err = TestReadTheMandatoryAttributePrimary2Y_89();
            break;
        case 90:
            ChipLogProgress(chipTool, " ***** Test Step 90 : Write the default mandatory attribute: Primary2Y\n");
            err = TestWriteTheDefaultMandatoryAttributePrimary2Y_90();
            break;
        case 91:
            ChipLogProgress(chipTool, " ***** Test Step 91 : Read back the mandatory attribute: Primary2Y\n");
            err = TestReadBackTheMandatoryAttributePrimary2Y_91();
            break;
        case 92:
            ChipLogProgress(chipTool, " ***** Test Step 92 : Validate constraints of attribute: Primary2Intensity\n");
            err = TestValidateConstraintsOfAttributePrimary2Intensity_92();
            break;
        case 93:
            ChipLogProgress(chipTool, " ***** Test Step 93 : Read the mandatory attribute: Primary3X\n");
            err = TestReadTheMandatoryAttributePrimary3X_93();
            break;
        case 94:
            ChipLogProgress(chipTool, " ***** Test Step 94 : Write the default mandatory attribute: Primary3X\n");
            err = TestWriteTheDefaultMandatoryAttributePrimary3X_94();
            break;
        case 95:
            ChipLogProgress(chipTool, " ***** Test Step 95 : Read back the mandatory attribute: Primary3X\n");
            err = TestReadBackTheMandatoryAttributePrimary3X_95();
            break;
        case 96:
            ChipLogProgress(chipTool, " ***** Test Step 96 : Read the mandatory attribute: Primary3Y\n");
            err = TestReadTheMandatoryAttributePrimary3Y_96();
            break;
        case 97:
            ChipLogProgress(chipTool, " ***** Test Step 97 : Write the default mandatory attribute: Primary3Y\n");
            err = TestWriteTheDefaultMandatoryAttributePrimary3Y_97();
            break;
        case 98:
            ChipLogProgress(chipTool, " ***** Test Step 98 : Read back the mandatory attribute: Primary3Y\n");
            err = TestReadBackTheMandatoryAttributePrimary3Y_98();
            break;
        case 99:
            ChipLogProgress(chipTool, " ***** Test Step 99 : Read the mandatory attribute: Primary3Intensity\n");
            err = TestReadTheMandatoryAttributePrimary3Intensity_99();
            break;
        case 100:
            ChipLogProgress(chipTool, " ***** Test Step 100 : Read the mandatory attribute: Primary4X\n");
            err = TestReadTheMandatoryAttributePrimary4X_100();
            break;
        case 101:
            ChipLogProgress(chipTool, " ***** Test Step 101 : Write the default mandatory attribute: Primary4X\n");
            err = TestWriteTheDefaultMandatoryAttributePrimary4X_101();
            break;
        case 102:
            ChipLogProgress(chipTool, " ***** Test Step 102 : Read back the mandatory attribute: Primary4X\n");
            err = TestReadBackTheMandatoryAttributePrimary4X_102();
            break;
        case 103:
            ChipLogProgress(chipTool, " ***** Test Step 103 : Read the mandatory attribute: Primary4Y\n");
            err = TestReadTheMandatoryAttributePrimary4Y_103();
            break;
        case 104:
            ChipLogProgress(chipTool, " ***** Test Step 104 : Write the default mandatory attribute: Primary4Y\n");
            err = TestWriteTheDefaultMandatoryAttributePrimary4Y_104();
            break;
        case 105:
            ChipLogProgress(chipTool, " ***** Test Step 105 : Read back the mandatory attribute: Primary4Y\n");
            err = TestReadBackTheMandatoryAttributePrimary4Y_105();
            break;
        case 106:
            ChipLogProgress(chipTool, " ***** Test Step 106 : Read the mandatory attribute: Primary4Intensity\n");
            err = TestReadTheMandatoryAttributePrimary4Intensity_106();
            break;
        case 107:
            ChipLogProgress(chipTool, " ***** Test Step 107 : Read the mandatory attribute: Primary5X\n");
            err = TestReadTheMandatoryAttributePrimary5X_107();
            break;
        case 108:
            ChipLogProgress(chipTool, " ***** Test Step 108 : Write the default mandatory attribute: Primary5X\n");
            err = TestWriteTheDefaultMandatoryAttributePrimary5X_108();
            break;
        case 109:
            ChipLogProgress(chipTool, " ***** Test Step 109 : Read back the mandatory attribute: Primary5X\n");
            err = TestReadBackTheMandatoryAttributePrimary5X_109();
            break;
        case 110:
            ChipLogProgress(chipTool, " ***** Test Step 110 : Read the mandatory attribute: Primary5Y\n");
            err = TestReadTheMandatoryAttributePrimary5Y_110();
            break;
        case 111:
            ChipLogProgress(chipTool, " ***** Test Step 111 : Write the default mandatory attribute: Primary5Y\n");
            err = TestWriteTheDefaultMandatoryAttributePrimary5Y_111();
            break;
        case 112:
            ChipLogProgress(chipTool, " ***** Test Step 112 : Read back the mandatory attribute: Primary5Y\n");
            err = TestReadBackTheMandatoryAttributePrimary5Y_112();
            break;
        case 113:
            ChipLogProgress(chipTool, " ***** Test Step 113 : Read the mandatory attribute: Primary5Intensity\n");
            err = TestReadTheMandatoryAttributePrimary5Intensity_113();
            break;
        case 114:
            ChipLogProgress(chipTool, " ***** Test Step 114 : Read the mandatory attribute: Primary6X\n");
            err = TestReadTheMandatoryAttributePrimary6X_114();
            break;
        case 115:
            ChipLogProgress(chipTool, " ***** Test Step 115 : Write the default mandatory attribute: Primary6X\n");
            err = TestWriteTheDefaultMandatoryAttributePrimary6X_115();
            break;
        case 116:
            ChipLogProgress(chipTool, " ***** Test Step 116 : Read back the mandatory attribute: Primary6X\n");
            err = TestReadBackTheMandatoryAttributePrimary6X_116();
            break;
        case 117:
            ChipLogProgress(chipTool, " ***** Test Step 117 : Read the mandatory attribute: Primary6Y\n");
            err = TestReadTheMandatoryAttributePrimary6Y_117();
            break;
        case 118:
            ChipLogProgress(chipTool, " ***** Test Step 118 : Write the default mandatory attribute: Primary6Y\n");
            err = TestWriteTheDefaultMandatoryAttributePrimary6Y_118();
            break;
        case 119:
            ChipLogProgress(chipTool, " ***** Test Step 119 : Read back the mandatory attribute: Primary6Y\n");
            err = TestReadBackTheMandatoryAttributePrimary6Y_119();
            break;
        case 120:
            ChipLogProgress(chipTool, " ***** Test Step 120 : Read the mandatory attribute: Primary6Intensity\n");
            err = TestReadTheMandatoryAttributePrimary6Intensity_120();
            break;
        case 121:
            ChipLogProgress(chipTool, " ***** Test Step 121 : Read the optional attribute: WhitePointX\n");
            err = TestReadTheOptionalAttributeWhitePointX_121();
            break;
        case 122:
            ChipLogProgress(chipTool, " ***** Test Step 122 : Write the default optional attribute: WhitePointX\n");
            err = TestWriteTheDefaultOptionalAttributeWhitePointX_122();
            break;
        case 123:
            ChipLogProgress(chipTool, " ***** Test Step 123 : Read back the optional attribute: WhitePointX\n");
            err = TestReadBackTheOptionalAttributeWhitePointX_123();
            break;
        case 124:
            ChipLogProgress(chipTool, " ***** Test Step 124 : Read the optional attribute: WhitePointY\n");
            err = TestReadTheOptionalAttributeWhitePointY_124();
            break;
        case 125:
            ChipLogProgress(chipTool, " ***** Test Step 125 : Write the default optional attribute: WhitePointY\n");
            err = TestWriteTheDefaultOptionalAttributeWhitePointY_125();
            break;
        case 126:
            ChipLogProgress(chipTool, " ***** Test Step 126 : Read back the optional attribute: WhitePointY\n");
            err = TestReadBackTheOptionalAttributeWhitePointY_126();
            break;
        case 127:
            ChipLogProgress(chipTool, " ***** Test Step 127 : Read the optional attribute: ColorPointRX\n");
            err = TestReadTheOptionalAttributeColorPointRX_127();
            break;
        case 128:
            ChipLogProgress(chipTool, " ***** Test Step 128 : Write the default optional attribute: ColorPointRX\n");
            err = TestWriteTheDefaultOptionalAttributeColorPointRX_128();
            break;
        case 129:
            ChipLogProgress(chipTool, " ***** Test Step 129 : Read back the optional attribute: ColorPointRX\n");
            err = TestReadBackTheOptionalAttributeColorPointRX_129();
            break;
        case 130:
            ChipLogProgress(chipTool, " ***** Test Step 130 : Read the optional attribute: ColorPointRY\n");
            err = TestReadTheOptionalAttributeColorPointRY_130();
            break;
        case 131:
            ChipLogProgress(chipTool, " ***** Test Step 131 : Write the default optional attribute: ColorPointRY\n");
            err = TestWriteTheDefaultOptionalAttributeColorPointRY_131();
            break;
        case 132:
            ChipLogProgress(chipTool, " ***** Test Step 132 : Read back the optional attribute: ColorPointRY\n");
            err = TestReadBackTheOptionalAttributeColorPointRY_132();
            break;
        case 133:
            ChipLogProgress(chipTool, " ***** Test Step 133 : Read the optional attribute: ColorPointRIntensity\n");
            err = TestReadTheOptionalAttributeColorPointRIntensity_133();
            break;
        case 134:
            ChipLogProgress(chipTool, " ***** Test Step 134 : Write the default optional attribute: ColorPointRIntensity\n");
            err = TestWriteTheDefaultOptionalAttributeColorPointRIntensity_134();
            break;
        case 135:
            ChipLogProgress(chipTool, " ***** Test Step 135 : Read back the optional attribute: ColorPointRIntensity\n");
            err = TestReadBackTheOptionalAttributeColorPointRIntensity_135();
            break;
        case 136:
            ChipLogProgress(chipTool, " ***** Test Step 136 : Read the optional attribute: ColorPointGX\n");
            err = TestReadTheOptionalAttributeColorPointGX_136();
            break;
        case 137:
            ChipLogProgress(chipTool, " ***** Test Step 137 : Write the default optional attribute: ColorPointGX\n");
            err = TestWriteTheDefaultOptionalAttributeColorPointGX_137();
            break;
        case 138:
            ChipLogProgress(chipTool, " ***** Test Step 138 : Read back the optional attribute: ColorPointGX\n");
            err = TestReadBackTheOptionalAttributeColorPointGX_138();
            break;
        case 139:
            ChipLogProgress(chipTool, " ***** Test Step 139 : Read the optional attribute: ColorPointGY\n");
            err = TestReadTheOptionalAttributeColorPointGY_139();
            break;
        case 140:
            ChipLogProgress(chipTool, " ***** Test Step 140 : Write the default optional attribute: ColorPointGY\n");
            err = TestWriteTheDefaultOptionalAttributeColorPointGY_140();
            break;
        case 141:
            ChipLogProgress(chipTool, " ***** Test Step 141 : Read back the optional attribute: ColorPointGY\n");
            err = TestReadBackTheOptionalAttributeColorPointGY_141();
            break;
        case 142:
            ChipLogProgress(chipTool, " ***** Test Step 142 : Read the optional attribute: ColorPointGIntensity\n");
            err = TestReadTheOptionalAttributeColorPointGIntensity_142();
            break;
        case 143:
            ChipLogProgress(chipTool, " ***** Test Step 143 : Write the default optional attribute: ColorPointGIntensity\n");
            err = TestWriteTheDefaultOptionalAttributeColorPointGIntensity_143();
            break;
        case 144:
            ChipLogProgress(chipTool, " ***** Test Step 144 : Read back the optional attribute: ColorPointGIntensity\n");
            err = TestReadBackTheOptionalAttributeColorPointGIntensity_144();
            break;
        case 145:
            ChipLogProgress(chipTool, " ***** Test Step 145 : Read the optional attribute: ColorPointBX\n");
            err = TestReadTheOptionalAttributeColorPointBX_145();
            break;
        case 146:
            ChipLogProgress(chipTool, " ***** Test Step 146 : Write the default optional attribute: ColorPointBX\n");
            err = TestWriteTheDefaultOptionalAttributeColorPointBX_146();
            break;
        case 147:
            ChipLogProgress(chipTool, " ***** Test Step 147 : Read back the optional attribute: ColorPointBX\n");
            err = TestReadBackTheOptionalAttributeColorPointBX_147();
            break;
        case 148:
            ChipLogProgress(chipTool, " ***** Test Step 148 : Read the optional attribute: ColorPointBY\n");
            err = TestReadTheOptionalAttributeColorPointBY_148();
            break;
        case 149:
            ChipLogProgress(chipTool, " ***** Test Step 149 : Write the default optional attribute: ColorPointBY\n");
            err = TestWriteTheDefaultOptionalAttributeColorPointBY_149();
            break;
        case 150:
            ChipLogProgress(chipTool, " ***** Test Step 150 : Read back the optional attribute: ColorPointBY\n");
            err = TestReadBackTheOptionalAttributeColorPointBY_150();
            break;
        case 151:
            ChipLogProgress(chipTool, " ***** Test Step 151 : Read the optional attribute: ColorPointBIntensity\n");
            err = TestReadTheOptionalAttributeColorPointBIntensity_151();
            break;
        case 152:
            ChipLogProgress(chipTool, " ***** Test Step 152 : Write the default optional attribute: ColorPointBIntensity\n");
            err = TestWriteTheDefaultOptionalAttributeColorPointBIntensity_152();
            break;
        case 153:
            ChipLogProgress(chipTool, " ***** Test Step 153 : Read back the optional attribute: ColorPointBIntensity\n");
            err = TestReadBackTheOptionalAttributeColorPointBIntensity_153();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 154;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_1(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_1(error);
    }

    static void OnSuccessCallback_1(void * context, uint8_t currentHue)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_1(currentHue);
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context, uint8_t currentHue)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_2(currentHue);
    }

    static void OnFailureCallback_3(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_3(error);
    }

    static void OnSuccessCallback_3(void * context) { (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_3(); }

    static void OnFailureCallback_4(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_4(error);
    }

    static void OnSuccessCallback_4(void * context, uint8_t currentHue)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_4(currentHue);
    }

    static void OnFailureCallback_5(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_5(error);
    }

    static void OnSuccessCallback_5(void * context, uint8_t currentSaturation)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_5(currentSaturation);
    }

    static void OnFailureCallback_6(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_6(error);
    }

    static void OnSuccessCallback_6(void * context, uint8_t currentSaturation)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_6(currentSaturation);
    }

    static void OnFailureCallback_7(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_7(error);
    }

    static void OnSuccessCallback_7(void * context) { (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_7(); }

    static void OnFailureCallback_8(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_8(error);
    }

    static void OnSuccessCallback_8(void * context, uint8_t currentSaturation)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_8(currentSaturation);
    }

    static void OnFailureCallback_9(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_9(error);
    }

    static void OnSuccessCallback_9(void * context, uint16_t currentX)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_9(currentX);
    }

    static void OnFailureCallback_10(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_10(error);
    }

    static void OnSuccessCallback_10(void * context, uint16_t currentX)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_10(currentX);
    }

    static void OnFailureCallback_11(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_11(error);
    }

    static void OnSuccessCallback_11(void * context) { (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_11(); }

    static void OnFailureCallback_12(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_12(error);
    }

    static void OnSuccessCallback_12(void * context, uint16_t currentX)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_12(currentX);
    }

    static void OnFailureCallback_13(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_13(error);
    }

    static void OnSuccessCallback_13(void * context, uint16_t currentY)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_13(currentY);
    }

    static void OnFailureCallback_14(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_14(error);
    }

    static void OnSuccessCallback_14(void * context, uint16_t currentY)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_14(currentY);
    }

    static void OnFailureCallback_15(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_15(error);
    }

    static void OnSuccessCallback_15(void * context) { (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_15(); }

    static void OnFailureCallback_16(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_16(error);
    }

    static void OnSuccessCallback_16(void * context, uint16_t currentY)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_16(currentY);
    }

    static void OnFailureCallback_17(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_17(error);
    }

    static void OnSuccessCallback_17(void * context, uint16_t colorTemperature)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_17(colorTemperature);
    }

    static void OnFailureCallback_18(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_18(error);
    }

    static void OnSuccessCallback_18(void * context, uint8_t colorMode)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_18(colorMode);
    }

    static void OnFailureCallback_19(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_19(error);
    }

    static void OnSuccessCallback_19(void * context, uint8_t colorControlOptions)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_19(colorControlOptions);
    }

    static void OnFailureCallback_20(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_20(error);
    }

    static void OnSuccessCallback_20(void * context, uint8_t colorControlOptions)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_20(colorControlOptions);
    }

    static void OnFailureCallback_21(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_21(error);
    }

    static void OnSuccessCallback_21(void * context) { (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_21(); }

    static void OnFailureCallback_22(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_22(error);
    }

    static void OnSuccessCallback_22(void * context, uint8_t colorControlOptions)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_22(colorControlOptions);
    }

    static void OnFailureCallback_23(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_23(error);
    }

    static void OnSuccessCallback_23(void * context, uint16_t enhancedCurrentHue)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_23(enhancedCurrentHue);
    }

    static void OnFailureCallback_24(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_24(error);
    }

    static void OnSuccessCallback_24(void * context, uint16_t enhancedCurrentHue)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_24(enhancedCurrentHue);
    }

    static void OnFailureCallback_25(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_25(error);
    }

    static void OnSuccessCallback_25(void * context) { (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_25(); }

    static void OnFailureCallback_26(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_26(error);
    }

    static void OnSuccessCallback_26(void * context, uint16_t enhancedCurrentHue)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_26(enhancedCurrentHue);
    }

    static void OnFailureCallback_27(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_27(error);
    }

    static void OnSuccessCallback_27(void * context, uint8_t enhancedColorMode)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_27(enhancedColorMode);
    }

    static void OnFailureCallback_28(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_28(error);
    }

    static void OnSuccessCallback_28(void * context, uint8_t colorLoopActive)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_28(colorLoopActive);
    }

    static void OnFailureCallback_29(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_29(error);
    }

    static void OnSuccessCallback_29(void * context, uint8_t colorLoopActive)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_29(colorLoopActive);
    }

    static void OnFailureCallback_30(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_30(error);
    }

    static void OnSuccessCallback_30(void * context) { (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_30(); }

    static void OnFailureCallback_31(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_31(error);
    }

    static void OnSuccessCallback_31(void * context, uint8_t colorLoopActive)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_31(colorLoopActive);
    }

    static void OnFailureCallback_32(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_32(error);
    }

    static void OnSuccessCallback_32(void * context, uint8_t colorLoopDirection)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_32(colorLoopDirection);
    }

    static void OnFailureCallback_33(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_33(error);
    }

    static void OnSuccessCallback_33(void * context, uint8_t colorLoopDirection)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_33(colorLoopDirection);
    }

    static void OnFailureCallback_34(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_34(error);
    }

    static void OnSuccessCallback_34(void * context) { (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_34(); }

    static void OnFailureCallback_35(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_35(error);
    }

    static void OnSuccessCallback_35(void * context, uint8_t colorLoopDirection)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_35(colorLoopDirection);
    }

    static void OnFailureCallback_36(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_36(error);
    }

    static void OnSuccessCallback_36(void * context, uint16_t colorLoopTime)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_36(colorLoopTime);
    }

    static void OnFailureCallback_37(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_37(error);
    }

    static void OnSuccessCallback_37(void * context, uint16_t colorLoopTime)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_37(colorLoopTime);
    }

    static void OnFailureCallback_38(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_38(error);
    }

    static void OnSuccessCallback_38(void * context) { (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_38(); }

    static void OnFailureCallback_39(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_39(error);
    }

    static void OnSuccessCallback_39(void * context, uint16_t colorLoopTime)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_39(colorLoopTime);
    }

    static void OnFailureCallback_40(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_40(error);
    }

    static void OnSuccessCallback_40(void * context, uint16_t colorLoopStartEnhancedHue)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_40(colorLoopStartEnhancedHue);
    }

    static void OnFailureCallback_41(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_41(error);
    }

    static void OnSuccessCallback_41(void * context, uint16_t colorLoopStartEnhancedHue)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_41(colorLoopStartEnhancedHue);
    }

    static void OnFailureCallback_42(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_42(error);
    }

    static void OnSuccessCallback_42(void * context) { (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_42(); }

    static void OnFailureCallback_43(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_43(error);
    }

    static void OnSuccessCallback_43(void * context, uint16_t colorLoopStartEnhancedHue)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_43(colorLoopStartEnhancedHue);
    }

    static void OnFailureCallback_44(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_44(error);
    }

    static void OnSuccessCallback_44(void * context, uint16_t colorLoopStoredEnhancedHue)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_44(colorLoopStoredEnhancedHue);
    }

    static void OnFailureCallback_45(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_45(error);
    }

    static void OnSuccessCallback_45(void * context, uint16_t colorLoopStoredEnhancedHue)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_45(colorLoopStoredEnhancedHue);
    }

    static void OnFailureCallback_46(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_46(error);
    }

    static void OnSuccessCallback_46(void * context) { (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_46(); }

    static void OnFailureCallback_47(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_47(error);
    }

    static void OnSuccessCallback_47(void * context, uint16_t colorLoopStoredEnhancedHue)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_47(colorLoopStoredEnhancedHue);
    }

    static void OnFailureCallback_48(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_48(error);
    }

    static void OnSuccessCallback_48(void * context, uint16_t colorCapabilities)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_48(colorCapabilities);
    }

    static void OnFailureCallback_49(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_49(error);
    }

    static void OnSuccessCallback_49(void * context, uint16_t colorCapabilities)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_49(colorCapabilities);
    }

    static void OnFailureCallback_50(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_50(error);
    }

    static void OnSuccessCallback_50(void * context) { (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_50(); }

    static void OnFailureCallback_51(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_51(error);
    }

    static void OnSuccessCallback_51(void * context, uint16_t colorCapabilities)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_51(colorCapabilities);
    }

    static void OnFailureCallback_52(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_52(error);
    }

    static void OnSuccessCallback_52(void * context, uint16_t colorTempPhysicalMin)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_52(colorTempPhysicalMin);
    }

    static void OnFailureCallback_53(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_53(error);
    }

    static void OnSuccessCallback_53(void * context, uint16_t colorTempPhysicalMin)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_53(colorTempPhysicalMin);
    }

    static void OnFailureCallback_54(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_54(error);
    }

    static void OnSuccessCallback_54(void * context) { (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_54(); }

    static void OnFailureCallback_55(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_55(error);
    }

    static void OnSuccessCallback_55(void * context, uint16_t colorTempPhysicalMin)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_55(colorTempPhysicalMin);
    }

    static void OnFailureCallback_56(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_56(error);
    }

    static void OnSuccessCallback_56(void * context, uint16_t colorTempPhysicalMax)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_56(colorTempPhysicalMax);
    }

    static void OnFailureCallback_57(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_57(error);
    }

    static void OnSuccessCallback_57(void * context, uint16_t colorTempPhysicalMax)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_57(colorTempPhysicalMax);
    }

    static void OnFailureCallback_58(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_58(error);
    }

    static void OnSuccessCallback_58(void * context) { (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_58(); }

    static void OnFailureCallback_59(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_59(error);
    }

    static void OnSuccessCallback_59(void * context, uint16_t colorTempPhysicalMax)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_59(colorTempPhysicalMax);
    }

    static void OnFailureCallback_60(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_60(error);
    }

    static void OnSuccessCallback_60(void * context, uint16_t coupleColorTempToLevelMinMireds)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_60(coupleColorTempToLevelMinMireds);
    }

    static void OnFailureCallback_61(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_61(error);
    }

    static void OnSuccessCallback_61(void * context) { (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_61(); }

    static void OnFailureCallback_62(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_62(error);
    }

    static void OnSuccessCallback_62(void * context, uint16_t coupleColorTempToLevelMinMireds)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_62(coupleColorTempToLevelMinMireds);
    }

    static void OnFailureCallback_63(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_63(error);
    }

    static void OnSuccessCallback_63(void * context, uint16_t startUpColorTemperatureMireds)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_63(startUpColorTemperatureMireds);
    }

    static void OnFailureCallback_64(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_64(error);
    }

    static void OnSuccessCallback_64(void * context) { (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_64(); }

    static void OnFailureCallback_65(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_65(error);
    }

    static void OnSuccessCallback_65(void * context, uint16_t startUpColorTemperatureMireds)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_65(startUpColorTemperatureMireds);
    }

    static void OnFailureCallback_66(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_66(error);
    }

    static void OnSuccessCallback_66(void * context, uint16_t remainingTime)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_66(remainingTime);
    }

    static void OnFailureCallback_67(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_67(error);
    }

    static void OnSuccessCallback_67(void * context, uint16_t remainingTime)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_67(remainingTime);
    }

    static void OnFailureCallback_68(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_68(error);
    }

    static void OnSuccessCallback_68(void * context) { (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_68(); }

    static void OnFailureCallback_69(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_69(error);
    }

    static void OnSuccessCallback_69(void * context, uint16_t remainingTime)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_69(remainingTime);
    }

    static void OnFailureCallback_70(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_70(error);
    }

    static void OnSuccessCallback_70(void * context, uint8_t driftCompensation)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_70(driftCompensation);
    }

    static void OnFailureCallback_71(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_71(error);
    }

    static void OnSuccessCallback_71(void * context) { (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_71(); }

    static void OnFailureCallback_72(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_72(error);
    }

    static void OnSuccessCallback_72(void * context, uint8_t driftCompensation)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_72(driftCompensation);
    }

    static void OnFailureCallback_73(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_73(error);
    }

    static void OnSuccessCallback_73(void * context, chip::CharSpan compensationText)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_73(compensationText);
    }

    static void OnFailureCallback_74(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_74(error);
    }

    static void OnSuccessCallback_74(void * context) { (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_74(); }

    static void OnFailureCallback_75(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_75(error);
    }

    static void OnSuccessCallback_75(void * context, chip::CharSpan compensationText)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_75(compensationText);
    }

    static void OnFailureCallback_76(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_76(error);
    }

    static void OnSuccessCallback_76(void * context, uint8_t numberOfPrimaries)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_76(numberOfPrimaries);
    }

    static void OnFailureCallback_77(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_77(error);
    }

    static void OnSuccessCallback_77(void * context) { (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_77(); }

    static void OnFailureCallback_78(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_78(error);
    }

    static void OnSuccessCallback_78(void * context, uint8_t numberOfPrimaries)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_78(numberOfPrimaries);
    }

    static void OnFailureCallback_79(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_79(error);
    }

    static void OnSuccessCallback_79(void * context, uint16_t primary1X)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_79(primary1X);
    }

    static void OnFailureCallback_80(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_80(error);
    }

    static void OnSuccessCallback_80(void * context) { (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_80(); }

    static void OnFailureCallback_81(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_81(error);
    }

    static void OnSuccessCallback_81(void * context, uint16_t primary1X)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_81(primary1X);
    }

    static void OnFailureCallback_82(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_82(error);
    }

    static void OnSuccessCallback_82(void * context, uint16_t primary1Y)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_82(primary1Y);
    }

    static void OnFailureCallback_83(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_83(error);
    }

    static void OnSuccessCallback_83(void * context) { (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_83(); }

    static void OnFailureCallback_84(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_84(error);
    }

    static void OnSuccessCallback_84(void * context, uint16_t primary1Y)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_84(primary1Y);
    }

    static void OnFailureCallback_85(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_85(error);
    }

    static void OnSuccessCallback_85(void * context, uint8_t primary1Intensity)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_85(primary1Intensity);
    }

    static void OnFailureCallback_86(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_86(error);
    }

    static void OnSuccessCallback_86(void * context, uint16_t primary2X)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_86(primary2X);
    }

    static void OnFailureCallback_87(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_87(error);
    }

    static void OnSuccessCallback_87(void * context) { (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_87(); }

    static void OnFailureCallback_88(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_88(error);
    }

    static void OnSuccessCallback_88(void * context, uint16_t primary2X)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_88(primary2X);
    }

    static void OnFailureCallback_89(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_89(error);
    }

    static void OnSuccessCallback_89(void * context, uint16_t primary2Y)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_89(primary2Y);
    }

    static void OnFailureCallback_90(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_90(error);
    }

    static void OnSuccessCallback_90(void * context) { (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_90(); }

    static void OnFailureCallback_91(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_91(error);
    }

    static void OnSuccessCallback_91(void * context, uint16_t primary2Y)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_91(primary2Y);
    }

    static void OnFailureCallback_92(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_92(error);
    }

    static void OnSuccessCallback_92(void * context, uint8_t primary2Intensity)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_92(primary2Intensity);
    }

    static void OnFailureCallback_93(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_93(error);
    }

    static void OnSuccessCallback_93(void * context, uint16_t primary3X)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_93(primary3X);
    }

    static void OnFailureCallback_94(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_94(error);
    }

    static void OnSuccessCallback_94(void * context) { (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_94(); }

    static void OnFailureCallback_95(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_95(error);
    }

    static void OnSuccessCallback_95(void * context, uint16_t primary3X)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_95(primary3X);
    }

    static void OnFailureCallback_96(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_96(error);
    }

    static void OnSuccessCallback_96(void * context, uint16_t primary3Y)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_96(primary3Y);
    }

    static void OnFailureCallback_97(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_97(error);
    }

    static void OnSuccessCallback_97(void * context) { (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_97(); }

    static void OnFailureCallback_98(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_98(error);
    }

    static void OnSuccessCallback_98(void * context, uint16_t primary3Y)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_98(primary3Y);
    }

    static void OnFailureCallback_99(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_99(error);
    }

    static void OnSuccessCallback_99(void * context, uint8_t primary3Intensity)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_99(primary3Intensity);
    }

    static void OnFailureCallback_100(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_100(error);
    }

    static void OnSuccessCallback_100(void * context, uint16_t primary4X)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_100(primary4X);
    }

    static void OnFailureCallback_101(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_101(error);
    }

    static void OnSuccessCallback_101(void * context) { (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_101(); }

    static void OnFailureCallback_102(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_102(error);
    }

    static void OnSuccessCallback_102(void * context, uint16_t primary4X)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_102(primary4X);
    }

    static void OnFailureCallback_103(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_103(error);
    }

    static void OnSuccessCallback_103(void * context, uint16_t primary4Y)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_103(primary4Y);
    }

    static void OnFailureCallback_104(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_104(error);
    }

    static void OnSuccessCallback_104(void * context) { (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_104(); }

    static void OnFailureCallback_105(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_105(error);
    }

    static void OnSuccessCallback_105(void * context, uint16_t primary4Y)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_105(primary4Y);
    }

    static void OnFailureCallback_106(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_106(error);
    }

    static void OnSuccessCallback_106(void * context, uint8_t primary4Intensity)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_106(primary4Intensity);
    }

    static void OnFailureCallback_107(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_107(error);
    }

    static void OnSuccessCallback_107(void * context, uint16_t primary5X)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_107(primary5X);
    }

    static void OnFailureCallback_108(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_108(error);
    }

    static void OnSuccessCallback_108(void * context) { (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_108(); }

    static void OnFailureCallback_109(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_109(error);
    }

    static void OnSuccessCallback_109(void * context, uint16_t primary5X)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_109(primary5X);
    }

    static void OnFailureCallback_110(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_110(error);
    }

    static void OnSuccessCallback_110(void * context, uint16_t primary5Y)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_110(primary5Y);
    }

    static void OnFailureCallback_111(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_111(error);
    }

    static void OnSuccessCallback_111(void * context) { (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_111(); }

    static void OnFailureCallback_112(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_112(error);
    }

    static void OnSuccessCallback_112(void * context, uint16_t primary5Y)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_112(primary5Y);
    }

    static void OnFailureCallback_113(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_113(error);
    }

    static void OnSuccessCallback_113(void * context, uint8_t primary5Intensity)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_113(primary5Intensity);
    }

    static void OnFailureCallback_114(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_114(error);
    }

    static void OnSuccessCallback_114(void * context, uint16_t primary6X)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_114(primary6X);
    }

    static void OnFailureCallback_115(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_115(error);
    }

    static void OnSuccessCallback_115(void * context) { (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_115(); }

    static void OnFailureCallback_116(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_116(error);
    }

    static void OnSuccessCallback_116(void * context, uint16_t primary6X)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_116(primary6X);
    }

    static void OnFailureCallback_117(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_117(error);
    }

    static void OnSuccessCallback_117(void * context, uint16_t primary6Y)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_117(primary6Y);
    }

    static void OnFailureCallback_118(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_118(error);
    }

    static void OnSuccessCallback_118(void * context) { (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_118(); }

    static void OnFailureCallback_119(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_119(error);
    }

    static void OnSuccessCallback_119(void * context, uint16_t primary6Y)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_119(primary6Y);
    }

    static void OnFailureCallback_120(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_120(error);
    }

    static void OnSuccessCallback_120(void * context, uint8_t primary6Intensity)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_120(primary6Intensity);
    }

    static void OnFailureCallback_121(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_121(error);
    }

    static void OnSuccessCallback_121(void * context, uint16_t whitePointX)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_121(whitePointX);
    }

    static void OnFailureCallback_122(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_122(error);
    }

    static void OnSuccessCallback_122(void * context) { (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_122(); }

    static void OnFailureCallback_123(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_123(error);
    }

    static void OnSuccessCallback_123(void * context, uint16_t whitePointX)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_123(whitePointX);
    }

    static void OnFailureCallback_124(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_124(error);
    }

    static void OnSuccessCallback_124(void * context, uint16_t whitePointY)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_124(whitePointY);
    }

    static void OnFailureCallback_125(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_125(error);
    }

    static void OnSuccessCallback_125(void * context) { (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_125(); }

    static void OnFailureCallback_126(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_126(error);
    }

    static void OnSuccessCallback_126(void * context, uint16_t whitePointY)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_126(whitePointY);
    }

    static void OnFailureCallback_127(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_127(error);
    }

    static void OnSuccessCallback_127(void * context, uint16_t colorPointRX)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_127(colorPointRX);
    }

    static void OnFailureCallback_128(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_128(error);
    }

    static void OnSuccessCallback_128(void * context) { (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_128(); }

    static void OnFailureCallback_129(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_129(error);
    }

    static void OnSuccessCallback_129(void * context, uint16_t colorPointRX)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_129(colorPointRX);
    }

    static void OnFailureCallback_130(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_130(error);
    }

    static void OnSuccessCallback_130(void * context, uint16_t colorPointRY)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_130(colorPointRY);
    }

    static void OnFailureCallback_131(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_131(error);
    }

    static void OnSuccessCallback_131(void * context) { (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_131(); }

    static void OnFailureCallback_132(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_132(error);
    }

    static void OnSuccessCallback_132(void * context, uint16_t colorPointRY)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_132(colorPointRY);
    }

    static void OnFailureCallback_133(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_133(error);
    }

    static void OnSuccessCallback_133(void * context, uint8_t colorPointRIntensity)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_133(colorPointRIntensity);
    }

    static void OnFailureCallback_134(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_134(error);
    }

    static void OnSuccessCallback_134(void * context) { (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_134(); }

    static void OnFailureCallback_135(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_135(error);
    }

    static void OnSuccessCallback_135(void * context, uint8_t colorPointRIntensity)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_135(colorPointRIntensity);
    }

    static void OnFailureCallback_136(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_136(error);
    }

    static void OnSuccessCallback_136(void * context, uint16_t colorPointGX)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_136(colorPointGX);
    }

    static void OnFailureCallback_137(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_137(error);
    }

    static void OnSuccessCallback_137(void * context) { (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_137(); }

    static void OnFailureCallback_138(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_138(error);
    }

    static void OnSuccessCallback_138(void * context, uint16_t colorPointGX)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_138(colorPointGX);
    }

    static void OnFailureCallback_139(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_139(error);
    }

    static void OnSuccessCallback_139(void * context, uint16_t colorPointGY)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_139(colorPointGY);
    }

    static void OnFailureCallback_140(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_140(error);
    }

    static void OnSuccessCallback_140(void * context) { (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_140(); }

    static void OnFailureCallback_141(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_141(error);
    }

    static void OnSuccessCallback_141(void * context, uint16_t colorPointGY)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_141(colorPointGY);
    }

    static void OnFailureCallback_142(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_142(error);
    }

    static void OnSuccessCallback_142(void * context, uint8_t colorPointGIntensity)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_142(colorPointGIntensity);
    }

    static void OnFailureCallback_143(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_143(error);
    }

    static void OnSuccessCallback_143(void * context) { (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_143(); }

    static void OnFailureCallback_144(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_144(error);
    }

    static void OnSuccessCallback_144(void * context, uint8_t colorPointGIntensity)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_144(colorPointGIntensity);
    }

    static void OnFailureCallback_145(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_145(error);
    }

    static void OnSuccessCallback_145(void * context, uint16_t colorPointBX)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_145(colorPointBX);
    }

    static void OnFailureCallback_146(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_146(error);
    }

    static void OnSuccessCallback_146(void * context) { (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_146(); }

    static void OnFailureCallback_147(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_147(error);
    }

    static void OnSuccessCallback_147(void * context, uint16_t colorPointBX)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_147(colorPointBX);
    }

    static void OnFailureCallback_148(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_148(error);
    }

    static void OnSuccessCallback_148(void * context, uint16_t colorPointBY)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_148(colorPointBY);
    }

    static void OnFailureCallback_149(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_149(error);
    }

    static void OnSuccessCallback_149(void * context) { (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_149(); }

    static void OnFailureCallback_150(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_150(error);
    }

    static void OnSuccessCallback_150(void * context, uint16_t colorPointBY)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_150(colorPointBY);
    }

    static void OnFailureCallback_151(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_151(error);
    }

    static void OnSuccessCallback_151(void * context, uint8_t colorPointBIntensity)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_151(colorPointBIntensity);
    }

    static void OnFailureCallback_152(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_152(error);
    }

    static void OnSuccessCallback_152(void * context) { (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_152(); }

    static void OnFailureCallback_153(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnFailureResponse_153(error);
    }

    static void OnSuccessCallback_153(void * context, uint8_t colorPointBIntensity)
    {
        (static_cast<Test_TC_CC_2_1Suite *>(context))->OnSuccessResponse_153(colorPointBIntensity);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestReadsMandatoryAttributeCurrentHue_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::CurrentHue::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1(uint8_t currentHue)
    {
        VerifyOrReturn(CheckValue("currentHue", currentHue, 0));

        NextTest();
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeCurrentHue_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::CurrentHue::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2(uint8_t currentHue)
    {
        VerifyOrReturn(CheckConstraintType("currentHue", "", "uint8"));
        VerifyOrReturn(CheckConstraintMinValue<uint8_t>("currentHue", currentHue, 0));
        VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("currentHue", currentHue, 254));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValueToMandatoryAttributeCurrentHue_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t currentHueArgument;
        currentHueArgument = 0;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::CurrentHue::TypeInfo>(
            currentHueArgument, this, OnSuccessCallback_3, OnFailureCallback_3));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_3() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackMandatoryAttributeCurrentHue_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::CurrentHue::TypeInfo>(
            this, OnSuccessCallback_4, OnFailureCallback_4, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_4(uint8_t currentHue)
    {
        VerifyOrReturn(CheckValue("currentHue", currentHue, 0));

        NextTest();
    }

    CHIP_ERROR TestReadsMandatoryAttributeCurrentSaturation_5()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::CurrentSaturation::TypeInfo>(
            this, OnSuccessCallback_5, OnFailureCallback_5, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_5(uint8_t currentSaturation)
    {
        VerifyOrReturn(CheckValue("currentSaturation", currentSaturation, 0));

        NextTest();
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeCurrentSaturation_6()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::CurrentSaturation::TypeInfo>(
            this, OnSuccessCallback_6, OnFailureCallback_6, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_6(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_6(uint8_t currentSaturation)
    {
        VerifyOrReturn(CheckConstraintType("currentSaturation", "", "uint8"));
        VerifyOrReturn(CheckConstraintMinValue<uint8_t>("currentSaturation", currentSaturation, 0));
        VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("currentSaturation", currentSaturation, 254));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValueToMandatoryAttributeCurrentSaturation_7()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t currentSaturationArgument;
        currentSaturationArgument = 0;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::CurrentSaturation::TypeInfo>(
            currentSaturationArgument, this, OnSuccessCallback_7, OnFailureCallback_7));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_7(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_7() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackMandatoryAttributeCurrentSaturation_8()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::CurrentSaturation::TypeInfo>(
            this, OnSuccessCallback_8, OnFailureCallback_8, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_8(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_8(uint8_t currentSaturation)
    {
        VerifyOrReturn(CheckValue("currentSaturation", currentSaturation, 0));

        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeCurrentX_9()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::CurrentX::TypeInfo>(
            this, OnSuccessCallback_9, OnFailureCallback_9, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_9(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_9(uint16_t currentX)
    {
        VerifyOrReturn(CheckValue("currentX", currentX, 24939U));

        NextTest();
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeCurrentX_10()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::CurrentX::TypeInfo>(
            this, OnSuccessCallback_10, OnFailureCallback_10, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_10(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_10(uint16_t currentX)
    {
        VerifyOrReturn(CheckConstraintType("currentX", "", "uint16"));
        VerifyOrReturn(CheckConstraintMinValue<uint16_t>("currentX", currentX, 0U));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("currentX", currentX, 65279U));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValueToMandatoryAttributeCurrentX_11()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t currentXArgument;
        currentXArgument = 24939U;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::CurrentX::TypeInfo>(
            currentXArgument, this, OnSuccessCallback_11, OnFailureCallback_11));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_11(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_11() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackMandatoryAttributeCurrentX_12()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::CurrentX::TypeInfo>(
            this, OnSuccessCallback_12, OnFailureCallback_12, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_12(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_12(uint16_t currentX)
    {
        VerifyOrReturn(CheckValue("currentX", currentX, 24939U));

        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeCurrentY_13()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::CurrentY::TypeInfo>(
            this, OnSuccessCallback_13, OnFailureCallback_13, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_13(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_13(uint16_t currentY)
    {
        VerifyOrReturn(CheckValue("currentY", currentY, 24701U));

        NextTest();
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeCurrentY_14()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::CurrentY::TypeInfo>(
            this, OnSuccessCallback_14, OnFailureCallback_14, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_14(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_14(uint16_t currentY)
    {
        VerifyOrReturn(CheckConstraintType("currentY", "", "uint16"));
        VerifyOrReturn(CheckConstraintMinValue<uint16_t>("currentY", currentY, 0U));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("currentY", currentY, 65279U));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryAttributeCurrentY_15()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t currentYArgument;
        currentYArgument = 24701U;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::CurrentY::TypeInfo>(
            currentYArgument, this, OnSuccessCallback_15, OnFailureCallback_15));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_15(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_15() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackMandatoryAttributeCurrentY_16()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::CurrentY::TypeInfo>(
            this, OnSuccessCallback_16, OnFailureCallback_16, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_16(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_16(uint16_t currentY)
    {
        VerifyOrReturn(CheckValue("currentY", currentY, 24701U));

        NextTest();
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeColorTemperatureMireds_17()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorTemperature::TypeInfo>(
            this, OnSuccessCallback_17, OnFailureCallback_17, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_17(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_17(uint16_t colorTemperature)
    {
        VerifyOrReturn(CheckConstraintType("colorTemperature", "", "uint16"));
        VerifyOrReturn(CheckConstraintMinValue<uint16_t>("colorTemperature", colorTemperature, 0U));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("colorTemperature", colorTemperature, 65279U));
        NextTest();
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeColorMode_18()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorMode::TypeInfo>(
            this, OnSuccessCallback_18, OnFailureCallback_18, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_18(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_18(uint8_t colorMode)
    {
        VerifyOrReturn(CheckConstraintType("colorMode", "", "enum8"));
        VerifyOrReturn(CheckConstraintMinValue<uint8_t>("colorMode", colorMode, 0));
        VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("colorMode", colorMode, 2));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeOptions_19()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorControlOptions::TypeInfo>(
            this, OnSuccessCallback_19, OnFailureCallback_19, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_19(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_19(uint8_t colorControlOptions)
    {
        VerifyOrReturn(CheckValue("colorControlOptions", colorControlOptions, 0));

        NextTest();
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeOptions_20()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorControlOptions::TypeInfo>(
            this, OnSuccessCallback_20, OnFailureCallback_20, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_20(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_20(uint8_t colorControlOptions)
    {
        VerifyOrReturn(CheckConstraintType("colorControlOptions", "", "map8"));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryAttributeOptions_21()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t colorControlOptionsArgument;
        colorControlOptionsArgument = 0;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::ColorControlOptions::TypeInfo>(
            colorControlOptionsArgument, this, OnSuccessCallback_21, OnFailureCallback_21));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_21(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_21() { NextTest(); }

    CHIP_ERROR TestReadsBackMandatoryAttributeOptions_22()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorControlOptions::TypeInfo>(
            this, OnSuccessCallback_22, OnFailureCallback_22, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_22(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_22(uint8_t colorControlOptions)
    {
        VerifyOrReturn(CheckValue("colorControlOptions", colorControlOptions, 0));

        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeEnhancedCurrentHue_23()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::EnhancedCurrentHue::TypeInfo>(
            this, OnSuccessCallback_23, OnFailureCallback_23, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_23(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_23(uint16_t enhancedCurrentHue)
    {
        VerifyOrReturn(CheckValue("enhancedCurrentHue", enhancedCurrentHue, 0U));

        NextTest();
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeEnhancedCurrentHue_24()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::EnhancedCurrentHue::TypeInfo>(
            this, OnSuccessCallback_24, OnFailureCallback_24, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_24(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_24(uint16_t enhancedCurrentHue)
    {
        VerifyOrReturn(CheckConstraintType("enhancedCurrentHue", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryAttributeEnhancedCurrentHue_25()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t enhancedCurrentHueArgument;
        enhancedCurrentHueArgument = 0U;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::EnhancedCurrentHue::TypeInfo>(
            enhancedCurrentHueArgument, this, OnSuccessCallback_25, OnFailureCallback_25));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_25(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_25() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackMandatoryAttributeEnhancedCurrentHue_26()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::EnhancedCurrentHue::TypeInfo>(
            this, OnSuccessCallback_26, OnFailureCallback_26, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_26(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_26(uint16_t enhancedCurrentHue)
    {
        VerifyOrReturn(CheckValue("enhancedCurrentHue", enhancedCurrentHue, 0U));

        NextTest();
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeEnhancedColorMode_27()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::EnhancedColorMode::TypeInfo>(
            this, OnSuccessCallback_27, OnFailureCallback_27, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_27(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_27(uint8_t enhancedColorMode)
    {
        VerifyOrReturn(CheckConstraintType("enhancedColorMode", "", "enum8"));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeColorLoopActive_28()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopActive::TypeInfo>(
            this, OnSuccessCallback_28, OnFailureCallback_28, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_28(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_28(uint8_t colorLoopActive)
    {
        VerifyOrReturn(CheckValue("colorLoopActive", colorLoopActive, 0));

        NextTest();
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeColorLoopActive_29()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopActive::TypeInfo>(
            this, OnSuccessCallback_29, OnFailureCallback_29, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_29(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_29(uint8_t colorLoopActive)
    {
        VerifyOrReturn(CheckConstraintType("colorLoopActive", "", "uint8"));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryAttributeColorLoopActive_30()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t colorLoopActiveArgument;
        colorLoopActiveArgument = 0;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopActive::TypeInfo>(
            colorLoopActiveArgument, this, OnSuccessCallback_30, OnFailureCallback_30));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_30(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_30() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackMandatoryAttributeColorLoopActive_31()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopActive::TypeInfo>(
            this, OnSuccessCallback_31, OnFailureCallback_31, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_31(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_31(uint8_t colorLoopActive)
    {
        VerifyOrReturn(CheckValue("colorLoopActive", colorLoopActive, 0));

        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeColorLoopDirection_32()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopDirection::TypeInfo>(
            this, OnSuccessCallback_32, OnFailureCallback_32, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_32(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_32(uint8_t colorLoopDirection)
    {
        VerifyOrReturn(CheckValue("colorLoopDirection", colorLoopDirection, 0));

        NextTest();
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeColorLoopDirection_33()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopDirection::TypeInfo>(
            this, OnSuccessCallback_33, OnFailureCallback_33, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_33(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_33(uint8_t colorLoopDirection)
    {
        VerifyOrReturn(CheckConstraintType("colorLoopDirection", "", "uint8"));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryAttributeColorLoopDirection_34()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t colorLoopDirectionArgument;
        colorLoopDirectionArgument = 0;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopDirection::TypeInfo>(
            colorLoopDirectionArgument, this, OnSuccessCallback_34, OnFailureCallback_34));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_34(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_34() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackMandatoryAttributeColorLoopDirection_35()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopDirection::TypeInfo>(
            this, OnSuccessCallback_35, OnFailureCallback_35, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_35(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_35(uint8_t colorLoopDirection)
    {
        VerifyOrReturn(CheckValue("colorLoopDirection", colorLoopDirection, 0));

        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeColorLoopTime_36()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopTime::TypeInfo>(
            this, OnSuccessCallback_36, OnFailureCallback_36, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_36(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_36(uint16_t colorLoopTime)
    {
        VerifyOrReturn(CheckValue("colorLoopTime", colorLoopTime, 25U));

        NextTest();
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeColorLoopTime_37()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopTime::TypeInfo>(
            this, OnSuccessCallback_37, OnFailureCallback_37, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_37(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_37(uint16_t colorLoopTime)
    {
        VerifyOrReturn(CheckConstraintType("colorLoopTime", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryAttributeColorLoopTime_38()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t colorLoopTimeArgument;
        colorLoopTimeArgument = 25U;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopTime::TypeInfo>(
            colorLoopTimeArgument, this, OnSuccessCallback_38, OnFailureCallback_38));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_38(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_38() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackMandatoryAttributeColorLoopTime_39()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopTime::TypeInfo>(
            this, OnSuccessCallback_39, OnFailureCallback_39, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_39(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_39(uint16_t colorLoopTime)
    {
        VerifyOrReturn(CheckValue("colorLoopTime", colorLoopTime, 25U));

        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeColorLoopStartEnhancedHue_40()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopStartEnhancedHue::TypeInfo>(
                this, OnSuccessCallback_40, OnFailureCallback_40, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_40(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_40(uint16_t colorLoopStartEnhancedHue)
    {
        VerifyOrReturn(CheckValue("colorLoopStartEnhancedHue", colorLoopStartEnhancedHue, 8960U));

        NextTest();
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeColorLoopStartEnhancedHue_41()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopStartEnhancedHue::TypeInfo>(
                this, OnSuccessCallback_41, OnFailureCallback_41, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_41(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_41(uint16_t colorLoopStartEnhancedHue)
    {
        VerifyOrReturn(CheckConstraintType("colorLoopStartEnhancedHue", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryAttributeColorLoopStartEnhancedHue_42()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t colorLoopStartEnhancedHueArgument;
        colorLoopStartEnhancedHueArgument = 8960U;

        ReturnErrorOnFailure(
            cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopStartEnhancedHue::TypeInfo>(
                colorLoopStartEnhancedHueArgument, this, OnSuccessCallback_42, OnFailureCallback_42));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_42(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_42() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackMandatoryAttributeColorLoopStartEnhancedHue_43()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopStartEnhancedHue::TypeInfo>(
                this, OnSuccessCallback_43, OnFailureCallback_43, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_43(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_43(uint16_t colorLoopStartEnhancedHue)
    {
        VerifyOrReturn(CheckValue("colorLoopStartEnhancedHue", colorLoopStartEnhancedHue, 8960U));

        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeColorLoopStoredEnhancedHue_44()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopStoredEnhancedHue::TypeInfo>(
                this, OnSuccessCallback_44, OnFailureCallback_44, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_44(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_44(uint16_t colorLoopStoredEnhancedHue)
    {
        VerifyOrReturn(CheckValue("colorLoopStoredEnhancedHue", colorLoopStoredEnhancedHue, 0U));

        NextTest();
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeColorLoopStoredEnhancedHue_45()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopStoredEnhancedHue::TypeInfo>(
                this, OnSuccessCallback_45, OnFailureCallback_45, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_45(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_45(uint16_t colorLoopStoredEnhancedHue)
    {
        VerifyOrReturn(CheckConstraintType("colorLoopStoredEnhancedHue", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryAttributeColorLoopStoredEnhancedHue_46()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t colorLoopStoredEnhancedHueArgument;
        colorLoopStoredEnhancedHueArgument = 0U;

        ReturnErrorOnFailure(
            cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopStoredEnhancedHue::TypeInfo>(
                colorLoopStoredEnhancedHueArgument, this, OnSuccessCallback_46, OnFailureCallback_46));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_46(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_46() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackMandatoryAttributeColorLoopStoredEnhancedHue_47()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopStoredEnhancedHue::TypeInfo>(
                this, OnSuccessCallback_47, OnFailureCallback_47, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_47(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_47(uint16_t colorLoopStoredEnhancedHue)
    {
        VerifyOrReturn(CheckValue("colorLoopStoredEnhancedHue", colorLoopStoredEnhancedHue, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeColorCapabilities_48()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorCapabilities::TypeInfo>(
            this, OnSuccessCallback_48, OnFailureCallback_48, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_48(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_48(uint16_t colorCapabilities)
    {
        VerifyOrReturn(CheckValue("colorCapabilities", colorCapabilities, 0U));

        NextTest();
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeColorCapabilities_49()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorCapabilities::TypeInfo>(
            this, OnSuccessCallback_49, OnFailureCallback_49, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_49(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_49(uint16_t colorCapabilities)
    {
        VerifyOrReturn(CheckConstraintType("colorCapabilities", "", "map16"));
        VerifyOrReturn(CheckConstraintMinValue<uint16_t>("colorCapabilities", colorCapabilities, 0U));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("colorCapabilities", colorCapabilities, 65279U));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryAttributeColorCapabilities_50()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t colorCapabilitiesArgument;
        colorCapabilitiesArgument = 0U;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::ColorCapabilities::TypeInfo>(
            colorCapabilitiesArgument, this, OnSuccessCallback_50, OnFailureCallback_50));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_50(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_50() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackMandatoryAttributeColorCapabilities_51()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorCapabilities::TypeInfo>(
            this, OnSuccessCallback_51, OnFailureCallback_51, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_51(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_51(uint16_t colorCapabilities)
    {
        VerifyOrReturn(CheckValue("colorCapabilities", colorCapabilities, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeColorTempPhysicalMinMireds_52()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorTempPhysicalMin::TypeInfo>(
            this, OnSuccessCallback_52, OnFailureCallback_52, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_52(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_52(uint16_t colorTempPhysicalMin)
    {
        VerifyOrReturn(CheckValue("colorTempPhysicalMin", colorTempPhysicalMin, 0U));

        NextTest();
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeColorTempPhysicalMinMireds_53()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorTempPhysicalMin::TypeInfo>(
            this, OnSuccessCallback_53, OnFailureCallback_53, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_53(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_53(uint16_t colorTempPhysicalMin)
    {
        VerifyOrReturn(CheckConstraintType("colorTempPhysicalMin", "", "uint16"));
        VerifyOrReturn(CheckConstraintMinValue<uint16_t>("colorTempPhysicalMin", colorTempPhysicalMin, 0U));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("colorTempPhysicalMin", colorTempPhysicalMin, 65279U));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryAttributeColorTempPhysicalMinMireds_54()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t colorTempPhysicalMinArgument;
        colorTempPhysicalMinArgument = 0U;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::ColorTempPhysicalMin::TypeInfo>(
            colorTempPhysicalMinArgument, this, OnSuccessCallback_54, OnFailureCallback_54));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_54(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_54() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackMandatoryAttributeColorTempPhysicalMinMireds_55()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorTempPhysicalMin::TypeInfo>(
            this, OnSuccessCallback_55, OnFailureCallback_55, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_55(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_55(uint16_t colorTempPhysicalMin)
    {
        VerifyOrReturn(CheckValue("colorTempPhysicalMin", colorTempPhysicalMin, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeColorTempPhysicalMaxMireds_56()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorTempPhysicalMax::TypeInfo>(
            this, OnSuccessCallback_56, OnFailureCallback_56, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_56(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_56(uint16_t colorTempPhysicalMax)
    {
        VerifyOrReturn(CheckValue("colorTempPhysicalMax", colorTempPhysicalMax, 65279U));

        NextTest();
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeColorTempPhysicalMaxMireds_57()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorTempPhysicalMax::TypeInfo>(
            this, OnSuccessCallback_57, OnFailureCallback_57, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_57(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_57(uint16_t colorTempPhysicalMax)
    {
        VerifyOrReturn(CheckConstraintType("colorTempPhysicalMax", "", "uint16"));
        VerifyOrReturn(CheckConstraintMinValue<uint16_t>("colorTempPhysicalMax", colorTempPhysicalMax, 0U));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("colorTempPhysicalMax", colorTempPhysicalMax, 65279U));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryAttributeColorTempPhysicalMaxMireds_58()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t colorTempPhysicalMaxArgument;
        colorTempPhysicalMaxArgument = 65279U;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::ColorTempPhysicalMax::TypeInfo>(
            colorTempPhysicalMaxArgument, this, OnSuccessCallback_58, OnFailureCallback_58));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_58(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_58() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackMandatoryAttributeColorTempPhysicalMaxMireds_59()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorTempPhysicalMax::TypeInfo>(
            this, OnSuccessCallback_59, OnFailureCallback_59, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_59(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_59(uint16_t colorTempPhysicalMax)
    {
        VerifyOrReturn(CheckValue("colorTempPhysicalMax", colorTempPhysicalMax, 65279U));

        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeCoupleColorTempToLevelMinMireds_60()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::CoupleColorTempToLevelMinMireds::TypeInfo>(
                this, OnSuccessCallback_60, OnFailureCallback_60, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_60(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_60(uint16_t coupleColorTempToLevelMinMireds)
    {
        VerifyOrReturn(CheckConstraintType("coupleColorTempToLevelMinMireds", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToOptionalAttributeCoupleColorTempToLevelMinMireds_61()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t coupleColorTempToLevelMinMiredsArgument;
        coupleColorTempToLevelMinMiredsArgument = 0U;

        ReturnErrorOnFailure(
            cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::CoupleColorTempToLevelMinMireds::TypeInfo>(
                coupleColorTempToLevelMinMiredsArgument, this, OnSuccessCallback_61, OnFailureCallback_61));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_61(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_61() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackOptionalAttributeCoupleColorTempToLevelMinMireds_62()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::CoupleColorTempToLevelMinMireds::TypeInfo>(
                this, OnSuccessCallback_62, OnFailureCallback_62, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_62(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_62(uint16_t coupleColorTempToLevelMinMireds)
    {
        VerifyOrReturn(CheckValue("coupleColorTempToLevelMinMireds", coupleColorTempToLevelMinMireds, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeStartUpColorTemperatureMireds_63()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::StartUpColorTemperatureMireds::TypeInfo>(
                this, OnSuccessCallback_63, OnFailureCallback_63, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_63(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_63(uint16_t startUpColorTemperatureMireds)
    {
        VerifyOrReturn(CheckConstraintType("startUpColorTemperatureMireds", "", "uint16"));
        VerifyOrReturn(CheckConstraintMinValue<uint16_t>("startUpColorTemperatureMireds", startUpColorTemperatureMireds, 0U));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("startUpColorTemperatureMireds", startUpColorTemperatureMireds, 65279U));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToOptionalAttributeStartUpColorTemperatureMireds_64()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t startUpColorTemperatureMiredsArgument;
        startUpColorTemperatureMiredsArgument = 0U;

        ReturnErrorOnFailure(
            cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::StartUpColorTemperatureMireds::TypeInfo>(
                startUpColorTemperatureMiredsArgument, this, OnSuccessCallback_64, OnFailureCallback_64));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_64(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_64() { NextTest(); }

    CHIP_ERROR TestReadsBackOptionalAttributeStartUpColorTemperatureMireds_65()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::StartUpColorTemperatureMireds::TypeInfo>(
                this, OnSuccessCallback_65, OnFailureCallback_65, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_65(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_65(uint16_t startUpColorTemperatureMireds)
    {
        VerifyOrReturn(CheckValue("startUpColorTemperatureMireds", startUpColorTemperatureMireds, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeRemainingTime_66()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::RemainingTime::TypeInfo>(
            this, OnSuccessCallback_66, OnFailureCallback_66, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_66(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_66(uint16_t remainingTime)
    {
        VerifyOrReturn(CheckValue("remainingTime", remainingTime, 0U));

        NextTest();
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeRemainingTime_67()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::RemainingTime::TypeInfo>(
            this, OnSuccessCallback_67, OnFailureCallback_67, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_67(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_67(uint16_t remainingTime)
    {
        VerifyOrReturn(CheckConstraintType("remainingTime", "", "uint16"));
        VerifyOrReturn(CheckConstraintMinValue<uint16_t>("remainingTime", remainingTime, 0U));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("remainingTime", remainingTime, 254U));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToOptionalAttributeRemainingTime_68()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t remainingTimeArgument;
        remainingTimeArgument = 0U;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::RemainingTime::TypeInfo>(
            remainingTimeArgument, this, OnSuccessCallback_68, OnFailureCallback_68));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_68(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_68() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackOptionalAttributeRemainingTime_69()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::RemainingTime::TypeInfo>(
            this, OnSuccessCallback_69, OnFailureCallback_69, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_69(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_69(uint16_t remainingTime)
    {
        VerifyOrReturn(CheckValue("remainingTime", remainingTime, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeDriftCompensation_70()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::DriftCompensation::TypeInfo>(
            this, OnSuccessCallback_70, OnFailureCallback_70, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_70(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_70(uint8_t driftCompensation)
    {
        VerifyOrReturn(CheckConstraintType("driftCompensation", "", "enum8"));
        VerifyOrReturn(CheckConstraintMinValue<uint8_t>("driftCompensation", driftCompensation, 0));
        VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("driftCompensation", driftCompensation, 4));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToOptionalAttributeDriftCompensation_71()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t driftCompensationArgument;
        driftCompensationArgument = 0;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::DriftCompensation::TypeInfo>(
            driftCompensationArgument, this, OnSuccessCallback_71, OnFailureCallback_71));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_71(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_71() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackOptionalAttributeDriftCompensation_72()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::DriftCompensation::TypeInfo>(
            this, OnSuccessCallback_72, OnFailureCallback_72, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_72(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_72(uint8_t driftCompensation)
    {
        VerifyOrReturn(CheckValue("driftCompensation", driftCompensation, 0));

        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeCompensationText_73()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::CompensationText::TypeInfo>(
            this, OnSuccessCallback_73, OnFailureCallback_73, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_73(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_73(chip::CharSpan compensationText)
    {
        VerifyOrReturn(CheckConstraintType("compensationText", "", "string"));
        VerifyOrReturn(CheckConstraintMaxLength("compensationText", compensationText.size(), 254));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToOptionalAttributeCompensationText_74()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::CharSpan compensationTextArgument;
        compensationTextArgument = chip::Span<const char>("garbage: not in length on purpose", 0);

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::CompensationText::TypeInfo>(
            compensationTextArgument, this, OnSuccessCallback_74, OnFailureCallback_74));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_74(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_74() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackOptionalAttributeCompensationText_75()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::CompensationText::TypeInfo>(
            this, OnSuccessCallback_75, OnFailureCallback_75, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_75(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_75(chip::CharSpan compensationText)
    {
        VerifyOrReturn(CheckValueAsString("compensationText", compensationText, chip::CharSpan("", 0)));

        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeNumberOfPrimaries_76()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::NumberOfPrimaries::TypeInfo>(
            this, OnSuccessCallback_76, OnFailureCallback_76, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_76(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_76(uint8_t numberOfPrimaries)
    {
        VerifyOrReturn(CheckConstraintType("numberOfPrimaries", "", "uint8"));
        VerifyOrReturn(CheckConstraintMinValue<uint8_t>("numberOfPrimaries", numberOfPrimaries, 0));
        VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("numberOfPrimaries", numberOfPrimaries, 6));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultMandatoryAttributeNumberOfPrimaries_77()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t numberOfPrimariesArgument;
        numberOfPrimariesArgument = 0;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::NumberOfPrimaries::TypeInfo>(
            numberOfPrimariesArgument, this, OnSuccessCallback_77, OnFailureCallback_77));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_77(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_77() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadBackTheMandatoryAttributeNumberOfPrimaries_78()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::NumberOfPrimaries::TypeInfo>(
            this, OnSuccessCallback_78, OnFailureCallback_78, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_78(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_78(uint8_t numberOfPrimaries)
    {
        VerifyOrReturn(CheckValue("numberOfPrimaries", numberOfPrimaries, 0));

        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributePrimary1X_79()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary1X::TypeInfo>(
            this, OnSuccessCallback_79, OnFailureCallback_79, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_79(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_79(uint16_t primary1X)
    {
        VerifyOrReturn(CheckConstraintType("primary1X", "", "uint16"));
        VerifyOrReturn(CheckConstraintMinValue<uint16_t>("primary1X", primary1X, 0U));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("primary1X", primary1X, 65279U));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultMandatoryAttributePrimary1X_80()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t primary1XArgument;
        primary1XArgument = 0U;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::Primary1X::TypeInfo>(
            primary1XArgument, this, OnSuccessCallback_80, OnFailureCallback_80));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_80(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_80() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadBackTheMandatoryAttributePrimary1X_81()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary1X::TypeInfo>(
            this, OnSuccessCallback_81, OnFailureCallback_81, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_81(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_81(uint16_t primary1X)
    {
        VerifyOrReturn(CheckValue("primary1X", primary1X, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributePrimary1Y_82()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary1Y::TypeInfo>(
            this, OnSuccessCallback_82, OnFailureCallback_82, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_82(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_82(uint16_t primary1Y)
    {
        VerifyOrReturn(CheckConstraintType("primary1Y", "", "uint16"));
        VerifyOrReturn(CheckConstraintMinValue<uint16_t>("primary1Y", primary1Y, 0U));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("primary1Y", primary1Y, 65279U));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultMandatoryAttributePrimary1Y_83()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t primary1YArgument;
        primary1YArgument = 0U;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::Primary1Y::TypeInfo>(
            primary1YArgument, this, OnSuccessCallback_83, OnFailureCallback_83));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_83(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_83() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadBackTheMandatoryAttributePrimary1Y_84()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary1Y::TypeInfo>(
            this, OnSuccessCallback_84, OnFailureCallback_84, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_84(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_84(uint16_t primary1Y)
    {
        VerifyOrReturn(CheckValue("primary1Y", primary1Y, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributePrimary1Intensity_85()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary1Intensity::TypeInfo>(
            this, OnSuccessCallback_85, OnFailureCallback_85, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_85(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_85(uint8_t primary1Intensity)
    {
        VerifyOrReturn(CheckConstraintType("primary1Intensity", "", "uint8"));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributePrimary2X_86()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary2X::TypeInfo>(
            this, OnSuccessCallback_86, OnFailureCallback_86, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_86(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_86(uint16_t primary2X)
    {
        VerifyOrReturn(CheckConstraintType("primary2X", "", "uint16"));
        VerifyOrReturn(CheckConstraintMinValue<uint16_t>("primary2X", primary2X, 0U));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("primary2X", primary2X, 65279U));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultMandatoryAttributePrimary2X_87()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t primary2XArgument;
        primary2XArgument = 0U;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::Primary2X::TypeInfo>(
            primary2XArgument, this, OnSuccessCallback_87, OnFailureCallback_87));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_87(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_87() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadBackTheMandatoryAttributePrimary2X_88()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary2X::TypeInfo>(
            this, OnSuccessCallback_88, OnFailureCallback_88, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_88(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_88(uint16_t primary2X)
    {
        VerifyOrReturn(CheckValue("primary2X", primary2X, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributePrimary2Y_89()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary2Y::TypeInfo>(
            this, OnSuccessCallback_89, OnFailureCallback_89, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_89(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_89(uint16_t primary2Y)
    {
        VerifyOrReturn(CheckConstraintType("primary2Y", "", "uint16"));
        VerifyOrReturn(CheckConstraintMinValue<uint16_t>("primary2Y", primary2Y, 0U));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("primary2Y", primary2Y, 65279U));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultMandatoryAttributePrimary2Y_90()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t primary2YArgument;
        primary2YArgument = 0U;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::Primary2Y::TypeInfo>(
            primary2YArgument, this, OnSuccessCallback_90, OnFailureCallback_90));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_90(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_90() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadBackTheMandatoryAttributePrimary2Y_91()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary2Y::TypeInfo>(
            this, OnSuccessCallback_91, OnFailureCallback_91, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_91(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_91(uint16_t primary2Y)
    {
        VerifyOrReturn(CheckValue("primary2Y", primary2Y, 0U));

        NextTest();
    }

    CHIP_ERROR TestValidateConstraintsOfAttributePrimary2Intensity_92()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary2Intensity::TypeInfo>(
            this, OnSuccessCallback_92, OnFailureCallback_92, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_92(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_92(uint8_t primary2Intensity)
    {
        VerifyOrReturn(CheckConstraintType("primary2Intensity", "", "uint8"));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributePrimary3X_93()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary3X::TypeInfo>(
            this, OnSuccessCallback_93, OnFailureCallback_93, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_93(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_93(uint16_t primary3X)
    {
        VerifyOrReturn(CheckConstraintType("primary3X", "", "uint16"));
        VerifyOrReturn(CheckConstraintMinValue<uint16_t>("primary3X", primary3X, 0U));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("primary3X", primary3X, 65279U));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultMandatoryAttributePrimary3X_94()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t primary3XArgument;
        primary3XArgument = 0U;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::Primary3X::TypeInfo>(
            primary3XArgument, this, OnSuccessCallback_94, OnFailureCallback_94));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_94(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_94() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadBackTheMandatoryAttributePrimary3X_95()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary3X::TypeInfo>(
            this, OnSuccessCallback_95, OnFailureCallback_95, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_95(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_95(uint16_t primary3X)
    {
        VerifyOrReturn(CheckValue("primary3X", primary3X, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributePrimary3Y_96()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary3Y::TypeInfo>(
            this, OnSuccessCallback_96, OnFailureCallback_96, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_96(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_96(uint16_t primary3Y)
    {
        VerifyOrReturn(CheckConstraintType("primary3Y", "", "uint16"));
        VerifyOrReturn(CheckConstraintMinValue<uint16_t>("primary3Y", primary3Y, 0U));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("primary3Y", primary3Y, 65279U));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultMandatoryAttributePrimary3Y_97()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t primary3YArgument;
        primary3YArgument = 0U;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::Primary3Y::TypeInfo>(
            primary3YArgument, this, OnSuccessCallback_97, OnFailureCallback_97));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_97(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_97() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadBackTheMandatoryAttributePrimary3Y_98()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary3Y::TypeInfo>(
            this, OnSuccessCallback_98, OnFailureCallback_98, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_98(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_98(uint16_t primary3Y)
    {
        VerifyOrReturn(CheckValue("primary3Y", primary3Y, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributePrimary3Intensity_99()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary3Intensity::TypeInfo>(
            this, OnSuccessCallback_99, OnFailureCallback_99, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_99(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_99(uint8_t primary3Intensity)
    {
        VerifyOrReturn(CheckConstraintType("primary3Intensity", "", "uint8"));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributePrimary4X_100()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary4X::TypeInfo>(
            this, OnSuccessCallback_100, OnFailureCallback_100, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_100(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_100(uint16_t primary4X)
    {
        VerifyOrReturn(CheckConstraintType("primary4X", "", "uint16"));
        VerifyOrReturn(CheckConstraintMinValue<uint16_t>("primary4X", primary4X, 0U));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("primary4X", primary4X, 65279U));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultMandatoryAttributePrimary4X_101()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t primary4XArgument;
        primary4XArgument = 0U;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::Primary4X::TypeInfo>(
            primary4XArgument, this, OnSuccessCallback_101, OnFailureCallback_101));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_101(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_101() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadBackTheMandatoryAttributePrimary4X_102()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary4X::TypeInfo>(
            this, OnSuccessCallback_102, OnFailureCallback_102, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_102(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_102(uint16_t primary4X)
    {
        VerifyOrReturn(CheckValue("primary4X", primary4X, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributePrimary4Y_103()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary4Y::TypeInfo>(
            this, OnSuccessCallback_103, OnFailureCallback_103, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_103(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_103(uint16_t primary4Y)
    {
        VerifyOrReturn(CheckConstraintType("primary4Y", "", "uint16"));
        VerifyOrReturn(CheckConstraintMinValue<uint16_t>("primary4Y", primary4Y, 0U));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("primary4Y", primary4Y, 65279U));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultMandatoryAttributePrimary4Y_104()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t primary4YArgument;
        primary4YArgument = 0U;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::Primary4Y::TypeInfo>(
            primary4YArgument, this, OnSuccessCallback_104, OnFailureCallback_104));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_104(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_104() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadBackTheMandatoryAttributePrimary4Y_105()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary4Y::TypeInfo>(
            this, OnSuccessCallback_105, OnFailureCallback_105, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_105(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_105(uint16_t primary4Y)
    {
        VerifyOrReturn(CheckValue("primary4Y", primary4Y, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributePrimary4Intensity_106()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary4Intensity::TypeInfo>(
            this, OnSuccessCallback_106, OnFailureCallback_106, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_106(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_106(uint8_t primary4Intensity)
    {
        VerifyOrReturn(CheckConstraintType("primary4Intensity", "", "uint8"));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributePrimary5X_107()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary5X::TypeInfo>(
            this, OnSuccessCallback_107, OnFailureCallback_107, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_107(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_107(uint16_t primary5X)
    {
        VerifyOrReturn(CheckConstraintType("primary5X", "", "uint16"));
        VerifyOrReturn(CheckConstraintMinValue<uint16_t>("primary5X", primary5X, 0U));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("primary5X", primary5X, 65279U));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultMandatoryAttributePrimary5X_108()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t primary5XArgument;
        primary5XArgument = 0U;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::Primary5X::TypeInfo>(
            primary5XArgument, this, OnSuccessCallback_108, OnFailureCallback_108));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_108(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_108() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadBackTheMandatoryAttributePrimary5X_109()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary5X::TypeInfo>(
            this, OnSuccessCallback_109, OnFailureCallback_109, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_109(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_109(uint16_t primary5X)
    {
        VerifyOrReturn(CheckValue("primary5X", primary5X, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributePrimary5Y_110()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary5Y::TypeInfo>(
            this, OnSuccessCallback_110, OnFailureCallback_110, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_110(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_110(uint16_t primary5Y)
    {
        VerifyOrReturn(CheckConstraintType("primary5Y", "", "uint16"));
        VerifyOrReturn(CheckConstraintMinValue<uint16_t>("primary5Y", primary5Y, 0U));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("primary5Y", primary5Y, 65279U));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultMandatoryAttributePrimary5Y_111()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t primary5YArgument;
        primary5YArgument = 0U;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::Primary5Y::TypeInfo>(
            primary5YArgument, this, OnSuccessCallback_111, OnFailureCallback_111));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_111(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_111() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadBackTheMandatoryAttributePrimary5Y_112()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary5Y::TypeInfo>(
            this, OnSuccessCallback_112, OnFailureCallback_112, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_112(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_112(uint16_t primary5Y)
    {
        VerifyOrReturn(CheckValue("primary5Y", primary5Y, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributePrimary5Intensity_113()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary5Intensity::TypeInfo>(
            this, OnSuccessCallback_113, OnFailureCallback_113, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_113(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_113(uint8_t primary5Intensity)
    {
        VerifyOrReturn(CheckConstraintType("primary5Intensity", "", "uint8"));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributePrimary6X_114()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary6X::TypeInfo>(
            this, OnSuccessCallback_114, OnFailureCallback_114, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_114(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_114(uint16_t primary6X)
    {
        VerifyOrReturn(CheckConstraintType("primary6X", "", "uint16"));
        VerifyOrReturn(CheckConstraintMinValue<uint16_t>("primary6X", primary6X, 0U));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("primary6X", primary6X, 65279U));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultMandatoryAttributePrimary6X_115()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t primary6XArgument;
        primary6XArgument = 0U;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::Primary6X::TypeInfo>(
            primary6XArgument, this, OnSuccessCallback_115, OnFailureCallback_115));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_115(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_115() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadBackTheMandatoryAttributePrimary6X_116()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary6X::TypeInfo>(
            this, OnSuccessCallback_116, OnFailureCallback_116, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_116(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_116(uint16_t primary6X)
    {
        VerifyOrReturn(CheckValue("primary6X", primary6X, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributePrimary6Y_117()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary6Y::TypeInfo>(
            this, OnSuccessCallback_117, OnFailureCallback_117, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_117(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_117(uint16_t primary6Y)
    {
        VerifyOrReturn(CheckConstraintType("primary6Y", "", "uint16"));
        VerifyOrReturn(CheckConstraintMinValue<uint16_t>("primary6Y", primary6Y, 0U));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("primary6Y", primary6Y, 65279U));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultMandatoryAttributePrimary6Y_118()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t primary6YArgument;
        primary6YArgument = 0U;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::Primary6Y::TypeInfo>(
            primary6YArgument, this, OnSuccessCallback_118, OnFailureCallback_118));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_118(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_118() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadBackTheMandatoryAttributePrimary6Y_119()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary6Y::TypeInfo>(
            this, OnSuccessCallback_119, OnFailureCallback_119, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_119(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_119(uint16_t primary6Y)
    {
        VerifyOrReturn(CheckValue("primary6Y", primary6Y, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributePrimary6Intensity_120()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary6Intensity::TypeInfo>(
            this, OnSuccessCallback_120, OnFailureCallback_120, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_120(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_120(uint8_t primary6Intensity)
    {
        VerifyOrReturn(CheckConstraintType("primary6Intensity", "", "uint8"));
        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeWhitePointX_121()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::WhitePointX::TypeInfo>(
            this, OnSuccessCallback_121, OnFailureCallback_121, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_121(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_121(uint16_t whitePointX)
    {
        VerifyOrReturn(CheckConstraintType("whitePointX", "", "uint16"));
        VerifyOrReturn(CheckConstraintMinValue<uint16_t>("whitePointX", whitePointX, 0U));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("whitePointX", whitePointX, 65279U));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultOptionalAttributeWhitePointX_122()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t whitePointXArgument;
        whitePointXArgument = 0U;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::WhitePointX::TypeInfo>(
            whitePointXArgument, this, OnSuccessCallback_122, OnFailureCallback_122));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_122(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_122() { NextTest(); }

    CHIP_ERROR TestReadBackTheOptionalAttributeWhitePointX_123()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::WhitePointX::TypeInfo>(
            this, OnSuccessCallback_123, OnFailureCallback_123, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_123(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_123(uint16_t whitePointX)
    {
        VerifyOrReturn(CheckValue("whitePointX", whitePointX, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeWhitePointY_124()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::WhitePointY::TypeInfo>(
            this, OnSuccessCallback_124, OnFailureCallback_124, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_124(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_124(uint16_t whitePointY)
    {
        VerifyOrReturn(CheckConstraintType("whitePointY", "", "uint16"));
        VerifyOrReturn(CheckConstraintMinValue<uint16_t>("whitePointY", whitePointY, 0U));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("whitePointY", whitePointY, 65279U));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultOptionalAttributeWhitePointY_125()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t whitePointYArgument;
        whitePointYArgument = 0U;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::WhitePointY::TypeInfo>(
            whitePointYArgument, this, OnSuccessCallback_125, OnFailureCallback_125));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_125(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_125() { NextTest(); }

    CHIP_ERROR TestReadBackTheOptionalAttributeWhitePointY_126()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::WhitePointY::TypeInfo>(
            this, OnSuccessCallback_126, OnFailureCallback_126, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_126(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_126(uint16_t whitePointY)
    {
        VerifyOrReturn(CheckValue("whitePointY", whitePointY, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeColorPointRX_127()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorPointRX::TypeInfo>(
            this, OnSuccessCallback_127, OnFailureCallback_127, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_127(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_127(uint16_t colorPointRX)
    {
        VerifyOrReturn(CheckConstraintType("colorPointRX", "", "uint16"));
        VerifyOrReturn(CheckConstraintMinValue<uint16_t>("colorPointRX", colorPointRX, 0U));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("colorPointRX", colorPointRX, 65279U));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultOptionalAttributeColorPointRX_128()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t colorPointRXArgument;
        colorPointRXArgument = 0U;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::ColorPointRX::TypeInfo>(
            colorPointRXArgument, this, OnSuccessCallback_128, OnFailureCallback_128));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_128(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_128() { NextTest(); }

    CHIP_ERROR TestReadBackTheOptionalAttributeColorPointRX_129()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorPointRX::TypeInfo>(
            this, OnSuccessCallback_129, OnFailureCallback_129, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_129(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_129(uint16_t colorPointRX)
    {
        VerifyOrReturn(CheckValue("colorPointRX", colorPointRX, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeColorPointRY_130()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorPointRY::TypeInfo>(
            this, OnSuccessCallback_130, OnFailureCallback_130, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_130(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_130(uint16_t colorPointRY)
    {
        VerifyOrReturn(CheckConstraintType("colorPointRY", "", "uint16"));
        VerifyOrReturn(CheckConstraintMinValue<uint16_t>("colorPointRY", colorPointRY, 0U));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("colorPointRY", colorPointRY, 65279U));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultOptionalAttributeColorPointRY_131()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t colorPointRYArgument;
        colorPointRYArgument = 0U;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::ColorPointRY::TypeInfo>(
            colorPointRYArgument, this, OnSuccessCallback_131, OnFailureCallback_131));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_131(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_131() { NextTest(); }

    CHIP_ERROR TestReadBackTheOptionalAttributeColorPointRY_132()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorPointRY::TypeInfo>(
            this, OnSuccessCallback_132, OnFailureCallback_132, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_132(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_132(uint16_t colorPointRY)
    {
        VerifyOrReturn(CheckValue("colorPointRY", colorPointRY, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeColorPointRIntensity_133()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorPointRIntensity::TypeInfo>(
            this, OnSuccessCallback_133, OnFailureCallback_133, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_133(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_133(uint8_t colorPointRIntensity)
    {
        VerifyOrReturn(CheckConstraintType("colorPointRIntensity", "", "uint8"));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultOptionalAttributeColorPointRIntensity_134()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t colorPointRIntensityArgument;
        colorPointRIntensityArgument = 0;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::ColorPointRIntensity::TypeInfo>(
            colorPointRIntensityArgument, this, OnSuccessCallback_134, OnFailureCallback_134));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_134(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_134() { NextTest(); }

    CHIP_ERROR TestReadBackTheOptionalAttributeColorPointRIntensity_135()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorPointRIntensity::TypeInfo>(
            this, OnSuccessCallback_135, OnFailureCallback_135, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_135(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_135(uint8_t colorPointRIntensity)
    {
        VerifyOrReturn(CheckValue("colorPointRIntensity", colorPointRIntensity, 0));

        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeColorPointGX_136()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorPointGX::TypeInfo>(
            this, OnSuccessCallback_136, OnFailureCallback_136, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_136(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_136(uint16_t colorPointGX)
    {
        VerifyOrReturn(CheckConstraintType("colorPointGX", "", "uint16"));
        VerifyOrReturn(CheckConstraintMinValue<uint16_t>("colorPointGX", colorPointGX, 0U));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("colorPointGX", colorPointGX, 65279U));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultOptionalAttributeColorPointGX_137()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t colorPointGXArgument;
        colorPointGXArgument = 0U;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::ColorPointGX::TypeInfo>(
            colorPointGXArgument, this, OnSuccessCallback_137, OnFailureCallback_137));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_137(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_137() { NextTest(); }

    CHIP_ERROR TestReadBackTheOptionalAttributeColorPointGX_138()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorPointGX::TypeInfo>(
            this, OnSuccessCallback_138, OnFailureCallback_138, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_138(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_138(uint16_t colorPointGX)
    {
        VerifyOrReturn(CheckValue("colorPointGX", colorPointGX, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeColorPointGY_139()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorPointGY::TypeInfo>(
            this, OnSuccessCallback_139, OnFailureCallback_139, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_139(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_139(uint16_t colorPointGY)
    {
        VerifyOrReturn(CheckConstraintType("colorPointGY", "", "uint16"));
        VerifyOrReturn(CheckConstraintMinValue<uint16_t>("colorPointGY", colorPointGY, 0U));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("colorPointGY", colorPointGY, 65279U));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultOptionalAttributeColorPointGY_140()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t colorPointGYArgument;
        colorPointGYArgument = 0U;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::ColorPointGY::TypeInfo>(
            colorPointGYArgument, this, OnSuccessCallback_140, OnFailureCallback_140));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_140(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_140() { NextTest(); }

    CHIP_ERROR TestReadBackTheOptionalAttributeColorPointGY_141()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorPointGY::TypeInfo>(
            this, OnSuccessCallback_141, OnFailureCallback_141, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_141(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_141(uint16_t colorPointGY)
    {
        VerifyOrReturn(CheckValue("colorPointGY", colorPointGY, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeColorPointGIntensity_142()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorPointGIntensity::TypeInfo>(
            this, OnSuccessCallback_142, OnFailureCallback_142, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_142(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_142(uint8_t colorPointGIntensity)
    {
        VerifyOrReturn(CheckConstraintType("colorPointGIntensity", "", "uint8"));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultOptionalAttributeColorPointGIntensity_143()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t colorPointGIntensityArgument;
        colorPointGIntensityArgument = 0;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::ColorPointGIntensity::TypeInfo>(
            colorPointGIntensityArgument, this, OnSuccessCallback_143, OnFailureCallback_143));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_143(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_143() { NextTest(); }

    CHIP_ERROR TestReadBackTheOptionalAttributeColorPointGIntensity_144()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorPointGIntensity::TypeInfo>(
            this, OnSuccessCallback_144, OnFailureCallback_144, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_144(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_144(uint8_t colorPointGIntensity)
    {
        VerifyOrReturn(CheckValue("colorPointGIntensity", colorPointGIntensity, 0));

        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeColorPointBX_145()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorPointBX::TypeInfo>(
            this, OnSuccessCallback_145, OnFailureCallback_145, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_145(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_145(uint16_t colorPointBX)
    {
        VerifyOrReturn(CheckConstraintType("colorPointBX", "", "uint16"));
        VerifyOrReturn(CheckConstraintMinValue<uint16_t>("colorPointBX", colorPointBX, 0U));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("colorPointBX", colorPointBX, 65279U));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultOptionalAttributeColorPointBX_146()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t colorPointBXArgument;
        colorPointBXArgument = 0U;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::ColorPointBX::TypeInfo>(
            colorPointBXArgument, this, OnSuccessCallback_146, OnFailureCallback_146));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_146(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_146() { NextTest(); }

    CHIP_ERROR TestReadBackTheOptionalAttributeColorPointBX_147()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorPointBX::TypeInfo>(
            this, OnSuccessCallback_147, OnFailureCallback_147, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_147(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_147(uint16_t colorPointBX)
    {
        VerifyOrReturn(CheckValue("colorPointBX", colorPointBX, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeColorPointBY_148()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorPointBY::TypeInfo>(
            this, OnSuccessCallback_148, OnFailureCallback_148, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_148(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_148(uint16_t colorPointBY)
    {
        VerifyOrReturn(CheckConstraintType("colorPointBY", "", "uint16"));
        VerifyOrReturn(CheckConstraintMinValue<uint16_t>("colorPointBY", colorPointBY, 0U));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("colorPointBY", colorPointBY, 65279U));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultOptionalAttributeColorPointBY_149()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t colorPointBYArgument;
        colorPointBYArgument = 0U;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::ColorPointBY::TypeInfo>(
            colorPointBYArgument, this, OnSuccessCallback_149, OnFailureCallback_149));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_149(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_149() { NextTest(); }

    CHIP_ERROR TestReadBackTheOptionalAttributeColorPointBY_150()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorPointBY::TypeInfo>(
            this, OnSuccessCallback_150, OnFailureCallback_150, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_150(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_150(uint16_t colorPointBY)
    {
        VerifyOrReturn(CheckValue("colorPointBY", colorPointBY, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeColorPointBIntensity_151()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorPointBIntensity::TypeInfo>(
            this, OnSuccessCallback_151, OnFailureCallback_151, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_151(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_151(uint8_t colorPointBIntensity)
    {
        VerifyOrReturn(CheckConstraintType("colorPointBIntensity", "", "uint8"));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultOptionalAttributeColorPointBIntensity_152()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t colorPointBIntensityArgument;
        colorPointBIntensityArgument = 0;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::ColorPointBIntensity::TypeInfo>(
            colorPointBIntensityArgument, this, OnSuccessCallback_152, OnFailureCallback_152));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_152(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_152() { NextTest(); }

    CHIP_ERROR TestReadBackTheOptionalAttributeColorPointBIntensity_153()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorPointBIntensity::TypeInfo>(
            this, OnSuccessCallback_153, OnFailureCallback_153, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_153(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_153(uint8_t colorPointBIntensity)
    {
        VerifyOrReturn(CheckValue("colorPointBIntensity", colorPointBIntensity, 0));

        NextTest();
    }
};

class Test_TC_CC_3_1Suite : public TestCommand
{
public:
    Test_TC_CC_3_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_CC_3_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_CC_3_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_3_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_3_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Reads CurrentHue attribute from DUT.\n");
            err = TestReadsCurrentHueAttributeFromDut_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Move to hue shortest distance command\n");
            err = TestMoveToHueShortestDistanceCommand_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Move to hue longest distance command\n");
            err = TestMoveToHueLongestDistanceCommand_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Move to hue up command\n");
            err = TestMoveToHueUpCommand_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Move to hue down command\n");
            err = TestMoveToHueDownCommand_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_9();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 10;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_3_1Suite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_3_1Suite *>(context))->OnSuccessResponse_2(onOff);
    }

    static void OnFailureCallback_3(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_3_1Suite *>(context))->OnFailureResponse_3(error);
    }

    static void OnSuccessCallback_3(void * context, uint8_t currentHue)
    {
        (static_cast<Test_TC_CC_3_1Suite *>(context))->OnSuccessResponse_3(currentHue);
    }

    static void OnFailureCallback_9(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_3_1Suite *>(context))->OnFailureResponse_9(error);
    }

    static void OnSuccessCallback_9(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_3_1Suite *>(context))->OnSuccessResponse_9(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestTurnOnLightForColorControlTests_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_3_1Suite *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_3_1Suite *>(context))->OnFailureResponse_1(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 1));

        NextTest();
    }

    CHIP_ERROR TestReadsCurrentHueAttributeFromDut_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::CurrentHue::TypeInfo>(
            this, OnSuccessCallback_3, OnFailureCallback_3, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3(uint8_t currentHue)
    {
        VerifyOrReturn(CheckConstraintType("currentHue", "", "uint8"));
        VerifyOrReturn(CheckConstraintMinValue<uint8_t>("currentHue", currentHue, 0));
        VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("currentHue", currentHue, 254));
        NextTest();
    }

    CHIP_ERROR TestMoveToHueShortestDistanceCommand_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::MoveToHue::Type;

        RequestType request;
        request.hue             = 150;
        request.direction       = static_cast<chip::app::Clusters::ColorControl::HueDirection>(0);
        request.transitionTime  = 300U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_3_1Suite *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_3_1Suite *>(context))->OnFailureResponse_4(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestMoveToHueLongestDistanceCommand_5()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::MoveToHue::Type;

        RequestType request;
        request.hue             = 200;
        request.direction       = static_cast<chip::app::Clusters::ColorControl::HueDirection>(1);
        request.transitionTime  = 300U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_3_1Suite *>(context))->OnSuccessResponse_5();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_3_1Suite *>(context))->OnFailureResponse_5(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_5() { NextTest(); }

    CHIP_ERROR TestMoveToHueUpCommand_6()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::MoveToHue::Type;

        RequestType request;
        request.hue             = 250;
        request.direction       = static_cast<chip::app::Clusters::ColorControl::HueDirection>(2);
        request.transitionTime  = 300U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_3_1Suite *>(context))->OnSuccessResponse_6();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_3_1Suite *>(context))->OnFailureResponse_6(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_6(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_6() { NextTest(); }

    CHIP_ERROR TestMoveToHueDownCommand_7()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::MoveToHue::Type;

        RequestType request;
        request.hue             = 225;
        request.direction       = static_cast<chip::app::Clusters::ColorControl::HueDirection>(3);
        request.transitionTime  = 300U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_3_1Suite *>(context))->OnSuccessResponse_7();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_3_1Suite *>(context))->OnFailureResponse_7(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_7(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_7() { NextTest(); }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_8()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_3_1Suite *>(context))->OnSuccessResponse_8();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_3_1Suite *>(context))->OnFailureResponse_8(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_8(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_8() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_9()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(
            this, OnSuccessCallback_9, OnFailureCallback_9, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_9(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_9(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 0));

        NextTest();
    }
};

class Test_TC_CC_3_2Suite : public TestCommand
{
public:
    Test_TC_CC_3_2Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_CC_3_2", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_CC_3_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_3_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_3_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Move hue up command\n");
            err = TestMoveHueUpCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Move hue stop command\n");
            err = TestMoveHueStopCommand_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Move hue down command\n");
            err = TestMoveHueDownCommand_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Move hue stop command\n");
            err = TestMoveHueStopCommand_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_8();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 9;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_3_2Suite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_3_2Suite *>(context))->OnSuccessResponse_2(onOff);
    }

    static void OnFailureCallback_8(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_3_2Suite *>(context))->OnFailureResponse_8(error);
    }

    static void OnSuccessCallback_8(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_3_2Suite *>(context))->OnSuccessResponse_8(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestTurnOnLightForColorControlTests_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_3_2Suite *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_3_2Suite *>(context))->OnFailureResponse_1(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 1));

        NextTest();
    }

    CHIP_ERROR TestMoveHueUpCommand_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::MoveHue::Type;

        RequestType request;
        request.moveMode        = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(1);
        request.rate            = 50;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_3_2Suite *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_3_2Suite *>(context))->OnFailureResponse_3(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestMoveHueStopCommand_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::MoveHue::Type;

        RequestType request;
        request.moveMode        = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(0);
        request.rate            = 50;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_3_2Suite *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_3_2Suite *>(context))->OnFailureResponse_4(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestMoveHueDownCommand_5()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::MoveHue::Type;

        RequestType request;
        request.moveMode        = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(3);
        request.rate            = 50;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_3_2Suite *>(context))->OnSuccessResponse_5();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_3_2Suite *>(context))->OnFailureResponse_5(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_5() { NextTest(); }

    CHIP_ERROR TestMoveHueStopCommand_6()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::MoveHue::Type;

        RequestType request;
        request.moveMode        = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(0);
        request.rate            = 50;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_3_2Suite *>(context))->OnSuccessResponse_6();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_3_2Suite *>(context))->OnFailureResponse_6(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_6(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_6() { NextTest(); }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_7()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_3_2Suite *>(context))->OnSuccessResponse_7();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_3_2Suite *>(context))->OnFailureResponse_7(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_7(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_7() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_8()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(
            this, OnSuccessCallback_8, OnFailureCallback_8, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_8(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_8(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 0));

        NextTest();
    }
};

class Test_TC_CC_3_3Suite : public TestCommand
{
public:
    Test_TC_CC_3_3Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_CC_3_3", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_CC_3_3Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_3_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_3_3\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Step hue up command\n");
            err = TestStepHueUpCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Step hue down command\n");
            err = TestStepHueDownCommand_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_6();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 7;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_3_3Suite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_3_3Suite *>(context))->OnSuccessResponse_2(onOff);
    }

    static void OnFailureCallback_6(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_3_3Suite *>(context))->OnFailureResponse_6(error);
    }

    static void OnSuccessCallback_6(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_3_3Suite *>(context))->OnSuccessResponse_6(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestTurnOnLightForColorControlTests_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_3_3Suite *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_3_3Suite *>(context))->OnFailureResponse_1(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 1));

        NextTest();
    }

    CHIP_ERROR TestStepHueUpCommand_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::StepHue::Type;

        RequestType request;
        request.stepMode        = static_cast<chip::app::Clusters::ColorControl::HueStepMode>(1);
        request.stepSize        = 5;
        request.transitionTime  = 25;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_3_3Suite *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_3_3Suite *>(context))->OnFailureResponse_3(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestStepHueDownCommand_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::StepHue::Type;

        RequestType request;
        request.stepMode        = static_cast<chip::app::Clusters::ColorControl::HueStepMode>(3);
        request.stepSize        = 5;
        request.transitionTime  = 25;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_3_3Suite *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_3_3Suite *>(context))->OnFailureResponse_4(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_5()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_3_3Suite *>(context))->OnSuccessResponse_5();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_3_3Suite *>(context))->OnFailureResponse_5(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_5() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_6()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(
            this, OnSuccessCallback_6, OnFailureCallback_6, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_6(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_6(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 0));

        NextTest();
    }
};

class Test_TC_CC_4_1Suite : public TestCommand
{
public:
    Test_TC_CC_4_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_CC_4_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_CC_4_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_4_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_4_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Move to saturation command\n");
            err = TestMoveToSaturationCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_5();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 6;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_4_1Suite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_4_1Suite *>(context))->OnSuccessResponse_2(onOff);
    }

    static void OnFailureCallback_5(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_4_1Suite *>(context))->OnFailureResponse_5(error);
    }

    static void OnSuccessCallback_5(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_4_1Suite *>(context))->OnSuccessResponse_5(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestTurnOnLightForColorControlTests_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_4_1Suite *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_4_1Suite *>(context))->OnFailureResponse_1(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 1));

        NextTest();
    }

    CHIP_ERROR TestMoveToSaturationCommand_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::MoveToSaturation::Type;

        RequestType request;
        request.saturation      = 90;
        request.transitionTime  = 10U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_4_1Suite *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_4_1Suite *>(context))->OnFailureResponse_3(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_4_1Suite *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_4_1Suite *>(context))->OnFailureResponse_4(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_5()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(
            this, OnSuccessCallback_5, OnFailureCallback_5, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_5(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 0));

        NextTest();
    }
};

class Test_TC_CC_4_2Suite : public TestCommand
{
public:
    Test_TC_CC_4_2Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_CC_4_2", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_CC_4_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_4_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_4_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Move saturation up command\n");
            err = TestMoveSaturationUpCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Move saturation down command\n");
            err = TestMoveSaturationDownCommand_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Move saturation up command\n");
            err = TestMoveSaturationUpCommand_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Move saturation stop command\n");
            err = TestMoveSaturationStopCommand_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Move saturation down command\n");
            err = TestMoveSaturationDownCommand_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Move saturation stop command\n");
            err = TestMoveSaturationStopCommand_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_10();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 11;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_4_2Suite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_4_2Suite *>(context))->OnSuccessResponse_2(onOff);
    }

    static void OnFailureCallback_10(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_4_2Suite *>(context))->OnFailureResponse_10(error);
    }

    static void OnSuccessCallback_10(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_4_2Suite *>(context))->OnSuccessResponse_10(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestTurnOnLightForColorControlTests_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_4_2Suite *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_4_2Suite *>(context))->OnFailureResponse_1(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 1));

        NextTest();
    }

    CHIP_ERROR TestMoveSaturationUpCommand_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::MoveSaturation::Type;

        RequestType request;
        request.moveMode        = static_cast<chip::app::Clusters::ColorControl::SaturationMoveMode>(1);
        request.rate            = 5;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_4_2Suite *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_4_2Suite *>(context))->OnFailureResponse_3(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestMoveSaturationDownCommand_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::MoveSaturation::Type;

        RequestType request;
        request.moveMode        = static_cast<chip::app::Clusters::ColorControl::SaturationMoveMode>(3);
        request.rate            = 5;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_4_2Suite *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_4_2Suite *>(context))->OnFailureResponse_4(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestMoveSaturationUpCommand_5()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::MoveSaturation::Type;

        RequestType request;
        request.moveMode        = static_cast<chip::app::Clusters::ColorControl::SaturationMoveMode>(1);
        request.rate            = 5;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_4_2Suite *>(context))->OnSuccessResponse_5();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_4_2Suite *>(context))->OnFailureResponse_5(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_5() { NextTest(); }

    CHIP_ERROR TestMoveSaturationStopCommand_6()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::MoveSaturation::Type;

        RequestType request;
        request.moveMode        = static_cast<chip::app::Clusters::ColorControl::SaturationMoveMode>(0);
        request.rate            = 5;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_4_2Suite *>(context))->OnSuccessResponse_6();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_4_2Suite *>(context))->OnFailureResponse_6(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_6(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_6() { NextTest(); }

    CHIP_ERROR TestMoveSaturationDownCommand_7()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::MoveSaturation::Type;

        RequestType request;
        request.moveMode        = static_cast<chip::app::Clusters::ColorControl::SaturationMoveMode>(3);
        request.rate            = 5;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_4_2Suite *>(context))->OnSuccessResponse_7();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_4_2Suite *>(context))->OnFailureResponse_7(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_7(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_7() { NextTest(); }

    CHIP_ERROR TestMoveSaturationStopCommand_8()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::MoveSaturation::Type;

        RequestType request;
        request.moveMode        = static_cast<chip::app::Clusters::ColorControl::SaturationMoveMode>(0);
        request.rate            = 5;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_4_2Suite *>(context))->OnSuccessResponse_8();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_4_2Suite *>(context))->OnFailureResponse_8(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_8(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_8() { NextTest(); }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_9()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_4_2Suite *>(context))->OnSuccessResponse_9();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_4_2Suite *>(context))->OnFailureResponse_9(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_9(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_9() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_10()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(
            this, OnSuccessCallback_10, OnFailureCallback_10, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_10(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_10(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 0));

        NextTest();
    }
};

class Test_TC_CC_4_3Suite : public TestCommand
{
public:
    Test_TC_CC_4_3Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_CC_4_3", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_CC_4_3Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_4_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_4_3\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Step saturation up command\n");
            err = TestStepSaturationUpCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Step saturation down command\n");
            err = TestStepSaturationDownCommand_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_6();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 7;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_4_3Suite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_4_3Suite *>(context))->OnSuccessResponse_2(onOff);
    }

    static void OnFailureCallback_6(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_4_3Suite *>(context))->OnFailureResponse_6(error);
    }

    static void OnSuccessCallback_6(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_4_3Suite *>(context))->OnSuccessResponse_6(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestTurnOnLightForColorControlTests_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_4_3Suite *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_4_3Suite *>(context))->OnFailureResponse_1(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 1));

        NextTest();
    }

    CHIP_ERROR TestStepSaturationUpCommand_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::StepSaturation::Type;

        RequestType request;
        request.stepMode        = static_cast<chip::app::Clusters::ColorControl::SaturationStepMode>(1);
        request.stepSize        = 15;
        request.transitionTime  = 10;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_4_3Suite *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_4_3Suite *>(context))->OnFailureResponse_3(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestStepSaturationDownCommand_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::StepSaturation::Type;

        RequestType request;
        request.stepMode        = static_cast<chip::app::Clusters::ColorControl::SaturationStepMode>(3);
        request.stepSize        = 20;
        request.transitionTime  = 10;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_4_3Suite *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_4_3Suite *>(context))->OnFailureResponse_4(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_5()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_4_3Suite *>(context))->OnSuccessResponse_5();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_4_3Suite *>(context))->OnFailureResponse_5(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_5() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_6()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(
            this, OnSuccessCallback_6, OnFailureCallback_6, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_6(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_6(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 0));

        NextTest();
    }
};

class Test_TC_CC_4_4Suite : public TestCommand
{
public:
    Test_TC_CC_4_4Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_CC_4_4", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_CC_4_4Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_4_4\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_4_4\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Move To current hue and saturation command\n");
            err = TestMoveToCurrentHueAndSaturationCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_5();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 6;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_4_4Suite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_4_4Suite *>(context))->OnSuccessResponse_2(onOff);
    }

    static void OnFailureCallback_5(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_4_4Suite *>(context))->OnFailureResponse_5(error);
    }

    static void OnSuccessCallback_5(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_4_4Suite *>(context))->OnSuccessResponse_5(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestTurnOnLightForColorControlTests_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_4_4Suite *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_4_4Suite *>(context))->OnFailureResponse_1(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 1));

        NextTest();
    }

    CHIP_ERROR TestMoveToCurrentHueAndSaturationCommand_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::MoveToHueAndSaturation::Type;

        RequestType request;
        request.hue             = 40;
        request.saturation      = 160;
        request.transitionTime  = 10U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_4_4Suite *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_4_4Suite *>(context))->OnFailureResponse_3(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_4_4Suite *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_4_4Suite *>(context))->OnFailureResponse_4(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_5()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(
            this, OnSuccessCallback_5, OnFailureCallback_5, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_5(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 0));

        NextTest();
    }
};

class Test_TC_CC_5_1Suite : public TestCommand
{
public:
    Test_TC_CC_5_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_CC_5_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_CC_5_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_5_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_5_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Move to Color command\n");
            err = TestMoveToColorCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_5();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 6;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_5_1Suite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_5_1Suite *>(context))->OnSuccessResponse_2(onOff);
    }

    static void OnFailureCallback_5(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_5_1Suite *>(context))->OnFailureResponse_5(error);
    }

    static void OnSuccessCallback_5(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_5_1Suite *>(context))->OnSuccessResponse_5(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestTurnOnLightForColorControlTests_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_5_1Suite *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_5_1Suite *>(context))->OnFailureResponse_1(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 1));

        NextTest();
    }

    CHIP_ERROR TestMoveToColorCommand_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::MoveToColor::Type;

        RequestType request;
        request.colorX          = 200U;
        request.colorY          = 300U;
        request.transitionTime  = 20U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_5_1Suite *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_5_1Suite *>(context))->OnFailureResponse_3(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_5_1Suite *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_5_1Suite *>(context))->OnFailureResponse_4(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_5()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(
            this, OnSuccessCallback_5, OnFailureCallback_5, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_5(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 0));

        NextTest();
    }
};

class Test_TC_CC_5_2Suite : public TestCommand
{
public:
    Test_TC_CC_5_2Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_CC_5_2", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_CC_5_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_5_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_5_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Move Color command\n");
            err = TestMoveColorCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Stop Move Step command\n");
            err = TestStopMoveStepCommand_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_6();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 7;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_5_2Suite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_5_2Suite *>(context))->OnSuccessResponse_2(onOff);
    }

    static void OnFailureCallback_6(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_5_2Suite *>(context))->OnFailureResponse_6(error);
    }

    static void OnSuccessCallback_6(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_5_2Suite *>(context))->OnSuccessResponse_6(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestTurnOnLightForColorControlTests_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_5_2Suite *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_5_2Suite *>(context))->OnFailureResponse_1(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 1));

        NextTest();
    }

    CHIP_ERROR TestMoveColorCommand_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::MoveColor::Type;

        RequestType request;
        request.rateX           = 15;
        request.rateY           = 20;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_5_2Suite *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_5_2Suite *>(context))->OnFailureResponse_3(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestStopMoveStepCommand_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::StopMoveStep::Type;

        RequestType request;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_5_2Suite *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_5_2Suite *>(context))->OnFailureResponse_4(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_5()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_5_2Suite *>(context))->OnSuccessResponse_5();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_5_2Suite *>(context))->OnFailureResponse_5(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_5() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_6()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(
            this, OnSuccessCallback_6, OnFailureCallback_6, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_6(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_6(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 0));

        NextTest();
    }
};

class Test_TC_CC_5_3Suite : public TestCommand
{
public:
    Test_TC_CC_5_3Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_CC_5_3", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_CC_5_3Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_5_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_5_3\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Step Color command\n");
            err = TestStepColorCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_5();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 6;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_5_3Suite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_5_3Suite *>(context))->OnSuccessResponse_2(onOff);
    }

    static void OnFailureCallback_5(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_5_3Suite *>(context))->OnFailureResponse_5(error);
    }

    static void OnSuccessCallback_5(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_5_3Suite *>(context))->OnSuccessResponse_5(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestTurnOnLightForColorControlTests_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_5_3Suite *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_5_3Suite *>(context))->OnFailureResponse_1(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 1));

        NextTest();
    }

    CHIP_ERROR TestStepColorCommand_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::StepColor::Type;

        RequestType request;
        request.stepX           = 15;
        request.stepY           = 20;
        request.transitionTime  = 50U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_5_3Suite *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_5_3Suite *>(context))->OnFailureResponse_3(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_5_3Suite *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_5_3Suite *>(context))->OnFailureResponse_4(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_5()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(
            this, OnSuccessCallback_5, OnFailureCallback_5, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_5(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 0));

        NextTest();
    }
};

class Test_TC_CC_6_1Suite : public TestCommand
{
public:
    Test_TC_CC_6_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_CC_6_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_CC_6_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_6_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_6_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Move To Color Temperature command\n");
            err = TestMoveToColorTemperatureCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_5();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 6;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_6_1Suite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_6_1Suite *>(context))->OnSuccessResponse_2(onOff);
    }

    static void OnFailureCallback_5(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_6_1Suite *>(context))->OnFailureResponse_5(error);
    }

    static void OnSuccessCallback_5(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_6_1Suite *>(context))->OnSuccessResponse_5(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestTurnOnLightForColorControlTests_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_6_1Suite *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_6_1Suite *>(context))->OnFailureResponse_1(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 1));

        NextTest();
    }

    CHIP_ERROR TestMoveToColorTemperatureCommand_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::MoveToColorTemperature::Type;

        RequestType request;
        request.colorTemperature = 100U;
        request.transitionTime   = 10U;
        request.optionsMask      = 0;
        request.optionsOverride  = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_6_1Suite *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_6_1Suite *>(context))->OnFailureResponse_3(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_6_1Suite *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_6_1Suite *>(context))->OnFailureResponse_4(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_5()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(
            this, OnSuccessCallback_5, OnFailureCallback_5, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_5(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 0));

        NextTest();
    }
};

class Test_TC_CC_6_2Suite : public TestCommand
{
public:
    Test_TC_CC_6_2Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_CC_6_2", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_CC_6_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_6_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_6_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read current color temprature\n");
            err = TestReadCurrentColorTemprature_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Move up color temperature command\n");
            err = TestMoveUpColorTemperatureCommand_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Move down color temperature command\n");
            err = TestMoveDownColorTemperatureCommand_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Move up color temperature command\n");
            err = TestMoveUpColorTemperatureCommand_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Stop Color Temperature command\n");
            err = TestStopColorTemperatureCommand_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Move down color temperature command\n");
            err = TestMoveDownColorTemperatureCommand_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Stop Color Temperature command\n");
            err = TestStopColorTemperatureCommand_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_11();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 12;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_6_2Suite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_6_2Suite *>(context))->OnSuccessResponse_2(onOff);
    }

    static void OnFailureCallback_3(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_6_2Suite *>(context))->OnFailureResponse_3(error);
    }

    static void OnSuccessCallback_3(void * context, uint16_t colorTemperature)
    {
        (static_cast<Test_TC_CC_6_2Suite *>(context))->OnSuccessResponse_3(colorTemperature);
    }

    static void OnFailureCallback_11(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_6_2Suite *>(context))->OnFailureResponse_11(error);
    }

    static void OnSuccessCallback_11(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_6_2Suite *>(context))->OnSuccessResponse_11(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestTurnOnLightForColorControlTests_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_6_2Suite *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_6_2Suite *>(context))->OnFailureResponse_1(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 1));

        NextTest();
    }

    CHIP_ERROR TestReadCurrentColorTemprature_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorTemperature::TypeInfo>(
            this, OnSuccessCallback_3, OnFailureCallback_3, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3(uint16_t colorTemperature)
    {
        VerifyOrReturn(CheckConstraintType("colorTemperature", "", "uint16"));
        VerifyOrReturn(CheckConstraintMinValue<uint16_t>("colorTemperature", colorTemperature, 0U));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("colorTemperature", colorTemperature, 65279U));
        NextTest();
    }

    CHIP_ERROR TestMoveUpColorTemperatureCommand_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::MoveColorTemperature::Type;

        RequestType request;
        request.moveMode                = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(1);
        request.rate                    = 10U;
        request.colorTemperatureMinimum = 1U;
        request.colorTemperatureMaximum = 255U;
        request.optionsMask             = 0;
        request.optionsOverride         = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_6_2Suite *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_6_2Suite *>(context))->OnFailureResponse_4(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestMoveDownColorTemperatureCommand_5()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::MoveColorTemperature::Type;

        RequestType request;
        request.moveMode                = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(3);
        request.rate                    = 20U;
        request.colorTemperatureMinimum = 1U;
        request.colorTemperatureMaximum = 255U;
        request.optionsMask             = 0;
        request.optionsOverride         = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_6_2Suite *>(context))->OnSuccessResponse_5();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_6_2Suite *>(context))->OnFailureResponse_5(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_5() { NextTest(); }

    CHIP_ERROR TestMoveUpColorTemperatureCommand_6()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::MoveColorTemperature::Type;

        RequestType request;
        request.moveMode                = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(1);
        request.rate                    = 10U;
        request.colorTemperatureMinimum = 1U;
        request.colorTemperatureMaximum = 255U;
        request.optionsMask             = 0;
        request.optionsOverride         = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_6_2Suite *>(context))->OnSuccessResponse_6();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_6_2Suite *>(context))->OnFailureResponse_6(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_6(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_6() { NextTest(); }

    CHIP_ERROR TestStopColorTemperatureCommand_7()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::MoveColorTemperature::Type;

        RequestType request;
        request.moveMode                = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(0);
        request.rate                    = 10U;
        request.colorTemperatureMinimum = 1U;
        request.colorTemperatureMaximum = 255U;
        request.optionsMask             = 0;
        request.optionsOverride         = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_6_2Suite *>(context))->OnSuccessResponse_7();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_6_2Suite *>(context))->OnFailureResponse_7(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_7(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_7() { NextTest(); }

    CHIP_ERROR TestMoveDownColorTemperatureCommand_8()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::MoveColorTemperature::Type;

        RequestType request;
        request.moveMode                = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(3);
        request.rate                    = 20U;
        request.colorTemperatureMinimum = 1U;
        request.colorTemperatureMaximum = 255U;
        request.optionsMask             = 0;
        request.optionsOverride         = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_6_2Suite *>(context))->OnSuccessResponse_8();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_6_2Suite *>(context))->OnFailureResponse_8(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_8(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_8() { NextTest(); }

    CHIP_ERROR TestStopColorTemperatureCommand_9()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::MoveColorTemperature::Type;

        RequestType request;
        request.moveMode                = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(0);
        request.rate                    = 10U;
        request.colorTemperatureMinimum = 1U;
        request.colorTemperatureMaximum = 255U;
        request.optionsMask             = 0;
        request.optionsOverride         = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_6_2Suite *>(context))->OnSuccessResponse_9();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_6_2Suite *>(context))->OnFailureResponse_9(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_9(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_9() { NextTest(); }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_10()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_6_2Suite *>(context))->OnSuccessResponse_10();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_6_2Suite *>(context))->OnFailureResponse_10(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_10(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_10() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_11()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(
            this, OnSuccessCallback_11, OnFailureCallback_11, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_11(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_11(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 0));

        NextTest();
    }
};

class Test_TC_CC_6_3Suite : public TestCommand
{
public:
    Test_TC_CC_6_3Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_CC_6_3", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_CC_6_3Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_6_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_6_3\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Step up color temperature command\n");
            err = TestStepUpColorTemperatureCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Step down color temperature command\n");
            err = TestStepDownColorTemperatureCommand_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_6();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 7;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_6_3Suite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_6_3Suite *>(context))->OnSuccessResponse_2(onOff);
    }

    static void OnFailureCallback_6(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_6_3Suite *>(context))->OnFailureResponse_6(error);
    }

    static void OnSuccessCallback_6(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_6_3Suite *>(context))->OnSuccessResponse_6(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestTurnOnLightForColorControlTests_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_6_3Suite *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_6_3Suite *>(context))->OnFailureResponse_1(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 1));

        NextTest();
    }

    CHIP_ERROR TestStepUpColorTemperatureCommand_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::StepColorTemperature::Type;

        RequestType request;
        request.stepMode                = static_cast<chip::app::Clusters::ColorControl::HueStepMode>(1);
        request.stepSize                = 5U;
        request.transitionTime          = 50U;
        request.colorTemperatureMinimum = 5U;
        request.colorTemperatureMaximum = 100U;
        request.optionsMask             = 0;
        request.optionsOverride         = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_6_3Suite *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_6_3Suite *>(context))->OnFailureResponse_3(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestStepDownColorTemperatureCommand_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::StepColorTemperature::Type;

        RequestType request;
        request.stepMode                = static_cast<chip::app::Clusters::ColorControl::HueStepMode>(3);
        request.stepSize                = 5U;
        request.transitionTime          = 50U;
        request.colorTemperatureMinimum = 5U;
        request.colorTemperatureMaximum = 100U;
        request.optionsMask             = 0;
        request.optionsOverride         = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_6_3Suite *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_6_3Suite *>(context))->OnFailureResponse_4(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_5()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_6_3Suite *>(context))->OnSuccessResponse_5();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_6_3Suite *>(context))->OnFailureResponse_5(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_5() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_6()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(
            this, OnSuccessCallback_6, OnFailureCallback_6, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_6(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_6(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 0));

        NextTest();
    }
};

class Test_TC_CC_7_1Suite : public TestCommand
{
public:
    Test_TC_CC_7_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_CC_7_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_CC_7_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_7_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_7_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Enhanced Move To Hue command\n");
            err = TestEnhancedMoveToHueCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Enhanced Move To Hue command\n");
            err = TestEnhancedMoveToHueCommand_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Enhanced Move To Hue command\n");
            err = TestEnhancedMoveToHueCommand_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Enhanced Move To Hue command\n");
            err = TestEnhancedMoveToHueCommand_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Enhanced Move To Hue command\n");
            err = TestEnhancedMoveToHueCommand_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_9();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 10;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_7_1Suite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_7_1Suite *>(context))->OnSuccessResponse_2(onOff);
    }

    static void OnFailureCallback_9(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_7_1Suite *>(context))->OnFailureResponse_9(error);
    }

    static void OnSuccessCallback_9(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_7_1Suite *>(context))->OnSuccessResponse_9(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestTurnOnLightForColorControlTests_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_7_1Suite *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_7_1Suite *>(context))->OnFailureResponse_1(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 1));

        NextTest();
    }

    CHIP_ERROR TestEnhancedMoveToHueCommand_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::EnhancedMoveToHue::Type;

        RequestType request;
        request.enhancedHue     = 1025U;
        request.direction       = static_cast<chip::app::Clusters::ColorControl::HueDirection>(0);
        request.transitionTime  = 1U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_7_1Suite *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_7_1Suite *>(context))->OnFailureResponse_3(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestEnhancedMoveToHueCommand_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::EnhancedMoveToHue::Type;

        RequestType request;
        request.enhancedHue     = 1100U;
        request.direction       = static_cast<chip::app::Clusters::ColorControl::HueDirection>(0);
        request.transitionTime  = 300U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_7_1Suite *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_7_1Suite *>(context))->OnFailureResponse_4(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestEnhancedMoveToHueCommand_5()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::EnhancedMoveToHue::Type;

        RequestType request;
        request.enhancedHue     = 1150U;
        request.direction       = static_cast<chip::app::Clusters::ColorControl::HueDirection>(1);
        request.transitionTime  = 300U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_7_1Suite *>(context))->OnSuccessResponse_5();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_7_1Suite *>(context))->OnFailureResponse_5(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_5() { NextTest(); }

    CHIP_ERROR TestEnhancedMoveToHueCommand_6()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::EnhancedMoveToHue::Type;

        RequestType request;
        request.enhancedHue     = 1200U;
        request.direction       = static_cast<chip::app::Clusters::ColorControl::HueDirection>(2);
        request.transitionTime  = 300U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_7_1Suite *>(context))->OnSuccessResponse_6();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_7_1Suite *>(context))->OnFailureResponse_6(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_6(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_6() { NextTest(); }

    CHIP_ERROR TestEnhancedMoveToHueCommand_7()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::EnhancedMoveToHue::Type;

        RequestType request;
        request.enhancedHue     = 1300U;
        request.direction       = static_cast<chip::app::Clusters::ColorControl::HueDirection>(3);
        request.transitionTime  = 300U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_7_1Suite *>(context))->OnSuccessResponse_7();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_7_1Suite *>(context))->OnFailureResponse_7(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_7(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_7() { NextTest(); }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_8()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_7_1Suite *>(context))->OnSuccessResponse_8();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_7_1Suite *>(context))->OnFailureResponse_8(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_8(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_8() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_9()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(
            this, OnSuccessCallback_9, OnFailureCallback_9, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_9(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_9(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 0));

        NextTest();
    }
};

class Test_TC_CC_7_2Suite : public TestCommand
{
public:
    Test_TC_CC_7_2Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_CC_7_2", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_CC_7_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_7_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_7_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Check EnhancedCurrentHue attribute from DUT\n");
            err = TestCheckEnhancedCurrentHueAttributeFromDut_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Enhanced Move Hue Up command\n");
            err = TestEnhancedMoveHueUpCommand_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Enhanced Move Hue Stop command\n");
            err = TestEnhancedMoveHueStopCommand_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Enhanced Move Hue Down command \n");
            err = TestEnhancedMoveHueDownCommand_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Enhanced Move Hue Stop command\n");
            err = TestEnhancedMoveHueStopCommand_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_9();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 10;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_7_2Suite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_7_2Suite *>(context))->OnSuccessResponse_2(onOff);
    }

    static void OnFailureCallback_3(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_7_2Suite *>(context))->OnFailureResponse_3(error);
    }

    static void OnSuccessCallback_3(void * context, uint16_t enhancedCurrentHue)
    {
        (static_cast<Test_TC_CC_7_2Suite *>(context))->OnSuccessResponse_3(enhancedCurrentHue);
    }

    static void OnFailureCallback_9(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_7_2Suite *>(context))->OnFailureResponse_9(error);
    }

    static void OnSuccessCallback_9(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_7_2Suite *>(context))->OnSuccessResponse_9(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestTurnOnLightForColorControlTests_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_7_2Suite *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_7_2Suite *>(context))->OnFailureResponse_1(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 1));

        NextTest();
    }

    CHIP_ERROR TestCheckEnhancedCurrentHueAttributeFromDut_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::EnhancedCurrentHue::TypeInfo>(
            this, OnSuccessCallback_3, OnFailureCallback_3, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3(uint16_t enhancedCurrentHue)
    {
        VerifyOrReturn(CheckConstraintType("enhancedCurrentHue", "", "uint16"));
        VerifyOrReturn(CheckConstraintMinValue<uint16_t>("enhancedCurrentHue", enhancedCurrentHue, 0U));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("enhancedCurrentHue", enhancedCurrentHue, 65535U));
        NextTest();
    }

    CHIP_ERROR TestEnhancedMoveHueUpCommand_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::EnhancedMoveHue::Type;

        RequestType request;
        request.moveMode        = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(1);
        request.rate            = 50U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_7_2Suite *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_7_2Suite *>(context))->OnFailureResponse_4(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestEnhancedMoveHueStopCommand_5()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::EnhancedMoveHue::Type;

        RequestType request;
        request.moveMode        = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(0);
        request.rate            = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_7_2Suite *>(context))->OnSuccessResponse_5();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_7_2Suite *>(context))->OnFailureResponse_5(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_5() { NextTest(); }

    CHIP_ERROR TestEnhancedMoveHueDownCommand_6()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::EnhancedMoveHue::Type;

        RequestType request;
        request.moveMode        = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(3);
        request.rate            = 5U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_7_2Suite *>(context))->OnSuccessResponse_6();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_7_2Suite *>(context))->OnFailureResponse_6(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_6(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_6() { NextTest(); }

    CHIP_ERROR TestEnhancedMoveHueStopCommand_7()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::EnhancedMoveHue::Type;

        RequestType request;
        request.moveMode        = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(0);
        request.rate            = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_7_2Suite *>(context))->OnSuccessResponse_7();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_7_2Suite *>(context))->OnFailureResponse_7(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_7(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_7() { NextTest(); }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_8()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_7_2Suite *>(context))->OnSuccessResponse_8();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_7_2Suite *>(context))->OnFailureResponse_8(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_8(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_8() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_9()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(
            this, OnSuccessCallback_9, OnFailureCallback_9, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_9(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_9(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 0));

        NextTest();
    }
};

class Test_TC_CC_7_3Suite : public TestCommand
{
public:
    Test_TC_CC_7_3Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_CC_7_3", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_CC_7_3Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_7_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_7_3\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Enhanced Step Hue Up command\n");
            err = TestEnhancedStepHueUpCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Enhanced Step Hue Down command\n");
            err = TestEnhancedStepHueDownCommand_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_6();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 7;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_7_3Suite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_7_3Suite *>(context))->OnSuccessResponse_2(onOff);
    }

    static void OnFailureCallback_6(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_7_3Suite *>(context))->OnFailureResponse_6(error);
    }

    static void OnSuccessCallback_6(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_7_3Suite *>(context))->OnSuccessResponse_6(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestTurnOnLightForColorControlTests_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_7_3Suite *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_7_3Suite *>(context))->OnFailureResponse_1(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 1));

        NextTest();
    }

    CHIP_ERROR TestEnhancedStepHueUpCommand_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::EnhancedStepHue::Type;

        RequestType request;
        request.stepMode        = static_cast<chip::app::Clusters::ColorControl::HueStepMode>(0);
        request.stepSize        = 50U;
        request.transitionTime  = 1U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_7_3Suite *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_7_3Suite *>(context))->OnFailureResponse_3(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestEnhancedStepHueDownCommand_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::EnhancedStepHue::Type;

        RequestType request;
        request.stepMode        = static_cast<chip::app::Clusters::ColorControl::HueStepMode>(1);
        request.stepSize        = 75U;
        request.transitionTime  = 1U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_7_3Suite *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_7_3Suite *>(context))->OnFailureResponse_4(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_5()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_7_3Suite *>(context))->OnSuccessResponse_5();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_7_3Suite *>(context))->OnFailureResponse_5(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_5() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_6()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(
            this, OnSuccessCallback_6, OnFailureCallback_6, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_6(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_6(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 0));

        NextTest();
    }
};

class Test_TC_CC_7_4Suite : public TestCommand
{
public:
    Test_TC_CC_7_4Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_CC_7_4", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_CC_7_4Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_7_4\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_7_4\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Enhanced move to hue and saturation command\n");
            err = TestEnhancedMoveToHueAndSaturationCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_5();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 6;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_7_4Suite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_7_4Suite *>(context))->OnSuccessResponse_2(onOff);
    }

    static void OnFailureCallback_5(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_7_4Suite *>(context))->OnFailureResponse_5(error);
    }

    static void OnSuccessCallback_5(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_7_4Suite *>(context))->OnSuccessResponse_5(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestTurnOnLightForColorControlTests_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_7_4Suite *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_7_4Suite *>(context))->OnFailureResponse_1(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 1));

        NextTest();
    }

    CHIP_ERROR TestEnhancedMoveToHueAndSaturationCommand_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::EnhancedMoveToHueAndSaturation::Type;

        RequestType request;
        request.enhancedHue     = 1200U;
        request.saturation      = 90;
        request.transitionTime  = 10U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_7_4Suite *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_7_4Suite *>(context))->OnFailureResponse_3(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_7_4Suite *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_7_4Suite *>(context))->OnFailureResponse_4(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_5()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(
            this, OnSuccessCallback_5, OnFailureCallback_5, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_5(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 0));

        NextTest();
    }
};

class Test_TC_CC_8_1Suite : public TestCommand
{
public:
    Test_TC_CC_8_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_CC_8_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_CC_8_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_8_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_8_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Color Loop Set Command - Set all Attributes\n");
            err = TestColorLoopSetCommandSetAllAttributes_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Check ColorLoopDirection Value\n");
            err = TestCheckColorLoopDirectionValue_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Check ColorLoopTime Value\n");
            err = TestCheckColorLoopTimeValue_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Check ColorLoopStartEnhancedHue Value\n");
            err = TestCheckColorLoopStartEnhancedHueValue_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Check ColorLoopActive Value\n");
            err = TestCheckColorLoopActiveValue_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Color Loop Set Command - Start Color Loop\n");
            err = TestColorLoopSetCommandStartColorLoop_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Check ColorLoopActive Value\n");
            err = TestCheckColorLoopActiveValue_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Color Loop Set Command - Set direction and time while running\n");
            err = TestColorLoopSetCommandSetDirectionAndTimeWhileRunning_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : Check ColorLoopDirection Value\n");
            err = TestCheckColorLoopDirectionValue_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : Check ColorLoopTime Value\n");
            err = TestCheckColorLoopTimeValue_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : Color Loop Set Command - Set direction while running\n");
            err = TestColorLoopSetCommandSetDirectionWhileRunning_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : Check ColorLoopDirection Value\n");
            err = TestCheckColorLoopDirectionValue_14();
            break;
        case 15:
            ChipLogProgress(chipTool, " ***** Test Step 15 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_15();
            break;
        case 16:
            ChipLogProgress(chipTool, " ***** Test Step 16 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_16();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 17;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_8_1Suite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_8_1Suite *>(context))->OnSuccessResponse_2(onOff);
    }

    static void OnFailureCallback_4(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_8_1Suite *>(context))->OnFailureResponse_4(error);
    }

    static void OnSuccessCallback_4(void * context, uint8_t colorLoopDirection)
    {
        (static_cast<Test_TC_CC_8_1Suite *>(context))->OnSuccessResponse_4(colorLoopDirection);
    }

    static void OnFailureCallback_5(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_8_1Suite *>(context))->OnFailureResponse_5(error);
    }

    static void OnSuccessCallback_5(void * context, uint16_t colorLoopTime)
    {
        (static_cast<Test_TC_CC_8_1Suite *>(context))->OnSuccessResponse_5(colorLoopTime);
    }

    static void OnFailureCallback_6(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_8_1Suite *>(context))->OnFailureResponse_6(error);
    }

    static void OnSuccessCallback_6(void * context, uint16_t colorLoopStartEnhancedHue)
    {
        (static_cast<Test_TC_CC_8_1Suite *>(context))->OnSuccessResponse_6(colorLoopStartEnhancedHue);
    }

    static void OnFailureCallback_7(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_8_1Suite *>(context))->OnFailureResponse_7(error);
    }

    static void OnSuccessCallback_7(void * context, uint8_t colorLoopActive)
    {
        (static_cast<Test_TC_CC_8_1Suite *>(context))->OnSuccessResponse_7(colorLoopActive);
    }

    static void OnFailureCallback_9(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_8_1Suite *>(context))->OnFailureResponse_9(error);
    }

    static void OnSuccessCallback_9(void * context, uint8_t colorLoopActive)
    {
        (static_cast<Test_TC_CC_8_1Suite *>(context))->OnSuccessResponse_9(colorLoopActive);
    }

    static void OnFailureCallback_11(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_8_1Suite *>(context))->OnFailureResponse_11(error);
    }

    static void OnSuccessCallback_11(void * context, uint8_t colorLoopDirection)
    {
        (static_cast<Test_TC_CC_8_1Suite *>(context))->OnSuccessResponse_11(colorLoopDirection);
    }

    static void OnFailureCallback_12(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_8_1Suite *>(context))->OnFailureResponse_12(error);
    }

    static void OnSuccessCallback_12(void * context, uint16_t colorLoopTime)
    {
        (static_cast<Test_TC_CC_8_1Suite *>(context))->OnSuccessResponse_12(colorLoopTime);
    }

    static void OnFailureCallback_14(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_8_1Suite *>(context))->OnFailureResponse_14(error);
    }

    static void OnSuccessCallback_14(void * context, uint8_t colorLoopDirection)
    {
        (static_cast<Test_TC_CC_8_1Suite *>(context))->OnSuccessResponse_14(colorLoopDirection);
    }

    static void OnFailureCallback_16(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_8_1Suite *>(context))->OnFailureResponse_16(error);
    }

    static void OnSuccessCallback_16(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_8_1Suite *>(context))->OnSuccessResponse_16(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestTurnOnLightForColorControlTests_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_8_1Suite *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_8_1Suite *>(context))->OnFailureResponse_1(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 1));

        NextTest();
    }

    CHIP_ERROR TestColorLoopSetCommandSetAllAttributes_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;

        RequestType request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(14);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(1);
        request.time            = 100U;
        request.startHue        = 500U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_8_1Suite *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_8_1Suite *>(context))->OnFailureResponse_3(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestCheckColorLoopDirectionValue_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopDirection::TypeInfo>(
            this, OnSuccessCallback_4, OnFailureCallback_4, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_4(uint8_t colorLoopDirection)
    {
        VerifyOrReturn(CheckValue("colorLoopDirection", colorLoopDirection, 1));

        NextTest();
    }

    CHIP_ERROR TestCheckColorLoopTimeValue_5()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopTime::TypeInfo>(
            this, OnSuccessCallback_5, OnFailureCallback_5, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_5(uint16_t colorLoopTime)
    {
        VerifyOrReturn(CheckValue("colorLoopTime", colorLoopTime, 100U));

        NextTest();
    }

    CHIP_ERROR TestCheckColorLoopStartEnhancedHueValue_6()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopStartEnhancedHue::TypeInfo>(
                this, OnSuccessCallback_6, OnFailureCallback_6, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_6(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_6(uint16_t colorLoopStartEnhancedHue)
    {
        VerifyOrReturn(CheckValue("colorLoopStartEnhancedHue", colorLoopStartEnhancedHue, 500U));

        NextTest();
    }

    CHIP_ERROR TestCheckColorLoopActiveValue_7()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopActive::TypeInfo>(
            this, OnSuccessCallback_7, OnFailureCallback_7, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_7(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_7(uint8_t colorLoopActive)
    {
        VerifyOrReturn(CheckValue("colorLoopActive", colorLoopActive, 0));

        NextTest();
    }

    CHIP_ERROR TestColorLoopSetCommandStartColorLoop_8()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;

        RequestType request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(1);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(1);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 0U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_8_1Suite *>(context))->OnSuccessResponse_8();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_8_1Suite *>(context))->OnFailureResponse_8(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_8(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_8() { NextTest(); }

    CHIP_ERROR TestCheckColorLoopActiveValue_9()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopActive::TypeInfo>(
            this, OnSuccessCallback_9, OnFailureCallback_9, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_9(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_9(uint8_t colorLoopActive)
    {
        VerifyOrReturn(CheckValue("colorLoopActive", colorLoopActive, 1));

        NextTest();
    }

    CHIP_ERROR TestColorLoopSetCommandSetDirectionAndTimeWhileRunning_10()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;

        RequestType request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(6);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 3500U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_8_1Suite *>(context))->OnSuccessResponse_10();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_8_1Suite *>(context))->OnFailureResponse_10(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_10(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_10() { NextTest(); }

    CHIP_ERROR TestCheckColorLoopDirectionValue_11()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopDirection::TypeInfo>(
            this, OnSuccessCallback_11, OnFailureCallback_11, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_11(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_11(uint8_t colorLoopDirection)
    {
        VerifyOrReturn(CheckValue("colorLoopDirection", colorLoopDirection, 0));

        NextTest();
    }

    CHIP_ERROR TestCheckColorLoopTimeValue_12()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopTime::TypeInfo>(
            this, OnSuccessCallback_12, OnFailureCallback_12, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_12(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_12(uint16_t colorLoopTime)
    {
        VerifyOrReturn(CheckValue("colorLoopTime", colorLoopTime, 3500U));

        NextTest();
    }

    CHIP_ERROR TestColorLoopSetCommandSetDirectionWhileRunning_13()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;

        RequestType request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(2);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(1);
        request.time            = 0U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_8_1Suite *>(context))->OnSuccessResponse_13();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_8_1Suite *>(context))->OnFailureResponse_13(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_13(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_13() { NextTest(); }

    CHIP_ERROR TestCheckColorLoopDirectionValue_14()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopDirection::TypeInfo>(
            this, OnSuccessCallback_14, OnFailureCallback_14, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_14(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_14(uint8_t colorLoopDirection)
    {
        VerifyOrReturn(CheckValue("colorLoopDirection", colorLoopDirection, 1));

        NextTest();
    }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_15()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_8_1Suite *>(context))->OnSuccessResponse_15();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_8_1Suite *>(context))->OnFailureResponse_15(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_15(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_15() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_16()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(
            this, OnSuccessCallback_16, OnFailureCallback_16, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_16(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_16(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 0));

        NextTest();
    }
};

class Test_TC_CC_9_1Suite : public TestCommand
{
public:
    Test_TC_CC_9_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_CC_9_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_CC_9_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_9_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_9_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Precondition : Turn on light for color control tests\n");
            err = TestPreconditionTurnOnLightForColorControlTests_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Sends ColorLoopSet Command - Set all Attributes\n");
            if (ShouldSkip("CR_COLORLOOPSET"))
            {
                NextTest();
                return;
            }
            err = TestSendsColorLoopSetCommandSetAllAttributes_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Read ColorLoopActive attribute from DUT\n");
            if (ShouldSkip("A_COLORLOOPACTIVE"))
            {
                NextTest();
                return;
            }
            err = TestReadColorLoopActiveAttributeFromDut_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Sends ColorLoopSet Command - Set all Attributes\n");
            if (ShouldSkip("CR_COLORLOOPSET"))
            {
                NextTest();
                return;
            }
            err = TestSendsColorLoopSetCommandSetAllAttributes_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Read ColorLoopDirection attribute from DUT\n");
            if (ShouldSkip("A_COLORLOOPDIRECTION"))
            {
                NextTest();
                return;
            }
            err = TestReadColorLoopDirectionAttributeFromDut_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Sends ColorLoopSet Command - Set all Attributes\n");
            if (ShouldSkip("CR_COLORLOOPSET"))
            {
                NextTest();
                return;
            }
            err = TestSendsColorLoopSetCommandSetAllAttributes_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Read ColorLoopTime attribute from DUT\n");
            if (ShouldSkip("A_COLORLOOPTIME"))
            {
                NextTest();
                return;
            }
            err = TestReadColorLoopTimeAttributeFromDut_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Sends ColorLoopSet Command - Set all Attributes\n");
            if (ShouldSkip("CR_COLORLOOPSET"))
            {
                NextTest();
                return;
            }
            err = TestSendsColorLoopSetCommandSetAllAttributes_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Read ColorLoopStartEnhancedHue attribute from DUT\n");
            if (ShouldSkip("A_COLORLOOPSTARTENHANCEDHUE"))
            {
                NextTest();
                return;
            }
            err = TestReadColorLoopStartEnhancedHueAttributeFromDut_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : Sends ColorLoopSet Command - Set all Attributes\n");
            if (ShouldSkip("CR_COLORLOOPSET"))
            {
                NextTest();
                return;
            }
            err = TestSendsColorLoopSetCommandSetAllAttributes_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : Read ColorLoopActive attribute from DUT\n");
            if (ShouldSkip("A_COLORLOOPACTIVE"))
            {
                NextTest();
                return;
            }
            err = TestReadColorLoopActiveAttributeFromDut_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : Read EnhancedCurrentHue attribute from DUT\n");
            if (ShouldSkip("A_ENHANCEDCURRENTHUE"))
            {
                NextTest();
                return;
            }
            err = TestReadEnhancedCurrentHueAttributeFromDut_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : Read ColorLoopStoredEnhancedHue attribute from DUT.\n");
            if (ShouldSkip("A_COLORLOOPSTOREDENHANCEDHUE"))
            {
                NextTest();
                return;
            }
            err = TestReadColorLoopStoredEnhancedHueAttributeFromDut_14();
            break;
        case 15:
            ChipLogProgress(chipTool, " ***** Test Step 15 : Sends ColorLoopSet Command - Set all Attributes\n");
            if (ShouldSkip("CR_COLORLOOPSET"))
            {
                NextTest();
                return;
            }
            err = TestSendsColorLoopSetCommandSetAllAttributes_15();
            break;
        case 16:
            ChipLogProgress(chipTool, " ***** Test Step 16 : Read ColorLoopActive attribute from DUT\n");
            if (ShouldSkip("A_COLORLOOPACTIVE"))
            {
                NextTest();
                return;
            }
            err = TestReadColorLoopActiveAttributeFromDut_16();
            break;
        case 17:
            ChipLogProgress(chipTool, " ***** Test Step 17 : Read ColorLoopStoredEnhancedHue attribute from DUT.\n");
            if (ShouldSkip("A_COLORLOOPSTOREDENHANCEDHUE"))
            {
                NextTest();
                return;
            }
            err = TestReadColorLoopStoredEnhancedHueAttributeFromDut_17();
            break;
        case 18:
            ChipLogProgress(chipTool, " ***** Test Step 18 : Read EnhancedCurrentHue attribute from DUT\n");
            if (ShouldSkip("A_ENHANCEDCURRENTHUE"))
            {
                NextTest();
                return;
            }
            err = TestReadEnhancedCurrentHueAttributeFromDut_18();
            break;
        case 19:
            ChipLogProgress(chipTool, " ***** Test Step 19 : Sends ColorLoopSet Command - Set all Attributes\n");
            if (ShouldSkip("CR_COLORLOOPSET"))
            {
                NextTest();
                return;
            }
            err = TestSendsColorLoopSetCommandSetAllAttributes_19();
            break;
        case 20:
            ChipLogProgress(chipTool, " ***** Test Step 20 : Read ColorLoopDirection attribute from DUT\n");
            if (ShouldSkip("A_COLORLOOPDIRECTION"))
            {
                NextTest();
                return;
            }
            err = TestReadColorLoopDirectionAttributeFromDut_20();
            break;
        case 21:
            ChipLogProgress(chipTool, " ***** Test Step 21 : Sends ColorLoopSet Command - Set all Attributes\n");
            if (ShouldSkip("CR_COLORLOOPSET"))
            {
                NextTest();
                return;
            }
            err = TestSendsColorLoopSetCommandSetAllAttributes_21();
            break;
        case 22:
            ChipLogProgress(chipTool, " ***** Test Step 22 : Read ColorLoopActive attribute from DUT\n");
            if (ShouldSkip("A_COLORLOOPACTIVE"))
            {
                NextTest();
                return;
            }
            err = TestReadColorLoopActiveAttributeFromDut_22();
            break;
        case 23:
            ChipLogProgress(chipTool, " ***** Test Step 23 : Read EnhancedCurrentHue attribute from DUT\n");
            if (ShouldSkip("A_ENHANCEDCURRENTHUE"))
            {
                NextTest();
                return;
            }
            err = TestReadEnhancedCurrentHueAttributeFromDut_23();
            break;
        case 24:
            ChipLogProgress(chipTool, " ***** Test Step 24 : Read ColorLoopStoredEnhancedHue attribute from DUT\n");
            if (ShouldSkip("A_COLORLOOPSTOREDENHANCEDHUE"))
            {
                NextTest();
                return;
            }
            err = TestReadColorLoopStoredEnhancedHueAttributeFromDut_24();
            break;
        case 25:
            ChipLogProgress(chipTool, " ***** Test Step 25 : Sends ColorLoopSet Command - Set all Attributes\n");
            if (ShouldSkip("CR_COLORLOOPSET"))
            {
                NextTest();
                return;
            }
            err = TestSendsColorLoopSetCommandSetAllAttributes_25();
            break;
        case 26:
            ChipLogProgress(chipTool, " ***** Test Step 26 : Read ColorLoopActive attribute from DUT\n");
            if (ShouldSkip("A_COLORLOOPACTIVE"))
            {
                NextTest();
                return;
            }
            err = TestReadColorLoopActiveAttributeFromDut_26();
            break;
        case 27:
            ChipLogProgress(chipTool, " ***** Test Step 27 : Read ColorLoopStoredEnhancedHue attribute from DUT.\n");
            if (ShouldSkip("A_COLORLOOPSTOREDENHANCEDHUE"))
            {
                NextTest();
                return;
            }
            err = TestReadColorLoopStoredEnhancedHueAttributeFromDut_27();
            break;
        case 28:
            ChipLogProgress(chipTool, " ***** Test Step 28 : Read EnhancedCurrentHue attribute from DUT\n");
            if (ShouldSkip("A_ENHANCEDCURRENTHUE"))
            {
                NextTest();
                return;
            }
            err = TestReadEnhancedCurrentHueAttributeFromDut_28();
            break;
        case 29:
            ChipLogProgress(chipTool, " ***** Test Step 29 : Enhanced Move To Hue command\n");
            if (ShouldSkip("CR_ENHANCEDMOVETOHUE"))
            {
                NextTest();
                return;
            }
            err = TestEnhancedMoveToHueCommand_29();
            break;
        case 30:
            ChipLogProgress(chipTool, " ***** Test Step 30 : Wait 2000ms\n");
            err = TestWait2000ms_30();
            break;
        case 31:
            ChipLogProgress(chipTool, " ***** Test Step 31 : Read EnhancedCurrentHue attribute from DUT\n");
            if (ShouldSkip("A_ENHANCEDCURRENTHUE"))
            {
                NextTest();
                return;
            }
            err = TestReadEnhancedCurrentHueAttributeFromDut_31();
            break;
        case 32:
            ChipLogProgress(chipTool, " ***** Test Step 32 : Sends ColorLoopSet Command - Set all Attributes\n");
            if (ShouldSkip("CR_COLORLOOPSET"))
            {
                NextTest();
                return;
            }
            err = TestSendsColorLoopSetCommandSetAllAttributes_32();
            break;
        case 33:
            ChipLogProgress(chipTool, " ***** Test Step 33 : Read ColorLoopDirection attribute from DUT\n");
            if (ShouldSkip("A_COLORLOOPDIRECTION"))
            {
                NextTest();
                return;
            }
            err = TestReadColorLoopDirectionAttributeFromDut_33();
            break;
        case 34:
            ChipLogProgress(chipTool, " ***** Test Step 34 : Sends ColorLoopSet Command - Set all Attributes\n");
            if (ShouldSkip("CR_COLORLOOPSET"))
            {
                NextTest();
                return;
            }
            err = TestSendsColorLoopSetCommandSetAllAttributes_34();
            break;
        case 35:
            ChipLogProgress(chipTool, " ***** Test Step 35 : Read ColorLoopActive attribute from DUT\n");
            if (ShouldSkip("A_COLORLOOPACTIVE"))
            {
                NextTest();
                return;
            }
            err = TestReadColorLoopActiveAttributeFromDut_35();
            break;
        case 36:
            ChipLogProgress(chipTool, " ***** Test Step 36 : Read EnhancedCurrentHue attribute from DUT\n");
            if (ShouldSkip("A_ENHANCEDCURRENTHUE"))
            {
                NextTest();
                return;
            }
            err = TestReadEnhancedCurrentHueAttributeFromDut_36();
            break;
        case 37:
            ChipLogProgress(chipTool, " ***** Test Step 37 : Read ColorLoopStoredEnhancedHue attribute from DUT\n");
            if (ShouldSkip("A_COLORLOOPSTOREDENHANCEDHUE"))
            {
                NextTest();
                return;
            }
            err = TestReadColorLoopStoredEnhancedHueAttributeFromDut_37();
            break;
        case 38:
            ChipLogProgress(chipTool, " ***** Test Step 38 : Sends ColorLoopSet Command - Set all Attributes\n");
            if (ShouldSkip("CR_COLORLOOPSET"))
            {
                NextTest();
                return;
            }
            err = TestSendsColorLoopSetCommandSetAllAttributes_38();
            break;
        case 39:
            ChipLogProgress(chipTool, " ***** Test Step 39 : Read ColorLoopActive attribute from DUT\n");
            if (ShouldSkip("A_COLORLOOPACTIVE"))
            {
                NextTest();
                return;
            }
            err = TestReadColorLoopActiveAttributeFromDut_39();
            break;
        case 40:
            ChipLogProgress(chipTool, " ***** Test Step 40 : Read ColorLoopStoredEnhancedHue attribute from DUT.\n");
            if (ShouldSkip("A_COLORLOOPSTOREDENHANCEDHUE"))
            {
                NextTest();
                return;
            }
            err = TestReadColorLoopStoredEnhancedHueAttributeFromDut_40();
            break;
        case 41:
            ChipLogProgress(chipTool, " ***** Test Step 41 : Read EnhancedCurrentHue attribute from DUT\n");
            if (ShouldSkip("A_ENHANCEDCURRENTHUE"))
            {
                NextTest();
                return;
            }
            err = TestReadEnhancedCurrentHueAttributeFromDut_41();
            break;
        case 42:
            ChipLogProgress(chipTool, " ***** Test Step 42 : Sends ColorLoopSet Command - Set all Attributes\n");
            if (ShouldSkip("CR_COLORLOOPSET"))
            {
                NextTest();
                return;
            }
            err = TestSendsColorLoopSetCommandSetAllAttributes_42();
            break;
        case 43:
            ChipLogProgress(chipTool, " ***** Test Step 43 : Read ColorLoopDirection attribute from DUT\n");
            if (ShouldSkip("A_COLORLOOPDIRECTION"))
            {
                NextTest();
                return;
            }
            err = TestReadColorLoopDirectionAttributeFromDut_43();
            break;
        case 44:
            ChipLogProgress(chipTool, " ***** Test Step 44 : Sends ColorLoopSet Command - Set all Attributes\n");
            if (ShouldSkip("CR_COLORLOOPSET"))
            {
                NextTest();
                return;
            }
            err = TestSendsColorLoopSetCommandSetAllAttributes_44();
            break;
        case 45:
            ChipLogProgress(chipTool, " ***** Test Step 45 : Read ColorLoopActive attribute from DUT\n");
            if (ShouldSkip("A_COLORLOOPACTIVE"))
            {
                NextTest();
                return;
            }
            err = TestReadColorLoopActiveAttributeFromDut_45();
            break;
        case 46:
            ChipLogProgress(chipTool, " ***** Test Step 46 : Read EnhancedCurrentHue attribute from DUT\n");
            if (ShouldSkip("A_ENHANCEDCURRENTHUE"))
            {
                NextTest();
                return;
            }
            err = TestReadEnhancedCurrentHueAttributeFromDut_46();
            break;
        case 47:
            ChipLogProgress(chipTool, " ***** Test Step 47 : Read ColorLoopStoredEnhancedHue attribute from DUT\n");
            if (ShouldSkip("A_COLORLOOPSTOREDENHANCEDHUE"))
            {
                NextTest();
                return;
            }
            err = TestReadColorLoopStoredEnhancedHueAttributeFromDut_47();
            break;
        case 48:
            ChipLogProgress(chipTool, " ***** Test Step 48 : Sends ColorLoopSet Command - Set all Attributes\n");
            if (ShouldSkip("CR_COLORLOOPSET"))
            {
                NextTest();
                return;
            }
            err = TestSendsColorLoopSetCommandSetAllAttributes_48();
            break;
        case 49:
            ChipLogProgress(chipTool, " ***** Test Step 49 : Read ColorLoopActive attribute from DUT\n");
            if (ShouldSkip("A_COLORLOOPACTIVE"))
            {
                NextTest();
                return;
            }
            err = TestReadColorLoopActiveAttributeFromDut_49();
            break;
        case 50:
            ChipLogProgress(chipTool, " ***** Test Step 50 : Read ColorLoopStoredEnhancedHue attribute from DUT.\n");
            if (ShouldSkip("A_COLORLOOPSTOREDENHANCEDHUE"))
            {
                NextTest();
                return;
            }
            err = TestReadColorLoopStoredEnhancedHueAttributeFromDut_50();
            break;
        case 51:
            ChipLogProgress(chipTool, " ***** Test Step 51 : Read EnhancedCurrentHue attribute from DUT\n");
            if (ShouldSkip("A_ENHANCEDCURRENTHUE"))
            {
                NextTest();
                return;
            }
            err = TestReadEnhancedCurrentHueAttributeFromDut_51();
            break;
        case 52:
            ChipLogProgress(chipTool, " ***** Test Step 52 : Turn Off light for color control tests\n");
            err = TestTurnOffLightForColorControlTests_52();
            break;
        case 53:
            ChipLogProgress(chipTool, " ***** Test Step 53 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_53();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 54;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    uint16_t EnhancedCurrentHueValue1;
    uint16_t ColorLoopStoredEnhancedHueValue1;
    uint16_t EnhancedCurrentHueValue2;
    uint16_t ColorLoopStoredEnhancedHueValue2;
    uint16_t EnhancedCurrentHueValue3;
    uint16_t ColorLoopStoredEnhancedHueValue3;
    uint16_t EnhancedCurrentHueValue4;
    uint16_t ColorLoopStoredEnhancedHue4;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_9_1Suite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_9_1Suite *>(context))->OnSuccessResponse_2(onOff);
    }

    static void OnFailureCallback_4(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_9_1Suite *>(context))->OnFailureResponse_4(error);
    }

    static void OnSuccessCallback_4(void * context, uint8_t colorLoopActive)
    {
        (static_cast<Test_TC_CC_9_1Suite *>(context))->OnSuccessResponse_4(colorLoopActive);
    }

    static void OnFailureCallback_6(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_9_1Suite *>(context))->OnFailureResponse_6(error);
    }

    static void OnSuccessCallback_6(void * context, uint8_t colorLoopDirection)
    {
        (static_cast<Test_TC_CC_9_1Suite *>(context))->OnSuccessResponse_6(colorLoopDirection);
    }

    static void OnFailureCallback_8(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_9_1Suite *>(context))->OnFailureResponse_8(error);
    }

    static void OnSuccessCallback_8(void * context, uint16_t colorLoopTime)
    {
        (static_cast<Test_TC_CC_9_1Suite *>(context))->OnSuccessResponse_8(colorLoopTime);
    }

    static void OnFailureCallback_10(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_9_1Suite *>(context))->OnFailureResponse_10(error);
    }

    static void OnSuccessCallback_10(void * context, uint16_t colorLoopStartEnhancedHue)
    {
        (static_cast<Test_TC_CC_9_1Suite *>(context))->OnSuccessResponse_10(colorLoopStartEnhancedHue);
    }

    static void OnFailureCallback_12(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_9_1Suite *>(context))->OnFailureResponse_12(error);
    }

    static void OnSuccessCallback_12(void * context, uint8_t colorLoopActive)
    {
        (static_cast<Test_TC_CC_9_1Suite *>(context))->OnSuccessResponse_12(colorLoopActive);
    }

    static void OnFailureCallback_13(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_9_1Suite *>(context))->OnFailureResponse_13(error);
    }

    static void OnSuccessCallback_13(void * context, uint16_t enhancedCurrentHue)
    {
        (static_cast<Test_TC_CC_9_1Suite *>(context))->OnSuccessResponse_13(enhancedCurrentHue);
    }

    static void OnFailureCallback_14(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_9_1Suite *>(context))->OnFailureResponse_14(error);
    }

    static void OnSuccessCallback_14(void * context, uint16_t colorLoopStoredEnhancedHue)
    {
        (static_cast<Test_TC_CC_9_1Suite *>(context))->OnSuccessResponse_14(colorLoopStoredEnhancedHue);
    }

    static void OnFailureCallback_16(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_9_1Suite *>(context))->OnFailureResponse_16(error);
    }

    static void OnSuccessCallback_16(void * context, uint8_t colorLoopActive)
    {
        (static_cast<Test_TC_CC_9_1Suite *>(context))->OnSuccessResponse_16(colorLoopActive);
    }

    static void OnFailureCallback_17(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_9_1Suite *>(context))->OnFailureResponse_17(error);
    }

    static void OnSuccessCallback_17(void * context, uint16_t colorLoopStoredEnhancedHue)
    {
        (static_cast<Test_TC_CC_9_1Suite *>(context))->OnSuccessResponse_17(colorLoopStoredEnhancedHue);
    }

    static void OnFailureCallback_18(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_9_1Suite *>(context))->OnFailureResponse_18(error);
    }

    static void OnSuccessCallback_18(void * context, uint16_t enhancedCurrentHue)
    {
        (static_cast<Test_TC_CC_9_1Suite *>(context))->OnSuccessResponse_18(enhancedCurrentHue);
    }

    static void OnFailureCallback_20(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_9_1Suite *>(context))->OnFailureResponse_20(error);
    }

    static void OnSuccessCallback_20(void * context, uint8_t colorLoopDirection)
    {
        (static_cast<Test_TC_CC_9_1Suite *>(context))->OnSuccessResponse_20(colorLoopDirection);
    }

    static void OnFailureCallback_22(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_9_1Suite *>(context))->OnFailureResponse_22(error);
    }

    static void OnSuccessCallback_22(void * context, uint8_t colorLoopActive)
    {
        (static_cast<Test_TC_CC_9_1Suite *>(context))->OnSuccessResponse_22(colorLoopActive);
    }

    static void OnFailureCallback_23(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_9_1Suite *>(context))->OnFailureResponse_23(error);
    }

    static void OnSuccessCallback_23(void * context, uint16_t enhancedCurrentHue)
    {
        (static_cast<Test_TC_CC_9_1Suite *>(context))->OnSuccessResponse_23(enhancedCurrentHue);
    }

    static void OnFailureCallback_24(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_9_1Suite *>(context))->OnFailureResponse_24(error);
    }

    static void OnSuccessCallback_24(void * context, uint16_t colorLoopStoredEnhancedHue)
    {
        (static_cast<Test_TC_CC_9_1Suite *>(context))->OnSuccessResponse_24(colorLoopStoredEnhancedHue);
    }

    static void OnFailureCallback_26(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_9_1Suite *>(context))->OnFailureResponse_26(error);
    }

    static void OnSuccessCallback_26(void * context, uint8_t colorLoopActive)
    {
        (static_cast<Test_TC_CC_9_1Suite *>(context))->OnSuccessResponse_26(colorLoopActive);
    }

    static void OnFailureCallback_27(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_9_1Suite *>(context))->OnFailureResponse_27(error);
    }

    static void OnSuccessCallback_27(void * context, uint16_t colorLoopStoredEnhancedHue)
    {
        (static_cast<Test_TC_CC_9_1Suite *>(context))->OnSuccessResponse_27(colorLoopStoredEnhancedHue);
    }

    static void OnFailureCallback_28(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_9_1Suite *>(context))->OnFailureResponse_28(error);
    }

    static void OnSuccessCallback_28(void * context, uint16_t enhancedCurrentHue)
    {
        (static_cast<Test_TC_CC_9_1Suite *>(context))->OnSuccessResponse_28(enhancedCurrentHue);
    }

    static void OnFailureCallback_31(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_9_1Suite *>(context))->OnFailureResponse_31(error);
    }

    static void OnSuccessCallback_31(void * context, uint16_t enhancedCurrentHue)
    {
        (static_cast<Test_TC_CC_9_1Suite *>(context))->OnSuccessResponse_31(enhancedCurrentHue);
    }

    static void OnFailureCallback_33(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_9_1Suite *>(context))->OnFailureResponse_33(error);
    }

    static void OnSuccessCallback_33(void * context, uint8_t colorLoopDirection)
    {
        (static_cast<Test_TC_CC_9_1Suite *>(context))->OnSuccessResponse_33(colorLoopDirection);
    }

    static void OnFailureCallback_35(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_9_1Suite *>(context))->OnFailureResponse_35(error);
    }

    static void OnSuccessCallback_35(void * context, uint8_t colorLoopActive)
    {
        (static_cast<Test_TC_CC_9_1Suite *>(context))->OnSuccessResponse_35(colorLoopActive);
    }

    static void OnFailureCallback_36(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_9_1Suite *>(context))->OnFailureResponse_36(error);
    }

    static void OnSuccessCallback_36(void * context, uint16_t enhancedCurrentHue)
    {
        (static_cast<Test_TC_CC_9_1Suite *>(context))->OnSuccessResponse_36(enhancedCurrentHue);
    }

    static void OnFailureCallback_37(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_9_1Suite *>(context))->OnFailureResponse_37(error);
    }

    static void OnSuccessCallback_37(void * context, uint16_t colorLoopStoredEnhancedHue)
    {
        (static_cast<Test_TC_CC_9_1Suite *>(context))->OnSuccessResponse_37(colorLoopStoredEnhancedHue);
    }

    static void OnFailureCallback_39(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_9_1Suite *>(context))->OnFailureResponse_39(error);
    }

    static void OnSuccessCallback_39(void * context, uint8_t colorLoopActive)
    {
        (static_cast<Test_TC_CC_9_1Suite *>(context))->OnSuccessResponse_39(colorLoopActive);
    }

    static void OnFailureCallback_40(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_9_1Suite *>(context))->OnFailureResponse_40(error);
    }

    static void OnSuccessCallback_40(void * context, uint16_t colorLoopStoredEnhancedHue)
    {
        (static_cast<Test_TC_CC_9_1Suite *>(context))->OnSuccessResponse_40(colorLoopStoredEnhancedHue);
    }

    static void OnFailureCallback_41(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_9_1Suite *>(context))->OnFailureResponse_41(error);
    }

    static void OnSuccessCallback_41(void * context, uint16_t enhancedCurrentHue)
    {
        (static_cast<Test_TC_CC_9_1Suite *>(context))->OnSuccessResponse_41(enhancedCurrentHue);
    }

    static void OnFailureCallback_43(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_9_1Suite *>(context))->OnFailureResponse_43(error);
    }

    static void OnSuccessCallback_43(void * context, uint8_t colorLoopDirection)
    {
        (static_cast<Test_TC_CC_9_1Suite *>(context))->OnSuccessResponse_43(colorLoopDirection);
    }

    static void OnFailureCallback_45(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_9_1Suite *>(context))->OnFailureResponse_45(error);
    }

    static void OnSuccessCallback_45(void * context, uint8_t colorLoopActive)
    {
        (static_cast<Test_TC_CC_9_1Suite *>(context))->OnSuccessResponse_45(colorLoopActive);
    }

    static void OnFailureCallback_46(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_9_1Suite *>(context))->OnFailureResponse_46(error);
    }

    static void OnSuccessCallback_46(void * context, uint16_t enhancedCurrentHue)
    {
        (static_cast<Test_TC_CC_9_1Suite *>(context))->OnSuccessResponse_46(enhancedCurrentHue);
    }

    static void OnFailureCallback_47(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_9_1Suite *>(context))->OnFailureResponse_47(error);
    }

    static void OnSuccessCallback_47(void * context, uint16_t colorLoopStoredEnhancedHue)
    {
        (static_cast<Test_TC_CC_9_1Suite *>(context))->OnSuccessResponse_47(colorLoopStoredEnhancedHue);
    }

    static void OnFailureCallback_49(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_9_1Suite *>(context))->OnFailureResponse_49(error);
    }

    static void OnSuccessCallback_49(void * context, uint8_t colorLoopActive)
    {
        (static_cast<Test_TC_CC_9_1Suite *>(context))->OnSuccessResponse_49(colorLoopActive);
    }

    static void OnFailureCallback_50(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_9_1Suite *>(context))->OnFailureResponse_50(error);
    }

    static void OnSuccessCallback_50(void * context, uint16_t colorLoopStoredEnhancedHue)
    {
        (static_cast<Test_TC_CC_9_1Suite *>(context))->OnSuccessResponse_50(colorLoopStoredEnhancedHue);
    }

    static void OnFailureCallback_51(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_9_1Suite *>(context))->OnFailureResponse_51(error);
    }

    static void OnSuccessCallback_51(void * context, uint16_t enhancedCurrentHue)
    {
        (static_cast<Test_TC_CC_9_1Suite *>(context))->OnSuccessResponse_51(enhancedCurrentHue);
    }

    static void OnFailureCallback_53(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_9_1Suite *>(context))->OnFailureResponse_53(error);
    }

    static void OnSuccessCallback_53(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_9_1Suite *>(context))->OnSuccessResponse_53(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestPreconditionTurnOnLightForColorControlTests_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_1Suite *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_9_1Suite *>(context))->OnFailureResponse_1(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 1));

        NextTest();
    }

    CHIP_ERROR TestSendsColorLoopSetCommandSetAllAttributes_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;

        RequestType request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(1);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 0U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_1Suite *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_9_1Suite *>(context))->OnFailureResponse_3(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestReadColorLoopActiveAttributeFromDut_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopActive::TypeInfo>(
            this, OnSuccessCallback_4, OnFailureCallback_4, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_4(uint8_t colorLoopActive)
    {
        VerifyOrReturn(CheckValue("colorLoopActive", colorLoopActive, 0));

        NextTest();
    }

    CHIP_ERROR TestSendsColorLoopSetCommandSetAllAttributes_5()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;

        RequestType request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(2);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 0U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_1Suite *>(context))->OnSuccessResponse_5();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_9_1Suite *>(context))->OnFailureResponse_5(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_5() { NextTest(); }

    CHIP_ERROR TestReadColorLoopDirectionAttributeFromDut_6()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopDirection::TypeInfo>(
            this, OnSuccessCallback_6, OnFailureCallback_6, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_6(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_6(uint8_t colorLoopDirection)
    {
        VerifyOrReturn(CheckValue("colorLoopDirection", colorLoopDirection, 0));

        NextTest();
    }

    CHIP_ERROR TestSendsColorLoopSetCommandSetAllAttributes_7()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;

        RequestType request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(4);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 30U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_1Suite *>(context))->OnSuccessResponse_7();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_9_1Suite *>(context))->OnFailureResponse_7(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_7(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_7() { NextTest(); }

    CHIP_ERROR TestReadColorLoopTimeAttributeFromDut_8()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopTime::TypeInfo>(
            this, OnSuccessCallback_8, OnFailureCallback_8, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_8(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_8(uint16_t colorLoopTime)
    {
        VerifyOrReturn(CheckValue("colorLoopTime", colorLoopTime, 30U));

        NextTest();
    }

    CHIP_ERROR TestSendsColorLoopSetCommandSetAllAttributes_9()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;

        RequestType request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(8);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 0U;
        request.startHue        = 160U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_1Suite *>(context))->OnSuccessResponse_9();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_9_1Suite *>(context))->OnFailureResponse_9(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_9(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_9() { NextTest(); }

    CHIP_ERROR TestReadColorLoopStartEnhancedHueAttributeFromDut_10()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopStartEnhancedHue::TypeInfo>(
                this, OnSuccessCallback_10, OnFailureCallback_10, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_10(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_10(uint16_t colorLoopStartEnhancedHue)
    {
        VerifyOrReturn(CheckValue("colorLoopStartEnhancedHue", colorLoopStartEnhancedHue, 160U));

        NextTest();
    }

    CHIP_ERROR TestSendsColorLoopSetCommandSetAllAttributes_11()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;

        RequestType request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(1);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(1);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 0U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_1Suite *>(context))->OnSuccessResponse_11();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_9_1Suite *>(context))->OnFailureResponse_11(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_11(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_11() { NextTest(); }

    CHIP_ERROR TestReadColorLoopActiveAttributeFromDut_12()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopActive::TypeInfo>(
            this, OnSuccessCallback_12, OnFailureCallback_12, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_12(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_12(uint8_t colorLoopActive)
    {
        VerifyOrReturn(CheckValue("colorLoopActive", colorLoopActive, 1));

        NextTest();
    }

    CHIP_ERROR TestReadEnhancedCurrentHueAttributeFromDut_13()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::EnhancedCurrentHue::TypeInfo>(
            this, OnSuccessCallback_13, OnFailureCallback_13, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_13(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_13(uint16_t enhancedCurrentHue)
    {
        VerifyOrReturn(CheckConstraintType("enhancedCurrentHue", "", "uint16"));
        EnhancedCurrentHueValue1 = enhancedCurrentHue;
        NextTest();
    }

    CHIP_ERROR TestReadColorLoopStoredEnhancedHueAttributeFromDut_14()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopStoredEnhancedHue::TypeInfo>(
                this, OnSuccessCallback_14, OnFailureCallback_14, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_14(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_14(uint16_t colorLoopStoredEnhancedHue)
    {
        VerifyOrReturn(CheckValue("colorLoopStoredEnhancedHue", colorLoopStoredEnhancedHue, EnhancedCurrentHueValue1));

        NextTest();
    }

    CHIP_ERROR TestSendsColorLoopSetCommandSetAllAttributes_15()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;

        RequestType request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(1);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 0U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_1Suite *>(context))->OnSuccessResponse_15();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_9_1Suite *>(context))->OnFailureResponse_15(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_15(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_15() { NextTest(); }

    CHIP_ERROR TestReadColorLoopActiveAttributeFromDut_16()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopActive::TypeInfo>(
            this, OnSuccessCallback_16, OnFailureCallback_16, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_16(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_16(uint8_t colorLoopActive)
    {
        VerifyOrReturn(CheckValue("colorLoopActive", colorLoopActive, 0));

        NextTest();
    }

    CHIP_ERROR TestReadColorLoopStoredEnhancedHueAttributeFromDut_17()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopStoredEnhancedHue::TypeInfo>(
                this, OnSuccessCallback_17, OnFailureCallback_17, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_17(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_17(uint16_t colorLoopStoredEnhancedHue)
    {
        VerifyOrReturn(CheckConstraintType("colorLoopStoredEnhancedHue", "", "uint16"));
        ColorLoopStoredEnhancedHueValue1 = colorLoopStoredEnhancedHue;
        NextTest();
    }

    CHIP_ERROR TestReadEnhancedCurrentHueAttributeFromDut_18()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::EnhancedCurrentHue::TypeInfo>(
            this, OnSuccessCallback_18, OnFailureCallback_18, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_18(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_18(uint16_t enhancedCurrentHue)
    {
        VerifyOrReturn(CheckValue("enhancedCurrentHue", enhancedCurrentHue, ColorLoopStoredEnhancedHueValue1));

        NextTest();
    }

    CHIP_ERROR TestSendsColorLoopSetCommandSetAllAttributes_19()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;

        RequestType request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(2);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(1);
        request.time            = 0U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_1Suite *>(context))->OnSuccessResponse_19();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_9_1Suite *>(context))->OnFailureResponse_19(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_19(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_19() { NextTest(); }

    CHIP_ERROR TestReadColorLoopDirectionAttributeFromDut_20()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopDirection::TypeInfo>(
            this, OnSuccessCallback_20, OnFailureCallback_20, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_20(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_20(uint8_t colorLoopDirection)
    {
        VerifyOrReturn(CheckValue("colorLoopDirection", colorLoopDirection, 1));

        NextTest();
    }

    CHIP_ERROR TestSendsColorLoopSetCommandSetAllAttributes_21()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;

        RequestType request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(1);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(1);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 0U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_1Suite *>(context))->OnSuccessResponse_21();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_9_1Suite *>(context))->OnFailureResponse_21(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_21(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_21() { NextTest(); }

    CHIP_ERROR TestReadColorLoopActiveAttributeFromDut_22()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopActive::TypeInfo>(
            this, OnSuccessCallback_22, OnFailureCallback_22, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_22(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_22(uint8_t colorLoopActive)
    {
        VerifyOrReturn(CheckValue("colorLoopActive", colorLoopActive, 1));

        NextTest();
    }

    CHIP_ERROR TestReadEnhancedCurrentHueAttributeFromDut_23()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::EnhancedCurrentHue::TypeInfo>(
            this, OnSuccessCallback_23, OnFailureCallback_23, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_23(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_23(uint16_t enhancedCurrentHue)
    {
        VerifyOrReturn(CheckConstraintType("enhancedCurrentHue", "", "uint16"));
        EnhancedCurrentHueValue2 = enhancedCurrentHue;
        NextTest();
    }

    CHIP_ERROR TestReadColorLoopStoredEnhancedHueAttributeFromDut_24()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopStoredEnhancedHue::TypeInfo>(
                this, OnSuccessCallback_24, OnFailureCallback_24, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_24(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_24(uint16_t colorLoopStoredEnhancedHue)
    {
        VerifyOrReturn(CheckValue("colorLoopStoredEnhancedHue", colorLoopStoredEnhancedHue, EnhancedCurrentHueValue2));

        NextTest();
    }

    CHIP_ERROR TestSendsColorLoopSetCommandSetAllAttributes_25()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;

        RequestType request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(1);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 0U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_1Suite *>(context))->OnSuccessResponse_25();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_9_1Suite *>(context))->OnFailureResponse_25(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_25(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_25() { NextTest(); }

    CHIP_ERROR TestReadColorLoopActiveAttributeFromDut_26()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopActive::TypeInfo>(
            this, OnSuccessCallback_26, OnFailureCallback_26, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_26(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_26(uint8_t colorLoopActive)
    {
        VerifyOrReturn(CheckValue("colorLoopActive", colorLoopActive, 0));

        NextTest();
    }

    CHIP_ERROR TestReadColorLoopStoredEnhancedHueAttributeFromDut_27()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopStoredEnhancedHue::TypeInfo>(
                this, OnSuccessCallback_27, OnFailureCallback_27, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_27(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_27(uint16_t colorLoopStoredEnhancedHue)
    {
        VerifyOrReturn(CheckConstraintType("colorLoopStoredEnhancedHue", "", "uint16"));
        ColorLoopStoredEnhancedHueValue2 = colorLoopStoredEnhancedHue;
        NextTest();
    }

    CHIP_ERROR TestReadEnhancedCurrentHueAttributeFromDut_28()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::EnhancedCurrentHue::TypeInfo>(
            this, OnSuccessCallback_28, OnFailureCallback_28, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_28(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_28(uint16_t enhancedCurrentHue)
    {
        VerifyOrReturn(CheckValue("enhancedCurrentHue", enhancedCurrentHue, ColorLoopStoredEnhancedHueValue2));

        NextTest();
    }

    CHIP_ERROR TestEnhancedMoveToHueCommand_29()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::EnhancedMoveToHue::Type;

        RequestType request;
        request.enhancedHue     = 40960U;
        request.direction       = static_cast<chip::app::Clusters::ColorControl::HueDirection>(0);
        request.transitionTime  = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_1Suite *>(context))->OnSuccessResponse_29();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_9_1Suite *>(context))->OnFailureResponse_29(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_29(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_29() { NextTest(); }

    CHIP_ERROR TestWait2000ms_30()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForMs(2000);
    }

    CHIP_ERROR TestReadEnhancedCurrentHueAttributeFromDut_31()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::EnhancedCurrentHue::TypeInfo>(
            this, OnSuccessCallback_31, OnFailureCallback_31, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_31(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_31(uint16_t enhancedCurrentHue)
    {
        VerifyOrReturn(CheckValue("enhancedCurrentHue", enhancedCurrentHue, 40960U));

        NextTest();
    }

    CHIP_ERROR TestSendsColorLoopSetCommandSetAllAttributes_32()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;

        RequestType request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(2);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 0U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_1Suite *>(context))->OnSuccessResponse_32();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_9_1Suite *>(context))->OnFailureResponse_32(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_32(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_32() { NextTest(); }

    CHIP_ERROR TestReadColorLoopDirectionAttributeFromDut_33()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopDirection::TypeInfo>(
            this, OnSuccessCallback_33, OnFailureCallback_33, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_33(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_33(uint8_t colorLoopDirection)
    {
        VerifyOrReturn(CheckValue("colorLoopDirection", colorLoopDirection, 0));

        NextTest();
    }

    CHIP_ERROR TestSendsColorLoopSetCommandSetAllAttributes_34()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;

        RequestType request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(1);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(2);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 0U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_1Suite *>(context))->OnSuccessResponse_34();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_9_1Suite *>(context))->OnFailureResponse_34(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_34(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_34() { NextTest(); }

    CHIP_ERROR TestReadColorLoopActiveAttributeFromDut_35()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopActive::TypeInfo>(
            this, OnSuccessCallback_35, OnFailureCallback_35, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_35(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_35(uint8_t colorLoopActive)
    {
        VerifyOrReturn(CheckValue("colorLoopActive", colorLoopActive, 1));

        NextTest();
    }

    CHIP_ERROR TestReadEnhancedCurrentHueAttributeFromDut_36()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::EnhancedCurrentHue::TypeInfo>(
            this, OnSuccessCallback_36, OnFailureCallback_36, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_36(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_36(uint16_t enhancedCurrentHue)
    {
        VerifyOrReturn(CheckConstraintType("enhancedCurrentHue", "", "uint16"));
        EnhancedCurrentHueValue3 = enhancedCurrentHue;
        NextTest();
    }

    CHIP_ERROR TestReadColorLoopStoredEnhancedHueAttributeFromDut_37()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopStoredEnhancedHue::TypeInfo>(
                this, OnSuccessCallback_37, OnFailureCallback_37, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_37(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_37(uint16_t colorLoopStoredEnhancedHue)
    {
        VerifyOrReturn(CheckValue("colorLoopStoredEnhancedHue", colorLoopStoredEnhancedHue, EnhancedCurrentHueValue3));

        NextTest();
    }

    CHIP_ERROR TestSendsColorLoopSetCommandSetAllAttributes_38()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;

        RequestType request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(1);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 0U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_1Suite *>(context))->OnSuccessResponse_38();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_9_1Suite *>(context))->OnFailureResponse_38(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_38(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_38() { NextTest(); }

    CHIP_ERROR TestReadColorLoopActiveAttributeFromDut_39()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopActive::TypeInfo>(
            this, OnSuccessCallback_39, OnFailureCallback_39, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_39(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_39(uint8_t colorLoopActive)
    {
        VerifyOrReturn(CheckValue("colorLoopActive", colorLoopActive, 0));

        NextTest();
    }

    CHIP_ERROR TestReadColorLoopStoredEnhancedHueAttributeFromDut_40()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopStoredEnhancedHue::TypeInfo>(
                this, OnSuccessCallback_40, OnFailureCallback_40, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_40(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_40(uint16_t colorLoopStoredEnhancedHue)
    {
        VerifyOrReturn(CheckConstraintType("colorLoopStoredEnhancedHue", "", "uint16"));
        ColorLoopStoredEnhancedHueValue3 = colorLoopStoredEnhancedHue;
        NextTest();
    }

    CHIP_ERROR TestReadEnhancedCurrentHueAttributeFromDut_41()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::EnhancedCurrentHue::TypeInfo>(
            this, OnSuccessCallback_41, OnFailureCallback_41, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_41(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_41(uint16_t enhancedCurrentHue)
    {
        VerifyOrReturn(CheckValue("enhancedCurrentHue", enhancedCurrentHue, ColorLoopStoredEnhancedHueValue3));

        NextTest();
    }

    CHIP_ERROR TestSendsColorLoopSetCommandSetAllAttributes_42()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;

        RequestType request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(2);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(1);
        request.time            = 0U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_1Suite *>(context))->OnSuccessResponse_42();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_9_1Suite *>(context))->OnFailureResponse_42(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_42(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_42() { NextTest(); }

    CHIP_ERROR TestReadColorLoopDirectionAttributeFromDut_43()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopDirection::TypeInfo>(
            this, OnSuccessCallback_43, OnFailureCallback_43, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_43(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_43(uint8_t colorLoopDirection)
    {
        VerifyOrReturn(CheckValue("colorLoopDirection", colorLoopDirection, 1));

        NextTest();
    }

    CHIP_ERROR TestSendsColorLoopSetCommandSetAllAttributes_44()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;

        RequestType request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(1);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(2);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 0U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_1Suite *>(context))->OnSuccessResponse_44();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_9_1Suite *>(context))->OnFailureResponse_44(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_44(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_44() { NextTest(); }

    CHIP_ERROR TestReadColorLoopActiveAttributeFromDut_45()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopActive::TypeInfo>(
            this, OnSuccessCallback_45, OnFailureCallback_45, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_45(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_45(uint8_t colorLoopActive)
    {
        VerifyOrReturn(CheckValue("colorLoopActive", colorLoopActive, 1));

        NextTest();
    }

    CHIP_ERROR TestReadEnhancedCurrentHueAttributeFromDut_46()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::EnhancedCurrentHue::TypeInfo>(
            this, OnSuccessCallback_46, OnFailureCallback_46, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_46(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_46(uint16_t enhancedCurrentHue)
    {
        VerifyOrReturn(CheckConstraintType("enhancedCurrentHue", "", "uint16"));
        EnhancedCurrentHueValue4 = enhancedCurrentHue;
        NextTest();
    }

    CHIP_ERROR TestReadColorLoopStoredEnhancedHueAttributeFromDut_47()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopStoredEnhancedHue::TypeInfo>(
                this, OnSuccessCallback_47, OnFailureCallback_47, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_47(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_47(uint16_t colorLoopStoredEnhancedHue)
    {
        VerifyOrReturn(CheckValue("colorLoopStoredEnhancedHue", colorLoopStoredEnhancedHue, EnhancedCurrentHueValue4));

        NextTest();
    }

    CHIP_ERROR TestSendsColorLoopSetCommandSetAllAttributes_48()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;

        RequestType request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(1);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 0U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_1Suite *>(context))->OnSuccessResponse_48();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_9_1Suite *>(context))->OnFailureResponse_48(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_48(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_48() { NextTest(); }

    CHIP_ERROR TestReadColorLoopActiveAttributeFromDut_49()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopActive::TypeInfo>(
            this, OnSuccessCallback_49, OnFailureCallback_49, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_49(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_49(uint8_t colorLoopActive)
    {
        VerifyOrReturn(CheckValue("colorLoopActive", colorLoopActive, 0));

        NextTest();
    }

    CHIP_ERROR TestReadColorLoopStoredEnhancedHueAttributeFromDut_50()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopStoredEnhancedHue::TypeInfo>(
                this, OnSuccessCallback_50, OnFailureCallback_50, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_50(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_50(uint16_t colorLoopStoredEnhancedHue)
    {
        VerifyOrReturn(CheckConstraintType("colorLoopStoredEnhancedHue", "", "uint16"));
        ColorLoopStoredEnhancedHue4 = colorLoopStoredEnhancedHue;
        NextTest();
    }

    CHIP_ERROR TestReadEnhancedCurrentHueAttributeFromDut_51()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::EnhancedCurrentHue::TypeInfo>(
            this, OnSuccessCallback_51, OnFailureCallback_51, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_51(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_51(uint16_t enhancedCurrentHue)
    {
        VerifyOrReturn(CheckValue("enhancedCurrentHue", enhancedCurrentHue, ColorLoopStoredEnhancedHue4));

        NextTest();
    }

    CHIP_ERROR TestTurnOffLightForColorControlTests_52()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_1Suite *>(context))->OnSuccessResponse_52();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_9_1Suite *>(context))->OnFailureResponse_52(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_52(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_52() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_53()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(
            this, OnSuccessCallback_53, OnFailureCallback_53, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_53(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_53(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 0));

        NextTest();
    }
};

class Test_TC_CC_9_2Suite : public TestCommand
{
public:
    Test_TC_CC_9_2Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_CC_9_2", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_CC_9_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_9_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_9_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Precondition: Turn on light for color control tests\n");
            err = TestPreconditionTurnOnLightForColorControlTests_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Precondition: Check on/off attribute value is true after on command\n");
            err = TestPreconditionCheckOnOffAttributeValueIsTrueAfterOnCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Sends ColorLoopSet Command - Set all Attributes\n");
            if (ShouldSkip("CR_COLORLOOPSET"))
            {
                NextTest();
                return;
            }
            err = TestSendsColorLoopSetCommandSetAllAttributes_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Read ColorLoopActive attribute from DUT\n");
            if (ShouldSkip("A_COLORLOOPACTIVE"))
            {
                NextTest();
                return;
            }
            err = TestReadColorLoopActiveAttributeFromDut_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Read ColorLoopDirection attribute from DUT.\n");
            if (ShouldSkip("A_COLORLOOPDIRECTION"))
            {
                NextTest();
                return;
            }
            err = TestReadColorLoopDirectionAttributeFromDut_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Read ColorLoopTime attribute from DUT.\n");
            if (ShouldSkip("A_COLORLOOPTIME"))
            {
                NextTest();
                return;
            }
            err = TestReadColorLoopTimeAttributeFromDut_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Read ColorLoopStartEnhancedHue attribute from DUT.\n");
            if (ShouldSkip("A_COLORLOOPSTARTENHANCEDHUE"))
            {
                NextTest();
                return;
            }
            err = TestReadColorLoopStartEnhancedHueAttributeFromDut_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Color Loop Set Command - Set all Attributes\n");
            if (ShouldSkip("CR_COLORLOOPSET"))
            {
                NextTest();
                return;
            }
            err = TestColorLoopSetCommandSetAllAttributes_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Read ColorLoopActive attribute from DUT.\n");
            if (ShouldSkip("A_COLORLOOPACTIVE"))
            {
                NextTest();
                return;
            }
            err = TestReadColorLoopActiveAttributeFromDut_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Read EnhancedCurrentHue attribute from DUT.\n");
            if (ShouldSkip("A_ENHANCEDCURRENTHUE"))
            {
                NextTest();
                return;
            }
            err = TestReadEnhancedCurrentHueAttributeFromDut_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : Read ColorLoopStoredEnhancedHue attribute from DUT.\n");
            if (ShouldSkip("A_COLORLOOPSTOREDENHANCEDHUE"))
            {
                NextTest();
                return;
            }
            err = TestReadColorLoopStoredEnhancedHueAttributeFromDut_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : Color Loop Set Command - Start Color Loop\n");
            if (ShouldSkip("CR_COLORLOOPSET"))
            {
                NextTest();
                return;
            }
            err = TestColorLoopSetCommandStartColorLoop_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : Read ColorLoopDirection attribute from DUT.\n");
            if (ShouldSkip("A_COLORLOOPDIRECTION"))
            {
                NextTest();
                return;
            }
            err = TestReadColorLoopDirectionAttributeFromDut_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : Color Loop Set Command - Start Color Loop\n");
            if (ShouldSkip("CR_COLORLOOPSET"))
            {
                NextTest();
                return;
            }
            err = TestColorLoopSetCommandStartColorLoop_14();
            break;
        case 15:
            ChipLogProgress(chipTool, " ***** Test Step 15 : Read ColorLoopActive attribute from DUT\n");
            if (ShouldSkip("A_COLORLOOPACTIVE"))
            {
                NextTest();
                return;
            }
            err = TestReadColorLoopActiveAttributeFromDut_15();
            break;
        case 16:
            ChipLogProgress(chipTool, " ***** Test Step 16 : Read ColorLoopStoredEnhancedHue attribute from DUT.\n");
            if (ShouldSkip("A_COLORLOOPSTOREDENHANCEDHUE"))
            {
                NextTest();
                return;
            }
            err = TestReadColorLoopStoredEnhancedHueAttributeFromDut_16();
            break;
        case 17:
            ChipLogProgress(chipTool, " ***** Test Step 17 : Read EnhancedCurrentHue attribute from DUT.\n");
            if (ShouldSkip("A_ENHANCEDCURRENTHUE"))
            {
                NextTest();
                return;
            }
            err = TestReadEnhancedCurrentHueAttributeFromDut_17();
            break;
        case 18:
            ChipLogProgress(chipTool, " ***** Test Step 18 : Turn off light for color control tests\n");
            err = TestTurnOffLightForColorControlTests_18();
            break;
        case 19:
            ChipLogProgress(chipTool, " ***** Test Step 19 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_19();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 20;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    uint16_t EnhancedCurrentHueValue;
    uint16_t ColorLoopStoredEnhancedHueValue;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_9_2Suite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_9_2Suite *>(context))->OnSuccessResponse_2(onOff);
    }

    static void OnFailureCallback_4(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_9_2Suite *>(context))->OnFailureResponse_4(error);
    }

    static void OnSuccessCallback_4(void * context, uint8_t colorLoopActive)
    {
        (static_cast<Test_TC_CC_9_2Suite *>(context))->OnSuccessResponse_4(colorLoopActive);
    }

    static void OnFailureCallback_5(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_9_2Suite *>(context))->OnFailureResponse_5(error);
    }

    static void OnSuccessCallback_5(void * context, uint8_t colorLoopDirection)
    {
        (static_cast<Test_TC_CC_9_2Suite *>(context))->OnSuccessResponse_5(colorLoopDirection);
    }

    static void OnFailureCallback_6(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_9_2Suite *>(context))->OnFailureResponse_6(error);
    }

    static void OnSuccessCallback_6(void * context, uint16_t colorLoopTime)
    {
        (static_cast<Test_TC_CC_9_2Suite *>(context))->OnSuccessResponse_6(colorLoopTime);
    }

    static void OnFailureCallback_7(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_9_2Suite *>(context))->OnFailureResponse_7(error);
    }

    static void OnSuccessCallback_7(void * context, uint16_t colorLoopStartEnhancedHue)
    {
        (static_cast<Test_TC_CC_9_2Suite *>(context))->OnSuccessResponse_7(colorLoopStartEnhancedHue);
    }

    static void OnFailureCallback_9(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_9_2Suite *>(context))->OnFailureResponse_9(error);
    }

    static void OnSuccessCallback_9(void * context, uint8_t colorLoopActive)
    {
        (static_cast<Test_TC_CC_9_2Suite *>(context))->OnSuccessResponse_9(colorLoopActive);
    }

    static void OnFailureCallback_10(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_9_2Suite *>(context))->OnFailureResponse_10(error);
    }

    static void OnSuccessCallback_10(void * context, uint16_t enhancedCurrentHue)
    {
        (static_cast<Test_TC_CC_9_2Suite *>(context))->OnSuccessResponse_10(enhancedCurrentHue);
    }

    static void OnFailureCallback_11(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_9_2Suite *>(context))->OnFailureResponse_11(error);
    }

    static void OnSuccessCallback_11(void * context, uint16_t colorLoopStoredEnhancedHue)
    {
        (static_cast<Test_TC_CC_9_2Suite *>(context))->OnSuccessResponse_11(colorLoopStoredEnhancedHue);
    }

    static void OnFailureCallback_13(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_9_2Suite *>(context))->OnFailureResponse_13(error);
    }

    static void OnSuccessCallback_13(void * context, uint8_t colorLoopDirection)
    {
        (static_cast<Test_TC_CC_9_2Suite *>(context))->OnSuccessResponse_13(colorLoopDirection);
    }

    static void OnFailureCallback_15(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_9_2Suite *>(context))->OnFailureResponse_15(error);
    }

    static void OnSuccessCallback_15(void * context, uint8_t colorLoopActive)
    {
        (static_cast<Test_TC_CC_9_2Suite *>(context))->OnSuccessResponse_15(colorLoopActive);
    }

    static void OnFailureCallback_16(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_9_2Suite *>(context))->OnFailureResponse_16(error);
    }

    static void OnSuccessCallback_16(void * context, uint16_t colorLoopStoredEnhancedHue)
    {
        (static_cast<Test_TC_CC_9_2Suite *>(context))->OnSuccessResponse_16(colorLoopStoredEnhancedHue);
    }

    static void OnFailureCallback_17(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_9_2Suite *>(context))->OnFailureResponse_17(error);
    }

    static void OnSuccessCallback_17(void * context, uint16_t enhancedCurrentHue)
    {
        (static_cast<Test_TC_CC_9_2Suite *>(context))->OnSuccessResponse_17(enhancedCurrentHue);
    }

    static void OnFailureCallback_19(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_9_2Suite *>(context))->OnFailureResponse_19(error);
    }

    static void OnSuccessCallback_19(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_9_2Suite *>(context))->OnSuccessResponse_19(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestPreconditionTurnOnLightForColorControlTests_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_2Suite *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_9_2Suite *>(context))->OnFailureResponse_1(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestPreconditionCheckOnOffAttributeValueIsTrueAfterOnCommand_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 1));

        NextTest();
    }

    CHIP_ERROR TestSendsColorLoopSetCommandSetAllAttributes_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;

        RequestType request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(15);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 30U;
        request.startHue        = 160U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_2Suite *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_9_2Suite *>(context))->OnFailureResponse_3(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestReadColorLoopActiveAttributeFromDut_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopActive::TypeInfo>(
            this, OnSuccessCallback_4, OnFailureCallback_4, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_4(uint8_t colorLoopActive)
    {
        VerifyOrReturn(CheckValue("colorLoopActive", colorLoopActive, 0));

        NextTest();
    }

    CHIP_ERROR TestReadColorLoopDirectionAttributeFromDut_5()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopDirection::TypeInfo>(
            this, OnSuccessCallback_5, OnFailureCallback_5, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_5(uint8_t colorLoopDirection)
    {
        VerifyOrReturn(CheckValue("colorLoopDirection", colorLoopDirection, 0));

        NextTest();
    }

    CHIP_ERROR TestReadColorLoopTimeAttributeFromDut_6()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopTime::TypeInfo>(
            this, OnSuccessCallback_6, OnFailureCallback_6, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_6(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_6(uint16_t colorLoopTime)
    {
        VerifyOrReturn(CheckValue("colorLoopTime", colorLoopTime, 30U));

        NextTest();
    }

    CHIP_ERROR TestReadColorLoopStartEnhancedHueAttributeFromDut_7()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopStartEnhancedHue::TypeInfo>(
                this, OnSuccessCallback_7, OnFailureCallback_7, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_7(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_7(uint16_t colorLoopStartEnhancedHue)
    {
        VerifyOrReturn(CheckValue("colorLoopStartEnhancedHue", colorLoopStartEnhancedHue, 160U));

        NextTest();
    }

    CHIP_ERROR TestColorLoopSetCommandSetAllAttributes_8()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;

        RequestType request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(1);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(1);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 0U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_2Suite *>(context))->OnSuccessResponse_8();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_9_2Suite *>(context))->OnFailureResponse_8(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_8(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_8() { NextTest(); }

    CHIP_ERROR TestReadColorLoopActiveAttributeFromDut_9()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopActive::TypeInfo>(
            this, OnSuccessCallback_9, OnFailureCallback_9, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_9(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_9(uint8_t colorLoopActive)
    {
        VerifyOrReturn(CheckValue("colorLoopActive", colorLoopActive, 1));

        NextTest();
    }

    CHIP_ERROR TestReadEnhancedCurrentHueAttributeFromDut_10()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::EnhancedCurrentHue::TypeInfo>(
            this, OnSuccessCallback_10, OnFailureCallback_10, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_10(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_10(uint16_t enhancedCurrentHue)
    {
        VerifyOrReturn(CheckConstraintType("enhancedCurrentHue", "", "uint16"));
        EnhancedCurrentHueValue = enhancedCurrentHue;
        NextTest();
    }

    CHIP_ERROR TestReadColorLoopStoredEnhancedHueAttributeFromDut_11()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopStoredEnhancedHue::TypeInfo>(
                this, OnSuccessCallback_11, OnFailureCallback_11, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_11(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_11(uint16_t colorLoopStoredEnhancedHue)
    {
        VerifyOrReturn(CheckValue("colorLoopStoredEnhancedHue", colorLoopStoredEnhancedHue, EnhancedCurrentHueValue));

        NextTest();
    }

    CHIP_ERROR TestColorLoopSetCommandStartColorLoop_12()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;

        RequestType request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(2);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(1);
        request.time            = 0U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_2Suite *>(context))->OnSuccessResponse_12();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_9_2Suite *>(context))->OnFailureResponse_12(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_12(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_12() { NextTest(); }

    CHIP_ERROR TestReadColorLoopDirectionAttributeFromDut_13()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopDirection::TypeInfo>(
            this, OnSuccessCallback_13, OnFailureCallback_13, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_13(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_13(uint8_t colorLoopDirection)
    {
        VerifyOrReturn(CheckValue("colorLoopDirection", colorLoopDirection, 1));

        NextTest();
    }

    CHIP_ERROR TestColorLoopSetCommandStartColorLoop_14()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;

        RequestType request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(1);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 0U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_2Suite *>(context))->OnSuccessResponse_14();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_9_2Suite *>(context))->OnFailureResponse_14(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_14(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_14() { NextTest(); }

    CHIP_ERROR TestReadColorLoopActiveAttributeFromDut_15()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopActive::TypeInfo>(
            this, OnSuccessCallback_15, OnFailureCallback_15, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_15(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_15(uint8_t colorLoopActive)
    {
        VerifyOrReturn(CheckValue("colorLoopActive", colorLoopActive, 0));

        NextTest();
    }

    CHIP_ERROR TestReadColorLoopStoredEnhancedHueAttributeFromDut_16()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopStoredEnhancedHue::TypeInfo>(
                this, OnSuccessCallback_16, OnFailureCallback_16, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_16(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_16(uint16_t colorLoopStoredEnhancedHue)
    {
        VerifyOrReturn(CheckConstraintType("colorLoopStoredEnhancedHue", "", "uint16"));
        ColorLoopStoredEnhancedHueValue = colorLoopStoredEnhancedHue;
        NextTest();
    }

    CHIP_ERROR TestReadEnhancedCurrentHueAttributeFromDut_17()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::EnhancedCurrentHue::TypeInfo>(
            this, OnSuccessCallback_17, OnFailureCallback_17, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_17(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_17(uint16_t enhancedCurrentHue)
    {
        VerifyOrReturn(CheckValue("enhancedCurrentHue", enhancedCurrentHue, ColorLoopStoredEnhancedHueValue));

        NextTest();
    }

    CHIP_ERROR TestTurnOffLightForColorControlTests_18()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_2Suite *>(context))->OnSuccessResponse_18();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_9_2Suite *>(context))->OnFailureResponse_18(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_18(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_18() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_19()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(
            this, OnSuccessCallback_19, OnFailureCallback_19, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_19(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_19(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 0));

        NextTest();
    }
};

class Test_TC_CC_9_3Suite : public TestCommand
{
public:
    Test_TC_CC_9_3Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_CC_9_3", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_CC_9_3Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_9_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_9_3\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Precondition: Turn on light for color control tests\n");
            err = TestPreconditionTurnOnLightForColorControlTests_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Precondition: Check on/off attribute value is true after on command\n");
            err = TestPreconditionCheckOnOffAttributeValueIsTrueAfterOnCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Sends ColorLoopSet Command - Set all Attributes\n");
            if (ShouldSkip("CR_COLORLOOPSET"))
            {
                NextTest();
                return;
            }
            err = TestSendsColorLoopSetCommandSetAllAttributes_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Read ColorLoopActive attribute from DUT\n");
            if (ShouldSkip("A_COLORLOOPACTIVE"))
            {
                NextTest();
                return;
            }
            err = TestReadColorLoopActiveAttributeFromDut_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Read ColorLoopDirection attribute from DUT.\n");
            if (ShouldSkip("A_COLORLOOPDIRECTION"))
            {
                NextTest();
                return;
            }
            err = TestReadColorLoopDirectionAttributeFromDut_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Read ColorLoopTime attribute from DUT.\n");
            if (ShouldSkip("A_COLORLOOPTIME"))
            {
                NextTest();
                return;
            }
            err = TestReadColorLoopTimeAttributeFromDut_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Read ColorLoopStartEnhancedHue attribute from DUT.\n");
            if (ShouldSkip("A_COLORLOOPSTARTENHANCEDHUE"))
            {
                NextTest();
                return;
            }
            err = TestReadColorLoopStartEnhancedHueAttributeFromDut_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Color Loop Set Command - Set all Attributes\n");
            if (ShouldSkip("CR_COLORLOOPSET"))
            {
                NextTest();
                return;
            }
            err = TestColorLoopSetCommandSetAllAttributes_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Read ColorLoopActive attribute from DUT.\n");
            if (ShouldSkip("A_COLORLOOPACTIVE"))
            {
                NextTest();
                return;
            }
            err = TestReadColorLoopActiveAttributeFromDut_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Read EnhancedCurrentHue attribute from DUT.\n");
            if (ShouldSkip("A_ENHANCEDCURRENTHUE"))
            {
                NextTest();
                return;
            }
            err = TestReadEnhancedCurrentHueAttributeFromDut_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : Read ColorLoopStoredEnhancedHue attribute from DUT.\n");
            if (ShouldSkip("A_COLORLOOPSTOREDENHANCEDHUE"))
            {
                NextTest();
                return;
            }
            err = TestReadColorLoopStoredEnhancedHueAttributeFromDut_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : Color Loop Set Command - Start Color Loop\n");
            if (ShouldSkip("CR_COLORLOOPSET"))
            {
                NextTest();
                return;
            }
            err = TestColorLoopSetCommandStartColorLoop_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : Read ColorLoopTime attribute from DUT.\n");
            if (ShouldSkip("A_COLORLOOPTIME"))
            {
                NextTest();
                return;
            }
            err = TestReadColorLoopTimeAttributeFromDut_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : Color Loop Set Command - Start Color Loop\n");
            if (ShouldSkip("CR_COLORLOOPSET"))
            {
                NextTest();
                return;
            }
            err = TestColorLoopSetCommandStartColorLoop_14();
            break;
        case 15:
            ChipLogProgress(chipTool, " ***** Test Step 15 : Read ColorLoopActive attribute from DUT\n");
            if (ShouldSkip("A_COLORLOOPACTIVE"))
            {
                NextTest();
                return;
            }
            err = TestReadColorLoopActiveAttributeFromDut_15();
            break;
        case 16:
            ChipLogProgress(chipTool, " ***** Test Step 16 : Read ColorLoopStoredEnhancedHue attribute from DUT.\n");
            if (ShouldSkip("A_COLORLOOPSTOREDENHANCEDHUE"))
            {
                NextTest();
                return;
            }
            err = TestReadColorLoopStoredEnhancedHueAttributeFromDut_16();
            break;
        case 17:
            ChipLogProgress(chipTool, " ***** Test Step 17 : Read EnhancedCurrentHue attribute from DUT.\n");
            if (ShouldSkip("A_ENHANCEDCURRENTHUE"))
            {
                NextTest();
                return;
            }
            err = TestReadEnhancedCurrentHueAttributeFromDut_17();
            break;
        case 18:
            ChipLogProgress(chipTool, " ***** Test Step 18 : Turn off light for color control tests\n");
            err = TestTurnOffLightForColorControlTests_18();
            break;
        case 19:
            ChipLogProgress(chipTool, " ***** Test Step 19 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_19();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 20;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    uint16_t EnhancedCurrentHueValue;
    uint16_t ColorLoopStoredEnhancedHueValue;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_9_3Suite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_9_3Suite *>(context))->OnSuccessResponse_2(onOff);
    }

    static void OnFailureCallback_4(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_9_3Suite *>(context))->OnFailureResponse_4(error);
    }

    static void OnSuccessCallback_4(void * context, uint8_t colorLoopActive)
    {
        (static_cast<Test_TC_CC_9_3Suite *>(context))->OnSuccessResponse_4(colorLoopActive);
    }

    static void OnFailureCallback_5(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_9_3Suite *>(context))->OnFailureResponse_5(error);
    }

    static void OnSuccessCallback_5(void * context, uint8_t colorLoopDirection)
    {
        (static_cast<Test_TC_CC_9_3Suite *>(context))->OnSuccessResponse_5(colorLoopDirection);
    }

    static void OnFailureCallback_6(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_9_3Suite *>(context))->OnFailureResponse_6(error);
    }

    static void OnSuccessCallback_6(void * context, uint16_t colorLoopTime)
    {
        (static_cast<Test_TC_CC_9_3Suite *>(context))->OnSuccessResponse_6(colorLoopTime);
    }

    static void OnFailureCallback_7(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_9_3Suite *>(context))->OnFailureResponse_7(error);
    }

    static void OnSuccessCallback_7(void * context, uint16_t colorLoopStartEnhancedHue)
    {
        (static_cast<Test_TC_CC_9_3Suite *>(context))->OnSuccessResponse_7(colorLoopStartEnhancedHue);
    }

    static void OnFailureCallback_9(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_9_3Suite *>(context))->OnFailureResponse_9(error);
    }

    static void OnSuccessCallback_9(void * context, uint8_t colorLoopActive)
    {
        (static_cast<Test_TC_CC_9_3Suite *>(context))->OnSuccessResponse_9(colorLoopActive);
    }

    static void OnFailureCallback_10(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_9_3Suite *>(context))->OnFailureResponse_10(error);
    }

    static void OnSuccessCallback_10(void * context, uint16_t enhancedCurrentHue)
    {
        (static_cast<Test_TC_CC_9_3Suite *>(context))->OnSuccessResponse_10(enhancedCurrentHue);
    }

    static void OnFailureCallback_11(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_9_3Suite *>(context))->OnFailureResponse_11(error);
    }

    static void OnSuccessCallback_11(void * context, uint16_t colorLoopStoredEnhancedHue)
    {
        (static_cast<Test_TC_CC_9_3Suite *>(context))->OnSuccessResponse_11(colorLoopStoredEnhancedHue);
    }

    static void OnFailureCallback_13(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_9_3Suite *>(context))->OnFailureResponse_13(error);
    }

    static void OnSuccessCallback_13(void * context, uint16_t colorLoopTime)
    {
        (static_cast<Test_TC_CC_9_3Suite *>(context))->OnSuccessResponse_13(colorLoopTime);
    }

    static void OnFailureCallback_15(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_9_3Suite *>(context))->OnFailureResponse_15(error);
    }

    static void OnSuccessCallback_15(void * context, uint8_t colorLoopActive)
    {
        (static_cast<Test_TC_CC_9_3Suite *>(context))->OnSuccessResponse_15(colorLoopActive);
    }

    static void OnFailureCallback_16(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_9_3Suite *>(context))->OnFailureResponse_16(error);
    }

    static void OnSuccessCallback_16(void * context, uint16_t colorLoopStoredEnhancedHue)
    {
        (static_cast<Test_TC_CC_9_3Suite *>(context))->OnSuccessResponse_16(colorLoopStoredEnhancedHue);
    }

    static void OnFailureCallback_17(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_9_3Suite *>(context))->OnFailureResponse_17(error);
    }

    static void OnSuccessCallback_17(void * context, uint16_t enhancedCurrentHue)
    {
        (static_cast<Test_TC_CC_9_3Suite *>(context))->OnSuccessResponse_17(enhancedCurrentHue);
    }

    static void OnFailureCallback_19(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_CC_9_3Suite *>(context))->OnFailureResponse_19(error);
    }

    static void OnSuccessCallback_19(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_9_3Suite *>(context))->OnSuccessResponse_19(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestPreconditionTurnOnLightForColorControlTests_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_3Suite *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_9_3Suite *>(context))->OnFailureResponse_1(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestPreconditionCheckOnOffAttributeValueIsTrueAfterOnCommand_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 1));

        NextTest();
    }

    CHIP_ERROR TestSendsColorLoopSetCommandSetAllAttributes_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;

        RequestType request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(15);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 30U;
        request.startHue        = 160U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_3Suite *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_9_3Suite *>(context))->OnFailureResponse_3(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestReadColorLoopActiveAttributeFromDut_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopActive::TypeInfo>(
            this, OnSuccessCallback_4, OnFailureCallback_4, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_4(uint8_t colorLoopActive)
    {
        VerifyOrReturn(CheckValue("colorLoopActive", colorLoopActive, 0));

        NextTest();
    }

    CHIP_ERROR TestReadColorLoopDirectionAttributeFromDut_5()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopDirection::TypeInfo>(
            this, OnSuccessCallback_5, OnFailureCallback_5, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_5(uint8_t colorLoopDirection)
    {
        VerifyOrReturn(CheckValue("colorLoopDirection", colorLoopDirection, 0));

        NextTest();
    }

    CHIP_ERROR TestReadColorLoopTimeAttributeFromDut_6()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopTime::TypeInfo>(
            this, OnSuccessCallback_6, OnFailureCallback_6, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_6(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_6(uint16_t colorLoopTime)
    {
        VerifyOrReturn(CheckValue("colorLoopTime", colorLoopTime, 30U));

        NextTest();
    }

    CHIP_ERROR TestReadColorLoopStartEnhancedHueAttributeFromDut_7()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopStartEnhancedHue::TypeInfo>(
                this, OnSuccessCallback_7, OnFailureCallback_7, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_7(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_7(uint16_t colorLoopStartEnhancedHue)
    {
        VerifyOrReturn(CheckValue("colorLoopStartEnhancedHue", colorLoopStartEnhancedHue, 160U));

        NextTest();
    }

    CHIP_ERROR TestColorLoopSetCommandSetAllAttributes_8()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;

        RequestType request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(1);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(1);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 0U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_3Suite *>(context))->OnSuccessResponse_8();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_9_3Suite *>(context))->OnFailureResponse_8(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_8(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_8() { NextTest(); }

    CHIP_ERROR TestReadColorLoopActiveAttributeFromDut_9()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopActive::TypeInfo>(
            this, OnSuccessCallback_9, OnFailureCallback_9, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_9(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_9(uint8_t colorLoopActive)
    {
        VerifyOrReturn(CheckValue("colorLoopActive", colorLoopActive, 1));

        NextTest();
    }

    CHIP_ERROR TestReadEnhancedCurrentHueAttributeFromDut_10()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::EnhancedCurrentHue::TypeInfo>(
            this, OnSuccessCallback_10, OnFailureCallback_10, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_10(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_10(uint16_t enhancedCurrentHue)
    {
        VerifyOrReturn(CheckConstraintType("enhancedCurrentHue", "", "uint16"));
        EnhancedCurrentHueValue = enhancedCurrentHue;
        NextTest();
    }

    CHIP_ERROR TestReadColorLoopStoredEnhancedHueAttributeFromDut_11()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopStoredEnhancedHue::TypeInfo>(
                this, OnSuccessCallback_11, OnFailureCallback_11, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_11(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_11(uint16_t colorLoopStoredEnhancedHue)
    {
        VerifyOrReturn(CheckValue("colorLoopStoredEnhancedHue", colorLoopStoredEnhancedHue, EnhancedCurrentHueValue));

        NextTest();
    }

    CHIP_ERROR TestColorLoopSetCommandStartColorLoop_12()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;

        RequestType request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(4);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 60U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_3Suite *>(context))->OnSuccessResponse_12();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_9_3Suite *>(context))->OnFailureResponse_12(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_12(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_12() { NextTest(); }

    CHIP_ERROR TestReadColorLoopTimeAttributeFromDut_13()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopTime::TypeInfo>(
            this, OnSuccessCallback_13, OnFailureCallback_13, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_13(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_13(uint16_t colorLoopTime)
    {
        VerifyOrReturn(CheckValue("colorLoopTime", colorLoopTime, 60U));

        NextTest();
    }

    CHIP_ERROR TestColorLoopSetCommandStartColorLoop_14()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;

        RequestType request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(1);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 0U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_3Suite *>(context))->OnSuccessResponse_14();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_9_3Suite *>(context))->OnFailureResponse_14(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_14(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_14() { NextTest(); }

    CHIP_ERROR TestReadColorLoopActiveAttributeFromDut_15()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopActive::TypeInfo>(
            this, OnSuccessCallback_15, OnFailureCallback_15, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_15(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_15(uint8_t colorLoopActive)
    {
        VerifyOrReturn(CheckValue("colorLoopActive", colorLoopActive, 0));

        NextTest();
    }

    CHIP_ERROR TestReadColorLoopStoredEnhancedHueAttributeFromDut_16()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopStoredEnhancedHue::TypeInfo>(
                this, OnSuccessCallback_16, OnFailureCallback_16, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_16(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_16(uint16_t colorLoopStoredEnhancedHue)
    {
        VerifyOrReturn(CheckConstraintType("colorLoopStoredEnhancedHue", "", "uint16"));
        ColorLoopStoredEnhancedHueValue = colorLoopStoredEnhancedHue;
        NextTest();
    }

    CHIP_ERROR TestReadEnhancedCurrentHueAttributeFromDut_17()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::EnhancedCurrentHue::TypeInfo>(
            this, OnSuccessCallback_17, OnFailureCallback_17, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_17(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_17(uint16_t enhancedCurrentHue)
    {
        VerifyOrReturn(CheckValue("enhancedCurrentHue", enhancedCurrentHue, ColorLoopStoredEnhancedHueValue));

        NextTest();
    }

    CHIP_ERROR TestTurnOffLightForColorControlTests_18()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_3Suite *>(context))->OnSuccessResponse_18();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_CC_9_3Suite *>(context))->OnFailureResponse_18(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_18(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_18() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_19()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(
            this, OnSuccessCallback_19, OnFailureCallback_19, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_19(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_19(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 0));

        NextTest();
    }
};

class Test_TC_DM_1_1Suite : public TestCommand
{
public:
    Test_TC_DM_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_DM_1_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_DM_1_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_DM_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_DM_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Query Data Model Revision\n");
            err = TestQueryDataModelRevision_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Query Vendor Name\n");
            err = TestQueryVendorName_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Query VendorID\n");
            err = TestQueryVendorID_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Query Product Name\n");
            err = TestQueryProductName_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Query ProductID\n");
            err = TestQueryProductID_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Query Node Label\n");
            err = TestQueryNodeLabel_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Query User Location\n");
            err = TestQueryUserLocation_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Query HardwareVersion\n");
            err = TestQueryHardwareVersion_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Query HardwareVersionString\n");
            err = TestQueryHardwareVersionString_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Query SoftwareVersion\n");
            err = TestQuerySoftwareVersion_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : Query SoftwareVersionString\n");
            err = TestQuerySoftwareVersionString_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : Query ManufacturingDate\n");
            if (ShouldSkip("MANF_DATE"))
            {
                NextTest();
                return;
            }
            err = TestQueryManufacturingDate_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : Query PartNumber\n");
            if (ShouldSkip("PART_NUM"))
            {
                NextTest();
                return;
            }
            err = TestQueryPartNumber_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : Query ProductURL\n");
            err = TestQueryProductURL_14();
            break;
        case 15:
            ChipLogProgress(chipTool, " ***** Test Step 15 : Query ProductLabel\n");
            err = TestQueryProductLabel_15();
            break;
        case 16:
            ChipLogProgress(chipTool, " ***** Test Step 16 : Query SerialNumber\n");
            err = TestQuerySerialNumber_16();
            break;
        case 17:
            ChipLogProgress(chipTool, " ***** Test Step 17 : Query LocalConfigDisabled\n");
            err = TestQueryLocalConfigDisabled_17();
            break;
        case 18:
            ChipLogProgress(chipTool, " ***** Test Step 18 : Query Reachable\n");
            err = TestQueryReachable_18();
            break;
        case 19:
            ChipLogProgress(chipTool, " ***** Test Step 19 : Query UniqueID\n");
            err = TestQueryUniqueID_19();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 20;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_1(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_DM_1_1Suite *>(context))->OnFailureResponse_1(error);
    }

    static void OnSuccessCallback_1(void * context, uint16_t dataModelRevision)
    {
        (static_cast<Test_TC_DM_1_1Suite *>(context))->OnSuccessResponse_1(dataModelRevision);
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_DM_1_1Suite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context, chip::CharSpan vendorName)
    {
        (static_cast<Test_TC_DM_1_1Suite *>(context))->OnSuccessResponse_2(vendorName);
    }

    static void OnFailureCallback_3(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_DM_1_1Suite *>(context))->OnFailureResponse_3(error);
    }

    static void OnSuccessCallback_3(void * context, chip::VendorId vendorID)
    {
        (static_cast<Test_TC_DM_1_1Suite *>(context))->OnSuccessResponse_3(vendorID);
    }

    static void OnFailureCallback_4(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_DM_1_1Suite *>(context))->OnFailureResponse_4(error);
    }

    static void OnSuccessCallback_4(void * context, chip::CharSpan productName)
    {
        (static_cast<Test_TC_DM_1_1Suite *>(context))->OnSuccessResponse_4(productName);
    }

    static void OnFailureCallback_5(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_DM_1_1Suite *>(context))->OnFailureResponse_5(error);
    }

    static void OnSuccessCallback_5(void * context, uint16_t productID)
    {
        (static_cast<Test_TC_DM_1_1Suite *>(context))->OnSuccessResponse_5(productID);
    }

    static void OnFailureCallback_6(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_DM_1_1Suite *>(context))->OnFailureResponse_6(error);
    }

    static void OnSuccessCallback_6(void * context, chip::CharSpan nodeLabel)
    {
        (static_cast<Test_TC_DM_1_1Suite *>(context))->OnSuccessResponse_6(nodeLabel);
    }

    static void OnFailureCallback_7(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_DM_1_1Suite *>(context))->OnFailureResponse_7(error);
    }

    static void OnSuccessCallback_7(void * context, chip::CharSpan location)
    {
        (static_cast<Test_TC_DM_1_1Suite *>(context))->OnSuccessResponse_7(location);
    }

    static void OnFailureCallback_8(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_DM_1_1Suite *>(context))->OnFailureResponse_8(error);
    }

    static void OnSuccessCallback_8(void * context, uint16_t hardwareVersion)
    {
        (static_cast<Test_TC_DM_1_1Suite *>(context))->OnSuccessResponse_8(hardwareVersion);
    }

    static void OnFailureCallback_9(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_DM_1_1Suite *>(context))->OnFailureResponse_9(error);
    }

    static void OnSuccessCallback_9(void * context, chip::CharSpan hardwareVersionString)
    {
        (static_cast<Test_TC_DM_1_1Suite *>(context))->OnSuccessResponse_9(hardwareVersionString);
    }

    static void OnFailureCallback_10(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_DM_1_1Suite *>(context))->OnFailureResponse_10(error);
    }

    static void OnSuccessCallback_10(void * context, uint32_t softwareVersion)
    {
        (static_cast<Test_TC_DM_1_1Suite *>(context))->OnSuccessResponse_10(softwareVersion);
    }

    static void OnFailureCallback_11(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_DM_1_1Suite *>(context))->OnFailureResponse_11(error);
    }

    static void OnSuccessCallback_11(void * context, chip::CharSpan softwareVersionString)
    {
        (static_cast<Test_TC_DM_1_1Suite *>(context))->OnSuccessResponse_11(softwareVersionString);
    }

    static void OnFailureCallback_12(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_DM_1_1Suite *>(context))->OnFailureResponse_12(error);
    }

    static void OnSuccessCallback_12(void * context, chip::CharSpan manufacturingDate)
    {
        (static_cast<Test_TC_DM_1_1Suite *>(context))->OnSuccessResponse_12(manufacturingDate);
    }

    static void OnFailureCallback_13(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_DM_1_1Suite *>(context))->OnFailureResponse_13(error);
    }

    static void OnSuccessCallback_13(void * context, chip::CharSpan partNumber)
    {
        (static_cast<Test_TC_DM_1_1Suite *>(context))->OnSuccessResponse_13(partNumber);
    }

    static void OnFailureCallback_14(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_DM_1_1Suite *>(context))->OnFailureResponse_14(error);
    }

    static void OnSuccessCallback_14(void * context, chip::CharSpan productURL)
    {
        (static_cast<Test_TC_DM_1_1Suite *>(context))->OnSuccessResponse_14(productURL);
    }

    static void OnFailureCallback_15(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_DM_1_1Suite *>(context))->OnFailureResponse_15(error);
    }

    static void OnSuccessCallback_15(void * context, chip::CharSpan productLabel)
    {
        (static_cast<Test_TC_DM_1_1Suite *>(context))->OnSuccessResponse_15(productLabel);
    }

    static void OnFailureCallback_16(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_DM_1_1Suite *>(context))->OnFailureResponse_16(error);
    }

    static void OnSuccessCallback_16(void * context, chip::CharSpan serialNumber)
    {
        (static_cast<Test_TC_DM_1_1Suite *>(context))->OnSuccessResponse_16(serialNumber);
    }

    static void OnFailureCallback_17(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_DM_1_1Suite *>(context))->OnFailureResponse_17(error);
    }

    static void OnSuccessCallback_17(void * context, bool localConfigDisabled)
    {
        (static_cast<Test_TC_DM_1_1Suite *>(context))->OnSuccessResponse_17(localConfigDisabled);
    }

    static void OnFailureCallback_18(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_DM_1_1Suite *>(context))->OnFailureResponse_18(error);
    }

    static void OnSuccessCallback_18(void * context, bool reachable)
    {
        (static_cast<Test_TC_DM_1_1Suite *>(context))->OnSuccessResponse_18(reachable);
    }

    static void OnFailureCallback_19(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_DM_1_1Suite *>(context))->OnFailureResponse_19(error);
    }

    static void OnSuccessCallback_19(void * context, chip::CharSpan uniqueID)
    {
        (static_cast<Test_TC_DM_1_1Suite *>(context))->OnSuccessResponse_19(uniqueID);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestQueryDataModelRevision_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Basic::Attributes::DataModelRevision::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1(uint16_t dataModelRevision)
    {
        VerifyOrReturn(CheckConstraintType("dataModelRevision", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestQueryVendorName_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Basic::Attributes::VendorName::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2(chip::CharSpan vendorName)
    {
        VerifyOrReturn(CheckConstraintType("vendorName", "", "string"));
        VerifyOrReturn(CheckConstraintMaxLength("vendorName", vendorName.size(), 32));
        NextTest();
    }

    CHIP_ERROR TestQueryVendorID_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Basic::Attributes::VendorID::TypeInfo>(
            this, OnSuccessCallback_3, OnFailureCallback_3, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3(chip::VendorId vendorID)
    {
        VerifyOrReturn(CheckConstraintType("vendorID", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestQueryProductName_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Basic::Attributes::ProductName::TypeInfo>(
            this, OnSuccessCallback_4, OnFailureCallback_4, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_4(chip::CharSpan productName)
    {
        VerifyOrReturn(CheckConstraintType("productName", "", "string"));
        VerifyOrReturn(CheckConstraintMaxLength("productName", productName.size(), 32));
        NextTest();
    }

    CHIP_ERROR TestQueryProductID_5()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Basic::Attributes::ProductID::TypeInfo>(
            this, OnSuccessCallback_5, OnFailureCallback_5, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_5(uint16_t productID)
    {
        VerifyOrReturn(CheckConstraintType("productID", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestQueryNodeLabel_6()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Basic::Attributes::NodeLabel::TypeInfo>(
            this, OnSuccessCallback_6, OnFailureCallback_6, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_6(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_6(chip::CharSpan nodeLabel)
    {
        VerifyOrReturn(CheckConstraintType("nodeLabel", "", "string"));
        VerifyOrReturn(CheckConstraintMaxLength("nodeLabel", nodeLabel.size(), 32));
        NextTest();
    }

    CHIP_ERROR TestQueryUserLocation_7()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Basic::Attributes::Location::TypeInfo>(
            this, OnSuccessCallback_7, OnFailureCallback_7, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_7(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_7(chip::CharSpan location)
    {
        VerifyOrReturn(CheckConstraintType("location", "", "string"));
        VerifyOrReturn(CheckConstraintFormat("location", "", "ISO 3166-1 alpha-2"));
        VerifyOrReturn(CheckConstraintMaxLength("location", location.size(), 2));
        NextTest();
    }

    CHIP_ERROR TestQueryHardwareVersion_8()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Basic::Attributes::HardwareVersion::TypeInfo>(
            this, OnSuccessCallback_8, OnFailureCallback_8, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_8(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_8(uint16_t hardwareVersion)
    {
        VerifyOrReturn(CheckConstraintType("hardwareVersion", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestQueryHardwareVersionString_9()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Basic::Attributes::HardwareVersionString::TypeInfo>(
            this, OnSuccessCallback_9, OnFailureCallback_9, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_9(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_9(chip::CharSpan hardwareVersionString)
    {
        VerifyOrReturn(CheckConstraintType("hardwareVersionString", "", "string"));
        VerifyOrReturn(CheckConstraintMinLength("hardwareVersionString", hardwareVersionString.size(), 1));
        VerifyOrReturn(CheckConstraintMaxLength("hardwareVersionString", hardwareVersionString.size(), 64));
        NextTest();
    }

    CHIP_ERROR TestQuerySoftwareVersion_10()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Basic::Attributes::SoftwareVersion::TypeInfo>(
            this, OnSuccessCallback_10, OnFailureCallback_10, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_10(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_10(uint32_t softwareVersion)
    {
        VerifyOrReturn(CheckConstraintType("softwareVersion", "", "uint32"));
        NextTest();
    }

    CHIP_ERROR TestQuerySoftwareVersionString_11()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Basic::Attributes::SoftwareVersionString::TypeInfo>(
            this, OnSuccessCallback_11, OnFailureCallback_11, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_11(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_11(chip::CharSpan softwareVersionString)
    {
        VerifyOrReturn(CheckConstraintType("softwareVersionString", "", "string"));
        VerifyOrReturn(CheckConstraintFormat("softwareVersionString", "", "ASCII"));
        VerifyOrReturn(CheckConstraintMinLength("softwareVersionString", softwareVersionString.size(), 1));
        VerifyOrReturn(CheckConstraintMaxLength("softwareVersionString", softwareVersionString.size(), 64));
        NextTest();
    }

    CHIP_ERROR TestQueryManufacturingDate_12()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Basic::Attributes::ManufacturingDate::TypeInfo>(
            this, OnSuccessCallback_12, OnFailureCallback_12, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_12(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_12(chip::CharSpan manufacturingDate)
    {
        VerifyOrReturn(CheckConstraintType("manufacturingDate", "", "string"));
        VerifyOrReturn(CheckConstraintFormat("manufacturingDate", "", "ISO 8601"));
        VerifyOrReturn(CheckConstraintMinLength("manufacturingDate", manufacturingDate.size(), 8));
        VerifyOrReturn(CheckConstraintMaxLength("manufacturingDate", manufacturingDate.size(), 16));
        NextTest();
    }

    CHIP_ERROR TestQueryPartNumber_13()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Basic::Attributes::PartNumber::TypeInfo>(
            this, OnSuccessCallback_13, OnFailureCallback_13, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_13(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_13(chip::CharSpan partNumber)
    {
        VerifyOrReturn(CheckConstraintType("partNumber", "", "string"));
        VerifyOrReturn(CheckConstraintMaxLength("partNumber", partNumber.size(), 32));
        NextTest();
    }

    CHIP_ERROR TestQueryProductURL_14()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Basic::Attributes::ProductURL::TypeInfo>(
            this, OnSuccessCallback_14, OnFailureCallback_14, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_14(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_14(chip::CharSpan productURL)
    {
        VerifyOrReturn(CheckConstraintType("productURL", "", "string"));
        VerifyOrReturn(CheckConstraintFormat("productURL", "", "RFC3986"));
        VerifyOrReturn(CheckConstraintMaxLength("productURL", productURL.size(), 256));
        NextTest();
    }

    CHIP_ERROR TestQueryProductLabel_15()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Basic::Attributes::ProductLabel::TypeInfo>(
            this, OnSuccessCallback_15, OnFailureCallback_15, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_15(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_15(chip::CharSpan productLabel)
    {
        VerifyOrReturn(CheckConstraintType("productLabel", "", "string"));
        VerifyOrReturn(CheckConstraintMaxLength("productLabel", productLabel.size(), 64));
        NextTest();
    }

    CHIP_ERROR TestQuerySerialNumber_16()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Basic::Attributes::SerialNumber::TypeInfo>(
            this, OnSuccessCallback_16, OnFailureCallback_16, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_16(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_16(chip::CharSpan serialNumber)
    {
        VerifyOrReturn(CheckConstraintType("serialNumber", "", "string"));
        VerifyOrReturn(CheckConstraintMaxLength("serialNumber", serialNumber.size(), 32));
        NextTest();
    }

    CHIP_ERROR TestQueryLocalConfigDisabled_17()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Basic::Attributes::LocalConfigDisabled::TypeInfo>(
            this, OnSuccessCallback_17, OnFailureCallback_17, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_17(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_17(bool localConfigDisabled)
    {
        VerifyOrReturn(CheckConstraintType("localConfigDisabled", "", "boolean"));
        NextTest();
    }

    CHIP_ERROR TestQueryReachable_18()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Basic::Attributes::Reachable::TypeInfo>(
            this, OnSuccessCallback_18, OnFailureCallback_18, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_18(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_18(bool reachable)
    {
        VerifyOrReturn(CheckConstraintType("reachable", "", "boolean"));
        NextTest();
    }

    CHIP_ERROR TestQueryUniqueID_19()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Basic::Attributes::UniqueID::TypeInfo>(
            this, OnSuccessCallback_19, OnFailureCallback_19, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_19(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_19(chip::CharSpan uniqueID)
    {
        VerifyOrReturn(CheckConstraintType("uniqueID", "", "string"));
        VerifyOrReturn(CheckConstraintMaxLength("uniqueID", uniqueID.size(), 32));
        NextTest();
    }
};

class Test_TC_DM_3_1Suite : public TestCommand
{
public:
    Test_TC_DM_3_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_DM_3_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_DM_3_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_DM_3_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_DM_3_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Query MaxNetworks\n");
            err = TestQueryMaxNetworks_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Query Networks\n");
            err = TestQueryNetworks_2();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 3;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_1(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_DM_3_1Suite *>(context))->OnFailureResponse_1(error);
    }

    static void OnSuccessCallback_1(void * context, uint8_t maxNetworks)
    {
        (static_cast<Test_TC_DM_3_1Suite *>(context))->OnSuccessResponse_1(maxNetworks);
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_DM_3_1Suite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(
        void * context,
        const chip::app::DataModel::DecodableList<chip::app::Clusters::NetworkCommissioning::Structs::NetworkInfo::DecodableType> &
            networks)
    {
        (static_cast<Test_TC_DM_3_1Suite *>(context))->OnSuccessResponse_2(networks);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestQueryMaxNetworks_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        chip::Controller::NetworkCommissioningClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::NetworkCommissioning::Attributes::MaxNetworks::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_1(uint8_t maxNetworks)
    {
        VerifyOrReturn(CheckConstraintType("maxNetworks", "", "uint8"));
        NextTest();
    }

    CHIP_ERROR TestQueryNetworks_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        chip::Controller::NetworkCommissioningClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::NetworkCommissioning::Attributes::Networks::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_2(
        const chip::app::DataModel::DecodableList<chip::app::Clusters::NetworkCommissioning::Structs::NetworkInfo::DecodableType> &
            networks)
    {
        VerifyOrReturn(CheckConstraintType("networks", "", "list"));
        NextTest();
    }
};

class Test_TC_DM_2_2Suite : public TestCommand
{
public:
    Test_TC_DM_2_2Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_DM_2_2", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_DM_2_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_DM_2_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_DM_2_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Query fabrics list\n");
            err = TestQueryFabricsList_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Query Supported Fabrics\n");
            err = TestQuerySupportedFabrics_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Query Commissioned Fabrics\n");
            err = TestQueryCommissionedFabrics_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Query User Trusted Root Certificates\n");
            err = TestQueryUserTrustedRootCertificates_4();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 5;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_1(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_DM_2_2Suite *>(context))->OnFailureResponse_1(error);
    }

    static void
    OnSuccessCallback_1(void * context,
                        const chip::app::DataModel::DecodableList<
                            chip::app::Clusters::OperationalCredentials::Structs::FabricDescriptor::DecodableType> & fabrics)
    {
        (static_cast<Test_TC_DM_2_2Suite *>(context))->OnSuccessResponse_1(fabrics);
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_DM_2_2Suite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context, uint8_t supportedFabrics)
    {
        (static_cast<Test_TC_DM_2_2Suite *>(context))->OnSuccessResponse_2(supportedFabrics);
    }

    static void OnFailureCallback_3(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_DM_2_2Suite *>(context))->OnFailureResponse_3(error);
    }

    static void OnSuccessCallback_3(void * context, uint8_t commissionedFabrics)
    {
        (static_cast<Test_TC_DM_2_2Suite *>(context))->OnSuccessResponse_3(commissionedFabrics);
    }

    static void OnFailureCallback_4(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_DM_2_2Suite *>(context))->OnFailureResponse_4(error);
    }

    static void OnSuccessCallback_4(void * context,
                                    const chip::app::DataModel::DecodableList<chip::ByteSpan> & trustedRootCertificates)
    {
        (static_cast<Test_TC_DM_2_2Suite *>(context))->OnSuccessResponse_4(trustedRootCertificates);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestQueryFabricsList_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        chip::Controller::OperationalCredentialsClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OperationalCredentials::Attributes::Fabrics::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1(const chip::app::DataModel::DecodableList<
                             chip::app::Clusters::OperationalCredentials::Structs::FabricDescriptor::DecodableType> & fabrics)
    {
        {
            auto iter_0 = fabrics.begin();
            VerifyOrReturn(CheckNextListItemDecodes<decltype(fabrics)>("fabrics", iter_0, 0));
            VerifyOrReturn(CheckValueAsString("fabrics[0].label", iter_0.GetValue().label, chip::CharSpan("", 0)));
            VerifyOrReturn(CheckNoMoreListItems<decltype(fabrics)>("fabrics", iter_0, 1));
        }
        VerifyOrReturn(CheckConstraintType("fabrics", "", "list"));
        NextTest();
    }

    CHIP_ERROR TestQuerySupportedFabrics_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        chip::Controller::OperationalCredentialsClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::OperationalCredentials::Attributes::SupportedFabrics::TypeInfo>(
                this, OnSuccessCallback_2, OnFailureCallback_2, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2(uint8_t supportedFabrics)
    {
        VerifyOrReturn(CheckValue("supportedFabrics", supportedFabrics, 16));
        VerifyOrReturn(CheckConstraintType("supportedFabrics", "", "uint8"));
        NextTest();
    }

    CHIP_ERROR TestQueryCommissionedFabrics_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        chip::Controller::OperationalCredentialsClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::OperationalCredentials::Attributes::CommissionedFabrics::TypeInfo>(
                this, OnSuccessCallback_3, OnFailureCallback_3, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3(uint8_t commissionedFabrics)
    {
        VerifyOrReturn(CheckValue("commissionedFabrics", commissionedFabrics, 1));
        VerifyOrReturn(CheckConstraintType("commissionedFabrics", "", "uint8"));
        NextTest();
    }

    CHIP_ERROR TestQueryUserTrustedRootCertificates_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        chip::Controller::OperationalCredentialsClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::OperationalCredentials::Attributes::TrustedRootCertificates::TypeInfo>(
                this, OnSuccessCallback_4, OnFailureCallback_4, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_4(const chip::app::DataModel::DecodableList<chip::ByteSpan> & trustedRootCertificates)
    {
        VerifyOrReturn(CheckConstraintType("trustedRootCertificates", "", "list"));
        NextTest();
    }
};

class Test_TC_EMR_1_1Suite : public TestCommand
{
public:
    Test_TC_EMR_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_EMR_1_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_EMR_1_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_EMR_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_EMR_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : read the global attribute: ClusterRevision\n");
            err = TestReadTheGlobalAttributeClusterRevision_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read the global attribute constraints: ClusterRevision\n");
            err = TestReadTheGlobalAttributeConstraintsClusterRevision_2();
            break;
        case 3:
            ChipLogProgress(chipTool,
                            " ***** Test Step 3 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : reads back global attribute: ClusterRevision\n");
            err = TestReadsBackGlobalAttributeClusterRevision_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Read the global attribute: AttributeList\n");
            err = TestReadTheGlobalAttributeAttributeList_5();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 6;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_1(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_EMR_1_1Suite *>(context))->OnFailureResponse_1(error);
    }

    static void OnSuccessCallback_1(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_EMR_1_1Suite *>(context))->OnSuccessResponse_1(clusterRevision);
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_EMR_1_1Suite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_EMR_1_1Suite *>(context))->OnSuccessResponse_2(clusterRevision);
    }

    static void OnFailureCallback_3(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_EMR_1_1Suite *>(context))->OnFailureResponse_3(error);
    }

    static void OnSuccessCallback_3(void * context) { (static_cast<Test_TC_EMR_1_1Suite *>(context))->OnSuccessResponse_3(); }

    static void OnFailureCallback_4(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_EMR_1_1Suite *>(context))->OnFailureResponse_4(error);
    }

    static void OnSuccessCallback_4(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_EMR_1_1Suite *>(context))->OnSuccessResponse_4(clusterRevision);
    }

    static void OnFailureCallback_5(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_EMR_1_1Suite *>(context))->OnFailureResponse_5(error);
    }

    static void OnSuccessCallback_5(void * context, const chip::app::DataModel::DecodableList<chip::AttributeId> & attributeList)
    {
        (static_cast<Test_TC_EMR_1_1Suite *>(context))->OnSuccessResponse_5(attributeList);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestReadTheGlobalAttributeClusterRevision_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ElectricalMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::ElectricalMeasurement::Attributes::ClusterRevision::TypeInfo>(
                this, OnSuccessCallback_1, OnFailureCallback_1, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckValue("clusterRevision", clusterRevision, 3U));

        NextTest();
    }

    CHIP_ERROR TestReadTheGlobalAttributeConstraintsClusterRevision_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ElectricalMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::ElectricalMeasurement::Attributes::ClusterRevision::TypeInfo>(
                this, OnSuccessCallback_2, OnFailureCallback_2, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckConstraintType("clusterRevision", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ElectricalMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t clusterRevisionArgument;
        clusterRevisionArgument = 1U;

        ReturnErrorOnFailure(
            cluster.WriteAttribute<chip::app::Clusters::ElectricalMeasurement::Attributes::ClusterRevision::TypeInfo>(
                clusterRevisionArgument, this, OnSuccessCallback_3, OnFailureCallback_3));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_3() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackGlobalAttributeClusterRevision_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ElectricalMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::ElectricalMeasurement::Attributes::ClusterRevision::TypeInfo>(
                this, OnSuccessCallback_4, OnFailureCallback_4, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_4(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckValue("clusterRevision", clusterRevision, 3U));

        NextTest();
    }

    CHIP_ERROR TestReadTheGlobalAttributeAttributeList_5()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ElectricalMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ElectricalMeasurement::Attributes::AttributeList::TypeInfo>(
            this, OnSuccessCallback_5, OnFailureCallback_5, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_5(const chip::app::DataModel::DecodableList<chip::AttributeId> & attributeList)
    {
        VerifyOrReturn(CheckConstraintType("attributeList", "", "list"));
        NextTest();
    }
};

class Test_TC_ETHDIAG_1_1Suite : public TestCommand
{
public:
    Test_TC_ETHDIAG_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_ETHDIAG_1_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_ETHDIAG_1_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_ETHDIAG_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_ETHDIAG_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }
};

class Test_TC_ETHDIAG_2_1Suite : public TestCommand
{
public:
    Test_TC_ETHDIAG_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_ETHDIAG_2_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_ETHDIAG_2_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_ETHDIAG_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_ETHDIAG_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }
};

class Test_TC_FLW_1_1Suite : public TestCommand
{
public:
    Test_TC_FLW_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_FLW_1_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_FLW_1_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_FLW_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_FLW_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read the global attribute constraints: ClusterRevision\n");
            err = TestReadTheGlobalAttributeConstraintsClusterRevision_1();
            break;
        case 2:
            ChipLogProgress(chipTool,
                            " ***** Test Step 2 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read the global attribute: AttributeList\n");
            err = TestReadTheGlobalAttributeAttributeList_3();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 4;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_1(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_FLW_1_1Suite *>(context))->OnFailureResponse_1(error);
    }

    static void OnSuccessCallback_1(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_FLW_1_1Suite *>(context))->OnSuccessResponse_1(clusterRevision);
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_FLW_1_1Suite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context) { (static_cast<Test_TC_FLW_1_1Suite *>(context))->OnSuccessResponse_2(); }

    static void OnFailureCallback_3(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_FLW_1_1Suite *>(context))->OnFailureResponse_3(error);
    }

    static void OnSuccessCallback_3(void * context, const chip::app::DataModel::DecodableList<chip::AttributeId> & attributeList)
    {
        (static_cast<Test_TC_FLW_1_1Suite *>(context))->OnSuccessResponse_3(attributeList);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestReadTheGlobalAttributeConstraintsClusterRevision_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::FlowMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::FlowMeasurement::Attributes::ClusterRevision::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckConstraintType("clusterRevision", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::FlowMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t clusterRevisionArgument;
        clusterRevisionArgument = 2U;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::FlowMeasurement::Attributes::ClusterRevision::TypeInfo>(
            clusterRevisionArgument, this, OnSuccessCallback_2, OnFailureCallback_2));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_2() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadTheGlobalAttributeAttributeList_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::FlowMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::FlowMeasurement::Attributes::AttributeList::TypeInfo>(
            this, OnSuccessCallback_3, OnFailureCallback_3, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3(const chip::app::DataModel::DecodableList<chip::AttributeId> & attributeList)
    {
        VerifyOrReturn(CheckConstraintType("attributeList", "", "list"));
        NextTest();
    }
};

class Test_TC_FLW_2_1Suite : public TestCommand
{
public:
    Test_TC_FLW_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_FLW_2_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_FLW_2_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_FLW_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_FLW_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : read the mandatory attribute: MeasuredValue\n");
            err = TestReadTheMandatoryAttributeMeasuredValue_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : read the mandatory attribute: MinMeasuredValue\n");
            err = TestReadTheMandatoryAttributeMinMeasuredValue_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : read the mandatory attribute: MaxMeasuredValue\n");
            err = TestReadTheMandatoryAttributeMaxMeasuredValue_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : write the default value to optional attribute: MeasuredValue\n");
            err = TestWriteTheDefaultValueToOptionalAttributeMeasuredValue_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : write the default value to optional attribute: MinMeasuredValue\n");
            err = TestWriteTheDefaultValueToOptionalAttributeMinMeasuredValue_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : write the default value to optional attribute: MaxMeasuredValue\n");
            err = TestWriteTheDefaultValueToOptionalAttributeMaxMeasuredValue_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : read the mandatory attribute: MeasuredValue\n");
            err = TestReadTheMandatoryAttributeMeasuredValue_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : read the mandatory attribute: MinMeasuredValue\n");
            err = TestReadTheMandatoryAttributeMinMeasuredValue_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : read the mandatory attribute: MaxMeasuredValue\n");
            err = TestReadTheMandatoryAttributeMaxMeasuredValue_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : read the optional attribute: Tolerance\n");
            err = TestReadTheOptionalAttributeTolerance_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : read the optional attribute: Tolerance\n");
            err = TestReadTheOptionalAttributeTolerance_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : write the default value to optional attribute: Tolerance\n");
            err = TestWriteTheDefaultValueToOptionalAttributeTolerance_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : read the optional attribute: Tolerance\n");
            err = TestReadTheOptionalAttributeTolerance_13();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 14;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_1(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_FLW_2_1Suite *>(context))->OnFailureResponse_1(error);
    }

    static void OnSuccessCallback_1(void * context, const chip::app::DataModel::Nullable<uint16_t> & measuredValue)
    {
        (static_cast<Test_TC_FLW_2_1Suite *>(context))->OnSuccessResponse_1(measuredValue);
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_FLW_2_1Suite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context, const chip::app::DataModel::Nullable<uint16_t> & minMeasuredValue)
    {
        (static_cast<Test_TC_FLW_2_1Suite *>(context))->OnSuccessResponse_2(minMeasuredValue);
    }

    static void OnFailureCallback_3(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_FLW_2_1Suite *>(context))->OnFailureResponse_3(error);
    }

    static void OnSuccessCallback_3(void * context, const chip::app::DataModel::Nullable<uint16_t> & maxMeasuredValue)
    {
        (static_cast<Test_TC_FLW_2_1Suite *>(context))->OnSuccessResponse_3(maxMeasuredValue);
    }

    static void OnFailureCallback_4(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_FLW_2_1Suite *>(context))->OnFailureResponse_4(error);
    }

    static void OnSuccessCallback_4(void * context) { (static_cast<Test_TC_FLW_2_1Suite *>(context))->OnSuccessResponse_4(); }

    static void OnFailureCallback_5(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_FLW_2_1Suite *>(context))->OnFailureResponse_5(error);
    }

    static void OnSuccessCallback_5(void * context) { (static_cast<Test_TC_FLW_2_1Suite *>(context))->OnSuccessResponse_5(); }

    static void OnFailureCallback_6(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_FLW_2_1Suite *>(context))->OnFailureResponse_6(error);
    }

    static void OnSuccessCallback_6(void * context) { (static_cast<Test_TC_FLW_2_1Suite *>(context))->OnSuccessResponse_6(); }

    static void OnFailureCallback_7(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_FLW_2_1Suite *>(context))->OnFailureResponse_7(error);
    }

    static void OnSuccessCallback_7(void * context, const chip::app::DataModel::Nullable<uint16_t> & measuredValue)
    {
        (static_cast<Test_TC_FLW_2_1Suite *>(context))->OnSuccessResponse_7(measuredValue);
    }

    static void OnFailureCallback_8(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_FLW_2_1Suite *>(context))->OnFailureResponse_8(error);
    }

    static void OnSuccessCallback_8(void * context, const chip::app::DataModel::Nullable<uint16_t> & minMeasuredValue)
    {
        (static_cast<Test_TC_FLW_2_1Suite *>(context))->OnSuccessResponse_8(minMeasuredValue);
    }

    static void OnFailureCallback_9(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_FLW_2_1Suite *>(context))->OnFailureResponse_9(error);
    }

    static void OnSuccessCallback_9(void * context, const chip::app::DataModel::Nullable<uint16_t> & maxMeasuredValue)
    {
        (static_cast<Test_TC_FLW_2_1Suite *>(context))->OnSuccessResponse_9(maxMeasuredValue);
    }

    static void OnFailureCallback_10(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_FLW_2_1Suite *>(context))->OnFailureResponse_10(error);
    }

    static void OnSuccessCallback_10(void * context, uint16_t tolerance)
    {
        (static_cast<Test_TC_FLW_2_1Suite *>(context))->OnSuccessResponse_10(tolerance);
    }

    static void OnFailureCallback_11(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_FLW_2_1Suite *>(context))->OnFailureResponse_11(error);
    }

    static void OnSuccessCallback_11(void * context, uint16_t tolerance)
    {
        (static_cast<Test_TC_FLW_2_1Suite *>(context))->OnSuccessResponse_11(tolerance);
    }

    static void OnFailureCallback_12(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_FLW_2_1Suite *>(context))->OnFailureResponse_12(error);
    }

    static void OnSuccessCallback_12(void * context) { (static_cast<Test_TC_FLW_2_1Suite *>(context))->OnSuccessResponse_12(); }

    static void OnFailureCallback_13(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_FLW_2_1Suite *>(context))->OnFailureResponse_13(error);
    }

    static void OnSuccessCallback_13(void * context, uint16_t tolerance)
    {
        (static_cast<Test_TC_FLW_2_1Suite *>(context))->OnSuccessResponse_13(tolerance);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestReadTheMandatoryAttributeMeasuredValue_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::FlowMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::FlowMeasurement::Attributes::MeasuredValue::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1(const chip::app::DataModel::Nullable<uint16_t> & measuredValue)
    {
        VerifyOrReturn(CheckConstraintType("measuredValue", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeMinMeasuredValue_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::FlowMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::FlowMeasurement::Attributes::MinMeasuredValue::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2(const chip::app::DataModel::Nullable<uint16_t> & minMeasuredValue)
    {
        VerifyOrReturn(CheckConstraintType("minMeasuredValue", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeMaxMeasuredValue_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::FlowMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::FlowMeasurement::Attributes::MaxMeasuredValue::TypeInfo>(
            this, OnSuccessCallback_3, OnFailureCallback_3, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3(const chip::app::DataModel::Nullable<uint16_t> & maxMeasuredValue)
    {
        VerifyOrReturn(CheckConstraintType("maxMeasuredValue", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValueToOptionalAttributeMeasuredValue_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::FlowMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint16_t> measuredValueArgument;
        measuredValueArgument.SetNonNull();
        measuredValueArgument.Value() = 0U;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::FlowMeasurement::Attributes::MeasuredValue::TypeInfo>(
            measuredValueArgument, this, OnSuccessCallback_4, OnFailureCallback_4));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_4() { ThrowSuccessResponse(); }

    CHIP_ERROR TestWriteTheDefaultValueToOptionalAttributeMinMeasuredValue_5()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::FlowMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint16_t> minMeasuredValueArgument;
        minMeasuredValueArgument.SetNonNull();
        minMeasuredValueArgument.Value() = 0U;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::FlowMeasurement::Attributes::MinMeasuredValue::TypeInfo>(
            minMeasuredValueArgument, this, OnSuccessCallback_5, OnFailureCallback_5));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_5() { ThrowSuccessResponse(); }

    CHIP_ERROR TestWriteTheDefaultValueToOptionalAttributeMaxMeasuredValue_6()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::FlowMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint16_t> maxMeasuredValueArgument;
        maxMeasuredValueArgument.SetNonNull();
        maxMeasuredValueArgument.Value() = 0U;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::FlowMeasurement::Attributes::MaxMeasuredValue::TypeInfo>(
            maxMeasuredValueArgument, this, OnSuccessCallback_6, OnFailureCallback_6));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_6(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_6() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadTheMandatoryAttributeMeasuredValue_7()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::FlowMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::FlowMeasurement::Attributes::MeasuredValue::TypeInfo>(
            this, OnSuccessCallback_7, OnFailureCallback_7, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_7(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_7(const chip::app::DataModel::Nullable<uint16_t> & measuredValue)
    {
        VerifyOrReturn(CheckConstraintType("measuredValue", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeMinMeasuredValue_8()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::FlowMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::FlowMeasurement::Attributes::MinMeasuredValue::TypeInfo>(
            this, OnSuccessCallback_8, OnFailureCallback_8, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_8(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_8(const chip::app::DataModel::Nullable<uint16_t> & minMeasuredValue)
    {
        VerifyOrReturn(CheckConstraintType("minMeasuredValue", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeMaxMeasuredValue_9()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::FlowMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::FlowMeasurement::Attributes::MaxMeasuredValue::TypeInfo>(
            this, OnSuccessCallback_9, OnFailureCallback_9, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_9(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_9(const chip::app::DataModel::Nullable<uint16_t> & maxMeasuredValue)
    {
        VerifyOrReturn(CheckConstraintType("maxMeasuredValue", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeTolerance_10()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::FlowMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::FlowMeasurement::Attributes::Tolerance::TypeInfo>(
            this, OnSuccessCallback_10, OnFailureCallback_10, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_10(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_10(uint16_t tolerance)
    {
        VerifyOrReturn(CheckValue("tolerance", tolerance, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeTolerance_11()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::FlowMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::FlowMeasurement::Attributes::Tolerance::TypeInfo>(
            this, OnSuccessCallback_11, OnFailureCallback_11, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_11(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_11(uint16_t tolerance)
    {
        VerifyOrReturn(CheckConstraintType("tolerance", "", "uint16"));
        VerifyOrReturn(CheckConstraintMinValue<uint16_t>("tolerance", tolerance, 0U));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("tolerance", tolerance, 2048U));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValueToOptionalAttributeTolerance_12()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::FlowMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t toleranceArgument;
        toleranceArgument = 0U;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::FlowMeasurement::Attributes::Tolerance::TypeInfo>(
            toleranceArgument, this, OnSuccessCallback_12, OnFailureCallback_12));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_12(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_12() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadTheOptionalAttributeTolerance_13()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::FlowMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::FlowMeasurement::Attributes::Tolerance::TypeInfo>(
            this, OnSuccessCallback_13, OnFailureCallback_13, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_13(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_13(uint16_t tolerance)
    {
        VerifyOrReturn(CheckValue("tolerance", tolerance, 0U));

        NextTest();
    }
};

class Test_TC_FLW_2_2Suite : public TestCommand
{
public:
    Test_TC_FLW_2_2Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_FLW_2_2", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_FLW_2_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_FLW_2_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_FLW_2_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : read the mandatory attribute: MeasuredValue\n");
            err = TestReadTheMandatoryAttributeMeasuredValue_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : read the mandatory attribute: MeasuredValue\n");
            err = TestReadTheMandatoryAttributeMeasuredValue_2();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 3;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_1(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_FLW_2_2Suite *>(context))->OnFailureResponse_1(error);
    }

    static void OnSuccessCallback_1(void * context, const chip::app::DataModel::Nullable<uint16_t> & measuredValue)
    {
        (static_cast<Test_TC_FLW_2_2Suite *>(context))->OnSuccessResponse_1(measuredValue);
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_FLW_2_2Suite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context, const chip::app::DataModel::Nullable<uint16_t> & measuredValue)
    {
        (static_cast<Test_TC_FLW_2_2Suite *>(context))->OnSuccessResponse_2(measuredValue);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestReadTheMandatoryAttributeMeasuredValue_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::FlowMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::FlowMeasurement::Attributes::MeasuredValue::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1(const chip::app::DataModel::Nullable<uint16_t> & measuredValue)
    {
        VerifyOrReturn(CheckConstraintType("measuredValue", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeMeasuredValue_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::FlowMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::FlowMeasurement::Attributes::MeasuredValue::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2(const chip::app::DataModel::Nullable<uint16_t> & measuredValue)
    {
        VerifyOrReturn(CheckConstraintType("measuredValue", "", "uint16"));
        NextTest();
    }
};

class Test_TC_ILL_1_1Suite : public TestCommand
{
public:
    Test_TC_ILL_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_ILL_1_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_ILL_1_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_ILL_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_ILL_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : read the global attribute: ClusterRevision\n");
            err = TestReadTheGlobalAttributeClusterRevision_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read the global attribute constraints: ClusterRevision\n");
            err = TestReadTheGlobalAttributeConstraintsClusterRevision_2();
            break;
        case 3:
            ChipLogProgress(chipTool,
                            " ***** Test Step 3 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : reads back global attribute: ClusterRevision\n");
            err = TestReadsBackGlobalAttributeClusterRevision_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Read the global attribute: AttributeList\n");
            err = TestReadTheGlobalAttributeAttributeList_5();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 6;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_1(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_ILL_1_1Suite *>(context))->OnFailureResponse_1(error);
    }

    static void OnSuccessCallback_1(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_ILL_1_1Suite *>(context))->OnSuccessResponse_1(clusterRevision);
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_ILL_1_1Suite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_ILL_1_1Suite *>(context))->OnSuccessResponse_2(clusterRevision);
    }

    static void OnFailureCallback_3(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_ILL_1_1Suite *>(context))->OnFailureResponse_3(error);
    }

    static void OnSuccessCallback_3(void * context) { (static_cast<Test_TC_ILL_1_1Suite *>(context))->OnSuccessResponse_3(); }

    static void OnFailureCallback_4(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_ILL_1_1Suite *>(context))->OnFailureResponse_4(error);
    }

    static void OnSuccessCallback_4(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_ILL_1_1Suite *>(context))->OnSuccessResponse_4(clusterRevision);
    }

    static void OnFailureCallback_5(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_ILL_1_1Suite *>(context))->OnFailureResponse_5(error);
    }

    static void OnSuccessCallback_5(void * context, const chip::app::DataModel::DecodableList<chip::AttributeId> & attributeList)
    {
        (static_cast<Test_TC_ILL_1_1Suite *>(context))->OnSuccessResponse_5(attributeList);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestReadTheGlobalAttributeClusterRevision_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::IlluminanceMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::IlluminanceMeasurement::Attributes::ClusterRevision::TypeInfo>(
                this, OnSuccessCallback_1, OnFailureCallback_1, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckValue("clusterRevision", clusterRevision, 2U));

        NextTest();
    }

    CHIP_ERROR TestReadTheGlobalAttributeConstraintsClusterRevision_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::IlluminanceMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::IlluminanceMeasurement::Attributes::ClusterRevision::TypeInfo>(
                this, OnSuccessCallback_2, OnFailureCallback_2, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckConstraintType("clusterRevision", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::IlluminanceMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t clusterRevisionArgument;
        clusterRevisionArgument = 1U;

        ReturnErrorOnFailure(
            cluster.WriteAttribute<chip::app::Clusters::IlluminanceMeasurement::Attributes::ClusterRevision::TypeInfo>(
                clusterRevisionArgument, this, OnSuccessCallback_3, OnFailureCallback_3));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_3() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackGlobalAttributeClusterRevision_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::IlluminanceMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::IlluminanceMeasurement::Attributes::ClusterRevision::TypeInfo>(
                this, OnSuccessCallback_4, OnFailureCallback_4, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_4(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckValue("clusterRevision", clusterRevision, 2U));

        NextTest();
    }

    CHIP_ERROR TestReadTheGlobalAttributeAttributeList_5()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::IlluminanceMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::IlluminanceMeasurement::Attributes::AttributeList::TypeInfo>(
                this, OnSuccessCallback_5, OnFailureCallback_5, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_5(const chip::app::DataModel::DecodableList<chip::AttributeId> & attributeList)
    {
        VerifyOrReturn(CheckConstraintType("attributeList", "", "list"));
        NextTest();
    }
};

class Test_TC_LVL_1_1Suite : public TestCommand
{
public:
    Test_TC_LVL_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_LVL_1_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_LVL_1_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_LVL_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_LVL_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : read the global attribute: ClusterRevision\n");
            err = TestReadTheGlobalAttributeClusterRevision_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read the global attribute constraints: ClusterRevision\n");
            err = TestReadTheGlobalAttributeConstraintsClusterRevision_2();
            break;
        case 3:
            ChipLogProgress(chipTool,
                            " ***** Test Step 3 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : reads back global attribute: ClusterRevision\n");
            err = TestReadsBackGlobalAttributeClusterRevision_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Read the global attribute: AttributeList\n");
            err = TestReadTheGlobalAttributeAttributeList_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Read the optional global attribute : FeatureMap\n");
            err = TestReadTheOptionalGlobalAttributeFeatureMap_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : write the default values to optional global attribute: FeatureMap\n");
            err = TestWriteTheDefaultValuesToOptionalGlobalAttributeFeatureMap_7();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 8;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_1(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_LVL_1_1Suite *>(context))->OnFailureResponse_1(error);
    }

    static void OnSuccessCallback_1(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_LVL_1_1Suite *>(context))->OnSuccessResponse_1(clusterRevision);
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_LVL_1_1Suite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_LVL_1_1Suite *>(context))->OnSuccessResponse_2(clusterRevision);
    }

    static void OnFailureCallback_3(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_LVL_1_1Suite *>(context))->OnFailureResponse_3(error);
    }

    static void OnSuccessCallback_3(void * context) { (static_cast<Test_TC_LVL_1_1Suite *>(context))->OnSuccessResponse_3(); }

    static void OnFailureCallback_4(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_LVL_1_1Suite *>(context))->OnFailureResponse_4(error);
    }

    static void OnSuccessCallback_4(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_LVL_1_1Suite *>(context))->OnSuccessResponse_4(clusterRevision);
    }

    static void OnFailureCallback_5(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_LVL_1_1Suite *>(context))->OnFailureResponse_5(error);
    }

    static void OnSuccessCallback_5(void * context, const chip::app::DataModel::DecodableList<chip::AttributeId> & attributeList)
    {
        (static_cast<Test_TC_LVL_1_1Suite *>(context))->OnSuccessResponse_5(attributeList);
    }

    static void OnFailureCallback_6(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_LVL_1_1Suite *>(context))->OnFailureResponse_6(error);
    }

    static void OnSuccessCallback_6(void * context, uint32_t featureMap)
    {
        (static_cast<Test_TC_LVL_1_1Suite *>(context))->OnSuccessResponse_6(featureMap);
    }

    static void OnFailureCallback_7(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_LVL_1_1Suite *>(context))->OnFailureResponse_7(error);
    }

    static void OnSuccessCallback_7(void * context) { (static_cast<Test_TC_LVL_1_1Suite *>(context))->OnSuccessResponse_7(); }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestReadTheGlobalAttributeClusterRevision_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::LevelControl::Attributes::ClusterRevision::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckValue("clusterRevision", clusterRevision, 5U));

        NextTest();
    }

    CHIP_ERROR TestReadTheGlobalAttributeConstraintsClusterRevision_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::LevelControl::Attributes::ClusterRevision::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckConstraintType("clusterRevision", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t clusterRevisionArgument;
        clusterRevisionArgument = 4U;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::LevelControl::Attributes::ClusterRevision::TypeInfo>(
            clusterRevisionArgument, this, OnSuccessCallback_3, OnFailureCallback_3));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_3() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackGlobalAttributeClusterRevision_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::LevelControl::Attributes::ClusterRevision::TypeInfo>(
            this, OnSuccessCallback_4, OnFailureCallback_4, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_4(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckValue("clusterRevision", clusterRevision, 5U));

        NextTest();
    }

    CHIP_ERROR TestReadTheGlobalAttributeAttributeList_5()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::LevelControl::Attributes::AttributeList::TypeInfo>(
            this, OnSuccessCallback_5, OnFailureCallback_5, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_5(const chip::app::DataModel::DecodableList<chip::AttributeId> & attributeList)
    {
        VerifyOrReturn(CheckConstraintType("attributeList", "", "list"));
        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalGlobalAttributeFeatureMap_6()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::LevelControl::Attributes::FeatureMap::TypeInfo>(
            this, OnSuccessCallback_6, OnFailureCallback_6, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_6(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_6(uint32_t featureMap)
    {
        VerifyOrReturn(CheckConstraintType("featureMap", "", "map32"));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToOptionalGlobalAttributeFeatureMap_7()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint32_t featureMapArgument;
        featureMapArgument = 0UL;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::LevelControl::Attributes::FeatureMap::TypeInfo>(
            featureMapArgument, this, OnSuccessCallback_7, OnFailureCallback_7));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_7(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_7() { ThrowSuccessResponse(); }
};

class Test_TC_LVL_2_1Suite : public TestCommand
{
public:
    Test_TC_LVL_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_LVL_2_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_LVL_2_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_LVL_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_LVL_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Reset level to 254\n");
            err = TestResetLevelTo254_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Wait 100ms\n");
            err = TestWait100ms_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Reads the CurrentLevel attribute\n");
            err = TestReadsTheCurrentLevelAttribute_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Reads the RemainingTime attribute\n");
            err = TestReadsTheRemainingTimeAttribute_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Reads the MinLevel attribute\n");
            err = TestReadsTheMinLevelAttribute_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Reads the MaxLevel attribute\n");
            err = TestReadsTheMaxLevelAttribute_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Reads the CurrentFrequency attribute\n");
            err = TestReadsTheCurrentFrequencyAttribute_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Reads the MinFrequency attribute\n");
            err = TestReadsTheMinFrequencyAttribute_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Reads the MaxFrequency attribute\n");
            err = TestReadsTheMaxFrequencyAttribute_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Reads the OnOffTransitionTime attribute\n");
            err = TestReadsTheOnOffTransitionTimeAttribute_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : Reads the OnLevel attribute \n");
            err = TestReadsTheOnLevelAttribute_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : Reads the OnTransitionTime attribute \n");
            err = TestReadsTheOnTransitionTimeAttribute_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : Reads the OffTransitionTime attribute \n");
            err = TestReadsTheOffTransitionTimeAttribute_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : Reads the DefaultMoveRate attribute \n");
            err = TestReadsTheDefaultMoveRateAttribute_14();
            break;
        case 15:
            ChipLogProgress(chipTool, " ***** Test Step 15 : Reads the Options attribute \n");
            err = TestReadsTheOptionsAttribute_15();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 16;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_3(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_LVL_2_1Suite *>(context))->OnFailureResponse_3(error);
    }

    static void OnSuccessCallback_3(void * context, uint8_t currentLevel)
    {
        (static_cast<Test_TC_LVL_2_1Suite *>(context))->OnSuccessResponse_3(currentLevel);
    }

    static void OnFailureCallback_4(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_LVL_2_1Suite *>(context))->OnFailureResponse_4(error);
    }

    static void OnSuccessCallback_4(void * context, uint16_t remainingTime)
    {
        (static_cast<Test_TC_LVL_2_1Suite *>(context))->OnSuccessResponse_4(remainingTime);
    }

    static void OnFailureCallback_5(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_LVL_2_1Suite *>(context))->OnFailureResponse_5(error);
    }

    static void OnSuccessCallback_5(void * context, uint8_t minLevel)
    {
        (static_cast<Test_TC_LVL_2_1Suite *>(context))->OnSuccessResponse_5(minLevel);
    }

    static void OnFailureCallback_6(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_LVL_2_1Suite *>(context))->OnFailureResponse_6(error);
    }

    static void OnSuccessCallback_6(void * context, uint8_t maxLevel)
    {
        (static_cast<Test_TC_LVL_2_1Suite *>(context))->OnSuccessResponse_6(maxLevel);
    }

    static void OnFailureCallback_7(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_LVL_2_1Suite *>(context))->OnFailureResponse_7(error);
    }

    static void OnSuccessCallback_7(void * context, uint16_t currentFrequency)
    {
        (static_cast<Test_TC_LVL_2_1Suite *>(context))->OnSuccessResponse_7(currentFrequency);
    }

    static void OnFailureCallback_8(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_LVL_2_1Suite *>(context))->OnFailureResponse_8(error);
    }

    static void OnSuccessCallback_8(void * context, uint16_t minFrequency)
    {
        (static_cast<Test_TC_LVL_2_1Suite *>(context))->OnSuccessResponse_8(minFrequency);
    }

    static void OnFailureCallback_9(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_LVL_2_1Suite *>(context))->OnFailureResponse_9(error);
    }

    static void OnSuccessCallback_9(void * context, uint16_t maxFrequency)
    {
        (static_cast<Test_TC_LVL_2_1Suite *>(context))->OnSuccessResponse_9(maxFrequency);
    }

    static void OnFailureCallback_10(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_LVL_2_1Suite *>(context))->OnFailureResponse_10(error);
    }

    static void OnSuccessCallback_10(void * context, uint16_t onOffTransitionTime)
    {
        (static_cast<Test_TC_LVL_2_1Suite *>(context))->OnSuccessResponse_10(onOffTransitionTime);
    }

    static void OnFailureCallback_11(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_LVL_2_1Suite *>(context))->OnFailureResponse_11(error);
    }

    static void OnSuccessCallback_11(void * context, const chip::app::DataModel::Nullable<uint8_t> & onLevel)
    {
        (static_cast<Test_TC_LVL_2_1Suite *>(context))->OnSuccessResponse_11(onLevel);
    }

    static void OnFailureCallback_12(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_LVL_2_1Suite *>(context))->OnFailureResponse_12(error);
    }

    static void OnSuccessCallback_12(void * context, const chip::app::DataModel::Nullable<uint16_t> & onTransitionTime)
    {
        (static_cast<Test_TC_LVL_2_1Suite *>(context))->OnSuccessResponse_12(onTransitionTime);
    }

    static void OnFailureCallback_13(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_LVL_2_1Suite *>(context))->OnFailureResponse_13(error);
    }

    static void OnSuccessCallback_13(void * context, const chip::app::DataModel::Nullable<uint16_t> & offTransitionTime)
    {
        (static_cast<Test_TC_LVL_2_1Suite *>(context))->OnSuccessResponse_13(offTransitionTime);
    }

    static void OnFailureCallback_14(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_LVL_2_1Suite *>(context))->OnFailureResponse_14(error);
    }

    static void OnSuccessCallback_14(void * context, const chip::app::DataModel::Nullable<uint8_t> & defaultMoveRate)
    {
        (static_cast<Test_TC_LVL_2_1Suite *>(context))->OnSuccessResponse_14(defaultMoveRate);
    }

    static void OnFailureCallback_15(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_LVL_2_1Suite *>(context))->OnFailureResponse_15(error);
    }

    static void OnSuccessCallback_15(void * context, uint8_t options)
    {
        (static_cast<Test_TC_LVL_2_1Suite *>(context))->OnSuccessResponse_15(options);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestResetLevelTo254_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::LevelControl::Commands::MoveToLevel::Type;

        RequestType request;
        request.level          = 254;
        request.transitionTime = 0U;
        request.optionMask     = 1;
        request.optionOverride = 1;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_LVL_2_1Suite *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_LVL_2_1Suite *>(context))->OnFailureResponse_1(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestWait100ms_2()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForMs(100);
    }

    CHIP_ERROR TestReadsTheCurrentLevelAttribute_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::LevelControl::Attributes::CurrentLevel::TypeInfo>(
            this, OnSuccessCallback_3, OnFailureCallback_3, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3(uint8_t currentLevel)
    {
        VerifyOrReturn(CheckValue("currentLevel", currentLevel, 254));
        VerifyOrReturn(CheckConstraintType("currentLevel", "", "uint8"));
        NextTest();
    }

    CHIP_ERROR TestReadsTheRemainingTimeAttribute_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::LevelControl::Attributes::RemainingTime::TypeInfo>(
            this, OnSuccessCallback_4, OnFailureCallback_4, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_4(uint16_t remainingTime)
    {
        VerifyOrReturn(CheckValue("remainingTime", remainingTime, 0U));
        VerifyOrReturn(CheckConstraintType("remainingTime", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestReadsTheMinLevelAttribute_5()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::LevelControl::Attributes::MinLevel::TypeInfo>(
            this, OnSuccessCallback_5, OnFailureCallback_5, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_5(uint8_t minLevel)
    {
        VerifyOrReturn(CheckValue("minLevel", minLevel, 0));
        VerifyOrReturn(CheckConstraintType("minLevel", "", "uint8"));
        NextTest();
    }

    CHIP_ERROR TestReadsTheMaxLevelAttribute_6()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::LevelControl::Attributes::MaxLevel::TypeInfo>(
            this, OnSuccessCallback_6, OnFailureCallback_6, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_6(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_6(uint8_t maxLevel)
    {
        VerifyOrReturn(CheckConstraintType("maxLevel", "", "uint8"));
        NextTest();
    }

    CHIP_ERROR TestReadsTheCurrentFrequencyAttribute_7()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::LevelControl::Attributes::CurrentFrequency::TypeInfo>(
            this, OnSuccessCallback_7, OnFailureCallback_7, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_7(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_7(uint16_t currentFrequency)
    {
        VerifyOrReturn(CheckValue("currentFrequency", currentFrequency, 0U));
        VerifyOrReturn(CheckConstraintType("currentFrequency", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestReadsTheMinFrequencyAttribute_8()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::LevelControl::Attributes::MinFrequency::TypeInfo>(
            this, OnSuccessCallback_8, OnFailureCallback_8, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_8(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_8(uint16_t minFrequency)
    {
        VerifyOrReturn(CheckValue("minFrequency", minFrequency, 0U));
        VerifyOrReturn(CheckConstraintType("minFrequency", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestReadsTheMaxFrequencyAttribute_9()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::LevelControl::Attributes::MaxFrequency::TypeInfo>(
            this, OnSuccessCallback_9, OnFailureCallback_9, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_9(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_9(uint16_t maxFrequency)
    {
        VerifyOrReturn(CheckValue("maxFrequency", maxFrequency, 0U));
        VerifyOrReturn(CheckConstraintType("maxFrequency", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestReadsTheOnOffTransitionTimeAttribute_10()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::LevelControl::Attributes::OnOffTransitionTime::TypeInfo>(
            this, OnSuccessCallback_10, OnFailureCallback_10, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_10(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_10(uint16_t onOffTransitionTime)
    {
        VerifyOrReturn(CheckValue("onOffTransitionTime", onOffTransitionTime, 0U));
        VerifyOrReturn(CheckConstraintType("onOffTransitionTime", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestReadsTheOnLevelAttribute_11()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::LevelControl::Attributes::OnLevel::TypeInfo>(
            this, OnSuccessCallback_11, OnFailureCallback_11, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_11(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_11(const chip::app::DataModel::Nullable<uint8_t> & onLevel)
    {
        VerifyOrReturn(CheckConstraintType("onLevel", "", "uint8"));
        NextTest();
    }

    CHIP_ERROR TestReadsTheOnTransitionTimeAttribute_12()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::LevelControl::Attributes::OnTransitionTime::TypeInfo>(
            this, OnSuccessCallback_12, OnFailureCallback_12, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_12(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_12(const chip::app::DataModel::Nullable<uint16_t> & onTransitionTime)
    {
        VerifyOrReturn(CheckConstraintType("onTransitionTime", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestReadsTheOffTransitionTimeAttribute_13()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::LevelControl::Attributes::OffTransitionTime::TypeInfo>(
            this, OnSuccessCallback_13, OnFailureCallback_13, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_13(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_13(const chip::app::DataModel::Nullable<uint16_t> & offTransitionTime)
    {
        VerifyOrReturn(CheckConstraintType("offTransitionTime", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestReadsTheDefaultMoveRateAttribute_14()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::LevelControl::Attributes::DefaultMoveRate::TypeInfo>(
            this, OnSuccessCallback_14, OnFailureCallback_14, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_14(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_14(const chip::app::DataModel::Nullable<uint8_t> & defaultMoveRate)
    {
        VerifyOrReturn(CheckConstraintType("defaultMoveRate", "", "uint8"));
        NextTest();
    }

    CHIP_ERROR TestReadsTheOptionsAttribute_15()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::LevelControl::Attributes::Options::TypeInfo>(
            this, OnSuccessCallback_15, OnFailureCallback_15, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_15(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_15(uint8_t options)
    {
        VerifyOrReturn(CheckValue("options", options, 0));
        VerifyOrReturn(CheckConstraintType("options", "", "map8"));
        NextTest();
    }
};

class Test_TC_LVL_2_2Suite : public TestCommand
{
public:
    Test_TC_LVL_2_2Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_LVL_2_2", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_LVL_2_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_LVL_2_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_LVL_2_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Reads the OnOffTransitionTime attribute from the DUT\n");
            err = TestReadsTheOnOffTransitionTimeAttributeFromTheDut_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : writes the OnOffTransitionTime attribute on the DUT\n");
            err = TestWritesTheOnOffTransitionTimeAttributeOnTheDut_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Reads the OnOffTransitionTime attribute from the DUT\n");
            err = TestReadsTheOnOffTransitionTimeAttributeFromTheDut_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : writes default value of OnOffTransitionTime attribute\n");
            err = TestWritesDefaultValueOfOnOffTransitionTimeAttribute_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : writes the OnLevel attribute on the DUT\n");
            err = TestWritesTheOnLevelAttributeOnTheDut_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Reads the OnLevel attribute from the DUT\n");
            err = TestReadsTheOnLevelAttributeFromTheDut_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Writes the OnTransitionTime attribute on the DUT\n");
            err = TestWritesTheOnTransitionTimeAttributeOnTheDut_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Reads the OnTransitionTime attribute from the DUT\n");
            err = TestReadsTheOnTransitionTimeAttributeFromTheDut_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Writes the OffTransitionTime attribute on the DUT\n");
            err = TestWritesTheOffTransitionTimeAttributeOnTheDut_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Reads the OffTransitionTime attribute from the DUT\n");
            err = TestReadsTheOffTransitionTimeAttributeFromTheDut_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : Reads the DefaultMoveRate attribute from the DUT\n");
            err = TestReadsTheDefaultMoveRateAttributeFromTheDut_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : Writes the DefaultMoveRate attribute on the DUT\n");
            err = TestWritesTheDefaultMoveRateAttributeOnTheDut_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : Reads the DefaultMoveRate attribute from the DUT\n");
            err = TestReadsTheDefaultMoveRateAttributeFromTheDut_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : writes the StartUpCurrentLevel attribute on the DUT\n");
            err = TestWritesTheStartUpCurrentLevelAttributeOnTheDut_14();
            break;
        case 15:
            ChipLogProgress(chipTool, " ***** Test Step 15 : reads the StartUpCurrentLevel attribute from the DUT\n");
            err = TestReadsTheStartUpCurrentLevelAttributeFromTheDut_15();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 16;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_1(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_LVL_2_2Suite *>(context))->OnFailureResponse_1(error);
    }

    static void OnSuccessCallback_1(void * context, uint16_t onOffTransitionTime)
    {
        (static_cast<Test_TC_LVL_2_2Suite *>(context))->OnSuccessResponse_1(onOffTransitionTime);
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_LVL_2_2Suite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context) { (static_cast<Test_TC_LVL_2_2Suite *>(context))->OnSuccessResponse_2(); }

    static void OnFailureCallback_3(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_LVL_2_2Suite *>(context))->OnFailureResponse_3(error);
    }

    static void OnSuccessCallback_3(void * context, uint16_t onOffTransitionTime)
    {
        (static_cast<Test_TC_LVL_2_2Suite *>(context))->OnSuccessResponse_3(onOffTransitionTime);
    }

    static void OnFailureCallback_4(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_LVL_2_2Suite *>(context))->OnFailureResponse_4(error);
    }

    static void OnSuccessCallback_4(void * context) { (static_cast<Test_TC_LVL_2_2Suite *>(context))->OnSuccessResponse_4(); }

    static void OnFailureCallback_5(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_LVL_2_2Suite *>(context))->OnFailureResponse_5(error);
    }

    static void OnSuccessCallback_5(void * context) { (static_cast<Test_TC_LVL_2_2Suite *>(context))->OnSuccessResponse_5(); }

    static void OnFailureCallback_6(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_LVL_2_2Suite *>(context))->OnFailureResponse_6(error);
    }

    static void OnSuccessCallback_6(void * context, const chip::app::DataModel::Nullable<uint8_t> & onLevel)
    {
        (static_cast<Test_TC_LVL_2_2Suite *>(context))->OnSuccessResponse_6(onLevel);
    }

    static void OnFailureCallback_7(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_LVL_2_2Suite *>(context))->OnFailureResponse_7(error);
    }

    static void OnSuccessCallback_7(void * context) { (static_cast<Test_TC_LVL_2_2Suite *>(context))->OnSuccessResponse_7(); }

    static void OnFailureCallback_8(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_LVL_2_2Suite *>(context))->OnFailureResponse_8(error);
    }

    static void OnSuccessCallback_8(void * context, const chip::app::DataModel::Nullable<uint16_t> & onTransitionTime)
    {
        (static_cast<Test_TC_LVL_2_2Suite *>(context))->OnSuccessResponse_8(onTransitionTime);
    }

    static void OnFailureCallback_9(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_LVL_2_2Suite *>(context))->OnFailureResponse_9(error);
    }

    static void OnSuccessCallback_9(void * context) { (static_cast<Test_TC_LVL_2_2Suite *>(context))->OnSuccessResponse_9(); }

    static void OnFailureCallback_10(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_LVL_2_2Suite *>(context))->OnFailureResponse_10(error);
    }

    static void OnSuccessCallback_10(void * context, const chip::app::DataModel::Nullable<uint16_t> & offTransitionTime)
    {
        (static_cast<Test_TC_LVL_2_2Suite *>(context))->OnSuccessResponse_10(offTransitionTime);
    }

    static void OnFailureCallback_11(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_LVL_2_2Suite *>(context))->OnFailureResponse_11(error);
    }

    static void OnSuccessCallback_11(void * context, const chip::app::DataModel::Nullable<uint8_t> & defaultMoveRate)
    {
        (static_cast<Test_TC_LVL_2_2Suite *>(context))->OnSuccessResponse_11(defaultMoveRate);
    }

    static void OnFailureCallback_12(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_LVL_2_2Suite *>(context))->OnFailureResponse_12(error);
    }

    static void OnSuccessCallback_12(void * context) { (static_cast<Test_TC_LVL_2_2Suite *>(context))->OnSuccessResponse_12(); }

    static void OnFailureCallback_13(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_LVL_2_2Suite *>(context))->OnFailureResponse_13(error);
    }

    static void OnSuccessCallback_13(void * context, const chip::app::DataModel::Nullable<uint8_t> & defaultMoveRate)
    {
        (static_cast<Test_TC_LVL_2_2Suite *>(context))->OnSuccessResponse_13(defaultMoveRate);
    }

    static void OnFailureCallback_14(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_LVL_2_2Suite *>(context))->OnFailureResponse_14(error);
    }

    static void OnSuccessCallback_14(void * context) { (static_cast<Test_TC_LVL_2_2Suite *>(context))->OnSuccessResponse_14(); }

    static void OnFailureCallback_15(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_LVL_2_2Suite *>(context))->OnFailureResponse_15(error);
    }

    static void OnSuccessCallback_15(void * context, const chip::app::DataModel::Nullable<uint8_t> & startUpCurrentLevel)
    {
        (static_cast<Test_TC_LVL_2_2Suite *>(context))->OnSuccessResponse_15(startUpCurrentLevel);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestReadsTheOnOffTransitionTimeAttributeFromTheDut_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::LevelControl::Attributes::OnOffTransitionTime::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1(uint16_t onOffTransitionTime)
    {
        VerifyOrReturn(CheckValue("onOffTransitionTime", onOffTransitionTime, 0U));
        VerifyOrReturn(CheckConstraintType("onOffTransitionTime", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestWritesTheOnOffTransitionTimeAttributeOnTheDut_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t onOffTransitionTimeArgument;
        onOffTransitionTimeArgument = 10U;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::LevelControl::Attributes::OnOffTransitionTime::TypeInfo>(
            onOffTransitionTimeArgument, this, OnSuccessCallback_2, OnFailureCallback_2));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestReadsTheOnOffTransitionTimeAttributeFromTheDut_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::LevelControl::Attributes::OnOffTransitionTime::TypeInfo>(
            this, OnSuccessCallback_3, OnFailureCallback_3, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3(uint16_t onOffTransitionTime)
    {
        VerifyOrReturn(CheckValue("onOffTransitionTime", onOffTransitionTime, 10U));
        VerifyOrReturn(CheckConstraintType("onOffTransitionTime", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestWritesDefaultValueOfOnOffTransitionTimeAttribute_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t onOffTransitionTimeArgument;
        onOffTransitionTimeArgument = 0U;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::LevelControl::Attributes::OnOffTransitionTime::TypeInfo>(
            onOffTransitionTimeArgument, this, OnSuccessCallback_4, OnFailureCallback_4));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestWritesTheOnLevelAttributeOnTheDut_5()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint8_t> onLevelArgument;
        onLevelArgument.SetNonNull();
        onLevelArgument.Value() = 254;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::LevelControl::Attributes::OnLevel::TypeInfo>(
            onLevelArgument, this, OnSuccessCallback_5, OnFailureCallback_5));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_5() { NextTest(); }

    CHIP_ERROR TestReadsTheOnLevelAttributeFromTheDut_6()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::LevelControl::Attributes::OnLevel::TypeInfo>(
            this, OnSuccessCallback_6, OnFailureCallback_6, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_6(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_6(const chip::app::DataModel::Nullable<uint8_t> & onLevel)
    {
        VerifyOrReturn(CheckValueNonNull("onLevel", onLevel));
        VerifyOrReturn(CheckValue("onLevel.Value()", onLevel.Value(), 254));
        VerifyOrReturn(CheckConstraintType("onLevel", "", "uint8"));
        NextTest();
    }

    CHIP_ERROR TestWritesTheOnTransitionTimeAttributeOnTheDut_7()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint16_t> onTransitionTimeArgument;
        onTransitionTimeArgument.SetNonNull();
        onTransitionTimeArgument.Value() = 100U;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::LevelControl::Attributes::OnTransitionTime::TypeInfo>(
            onTransitionTimeArgument, this, OnSuccessCallback_7, OnFailureCallback_7));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_7(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_7() { NextTest(); }

    CHIP_ERROR TestReadsTheOnTransitionTimeAttributeFromTheDut_8()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::LevelControl::Attributes::OnTransitionTime::TypeInfo>(
            this, OnSuccessCallback_8, OnFailureCallback_8, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_8(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_8(const chip::app::DataModel::Nullable<uint16_t> & onTransitionTime)
    {
        VerifyOrReturn(CheckValueNonNull("onTransitionTime", onTransitionTime));
        VerifyOrReturn(CheckValue("onTransitionTime.Value()", onTransitionTime.Value(), 100U));
        VerifyOrReturn(CheckConstraintType("onTransitionTime", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestWritesTheOffTransitionTimeAttributeOnTheDut_9()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint16_t> offTransitionTimeArgument;
        offTransitionTimeArgument.SetNonNull();
        offTransitionTimeArgument.Value() = 100U;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::LevelControl::Attributes::OffTransitionTime::TypeInfo>(
            offTransitionTimeArgument, this, OnSuccessCallback_9, OnFailureCallback_9));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_9(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_9() { NextTest(); }

    CHIP_ERROR TestReadsTheOffTransitionTimeAttributeFromTheDut_10()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::LevelControl::Attributes::OffTransitionTime::TypeInfo>(
            this, OnSuccessCallback_10, OnFailureCallback_10, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_10(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_10(const chip::app::DataModel::Nullable<uint16_t> & offTransitionTime)
    {
        VerifyOrReturn(CheckValueNonNull("offTransitionTime", offTransitionTime));
        VerifyOrReturn(CheckValue("offTransitionTime.Value()", offTransitionTime.Value(), 100U));
        VerifyOrReturn(CheckConstraintType("offTransitionTime", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestReadsTheDefaultMoveRateAttributeFromTheDut_11()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::LevelControl::Attributes::DefaultMoveRate::TypeInfo>(
            this, OnSuccessCallback_11, OnFailureCallback_11, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_11(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_11(const chip::app::DataModel::Nullable<uint8_t> & defaultMoveRate)
    {
        VerifyOrReturn(CheckValueNonNull("defaultMoveRate", defaultMoveRate));
        VerifyOrReturn(CheckValue("defaultMoveRate.Value()", defaultMoveRate.Value(), 0));
        VerifyOrReturn(CheckConstraintType("defaultMoveRate", "", "uint8"));
        NextTest();
    }

    CHIP_ERROR TestWritesTheDefaultMoveRateAttributeOnTheDut_12()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint8_t> defaultMoveRateArgument;
        defaultMoveRateArgument.SetNonNull();
        defaultMoveRateArgument.Value() = 100;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::LevelControl::Attributes::DefaultMoveRate::TypeInfo>(
            defaultMoveRateArgument, this, OnSuccessCallback_12, OnFailureCallback_12));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_12(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_12() { NextTest(); }

    CHIP_ERROR TestReadsTheDefaultMoveRateAttributeFromTheDut_13()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::LevelControl::Attributes::DefaultMoveRate::TypeInfo>(
            this, OnSuccessCallback_13, OnFailureCallback_13, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_13(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_13(const chip::app::DataModel::Nullable<uint8_t> & defaultMoveRate)
    {
        VerifyOrReturn(CheckValueNonNull("defaultMoveRate", defaultMoveRate));
        VerifyOrReturn(CheckValue("defaultMoveRate.Value()", defaultMoveRate.Value(), 100));
        VerifyOrReturn(CheckConstraintType("defaultMoveRate", "", "uint8"));
        NextTest();
    }

    CHIP_ERROR TestWritesTheStartUpCurrentLevelAttributeOnTheDut_14()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint8_t> startUpCurrentLevelArgument;
        startUpCurrentLevelArgument.SetNonNull();
        startUpCurrentLevelArgument.Value() = 254;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::LevelControl::Attributes::StartUpCurrentLevel::TypeInfo>(
            startUpCurrentLevelArgument, this, OnSuccessCallback_14, OnFailureCallback_14));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_14(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_14() { NextTest(); }

    CHIP_ERROR TestReadsTheStartUpCurrentLevelAttributeFromTheDut_15()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::LevelControl::Attributes::StartUpCurrentLevel::TypeInfo>(
            this, OnSuccessCallback_15, OnFailureCallback_15, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_15(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_15(const chip::app::DataModel::Nullable<uint8_t> & startUpCurrentLevel)
    {
        VerifyOrReturn(CheckValueNonNull("startUpCurrentLevel", startUpCurrentLevel));
        VerifyOrReturn(CheckValue("startUpCurrentLevel.Value()", startUpCurrentLevel.Value(), 254));
        VerifyOrReturn(CheckConstraintType("startUpCurrentLevel", "", "uint8"));
        NextTest();
    }
};

class Test_TC_LVL_3_1Suite : public TestCommand
{
public:
    Test_TC_LVL_3_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_LVL_3_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_LVL_3_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_LVL_3_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_LVL_3_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : reads CurrentLevel attribute from DUT\n");
            err = TestReadsCurrentLevelAttributeFromDut_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Reads the MinLevel attribute\n");
            err = TestReadsTheMinLevelAttribute_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Reads the MaxLevel attribute\n");
            err = TestReadsTheMaxLevelAttribute_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : sends a Move to level command\n");
            err = TestSendsAMoveToLevelCommand_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Wait 100ms\n");
            err = TestWait100ms_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : reads CurrentLevel attribute from DUT\n");
            err = TestReadsCurrentLevelAttributeFromDut_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : sends a Move to level command\n");
            err = TestSendsAMoveToLevelCommand_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Wait a second\n");
            err = TestWaitASecond_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : reads CurrentLevel attribute from DUT\n");
            err = TestReadsCurrentLevelAttributeFromDut_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : reads On Off Transition Time attribute from DUT\n");
            err = TestReadsOnOffTransitionTimeAttributeFromDut_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : sends a Move to level command\n");
            err = TestSendsAMoveToLevelCommand_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : Wait 10ms\n");
            err = TestWait10ms_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : reads CurrentLevel attribute from DUT\n");
            err = TestReadsCurrentLevelAttributeFromDut_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : Reset level to 254\n");
            err = TestResetLevelTo254_14();
            break;
        case 15:
            ChipLogProgress(chipTool, " ***** Test Step 15 : Wait 100ms\n");
            err = TestWait100ms_15();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 16;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_1(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_LVL_3_1Suite *>(context))->OnFailureResponse_1(error);
    }

    static void OnSuccessCallback_1(void * context, uint8_t currentLevel)
    {
        (static_cast<Test_TC_LVL_3_1Suite *>(context))->OnSuccessResponse_1(currentLevel);
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_LVL_3_1Suite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context, uint8_t minLevel)
    {
        (static_cast<Test_TC_LVL_3_1Suite *>(context))->OnSuccessResponse_2(minLevel);
    }

    static void OnFailureCallback_3(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_LVL_3_1Suite *>(context))->OnFailureResponse_3(error);
    }

    static void OnSuccessCallback_3(void * context, uint8_t maxLevel)
    {
        (static_cast<Test_TC_LVL_3_1Suite *>(context))->OnSuccessResponse_3(maxLevel);
    }

    static void OnFailureCallback_6(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_LVL_3_1Suite *>(context))->OnFailureResponse_6(error);
    }

    static void OnSuccessCallback_6(void * context, uint8_t currentLevel)
    {
        (static_cast<Test_TC_LVL_3_1Suite *>(context))->OnSuccessResponse_6(currentLevel);
    }

    static void OnFailureCallback_9(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_LVL_3_1Suite *>(context))->OnFailureResponse_9(error);
    }

    static void OnSuccessCallback_9(void * context, uint8_t currentLevel)
    {
        (static_cast<Test_TC_LVL_3_1Suite *>(context))->OnSuccessResponse_9(currentLevel);
    }

    static void OnFailureCallback_10(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_LVL_3_1Suite *>(context))->OnFailureResponse_10(error);
    }

    static void OnSuccessCallback_10(void * context, uint16_t onOffTransitionTime)
    {
        (static_cast<Test_TC_LVL_3_1Suite *>(context))->OnSuccessResponse_10(onOffTransitionTime);
    }

    static void OnFailureCallback_13(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_LVL_3_1Suite *>(context))->OnFailureResponse_13(error);
    }

    static void OnSuccessCallback_13(void * context, uint8_t currentLevel)
    {
        (static_cast<Test_TC_LVL_3_1Suite *>(context))->OnSuccessResponse_13(currentLevel);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestReadsCurrentLevelAttributeFromDut_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::LevelControl::Attributes::CurrentLevel::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1(uint8_t currentLevel)
    {
        VerifyOrReturn(CheckValue("currentLevel", currentLevel, 254));

        NextTest();
    }

    CHIP_ERROR TestReadsTheMinLevelAttribute_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::LevelControl::Attributes::MinLevel::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2(uint8_t minLevel)
    {
        VerifyOrReturn(CheckValue("minLevel", minLevel, 0));

        NextTest();
    }

    CHIP_ERROR TestReadsTheMaxLevelAttribute_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::LevelControl::Attributes::MaxLevel::TypeInfo>(
            this, OnSuccessCallback_3, OnFailureCallback_3, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3(uint8_t maxLevel)
    {
        VerifyOrReturn(CheckValue("maxLevel", maxLevel, 254));

        NextTest();
    }

    CHIP_ERROR TestSendsAMoveToLevelCommand_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::LevelControl::Commands::MoveToLevel::Type;

        RequestType request;
        request.level          = 64;
        request.transitionTime = 0U;
        request.optionMask     = 1;
        request.optionOverride = 1;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_LVL_3_1Suite *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_LVL_3_1Suite *>(context))->OnFailureResponse_4(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestWait100ms_5()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForMs(100);
    }

    CHIP_ERROR TestReadsCurrentLevelAttributeFromDut_6()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::LevelControl::Attributes::CurrentLevel::TypeInfo>(
            this, OnSuccessCallback_6, OnFailureCallback_6, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_6(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_6(uint8_t currentLevel)
    {
        VerifyOrReturn(CheckValue("currentLevel", currentLevel, 64));

        NextTest();
    }

    CHIP_ERROR TestSendsAMoveToLevelCommand_7()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::LevelControl::Commands::MoveToLevel::Type;

        RequestType request;
        request.level          = 128;
        request.transitionTime = 1U;
        request.optionMask     = 1;
        request.optionOverride = 1;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_LVL_3_1Suite *>(context))->OnSuccessResponse_7();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_LVL_3_1Suite *>(context))->OnFailureResponse_7(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_7(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_7() { NextTest(); }

    CHIP_ERROR TestWaitASecond_8()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForMs(1000);
    }

    CHIP_ERROR TestReadsCurrentLevelAttributeFromDut_9()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::LevelControl::Attributes::CurrentLevel::TypeInfo>(
            this, OnSuccessCallback_9, OnFailureCallback_9, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_9(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_9(uint8_t currentLevel)
    {
        VerifyOrReturn(CheckValue("currentLevel", currentLevel, 128));

        NextTest();
    }

    CHIP_ERROR TestReadsOnOffTransitionTimeAttributeFromDut_10()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::LevelControl::Attributes::OnOffTransitionTime::TypeInfo>(
            this, OnSuccessCallback_10, OnFailureCallback_10, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_10(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_10(uint16_t onOffTransitionTime)
    {
        VerifyOrReturn(CheckValue("onOffTransitionTime", onOffTransitionTime, 0U));

        NextTest();
    }

    CHIP_ERROR TestSendsAMoveToLevelCommand_11()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::LevelControl::Commands::MoveToLevel::Type;

        RequestType request;
        request.level          = 254;
        request.transitionTime = 65535U;
        request.optionMask     = 1;
        request.optionOverride = 1;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_LVL_3_1Suite *>(context))->OnSuccessResponse_11();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_LVL_3_1Suite *>(context))->OnFailureResponse_11(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_11(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_11() { NextTest(); }

    CHIP_ERROR TestWait10ms_12()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForMs(100);
    }

    CHIP_ERROR TestReadsCurrentLevelAttributeFromDut_13()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::LevelControl::Attributes::CurrentLevel::TypeInfo>(
            this, OnSuccessCallback_13, OnFailureCallback_13, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_13(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_13(uint8_t currentLevel)
    {
        VerifyOrReturn(CheckValue("currentLevel", currentLevel, 254));

        NextTest();
    }

    CHIP_ERROR TestResetLevelTo254_14()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::LevelControl::Commands::MoveToLevel::Type;

        RequestType request;
        request.level          = 254;
        request.transitionTime = 0U;
        request.optionMask     = 1;
        request.optionOverride = 1;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_LVL_3_1Suite *>(context))->OnSuccessResponse_14();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_LVL_3_1Suite *>(context))->OnFailureResponse_14(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_14(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_14() { NextTest(); }

    CHIP_ERROR TestWait100ms_15()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForMs(100);
    }
};

class Test_TC_LVL_4_1Suite : public TestCommand
{
public:
    Test_TC_LVL_4_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_LVL_4_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_LVL_4_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_LVL_4_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_LVL_4_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : reads CurrentLevel attribute from DUT\n");
            err = TestReadsCurrentLevelAttributeFromDut_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : reads max level attribute from DUT\n");
            err = TestReadsMaxLevelAttributeFromDut_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : sends a Move up command\n");
            err = TestSendsAMoveUpCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Wait 3000ms\n");
            err = TestWait3000ms_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : reads CurrentLevel attribute from DUT\n");
            err = TestReadsCurrentLevelAttributeFromDut_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : reads min level attribute from DUT\n");
            err = TestReadsMinLevelAttributeFromDut_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : sends a Move down command\n");
            err = TestSendsAMoveDownCommand_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Wait 3000ms\n");
            err = TestWait3000ms_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : reads CurrentLevel attribute from DUT\n");
            err = TestReadsCurrentLevelAttributeFromDut_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Write default move rate attribute from DUT\n");
            err = TestWriteDefaultMoveRateAttributeFromDut_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : reads default move rate attribute from DUT\n");
            err = TestReadsDefaultMoveRateAttributeFromDut_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : sends a Move up command at default move rate\n");
            err = TestSendsAMoveUpCommandAtDefaultMoveRate_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : Wait 100ms\n");
            err = TestWait100ms_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : reads CurrentLevel attribute from DUT\n");
            err = TestReadsCurrentLevelAttributeFromDut_14();
            break;
        case 15:
            ChipLogProgress(chipTool, " ***** Test Step 15 : Reset level to 254\n");
            err = TestResetLevelTo254_15();
            break;
        case 16:
            ChipLogProgress(chipTool, " ***** Test Step 16 : Wait 100ms\n");
            err = TestWait100ms_16();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 17;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_1(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_LVL_4_1Suite *>(context))->OnFailureResponse_1(error);
    }

    static void OnSuccessCallback_1(void * context, uint8_t currentLevel)
    {
        (static_cast<Test_TC_LVL_4_1Suite *>(context))->OnSuccessResponse_1(currentLevel);
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_LVL_4_1Suite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context, uint8_t maxLevel)
    {
        (static_cast<Test_TC_LVL_4_1Suite *>(context))->OnSuccessResponse_2(maxLevel);
    }

    static void OnFailureCallback_5(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_LVL_4_1Suite *>(context))->OnFailureResponse_5(error);
    }

    static void OnSuccessCallback_5(void * context, uint8_t currentLevel)
    {
        (static_cast<Test_TC_LVL_4_1Suite *>(context))->OnSuccessResponse_5(currentLevel);
    }

    static void OnFailureCallback_6(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_LVL_4_1Suite *>(context))->OnFailureResponse_6(error);
    }

    static void OnSuccessCallback_6(void * context, uint8_t minLevel)
    {
        (static_cast<Test_TC_LVL_4_1Suite *>(context))->OnSuccessResponse_6(minLevel);
    }

    static void OnFailureCallback_9(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_LVL_4_1Suite *>(context))->OnFailureResponse_9(error);
    }

    static void OnSuccessCallback_9(void * context, uint8_t currentLevel)
    {
        (static_cast<Test_TC_LVL_4_1Suite *>(context))->OnSuccessResponse_9(currentLevel);
    }

    static void OnFailureCallback_10(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_LVL_4_1Suite *>(context))->OnFailureResponse_10(error);
    }

    static void OnSuccessCallback_10(void * context) { (static_cast<Test_TC_LVL_4_1Suite *>(context))->OnSuccessResponse_10(); }

    static void OnFailureCallback_11(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_LVL_4_1Suite *>(context))->OnFailureResponse_11(error);
    }

    static void OnSuccessCallback_11(void * context, const chip::app::DataModel::Nullable<uint8_t> & defaultMoveRate)
    {
        (static_cast<Test_TC_LVL_4_1Suite *>(context))->OnSuccessResponse_11(defaultMoveRate);
    }

    static void OnFailureCallback_14(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_LVL_4_1Suite *>(context))->OnFailureResponse_14(error);
    }

    static void OnSuccessCallback_14(void * context, uint8_t currentLevel)
    {
        (static_cast<Test_TC_LVL_4_1Suite *>(context))->OnSuccessResponse_14(currentLevel);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestReadsCurrentLevelAttributeFromDut_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::LevelControl::Attributes::CurrentLevel::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1(uint8_t currentLevel)
    {
        VerifyOrReturn(CheckValue("currentLevel", currentLevel, 254));

        NextTest();
    }

    CHIP_ERROR TestReadsMaxLevelAttributeFromDut_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::LevelControl::Attributes::MaxLevel::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2(uint8_t maxLevel)
    {
        VerifyOrReturn(CheckValue("maxLevel", maxLevel, 254));

        NextTest();
    }

    CHIP_ERROR TestSendsAMoveUpCommand_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::LevelControl::Commands::Move::Type;

        RequestType request;
        request.moveMode       = static_cast<chip::app::Clusters::LevelControl::MoveMode>(0);
        request.rate           = 200;
        request.optionMask     = 1;
        request.optionOverride = 1;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_LVL_4_1Suite *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_LVL_4_1Suite *>(context))->OnFailureResponse_3(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestWait3000ms_4()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForMs(3000);
    }

    CHIP_ERROR TestReadsCurrentLevelAttributeFromDut_5()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::LevelControl::Attributes::CurrentLevel::TypeInfo>(
            this, OnSuccessCallback_5, OnFailureCallback_5, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_5(uint8_t currentLevel)
    {
        VerifyOrReturn(CheckValue("currentLevel", currentLevel, 254));

        NextTest();
    }

    CHIP_ERROR TestReadsMinLevelAttributeFromDut_6()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::LevelControl::Attributes::MinLevel::TypeInfo>(
            this, OnSuccessCallback_6, OnFailureCallback_6, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_6(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_6(uint8_t minLevel)
    {
        VerifyOrReturn(CheckValue("minLevel", minLevel, 0));

        NextTest();
    }

    CHIP_ERROR TestSendsAMoveDownCommand_7()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::LevelControl::Commands::Move::Type;

        RequestType request;
        request.moveMode       = static_cast<chip::app::Clusters::LevelControl::MoveMode>(1);
        request.rate           = 250;
        request.optionMask     = 1;
        request.optionOverride = 1;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_LVL_4_1Suite *>(context))->OnSuccessResponse_7();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_LVL_4_1Suite *>(context))->OnFailureResponse_7(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_7(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_7() { NextTest(); }

    CHIP_ERROR TestWait3000ms_8()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForMs(3000);
    }

    CHIP_ERROR TestReadsCurrentLevelAttributeFromDut_9()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::LevelControl::Attributes::CurrentLevel::TypeInfo>(
            this, OnSuccessCallback_9, OnFailureCallback_9, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_9(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_9(uint8_t currentLevel)
    {
        VerifyOrReturn(CheckConstraintMinValue<uint8_t>("currentLevel", currentLevel, 0));
        VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("currentLevel", currentLevel, 1));
        NextTest();
    }

    CHIP_ERROR TestWriteDefaultMoveRateAttributeFromDut_10()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint8_t> defaultMoveRateArgument;
        defaultMoveRateArgument.SetNonNull();
        defaultMoveRateArgument.Value() = 20;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::LevelControl::Attributes::DefaultMoveRate::TypeInfo>(
            defaultMoveRateArgument, this, OnSuccessCallback_10, OnFailureCallback_10));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_10(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_10() { NextTest(); }

    CHIP_ERROR TestReadsDefaultMoveRateAttributeFromDut_11()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::LevelControl::Attributes::DefaultMoveRate::TypeInfo>(
            this, OnSuccessCallback_11, OnFailureCallback_11, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_11(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_11(const chip::app::DataModel::Nullable<uint8_t> & defaultMoveRate)
    {
        VerifyOrReturn(CheckValueNonNull("defaultMoveRate", defaultMoveRate));
        VerifyOrReturn(CheckValue("defaultMoveRate.Value()", defaultMoveRate.Value(), 20));

        NextTest();
    }

    CHIP_ERROR TestSendsAMoveUpCommandAtDefaultMoveRate_12()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::LevelControl::Commands::Move::Type;

        RequestType request;
        request.moveMode       = static_cast<chip::app::Clusters::LevelControl::MoveMode>(0);
        request.rate           = 255;
        request.optionMask     = 1;
        request.optionOverride = 1;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_LVL_4_1Suite *>(context))->OnSuccessResponse_12();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_LVL_4_1Suite *>(context))->OnFailureResponse_12(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_12(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_12() { NextTest(); }

    CHIP_ERROR TestWait100ms_13()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForMs(100);
    }

    CHIP_ERROR TestReadsCurrentLevelAttributeFromDut_14()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::LevelControl::Attributes::CurrentLevel::TypeInfo>(
            this, OnSuccessCallback_14, OnFailureCallback_14, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_14(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_14(uint8_t currentLevel)
    {
        VerifyOrReturn(CheckConstraintNotValue("currentLevel", currentLevel, 255));

        NextTest();
    }

    CHIP_ERROR TestResetLevelTo254_15()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::LevelControl::Commands::MoveToLevel::Type;

        RequestType request;
        request.level          = 254;
        request.transitionTime = 0U;
        request.optionMask     = 1;
        request.optionOverride = 1;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_LVL_4_1Suite *>(context))->OnSuccessResponse_15();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_LVL_4_1Suite *>(context))->OnFailureResponse_15(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_15(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_15() { NextTest(); }

    CHIP_ERROR TestWait100ms_16()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForMs(100);
    }
};

class Test_TC_LVL_5_1Suite : public TestCommand
{
public:
    Test_TC_LVL_5_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_LVL_5_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_LVL_5_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_LVL_5_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_LVL_5_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Sending on command\n");
            err = TestSendingOnCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Precondition: DUT level is set to 0x80\n");
            err = TestPreconditionDutLevelIsSetTo0x80_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Wait 4000ms\n");
            err = TestWait4000ms_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Reads current level attribute from DUT\n");
            err = TestReadsCurrentLevelAttributeFromDut_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Sends step down command to DUT\n");
            err = TestSendsStepDownCommandToDut_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Wait 4000ms\n");
            err = TestWait4000ms_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Reads current level attribute from DUT\n");
            err = TestReadsCurrentLevelAttributeFromDut_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Sends a Step up command\n");
            err = TestSendsAStepUpCommand_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Wait 4000ms\n");
            err = TestWait4000ms_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Reads current level attribute from DUT\n");
            err = TestReadsCurrentLevelAttributeFromDut_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : Reset level to 254\n");
            err = TestResetLevelTo254_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : Wait 100ms\n");
            err = TestWait100ms_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : Sending off command\n");
            err = TestSendingOffCommand_13();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 14;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_4(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_LVL_5_1Suite *>(context))->OnFailureResponse_4(error);
    }

    static void OnSuccessCallback_4(void * context, uint8_t currentLevel)
    {
        (static_cast<Test_TC_LVL_5_1Suite *>(context))->OnSuccessResponse_4(currentLevel);
    }

    static void OnFailureCallback_7(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_LVL_5_1Suite *>(context))->OnFailureResponse_7(error);
    }

    static void OnSuccessCallback_7(void * context, uint8_t currentLevel)
    {
        (static_cast<Test_TC_LVL_5_1Suite *>(context))->OnSuccessResponse_7(currentLevel);
    }

    static void OnFailureCallback_10(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_LVL_5_1Suite *>(context))->OnFailureResponse_10(error);
    }

    static void OnSuccessCallback_10(void * context, uint8_t currentLevel)
    {
        (static_cast<Test_TC_LVL_5_1Suite *>(context))->OnSuccessResponse_10(currentLevel);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestSendingOnCommand_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_LVL_5_1Suite *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_LVL_5_1Suite *>(context))->OnFailureResponse_1(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestPreconditionDutLevelIsSetTo0x80_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::LevelControl::Commands::Step::Type;

        RequestType request;
        request.stepMode       = static_cast<chip::app::Clusters::LevelControl::StepMode>(1);
        request.stepSize       = 126;
        request.transitionTime = 20U;
        request.optionMask     = 0;
        request.optionOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_LVL_5_1Suite *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_LVL_5_1Suite *>(context))->OnFailureResponse_2(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestWait4000ms_3()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForMs(4000);
    }

    CHIP_ERROR TestReadsCurrentLevelAttributeFromDut_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::LevelControl::Attributes::CurrentLevel::TypeInfo>(
            this, OnSuccessCallback_4, OnFailureCallback_4, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_4(uint8_t currentLevel)
    {
        VerifyOrReturn(CheckValue("currentLevel", currentLevel, 128));

        NextTest();
    }

    CHIP_ERROR TestSendsStepDownCommandToDut_5()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::LevelControl::Commands::Step::Type;

        RequestType request;
        request.stepMode       = static_cast<chip::app::Clusters::LevelControl::StepMode>(1);
        request.stepSize       = 64;
        request.transitionTime = 20U;
        request.optionMask     = 0;
        request.optionOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_LVL_5_1Suite *>(context))->OnSuccessResponse_5();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_LVL_5_1Suite *>(context))->OnFailureResponse_5(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_5() { NextTest(); }

    CHIP_ERROR TestWait4000ms_6()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForMs(4000);
    }

    CHIP_ERROR TestReadsCurrentLevelAttributeFromDut_7()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::LevelControl::Attributes::CurrentLevel::TypeInfo>(
            this, OnSuccessCallback_7, OnFailureCallback_7, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_7(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_7(uint8_t currentLevel)
    {
        VerifyOrReturn(CheckValue("currentLevel", currentLevel, 64));

        NextTest();
    }

    CHIP_ERROR TestSendsAStepUpCommand_8()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::LevelControl::Commands::Step::Type;

        RequestType request;
        request.stepMode       = static_cast<chip::app::Clusters::LevelControl::StepMode>(0);
        request.stepSize       = 64;
        request.transitionTime = 20U;
        request.optionMask     = 0;
        request.optionOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_LVL_5_1Suite *>(context))->OnSuccessResponse_8();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_LVL_5_1Suite *>(context))->OnFailureResponse_8(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_8(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_8() { NextTest(); }

    CHIP_ERROR TestWait4000ms_9()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForMs(4000);
    }

    CHIP_ERROR TestReadsCurrentLevelAttributeFromDut_10()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::LevelControl::Attributes::CurrentLevel::TypeInfo>(
            this, OnSuccessCallback_10, OnFailureCallback_10, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_10(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_10(uint8_t currentLevel)
    {
        VerifyOrReturn(CheckValue("currentLevel", currentLevel, 128));

        NextTest();
    }

    CHIP_ERROR TestResetLevelTo254_11()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::LevelControl::Commands::MoveToLevel::Type;

        RequestType request;
        request.level          = 254;
        request.transitionTime = 0U;
        request.optionMask     = 1;
        request.optionOverride = 1;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_LVL_5_1Suite *>(context))->OnSuccessResponse_11();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_LVL_5_1Suite *>(context))->OnFailureResponse_11(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_11(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_11() { NextTest(); }

    CHIP_ERROR TestWait100ms_12()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForMs(100);
    }

    CHIP_ERROR TestSendingOffCommand_13()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_LVL_5_1Suite *>(context))->OnSuccessResponse_13();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_LVL_5_1Suite *>(context))->OnFailureResponse_13(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_13(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_13() { NextTest(); }
};

class Test_TC_LVL_6_1Suite : public TestCommand
{
public:
    Test_TC_LVL_6_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_LVL_6_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_LVL_6_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_LVL_6_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_LVL_6_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Sending on command\n");
            err = TestSendingOnCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Precondition: set DUT to lowest point\n");
            err = TestPreconditionSetDutToLowestPoint_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Wait 100ms\n");
            err = TestWait100ms_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Reads CurrentLevel attribute from DUT\n");
            err = TestReadsCurrentLevelAttributeFromDut_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Sends a move up command to DUT\n");
            err = TestSendsAMoveUpCommandToDut_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Wait 2000ms\n");
            err = TestWait2000ms_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Sends stop command to DUT\n");
            err = TestSendsStopCommandToDut_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Reads CurrentLevel attribute from DUT\n");
            err = TestReadsCurrentLevelAttributeFromDut_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Reset level to 254\n");
            err = TestResetLevelTo254_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Wait 100ms\n");
            err = TestWait100ms_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : Sending off command\n");
            err = TestSendingOffCommand_11();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 12;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_4(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_LVL_6_1Suite *>(context))->OnFailureResponse_4(error);
    }

    static void OnSuccessCallback_4(void * context, uint8_t currentLevel)
    {
        (static_cast<Test_TC_LVL_6_1Suite *>(context))->OnSuccessResponse_4(currentLevel);
    }

    static void OnFailureCallback_8(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_LVL_6_1Suite *>(context))->OnFailureResponse_8(error);
    }

    static void OnSuccessCallback_8(void * context, uint8_t currentLevel)
    {
        (static_cast<Test_TC_LVL_6_1Suite *>(context))->OnSuccessResponse_8(currentLevel);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestSendingOnCommand_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_LVL_6_1Suite *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_LVL_6_1Suite *>(context))->OnFailureResponse_1(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestPreconditionSetDutToLowestPoint_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::LevelControl::Commands::MoveToLevel::Type;

        RequestType request;
        request.level          = 0;
        request.transitionTime = 0U;
        request.optionMask     = 1;
        request.optionOverride = 1;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_LVL_6_1Suite *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_LVL_6_1Suite *>(context))->OnFailureResponse_2(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestWait100ms_3()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForMs(100);
    }

    CHIP_ERROR TestReadsCurrentLevelAttributeFromDut_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::LevelControl::Attributes::CurrentLevel::TypeInfo>(
            this, OnSuccessCallback_4, OnFailureCallback_4, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_4(uint8_t currentLevel)
    {
        VerifyOrReturn(CheckConstraintMinValue<uint8_t>("currentLevel", currentLevel, 0));
        VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("currentLevel", currentLevel, 1));
        NextTest();
    }

    CHIP_ERROR TestSendsAMoveUpCommandToDut_5()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::LevelControl::Commands::Move::Type;

        RequestType request;
        request.moveMode       = static_cast<chip::app::Clusters::LevelControl::MoveMode>(0);
        request.rate           = 1;
        request.optionMask     = 1;
        request.optionOverride = 1;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_LVL_6_1Suite *>(context))->OnSuccessResponse_5();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_LVL_6_1Suite *>(context))->OnFailureResponse_5(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_5() { NextTest(); }

    CHIP_ERROR TestWait2000ms_6()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForMs(2000);
    }

    CHIP_ERROR TestSendsStopCommandToDut_7()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::LevelControl::Commands::Stop::Type;

        RequestType request;
        request.optionMask     = 0;
        request.optionOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_LVL_6_1Suite *>(context))->OnSuccessResponse_7();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_LVL_6_1Suite *>(context))->OnFailureResponse_7(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_7(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_7() { NextTest(); }

    CHIP_ERROR TestReadsCurrentLevelAttributeFromDut_8()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::LevelControl::Attributes::CurrentLevel::TypeInfo>(
            this, OnSuccessCallback_8, OnFailureCallback_8, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_8(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_8(uint8_t currentLevel)
    {
        VerifyOrReturn(CheckConstraintMinValue<uint8_t>("currentLevel", currentLevel, 2));
        VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("currentLevel", currentLevel, 3));
        NextTest();
    }

    CHIP_ERROR TestResetLevelTo254_9()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::LevelControl::Commands::MoveToLevel::Type;

        RequestType request;
        request.level          = 254;
        request.transitionTime = 0U;
        request.optionMask     = 1;
        request.optionOverride = 1;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_LVL_6_1Suite *>(context))->OnSuccessResponse_9();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_LVL_6_1Suite *>(context))->OnFailureResponse_9(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_9(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_9() { NextTest(); }

    CHIP_ERROR TestWait100ms_10()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForMs(100);
    }

    CHIP_ERROR TestSendingOffCommand_11()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_LVL_6_1Suite *>(context))->OnSuccessResponse_11();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_LVL_6_1Suite *>(context))->OnFailureResponse_11(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_11(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_11() { NextTest(); }
};

class Test_TC_MC_1_1Suite : public TestCommand
{
public:
    Test_TC_MC_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_MC_1_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MC_1_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : read the global attribute: ClusterRevision\n");
            err = TestReadTheGlobalAttributeClusterRevision_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read the global attribute constraints: ClusterRevision\n");
            err = TestReadTheGlobalAttributeConstraintsClusterRevision_2();
            break;
        case 3:
            ChipLogProgress(chipTool,
                            " ***** Test Step 3 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : reads back global attribute: ClusterRevision\n");
            err = TestReadsBackGlobalAttributeClusterRevision_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Read the global attribute: AttributeList\n");
            err = TestReadTheGlobalAttributeAttributeList_5();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 6;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_1(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_MC_1_1Suite *>(context))->OnFailureResponse_1(error);
    }

    static void OnSuccessCallback_1(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_MC_1_1Suite *>(context))->OnSuccessResponse_1(clusterRevision);
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_MC_1_1Suite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_MC_1_1Suite *>(context))->OnSuccessResponse_2(clusterRevision);
    }

    static void OnFailureCallback_3(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_MC_1_1Suite *>(context))->OnFailureResponse_3(error);
    }

    static void OnSuccessCallback_3(void * context) { (static_cast<Test_TC_MC_1_1Suite *>(context))->OnSuccessResponse_3(); }

    static void OnFailureCallback_4(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_MC_1_1Suite *>(context))->OnFailureResponse_4(error);
    }

    static void OnSuccessCallback_4(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_MC_1_1Suite *>(context))->OnSuccessResponse_4(clusterRevision);
    }

    static void OnFailureCallback_5(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_MC_1_1Suite *>(context))->OnFailureResponse_5(error);
    }

    static void OnSuccessCallback_5(void * context, const chip::app::DataModel::DecodableList<chip::AttributeId> & attributeList)
    {
        (static_cast<Test_TC_MC_1_1Suite *>(context))->OnSuccessResponse_5(attributeList);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestReadTheGlobalAttributeClusterRevision_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::MediaInputClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::MediaInput::Attributes::ClusterRevision::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckValue("clusterRevision", clusterRevision, 1U));

        NextTest();
    }

    CHIP_ERROR TestReadTheGlobalAttributeConstraintsClusterRevision_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::MediaInputClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::MediaInput::Attributes::ClusterRevision::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckConstraintType("clusterRevision", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::MediaInputClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t clusterRevisionArgument;
        clusterRevisionArgument = 1U;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::MediaInput::Attributes::ClusterRevision::TypeInfo>(
            clusterRevisionArgument, this, OnSuccessCallback_3, OnFailureCallback_3));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_3() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackGlobalAttributeClusterRevision_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::MediaInputClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::MediaInput::Attributes::ClusterRevision::TypeInfo>(
            this, OnSuccessCallback_4, OnFailureCallback_4, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_4(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckValue("clusterRevision", clusterRevision, 1U));

        NextTest();
    }

    CHIP_ERROR TestReadTheGlobalAttributeAttributeList_5()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::MediaInputClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::MediaInput::Attributes::AttributeList::TypeInfo>(
            this, OnSuccessCallback_5, OnFailureCallback_5, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_5(const chip::app::DataModel::DecodableList<chip::AttributeId> & attributeList)
    {
        VerifyOrReturn(CheckConstraintType("attributeList", "", "list"));
        NextTest();
    }
};

class Test_TC_MC_2_1Suite : public TestCommand
{
public:
    Test_TC_MC_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_MC_2_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MC_2_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Put the device into low power mode\n");
            err = TestPutTheDeviceIntoLowPowerMode_1();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 2;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestPutTheDeviceIntoLowPowerMode_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::LowPower::Commands::Sleep::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_MC_2_1Suite *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_MC_2_1Suite *>(context))->OnFailureResponse_1(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1() { NextTest(); }
};

class Test_TC_MC_3_1Suite : public TestCommand
{
public:
    Test_TC_MC_3_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_MC_3_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MC_3_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_3_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_3_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }
};

class Test_TC_MC_3_2Suite : public TestCommand
{
public:
    Test_TC_MC_3_2Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_MC_3_2", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MC_3_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_3_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_3_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }
};

class Test_TC_MC_3_3Suite : public TestCommand
{
public:
    Test_TC_MC_3_3Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_MC_3_3", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MC_3_3Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_3_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_3_3\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }
};

class Test_TC_MC_3_4Suite : public TestCommand
{
public:
    Test_TC_MC_3_4Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_MC_3_4", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MC_3_4Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_3_4\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_3_4\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }
};

class Test_TC_MC_3_5Suite : public TestCommand
{
public:
    Test_TC_MC_3_5Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_MC_3_5", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MC_3_5Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_3_5\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_3_5\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }
};

class Test_TC_MC_3_6Suite : public TestCommand
{
public:
    Test_TC_MC_3_6Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_MC_3_6", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MC_3_6Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_3_6\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_3_6\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }
};

class Test_TC_MC_3_7Suite : public TestCommand
{
public:
    Test_TC_MC_3_7Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_MC_3_7", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MC_3_7Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_3_7\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_3_7\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }
};

class Test_TC_MC_3_8Suite : public TestCommand
{
public:
    Test_TC_MC_3_8Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_MC_3_8", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MC_3_8Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_3_8\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_3_8\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }
};

class Test_TC_MC_3_9Suite : public TestCommand
{
public:
    Test_TC_MC_3_9Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_MC_3_9", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MC_3_9Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_3_9\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_3_9\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }
};

class Test_TC_MC_3_10Suite : public TestCommand
{
public:
    Test_TC_MC_3_10Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_MC_3_10", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MC_3_10Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_3_10\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_3_10\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }
};

class Test_TC_MC_3_11Suite : public TestCommand
{
public:
    Test_TC_MC_3_11Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_MC_3_11", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MC_3_11Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_3_11\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_3_11\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }
};

class Test_TC_MC_5_1Suite : public TestCommand
{
public:
    Test_TC_MC_5_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_MC_5_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MC_5_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_5_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_5_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Reads the ChannelList attribute from the DUT\n");
            err = TestReadsTheChannelListAttributeFromTheDut_1();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 2;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_1(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_MC_5_1Suite *>(context))->OnFailureResponse_1(error);
    }

    static void OnSuccessCallback_1(
        void * context,
        const chip::app::DataModel::DecodableList<chip::app::Clusters::Channel::Structs::ChannelInfo::DecodableType> & channelList)
    {
        (static_cast<Test_TC_MC_5_1Suite *>(context))->OnSuccessResponse_1(channelList);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestReadsTheChannelListAttributeFromTheDut_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ChannelClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Channel::Attributes::ChannelList::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1(
        const chip::app::DataModel::DecodableList<chip::app::Clusters::Channel::Structs::ChannelInfo::DecodableType> & channelList)
    {
        VerifyOrReturn(CheckConstraintType("channelList", "", "list"));
        NextTest();
    }
};

class Test_TC_MC_5_2Suite : public TestCommand
{
public:
    Test_TC_MC_5_2Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_MC_5_2", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MC_5_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_5_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_5_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : log a command\n");
            err = TestLogACommand_1();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 2;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestLogACommand_1()
    {
        SetIdentity(kIdentityAlpha);
        return UserPrompt("verify that the channel has changed on the device.");
    }
};

class Test_TC_MC_5_3Suite : public TestCommand
{
public:
    Test_TC_MC_5_3Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_MC_5_3", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MC_5_3Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_5_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_5_3\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : log a command\n");
            err = TestLogACommand_1();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 2;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestLogACommand_1()
    {
        SetIdentity(kIdentityAlpha);
        return UserPrompt("verify that the channel has changed on the device");
    }
};

class Test_TC_MC_6_1Suite : public TestCommand
{
public:
    Test_TC_MC_6_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_MC_6_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MC_6_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_6_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_6_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : log a command\n");
            err = TestLogACommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : log a command\n");
            err = TestLogACommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Reads the playback state attribute\n");
            err = TestReadsThePlaybackStateAttribute_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : log a command\n");
            err = TestLogACommand_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : log a command\n");
            err = TestLogACommand_5();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 6;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_3(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_MC_6_1Suite *>(context))->OnFailureResponse_3(error);
    }

    static void OnSuccessCallback_3(void * context, chip::app::Clusters::MediaPlayback::PlaybackStateEnum currentState)
    {
        (static_cast<Test_TC_MC_6_1Suite *>(context))->OnSuccessResponse_3(currentState);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestLogACommand_1()
    {
        SetIdentity(kIdentityAlpha);
        return UserPrompt("Verify that media is paused");
    }

    CHIP_ERROR TestLogACommand_2()
    {
        SetIdentity(kIdentityAlpha);
        return UserPrompt("Physically verify that the media is playing");
    }

    CHIP_ERROR TestReadsThePlaybackStateAttribute_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::MediaPlaybackClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::MediaPlayback::Attributes::CurrentState::TypeInfo>(
            this, OnSuccessCallback_3, OnFailureCallback_3, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3(chip::app::Clusters::MediaPlayback::PlaybackStateEnum currentState)
    {
        VerifyOrReturn(CheckValue("currentState", currentState, 0));

        NextTest();
    }

    CHIP_ERROR TestLogACommand_4()
    {
        SetIdentity(kIdentityAlpha);
        return UserPrompt("Physically verify that the media is paused");
    }

    CHIP_ERROR TestLogACommand_5()
    {
        SetIdentity(kIdentityAlpha);
        return UserPrompt("Physically verify that the media is stoped");
    }
};

class Test_TC_MC_6_2Suite : public TestCommand
{
public:
    Test_TC_MC_6_2Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_MC_6_2", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MC_6_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_6_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_6_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : log a command\n");
            err = TestLogACommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : log a command\n");
            err = TestLogACommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Reads the CurrentState attribute\n");
            err = TestReadsTheCurrentStateAttribute_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : log a command\n");
            err = TestLogACommand_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : log a command\n");
            err = TestLogACommand_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : log a command\n");
            err = TestLogACommand_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : log a command\n");
            err = TestLogACommand_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : log a command\n");
            err = TestLogACommand_8();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 9;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_3(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_MC_6_2Suite *>(context))->OnFailureResponse_3(error);
    }

    static void OnSuccessCallback_3(void * context, chip::app::Clusters::MediaPlayback::PlaybackStateEnum currentState)
    {
        (static_cast<Test_TC_MC_6_2Suite *>(context))->OnSuccessResponse_3(currentState);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestLogACommand_1()
    {
        SetIdentity(kIdentityAlpha);
        return UserPrompt("Verify that media is paused");
    }

    CHIP_ERROR TestLogACommand_2()
    {
        SetIdentity(kIdentityAlpha);
        return UserPrompt("Physically verify that the media is playing");
    }

    CHIP_ERROR TestReadsTheCurrentStateAttribute_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::MediaPlaybackClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::MediaPlayback::Attributes::CurrentState::TypeInfo>(
            this, OnSuccessCallback_3, OnFailureCallback_3, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3(chip::app::Clusters::MediaPlayback::PlaybackStateEnum currentState)
    {
        VerifyOrReturn(CheckValue("currentState", currentState, 0));

        NextTest();
    }

    CHIP_ERROR TestLogACommand_4()
    {
        SetIdentity(kIdentityAlpha);
        return UserPrompt("Physically verify that the media is started over");
    }

    CHIP_ERROR TestLogACommand_5()
    {
        SetIdentity(kIdentityAlpha);
        return UserPrompt("Verify that the next media item in the queue has been loaded");
    }

    CHIP_ERROR TestLogACommand_6()
    {
        SetIdentity(kIdentityAlpha);
        return UserPrompt("Verify that the previous media item in the queue has been loaded");
    }

    CHIP_ERROR TestLogACommand_7()
    {
        SetIdentity(kIdentityAlpha);
        return UserPrompt("Verify that the media has skipped forward 10 seconds");
    }

    CHIP_ERROR TestLogACommand_8()
    {
        SetIdentity(kIdentityAlpha);
        return UserPrompt("Verify that the media has skipped backward 10 seconds");
    }
};

class Test_TC_MC_6_3Suite : public TestCommand
{
public:
    Test_TC_MC_6_3Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_MC_6_3", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MC_6_3Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_6_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_6_3\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : log a command\n");
            err = TestLogACommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : log a command\n");
            err = TestLogACommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : log a command\n");
            err = TestLogACommand_3();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 4;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestLogACommand_1()
    {
        SetIdentity(kIdentityAlpha);
        return UserPrompt("Verify that media is paused");
    }

    CHIP_ERROR TestLogACommand_2()
    {
        SetIdentity(kIdentityAlpha);
        return UserPrompt("Verify that the media has moved to 10 seconds from the starting point.");
    }

    CHIP_ERROR TestLogACommand_3()
    {
        SetIdentity(kIdentityAlpha);
        return UserPrompt("User prompt needed to enter the value beyond the furthest valid position");
    }
};

class Test_TC_MC_6_4Suite : public TestCommand
{
public:
    Test_TC_MC_6_4Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_MC_6_4", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MC_6_4Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_6_4\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_6_4\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : log a command\n");
            err = TestLogACommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Reads the PlaybackSpeed attribute from the DUT\n");
            err = TestReadsThePlaybackSpeedAttributeFromTheDut_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : log a command\n");
            err = TestLogACommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Reads the CurrentState attribute\n");
            err = TestReadsTheCurrentStateAttribute_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : log a command\n");
            err = TestLogACommand_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : log a command\n");
            err = TestLogACommand_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Reads the CurrentState attribute\n");
            err = TestReadsTheCurrentStateAttribute_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : log a command\n");
            err = TestLogACommand_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : log a command\n");
            err = TestLogACommand_9();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 10;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_MC_6_4Suite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context, float playbackSpeed)
    {
        (static_cast<Test_TC_MC_6_4Suite *>(context))->OnSuccessResponse_2(playbackSpeed);
    }

    static void OnFailureCallback_4(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_MC_6_4Suite *>(context))->OnFailureResponse_4(error);
    }

    static void OnSuccessCallback_4(void * context, chip::app::Clusters::MediaPlayback::PlaybackStateEnum currentState)
    {
        (static_cast<Test_TC_MC_6_4Suite *>(context))->OnSuccessResponse_4(currentState);
    }

    static void OnFailureCallback_7(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_MC_6_4Suite *>(context))->OnFailureResponse_7(error);
    }

    static void OnSuccessCallback_7(void * context, chip::app::Clusters::MediaPlayback::PlaybackStateEnum currentState)
    {
        (static_cast<Test_TC_MC_6_4Suite *>(context))->OnSuccessResponse_7(currentState);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestLogACommand_1()
    {
        SetIdentity(kIdentityAlpha);
        return UserPrompt("Verify that media is paused");
    }

    CHIP_ERROR TestReadsThePlaybackSpeedAttributeFromTheDut_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::MediaPlaybackClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::MediaPlayback::Attributes::PlaybackSpeed::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2(float playbackSpeed)
    {
        VerifyOrReturn(CheckValue("playbackSpeed", playbackSpeed, 0.0f));

        NextTest();
    }

    CHIP_ERROR TestLogACommand_3()
    {
        SetIdentity(kIdentityAlpha);
        return UserPrompt("Verify that the media is playing");
    }

    CHIP_ERROR TestReadsTheCurrentStateAttribute_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::MediaPlaybackClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::MediaPlayback::Attributes::CurrentState::TypeInfo>(
            this, OnSuccessCallback_4, OnFailureCallback_4, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_4(chip::app::Clusters::MediaPlayback::PlaybackStateEnum currentState)
    {
        VerifyOrReturn(CheckValue("currentState", currentState, 0));

        NextTest();
    }

    CHIP_ERROR TestLogACommand_5()
    {
        SetIdentity(kIdentityAlpha);
        return UserPrompt("Verify that the media play speed has increased");
    }

    CHIP_ERROR TestLogACommand_6()
    {
        SetIdentity(kIdentityAlpha);
        return UserPrompt("Verify that the media play has reversed direction");
    }

    CHIP_ERROR TestReadsTheCurrentStateAttribute_7()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::MediaPlaybackClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::MediaPlayback::Attributes::CurrentState::TypeInfo>(
            this, OnSuccessCallback_7, OnFailureCallback_7, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_7(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_7(chip::app::Clusters::MediaPlayback::PlaybackStateEnum currentState)
    {
        VerifyOrReturn(CheckValue("currentState", currentState, 0));

        NextTest();
    }

    CHIP_ERROR TestLogACommand_8()
    {
        SetIdentity(kIdentityAlpha);
        return UserPrompt("Verify that the media play has reversed direction");
    }

    CHIP_ERROR TestLogACommand_9()
    {
        SetIdentity(kIdentityAlpha);
        return UserPrompt("Verify that the media is has resumed playing forward at the default speed");
    }
};

class Test_TC_MC_7_1Suite : public TestCommand
{
public:
    Test_TC_MC_7_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_MC_7_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MC_7_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_7_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_7_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }
};

class Test_TC_MC_7_2Suite : public TestCommand
{
public:
    Test_TC_MC_7_2Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_MC_7_2", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MC_7_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_7_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_7_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }
};

class Test_TC_MC_8_1Suite : public TestCommand
{
public:
    Test_TC_MC_8_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_MC_8_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MC_8_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_8_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_8_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Reads the CurrentTarget attribute\n");
            err = TestReadsTheCurrentTargetAttribute_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Reads the TargetList attribute\n");
            err = TestReadsTheTargetListAttribute_2();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 3;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_1(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_MC_8_1Suite *>(context))->OnFailureResponse_1(error);
    }

    static void OnSuccessCallback_1(void * context, uint8_t currentTarget)
    {
        (static_cast<Test_TC_MC_8_1Suite *>(context))->OnSuccessResponse_1(currentTarget);
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_MC_8_1Suite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(
        void * context,
        const chip::app::DataModel::DecodableList<chip::app::Clusters::TargetNavigator::Structs::TargetInfo::DecodableType> &
            targetList)
    {
        (static_cast<Test_TC_MC_8_1Suite *>(context))->OnSuccessResponse_2(targetList);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestReadsTheCurrentTargetAttribute_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TargetNavigatorClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TargetNavigator::Attributes::CurrentTarget::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1(uint8_t currentTarget)
    {
        VerifyOrReturn(CheckConstraintType("currentTarget", "", "uint8"));
        NextTest();
    }

    CHIP_ERROR TestReadsTheTargetListAttribute_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TargetNavigatorClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TargetNavigator::Attributes::TargetList::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2(
        const chip::app::DataModel::DecodableList<chip::app::Clusters::TargetNavigator::Structs::TargetInfo::DecodableType> &
            targetList)
    {
        VerifyOrReturn(CheckConstraintType("targetList", "", "list"));
        NextTest();
    }
};

class Test_TC_MC_9_1Suite : public TestCommand
{
public:
    Test_TC_MC_9_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_MC_9_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MC_9_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_9_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_9_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Precondition\n");
            err = TestPrecondition_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Reads the VendorName attribute\n");
            err = TestReadsTheVendorNameAttribute_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Reads the VendorID attribute\n");
            err = TestReadsTheVendorIDAttribute_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Reads the ApplicationName attribute\n");
            err = TestReadsTheApplicationNameAttribute_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Reads the ProductID attribute\n");
            err = TestReadsTheProductIDAttribute_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Reads the Status attribute\n");
            err = TestReadsTheStatusAttribute_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Reads the ApplicationVersion attribute\n");
            err = TestReadsTheApplicationVersionAttribute_7();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 8;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_MC_9_1Suite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context, chip::CharSpan vendorName)
    {
        (static_cast<Test_TC_MC_9_1Suite *>(context))->OnSuccessResponse_2(vendorName);
    }

    static void OnFailureCallback_3(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_MC_9_1Suite *>(context))->OnFailureResponse_3(error);
    }

    static void OnSuccessCallback_3(void * context, uint16_t vendorID)
    {
        (static_cast<Test_TC_MC_9_1Suite *>(context))->OnSuccessResponse_3(vendorID);
    }

    static void OnFailureCallback_4(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_MC_9_1Suite *>(context))->OnFailureResponse_4(error);
    }

    static void OnSuccessCallback_4(void * context, chip::CharSpan applicationName)
    {
        (static_cast<Test_TC_MC_9_1Suite *>(context))->OnSuccessResponse_4(applicationName);
    }

    static void OnFailureCallback_5(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_MC_9_1Suite *>(context))->OnFailureResponse_5(error);
    }

    static void OnSuccessCallback_5(void * context, uint16_t productID)
    {
        (static_cast<Test_TC_MC_9_1Suite *>(context))->OnSuccessResponse_5(productID);
    }

    static void OnFailureCallback_6(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_MC_9_1Suite *>(context))->OnFailureResponse_6(error);
    }

    static void OnSuccessCallback_6(void * context, chip::app::Clusters::ApplicationBasic::ApplicationStatusEnum status)
    {
        (static_cast<Test_TC_MC_9_1Suite *>(context))->OnSuccessResponse_6(status);
    }

    static void OnFailureCallback_7(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_MC_9_1Suite *>(context))->OnFailureResponse_7(error);
    }

    static void OnSuccessCallback_7(void * context, chip::CharSpan applicationVersion)
    {
        (static_cast<Test_TC_MC_9_1Suite *>(context))->OnSuccessResponse_7(applicationVersion);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestPrecondition_1()
    {
        SetIdentity(kIdentityAlpha);
        return Log("DUT has one or more Content Apps available");
    }

    CHIP_ERROR TestReadsTheVendorNameAttribute_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ApplicationBasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ApplicationBasic::Attributes::VendorName::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2(chip::CharSpan vendorName)
    {
        VerifyOrReturn(CheckConstraintType("vendorName", "", "string"));
        NextTest();
    }

    CHIP_ERROR TestReadsTheVendorIDAttribute_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ApplicationBasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ApplicationBasic::Attributes::VendorID::TypeInfo>(
            this, OnSuccessCallback_3, OnFailureCallback_3, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3(uint16_t vendorID)
    {
        VerifyOrReturn(CheckValue("vendorID", vendorID, 0U));
        VerifyOrReturn(CheckConstraintType("vendorID", "", "vendor-id"));
        NextTest();
    }

    CHIP_ERROR TestReadsTheApplicationNameAttribute_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ApplicationBasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ApplicationBasic::Attributes::ApplicationName::TypeInfo>(
            this, OnSuccessCallback_4, OnFailureCallback_4, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_4(chip::CharSpan applicationName)
    {
        VerifyOrReturn(CheckConstraintType("applicationName", "", "string"));
        VerifyOrReturn(CheckConstraintMaxLength("applicationName", applicationName.size(), 256));
        NextTest();
    }

    CHIP_ERROR TestReadsTheProductIDAttribute_5()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ApplicationBasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ApplicationBasic::Attributes::ProductID::TypeInfo>(
            this, OnSuccessCallback_5, OnFailureCallback_5, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_5(uint16_t productID)
    {
        VerifyOrReturn(CheckConstraintType("productID", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestReadsTheStatusAttribute_6()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ApplicationBasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ApplicationBasic::Attributes::Status::TypeInfo>(
            this, OnSuccessCallback_6, OnFailureCallback_6, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_6(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_6(chip::app::Clusters::ApplicationBasic::ApplicationStatusEnum status)
    {
        VerifyOrReturn(CheckValue("status", status, 0));

        NextTest();
    }

    CHIP_ERROR TestReadsTheApplicationVersionAttribute_7()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ApplicationBasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ApplicationBasic::Attributes::ApplicationVersion::TypeInfo>(
            this, OnSuccessCallback_7, OnFailureCallback_7, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_7(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_7(chip::CharSpan applicationVersion)
    {
        VerifyOrReturn(CheckConstraintType("applicationVersion", "", "string"));
        VerifyOrReturn(CheckConstraintMaxLength("applicationVersion", applicationVersion.size(), 32));
        NextTest();
    }
};

class Test_TC_OCC_1_1Suite : public TestCommand
{
public:
    Test_TC_OCC_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_OCC_1_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_OCC_1_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_OCC_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_OCC_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read the global attribute constraints: ClusterRevision\n");
            err = TestReadTheGlobalAttributeConstraintsClusterRevision_1();
            break;
        case 2:
            ChipLogProgress(chipTool,
                            " ***** Test Step 2 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read the global attribute: AttributeList\n");
            err = TestReadTheGlobalAttributeAttributeList_3();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 4;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_1(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_OCC_1_1Suite *>(context))->OnFailureResponse_1(error);
    }

    static void OnSuccessCallback_1(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_OCC_1_1Suite *>(context))->OnSuccessResponse_1(clusterRevision);
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_OCC_1_1Suite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context) { (static_cast<Test_TC_OCC_1_1Suite *>(context))->OnSuccessResponse_2(); }

    static void OnFailureCallback_3(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_OCC_1_1Suite *>(context))->OnFailureResponse_3(error);
    }

    static void OnSuccessCallback_3(void * context, const chip::app::DataModel::DecodableList<chip::AttributeId> & attributeList)
    {
        (static_cast<Test_TC_OCC_1_1Suite *>(context))->OnSuccessResponse_3(attributeList);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestReadTheGlobalAttributeConstraintsClusterRevision_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OccupancySensingClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OccupancySensing::Attributes::ClusterRevision::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckConstraintType("clusterRevision", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OccupancySensingClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t clusterRevisionArgument;
        clusterRevisionArgument = 3U;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::OccupancySensing::Attributes::ClusterRevision::TypeInfo>(
            clusterRevisionArgument, this, OnSuccessCallback_2, OnFailureCallback_2));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_2() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadTheGlobalAttributeAttributeList_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OccupancySensingClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OccupancySensing::Attributes::AttributeList::TypeInfo>(
            this, OnSuccessCallback_3, OnFailureCallback_3, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3(const chip::app::DataModel::DecodableList<chip::AttributeId> & attributeList)
    {
        VerifyOrReturn(CheckConstraintType("attributeList", "", "list"));
        NextTest();
    }
};

class Test_TC_OCC_2_1Suite : public TestCommand
{
public:
    Test_TC_OCC_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_OCC_2_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_OCC_2_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_OCC_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_OCC_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Reads mandatory attribute constrains: Occupancy\n");
            err = TestReadsMandatoryAttributeConstrainsOccupancy_1();
            break;
        case 2:
            ChipLogProgress(chipTool,
                            " ***** Test Step 2 : Writes the respective default value to mandatory attribute: Occupancy\n");
            err = TestWritesTheRespectiveDefaultValueToMandatoryAttributeOccupancy_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Reads back mandatory attribute: Occupancy\n");
            err = TestReadsBackMandatoryAttributeOccupancy_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Reads mandatory attribute constrains: OccupancySensorType\n");
            err = TestReadsMandatoryAttributeConstrainsOccupancySensorType_4();
            break;
        case 5:
            ChipLogProgress(
                chipTool, " ***** Test Step 5 : Writes the respective default value to mandatory attribute: OccupancySensorType\n");
            err = TestWritesTheRespectiveDefaultValueToMandatoryAttributeOccupancySensorType_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Reads back mandatory attribute: OccupancySensorType\n");
            err = TestReadsBackMandatoryAttributeOccupancySensorType_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Reads mandatory attribute constrains: OccupancySensorTypeBitmap\n");
            err = TestReadsMandatoryAttributeConstrainsOccupancySensorTypeBitmap_7();
            break;
        case 8:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 8 : Writes the respective default value to mandatory attribute: OccupancySensorTypeBitmap\n");
            err = TestWritesTheRespectiveDefaultValueToMandatoryAttributeOccupancySensorTypeBitmap_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Reads back mandatory attribute: OccupancySensorTypeBitmap\n");
            err = TestReadsBackMandatoryAttributeOccupancySensorTypeBitmap_9();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 10;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_1(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_OCC_2_1Suite *>(context))->OnFailureResponse_1(error);
    }

    static void OnSuccessCallback_1(void * context, uint8_t occupancy)
    {
        (static_cast<Test_TC_OCC_2_1Suite *>(context))->OnSuccessResponse_1(occupancy);
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_OCC_2_1Suite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context) { (static_cast<Test_TC_OCC_2_1Suite *>(context))->OnSuccessResponse_2(); }

    static void OnFailureCallback_3(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_OCC_2_1Suite *>(context))->OnFailureResponse_3(error);
    }

    static void OnSuccessCallback_3(void * context, uint8_t occupancy)
    {
        (static_cast<Test_TC_OCC_2_1Suite *>(context))->OnSuccessResponse_3(occupancy);
    }

    static void OnFailureCallback_4(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_OCC_2_1Suite *>(context))->OnFailureResponse_4(error);
    }

    static void OnSuccessCallback_4(void * context, uint8_t occupancySensorType)
    {
        (static_cast<Test_TC_OCC_2_1Suite *>(context))->OnSuccessResponse_4(occupancySensorType);
    }

    static void OnFailureCallback_5(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_OCC_2_1Suite *>(context))->OnFailureResponse_5(error);
    }

    static void OnSuccessCallback_5(void * context) { (static_cast<Test_TC_OCC_2_1Suite *>(context))->OnSuccessResponse_5(); }

    static void OnFailureCallback_6(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_OCC_2_1Suite *>(context))->OnFailureResponse_6(error);
    }

    static void OnSuccessCallback_6(void * context, uint8_t occupancySensorType)
    {
        (static_cast<Test_TC_OCC_2_1Suite *>(context))->OnSuccessResponse_6(occupancySensorType);
    }

    static void OnFailureCallback_7(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_OCC_2_1Suite *>(context))->OnFailureResponse_7(error);
    }

    static void OnSuccessCallback_7(void * context, uint8_t occupancySensorTypeBitmap)
    {
        (static_cast<Test_TC_OCC_2_1Suite *>(context))->OnSuccessResponse_7(occupancySensorTypeBitmap);
    }

    static void OnFailureCallback_8(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_OCC_2_1Suite *>(context))->OnFailureResponse_8(error);
    }

    static void OnSuccessCallback_8(void * context) { (static_cast<Test_TC_OCC_2_1Suite *>(context))->OnSuccessResponse_8(); }

    static void OnFailureCallback_9(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_OCC_2_1Suite *>(context))->OnFailureResponse_9(error);
    }

    static void OnSuccessCallback_9(void * context, uint8_t occupancySensorTypeBitmap)
    {
        (static_cast<Test_TC_OCC_2_1Suite *>(context))->OnSuccessResponse_9(occupancySensorTypeBitmap);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestReadsMandatoryAttributeConstrainsOccupancy_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OccupancySensingClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OccupancySensing::Attributes::Occupancy::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1(uint8_t occupancy)
    {
        VerifyOrReturn(CheckConstraintType("occupancy", "", "map8"));
        VerifyOrReturn(CheckConstraintMinValue<uint8_t>("occupancy", occupancy, 0));
        VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("occupancy", occupancy, 1));
        NextTest();
    }

    CHIP_ERROR TestWritesTheRespectiveDefaultValueToMandatoryAttributeOccupancy_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OccupancySensingClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t occupancyArgument;
        occupancyArgument = 0;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::OccupancySensing::Attributes::Occupancy::TypeInfo>(
            occupancyArgument, this, OnSuccessCallback_2, OnFailureCallback_2));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_2() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackMandatoryAttributeOccupancy_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OccupancySensingClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OccupancySensing::Attributes::Occupancy::TypeInfo>(
            this, OnSuccessCallback_3, OnFailureCallback_3, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3(uint8_t occupancy)
    {
        VerifyOrReturn(CheckValue("occupancy", occupancy, 0));

        NextTest();
    }

    CHIP_ERROR TestReadsMandatoryAttributeConstrainsOccupancySensorType_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OccupancySensingClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::OccupancySensing::Attributes::OccupancySensorType::TypeInfo>(
                this, OnSuccessCallback_4, OnFailureCallback_4, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_4(uint8_t occupancySensorType)
    {
        VerifyOrReturn(CheckConstraintType("occupancySensorType", "", "enum8"));
        VerifyOrReturn(CheckConstraintMinValue<uint8_t>("occupancySensorType", occupancySensorType, 0));
        VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("occupancySensorType", occupancySensorType, 3));
        NextTest();
    }

    CHIP_ERROR TestWritesTheRespectiveDefaultValueToMandatoryAttributeOccupancySensorType_5()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OccupancySensingClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t occupancySensorTypeArgument;
        occupancySensorTypeArgument = 0;

        ReturnErrorOnFailure(
            cluster.WriteAttribute<chip::app::Clusters::OccupancySensing::Attributes::OccupancySensorType::TypeInfo>(
                occupancySensorTypeArgument, this, OnSuccessCallback_5, OnFailureCallback_5));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_5() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackMandatoryAttributeOccupancySensorType_6()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OccupancySensingClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::OccupancySensing::Attributes::OccupancySensorType::TypeInfo>(
                this, OnSuccessCallback_6, OnFailureCallback_6, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_6(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_6(uint8_t occupancySensorType)
    {
        VerifyOrReturn(CheckValue("occupancySensorType", occupancySensorType, 0));

        NextTest();
    }

    CHIP_ERROR TestReadsMandatoryAttributeConstrainsOccupancySensorTypeBitmap_7()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OccupancySensingClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::OccupancySensing::Attributes::OccupancySensorTypeBitmap::TypeInfo>(
                this, OnSuccessCallback_7, OnFailureCallback_7, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_7(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_7(uint8_t occupancySensorTypeBitmap)
    {
        VerifyOrReturn(CheckConstraintType("occupancySensorTypeBitmap", "", "map8"));
        VerifyOrReturn(CheckConstraintMinValue<uint8_t>("occupancySensorTypeBitmap", occupancySensorTypeBitmap, 1));
        VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("occupancySensorTypeBitmap", occupancySensorTypeBitmap, 7));
        NextTest();
    }

    CHIP_ERROR TestWritesTheRespectiveDefaultValueToMandatoryAttributeOccupancySensorTypeBitmap_8()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OccupancySensingClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t occupancySensorTypeBitmapArgument;
        occupancySensorTypeBitmapArgument = 1;

        ReturnErrorOnFailure(
            cluster.WriteAttribute<chip::app::Clusters::OccupancySensing::Attributes::OccupancySensorTypeBitmap::TypeInfo>(
                occupancySensorTypeBitmapArgument, this, OnSuccessCallback_8, OnFailureCallback_8));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_8(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_8() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackMandatoryAttributeOccupancySensorTypeBitmap_9()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OccupancySensingClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::OccupancySensing::Attributes::OccupancySensorTypeBitmap::TypeInfo>(
                this, OnSuccessCallback_9, OnFailureCallback_9, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_9(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_9(uint8_t occupancySensorTypeBitmap)
    {
        VerifyOrReturn(CheckValue("occupancySensorTypeBitmap", occupancySensorTypeBitmap, 1));

        NextTest();
    }
};

class Test_TC_OCC_2_2Suite : public TestCommand
{
public:
    Test_TC_OCC_2_2Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_OCC_2_2", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_OCC_2_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_OCC_2_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_OCC_2_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Reads Occupancy attribute from DUT\n");
            if (ShouldSkip("A_OCCUPANCY"))
            {
                NextTest();
                return;
            }
            err = TestReadsOccupancyAttributeFromDut_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Reads Occupancy attribute from DUT\n");
            if (ShouldSkip("A_OCCUPANCY"))
            {
                NextTest();
                return;
            }
            err = TestReadsOccupancyAttributeFromDut_2();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 3;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_1(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_OCC_2_2Suite *>(context))->OnFailureResponse_1(error);
    }

    static void OnSuccessCallback_1(void * context, uint8_t occupancy)
    {
        (static_cast<Test_TC_OCC_2_2Suite *>(context))->OnSuccessResponse_1(occupancy);
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_OCC_2_2Suite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context, uint8_t occupancy)
    {
        (static_cast<Test_TC_OCC_2_2Suite *>(context))->OnSuccessResponse_2(occupancy);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestReadsOccupancyAttributeFromDut_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OccupancySensingClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OccupancySensing::Attributes::Occupancy::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1(uint8_t occupancy)
    {
        VerifyOrReturn(CheckConstraintType("occupancy", "", "map8"));
        NextTest();
    }

    CHIP_ERROR TestReadsOccupancyAttributeFromDut_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OccupancySensingClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OccupancySensing::Attributes::Occupancy::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2(uint8_t occupancy)
    {
        VerifyOrReturn(CheckConstraintType("occupancy", "", "map8"));
        NextTest();
    }
};

class Test_TC_OO_1_1Suite : public TestCommand
{
public:
    Test_TC_OO_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_OO_1_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_OO_1_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_OO_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_OO_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : read the global attribute: ClusterRevision\n");
            err = TestReadTheGlobalAttributeClusterRevision_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read the global attribute constraints: ClusterRevision\n");
            err = TestReadTheGlobalAttributeConstraintsClusterRevision_2();
            break;
        case 3:
            ChipLogProgress(chipTool,
                            " ***** Test Step 3 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : reads back global attribute: ClusterRevision\n");
            err = TestReadsBackGlobalAttributeClusterRevision_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Read the global attribute: AttributeList\n");
            err = TestReadTheGlobalAttributeAttributeList_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : read the optional global attribute: FeatureMap\n");
            err = TestReadTheOptionalGlobalAttributeFeatureMap_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Read the optional global attribute : FeatureMap\n");
            err = TestReadTheOptionalGlobalAttributeFeatureMap_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : write the default values to optional global attribute: FeatureMap\n");
            err = TestWriteTheDefaultValuesToOptionalGlobalAttributeFeatureMap_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : reads back optional global attribute: FeatureMap\n");
            err = TestReadsBackOptionalGlobalAttributeFeatureMap_9();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 10;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_1(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_OO_1_1Suite *>(context))->OnFailureResponse_1(error);
    }

    static void OnSuccessCallback_1(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_OO_1_1Suite *>(context))->OnSuccessResponse_1(clusterRevision);
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_OO_1_1Suite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_OO_1_1Suite *>(context))->OnSuccessResponse_2(clusterRevision);
    }

    static void OnFailureCallback_3(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_OO_1_1Suite *>(context))->OnFailureResponse_3(error);
    }

    static void OnSuccessCallback_3(void * context) { (static_cast<Test_TC_OO_1_1Suite *>(context))->OnSuccessResponse_3(); }

    static void OnFailureCallback_4(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_OO_1_1Suite *>(context))->OnFailureResponse_4(error);
    }

    static void OnSuccessCallback_4(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_OO_1_1Suite *>(context))->OnSuccessResponse_4(clusterRevision);
    }

    static void OnFailureCallback_5(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_OO_1_1Suite *>(context))->OnFailureResponse_5(error);
    }

    static void OnSuccessCallback_5(void * context, const chip::app::DataModel::DecodableList<chip::AttributeId> & attributeList)
    {
        (static_cast<Test_TC_OO_1_1Suite *>(context))->OnSuccessResponse_5(attributeList);
    }

    static void OnFailureCallback_6(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_OO_1_1Suite *>(context))->OnFailureResponse_6(error);
    }

    static void OnSuccessCallback_6(void * context, uint32_t featureMap)
    {
        (static_cast<Test_TC_OO_1_1Suite *>(context))->OnSuccessResponse_6(featureMap);
    }

    static void OnFailureCallback_7(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_OO_1_1Suite *>(context))->OnFailureResponse_7(error);
    }

    static void OnSuccessCallback_7(void * context, uint32_t featureMap)
    {
        (static_cast<Test_TC_OO_1_1Suite *>(context))->OnSuccessResponse_7(featureMap);
    }

    static void OnFailureCallback_8(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_OO_1_1Suite *>(context))->OnFailureResponse_8(error);
    }

    static void OnSuccessCallback_8(void * context) { (static_cast<Test_TC_OO_1_1Suite *>(context))->OnSuccessResponse_8(); }

    static void OnFailureCallback_9(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_OO_1_1Suite *>(context))->OnFailureResponse_9(error);
    }

    static void OnSuccessCallback_9(void * context, uint32_t featureMap)
    {
        (static_cast<Test_TC_OO_1_1Suite *>(context))->OnSuccessResponse_9(featureMap);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestReadTheGlobalAttributeClusterRevision_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::ClusterRevision::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckValue("clusterRevision", clusterRevision, 4U));

        NextTest();
    }

    CHIP_ERROR TestReadTheGlobalAttributeConstraintsClusterRevision_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::ClusterRevision::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckConstraintType("clusterRevision", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t clusterRevisionArgument;
        clusterRevisionArgument = 3U;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::OnOff::Attributes::ClusterRevision::TypeInfo>(
            clusterRevisionArgument, this, OnSuccessCallback_3, OnFailureCallback_3));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_3() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackGlobalAttributeClusterRevision_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::ClusterRevision::TypeInfo>(
            this, OnSuccessCallback_4, OnFailureCallback_4, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_4(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckValue("clusterRevision", clusterRevision, 4U));

        NextTest();
    }

    CHIP_ERROR TestReadTheGlobalAttributeAttributeList_5()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::AttributeList::TypeInfo>(
            this, OnSuccessCallback_5, OnFailureCallback_5, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_5(const chip::app::DataModel::DecodableList<chip::AttributeId> & attributeList)
    {
        VerifyOrReturn(CheckConstraintType("attributeList", "", "list"));
        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalGlobalAttributeFeatureMap_6()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::FeatureMap::TypeInfo>(
            this, OnSuccessCallback_6, OnFailureCallback_6, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_6(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_6(uint32_t featureMap)
    {
        VerifyOrReturn(CheckValue("featureMap", featureMap, 0UL));

        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalGlobalAttributeFeatureMap_7()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::FeatureMap::TypeInfo>(
            this, OnSuccessCallback_7, OnFailureCallback_7, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_7(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_7(uint32_t featureMap)
    {
        VerifyOrReturn(CheckConstraintType("featureMap", "", "map32"));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToOptionalGlobalAttributeFeatureMap_8()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint32_t featureMapArgument;
        featureMapArgument = 0UL;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::OnOff::Attributes::FeatureMap::TypeInfo>(
            featureMapArgument, this, OnSuccessCallback_8, OnFailureCallback_8));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_8(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_8() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackOptionalGlobalAttributeFeatureMap_9()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::FeatureMap::TypeInfo>(
            this, OnSuccessCallback_9, OnFailureCallback_9, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_9(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_9(uint32_t featureMap)
    {
        VerifyOrReturn(CheckValue("featureMap", featureMap, 0UL));

        NextTest();
    }
};

class Test_TC_OO_2_1Suite : public TestCommand
{
public:
    Test_TC_OO_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_OO_2_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_OO_2_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_OO_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_OO_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : read the mandatory attribute: OnOff\n");
            err = TestReadTheMandatoryAttributeOnOff_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : write the default value of mandatory attribute: OnOff\n");
            err = TestWriteTheDefaultValueOfMandatoryAttributeOnOff_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : reads back mandatory attribute: OnOff\n");
            err = TestReadsBackMandatoryAttributeOnOff_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : read LT attribute: GlobalSceneControl\n");
            err = TestReadLtAttributeGlobalSceneControl_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : read LT attribute: OnTime\n");
            err = TestReadLtAttributeOnTime_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : read LT attribute: OffWaitTime\n");
            err = TestReadLtAttributeOffWaitTime_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : read LT attribute: StartUpOnOff\n");
            err = TestReadLtAttributeStartUpOnOff_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : write the default value to LT attribute: GlobalSceneControl\n");
            err = TestWriteTheDefaultValueToLtAttributeGlobalSceneControl_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : write the default value to LT attribute: OnTime\n");
            err = TestWriteTheDefaultValueToLtAttributeOnTime_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : write the default value to LT attribute: OffWaitTime\n");
            err = TestWriteTheDefaultValueToLtAttributeOffWaitTime_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : write the default value to LT attribute: StartUpOnOff\n");
            err = TestWriteTheDefaultValueToLtAttributeStartUpOnOff_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : reads back LT attribute: GlobalSceneControl\n");
            err = TestReadsBackLtAttributeGlobalSceneControl_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : reads back LT attribute: OnTime\n");
            err = TestReadsBackLtAttributeOnTime_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : reads back LT attribute: OffWaitTime\n");
            err = TestReadsBackLtAttributeOffWaitTime_14();
            break;
        case 15:
            ChipLogProgress(chipTool, " ***** Test Step 15 : reads back LT attribute: StartUpOnOff\n");
            err = TestReadsBackLtAttributeStartUpOnOff_15();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 16;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_1(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_OO_2_1Suite *>(context))->OnFailureResponse_1(error);
    }

    static void OnSuccessCallback_1(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_1Suite *>(context))->OnSuccessResponse_1(onOff);
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_OO_2_1Suite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context) { (static_cast<Test_TC_OO_2_1Suite *>(context))->OnSuccessResponse_2(); }

    static void OnFailureCallback_3(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_OO_2_1Suite *>(context))->OnFailureResponse_3(error);
    }

    static void OnSuccessCallback_3(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_1Suite *>(context))->OnSuccessResponse_3(onOff);
    }

    static void OnFailureCallback_4(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_OO_2_1Suite *>(context))->OnFailureResponse_4(error);
    }

    static void OnSuccessCallback_4(void * context, bool globalSceneControl)
    {
        (static_cast<Test_TC_OO_2_1Suite *>(context))->OnSuccessResponse_4(globalSceneControl);
    }

    static void OnFailureCallback_5(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_OO_2_1Suite *>(context))->OnFailureResponse_5(error);
    }

    static void OnSuccessCallback_5(void * context, uint16_t onTime)
    {
        (static_cast<Test_TC_OO_2_1Suite *>(context))->OnSuccessResponse_5(onTime);
    }

    static void OnFailureCallback_6(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_OO_2_1Suite *>(context))->OnFailureResponse_6(error);
    }

    static void OnSuccessCallback_6(void * context, uint16_t offWaitTime)
    {
        (static_cast<Test_TC_OO_2_1Suite *>(context))->OnSuccessResponse_6(offWaitTime);
    }

    static void OnFailureCallback_7(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_OO_2_1Suite *>(context))->OnFailureResponse_7(error);
    }

    static void OnSuccessCallback_7(void * context, uint8_t startUpOnOff)
    {
        (static_cast<Test_TC_OO_2_1Suite *>(context))->OnSuccessResponse_7(startUpOnOff);
    }

    static void OnFailureCallback_8(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_OO_2_1Suite *>(context))->OnFailureResponse_8(error);
    }

    static void OnSuccessCallback_8(void * context) { (static_cast<Test_TC_OO_2_1Suite *>(context))->OnSuccessResponse_8(); }

    static void OnFailureCallback_9(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_OO_2_1Suite *>(context))->OnFailureResponse_9(error);
    }

    static void OnSuccessCallback_9(void * context) { (static_cast<Test_TC_OO_2_1Suite *>(context))->OnSuccessResponse_9(); }

    static void OnFailureCallback_10(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_OO_2_1Suite *>(context))->OnFailureResponse_10(error);
    }

    static void OnSuccessCallback_10(void * context) { (static_cast<Test_TC_OO_2_1Suite *>(context))->OnSuccessResponse_10(); }

    static void OnFailureCallback_11(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_OO_2_1Suite *>(context))->OnFailureResponse_11(error);
    }

    static void OnSuccessCallback_11(void * context) { (static_cast<Test_TC_OO_2_1Suite *>(context))->OnSuccessResponse_11(); }

    static void OnFailureCallback_12(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_OO_2_1Suite *>(context))->OnFailureResponse_12(error);
    }

    static void OnSuccessCallback_12(void * context, bool globalSceneControl)
    {
        (static_cast<Test_TC_OO_2_1Suite *>(context))->OnSuccessResponse_12(globalSceneControl);
    }

    static void OnFailureCallback_13(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_OO_2_1Suite *>(context))->OnFailureResponse_13(error);
    }

    static void OnSuccessCallback_13(void * context, uint16_t onTime)
    {
        (static_cast<Test_TC_OO_2_1Suite *>(context))->OnSuccessResponse_13(onTime);
    }

    static void OnFailureCallback_14(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_OO_2_1Suite *>(context))->OnFailureResponse_14(error);
    }

    static void OnSuccessCallback_14(void * context, uint16_t offWaitTime)
    {
        (static_cast<Test_TC_OO_2_1Suite *>(context))->OnSuccessResponse_14(offWaitTime);
    }

    static void OnFailureCallback_15(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_OO_2_1Suite *>(context))->OnFailureResponse_15(error);
    }

    static void OnSuccessCallback_15(void * context, uint8_t startUpOnOff)
    {
        (static_cast<Test_TC_OO_2_1Suite *>(context))->OnSuccessResponse_15(startUpOnOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestReadTheMandatoryAttributeOnOff_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 0));

        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValueOfMandatoryAttributeOnOff_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        bool onOffArgument;
        onOffArgument = 0;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(
            onOffArgument, this, OnSuccessCallback_2, OnFailureCallback_2));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_2() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackMandatoryAttributeOnOff_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(
            this, OnSuccessCallback_3, OnFailureCallback_3, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 0));

        NextTest();
    }

    CHIP_ERROR TestReadLtAttributeGlobalSceneControl_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::GlobalSceneControl::TypeInfo>(
            this, OnSuccessCallback_4, OnFailureCallback_4, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_4(bool globalSceneControl)
    {
        VerifyOrReturn(CheckValue("globalSceneControl", globalSceneControl, 1));

        NextTest();
    }

    CHIP_ERROR TestReadLtAttributeOnTime_5()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnTime::TypeInfo>(
            this, OnSuccessCallback_5, OnFailureCallback_5, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_5(uint16_t onTime)
    {
        VerifyOrReturn(CheckValue("onTime", onTime, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadLtAttributeOffWaitTime_6()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OffWaitTime::TypeInfo>(
            this, OnSuccessCallback_6, OnFailureCallback_6, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_6(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_6(uint16_t offWaitTime)
    {
        VerifyOrReturn(CheckValue("offWaitTime", offWaitTime, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadLtAttributeStartUpOnOff_7()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::StartUpOnOff::TypeInfo>(
            this, OnSuccessCallback_7, OnFailureCallback_7, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_7(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_7(uint8_t startUpOnOff)
    {
        VerifyOrReturn(CheckValue("startUpOnOff", startUpOnOff, 0));

        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValueToLtAttributeGlobalSceneControl_8()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        bool globalSceneControlArgument;
        globalSceneControlArgument = 0;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::OnOff::Attributes::GlobalSceneControl::TypeInfo>(
            globalSceneControlArgument, this, OnSuccessCallback_8, OnFailureCallback_8));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_8(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_8() { ThrowSuccessResponse(); }

    CHIP_ERROR TestWriteTheDefaultValueToLtAttributeOnTime_9()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t onTimeArgument;
        onTimeArgument = 0U;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::OnOff::Attributes::OnTime::TypeInfo>(
            onTimeArgument, this, OnSuccessCallback_9, OnFailureCallback_9));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_9(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_9() { NextTest(); }

    CHIP_ERROR TestWriteTheDefaultValueToLtAttributeOffWaitTime_10()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t offWaitTimeArgument;
        offWaitTimeArgument = 0U;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::OnOff::Attributes::OffWaitTime::TypeInfo>(
            offWaitTimeArgument, this, OnSuccessCallback_10, OnFailureCallback_10));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_10(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_10() { NextTest(); }

    CHIP_ERROR TestWriteTheDefaultValueToLtAttributeStartUpOnOff_11()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t startUpOnOffArgument;
        startUpOnOffArgument = 0;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::OnOff::Attributes::StartUpOnOff::TypeInfo>(
            startUpOnOffArgument, this, OnSuccessCallback_11, OnFailureCallback_11));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_11(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_11() { NextTest(); }

    CHIP_ERROR TestReadsBackLtAttributeGlobalSceneControl_12()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::GlobalSceneControl::TypeInfo>(
            this, OnSuccessCallback_12, OnFailureCallback_12, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_12(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_12(bool globalSceneControl)
    {
        VerifyOrReturn(CheckValue("globalSceneControl", globalSceneControl, 1));

        NextTest();
    }

    CHIP_ERROR TestReadsBackLtAttributeOnTime_13()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnTime::TypeInfo>(
            this, OnSuccessCallback_13, OnFailureCallback_13, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_13(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_13(uint16_t onTime)
    {
        VerifyOrReturn(CheckValue("onTime", onTime, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadsBackLtAttributeOffWaitTime_14()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OffWaitTime::TypeInfo>(
            this, OnSuccessCallback_14, OnFailureCallback_14, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_14(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_14(uint16_t offWaitTime)
    {
        VerifyOrReturn(CheckValue("offWaitTime", offWaitTime, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadsBackLtAttributeStartUpOnOff_15()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::StartUpOnOff::TypeInfo>(
            this, OnSuccessCallback_15, OnFailureCallback_15, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_15(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_15(uint8_t startUpOnOff)
    {
        VerifyOrReturn(CheckValue("startUpOnOff", startUpOnOff, 0));

        NextTest();
    }
};

class Test_TC_OO_2_2Suite : public TestCommand
{
public:
    Test_TC_OO_2_2Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_OO_2_2", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_OO_2_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_OO_2_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_OO_2_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Send Off Command\n");
            err = TestSendOffCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Send On Command\n");
            err = TestSendOnCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Send Off Command\n");
            err = TestSendOffCommand_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Send Toggle Command\n");
            err = TestSendToggleCommand_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Check on/off attribute value is true after toggle command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterToggleCommand_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Send Toggle Command\n");
            err = TestSendToggleCommand_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Check on/off attribute value is false after toggle command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterToggleCommand_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : Send On Command\n");
            err = TestSendOnCommand_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : Send Off Command\n");
            err = TestSendOffCommand_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_14();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 15;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_OO_2_2Suite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_2Suite *>(context))->OnSuccessResponse_2(onOff);
    }

    static void OnFailureCallback_4(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_OO_2_2Suite *>(context))->OnFailureResponse_4(error);
    }

    static void OnSuccessCallback_4(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_2Suite *>(context))->OnSuccessResponse_4(onOff);
    }

    static void OnFailureCallback_6(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_OO_2_2Suite *>(context))->OnFailureResponse_6(error);
    }

    static void OnSuccessCallback_6(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_2Suite *>(context))->OnSuccessResponse_6(onOff);
    }

    static void OnFailureCallback_8(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_OO_2_2Suite *>(context))->OnFailureResponse_8(error);
    }

    static void OnSuccessCallback_8(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_2Suite *>(context))->OnSuccessResponse_8(onOff);
    }

    static void OnFailureCallback_10(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_OO_2_2Suite *>(context))->OnFailureResponse_10(error);
    }

    static void OnSuccessCallback_10(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_2Suite *>(context))->OnSuccessResponse_10(onOff);
    }

    static void OnFailureCallback_12(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_OO_2_2Suite *>(context))->OnFailureResponse_12(error);
    }

    static void OnSuccessCallback_12(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_2Suite *>(context))->OnSuccessResponse_12(onOff);
    }

    static void OnFailureCallback_14(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_OO_2_2Suite *>(context))->OnFailureResponse_14(error);
    }

    static void OnSuccessCallback_14(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_2Suite *>(context))->OnSuccessResponse_14(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestSendOffCommand_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_OO_2_2Suite *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_OO_2_2Suite *>(context))->OnFailureResponse_1(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 0));

        NextTest();
    }

    CHIP_ERROR TestSendOnCommand_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_OO_2_2Suite *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_OO_2_2Suite *>(context))->OnFailureResponse_3(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(
            this, OnSuccessCallback_4, OnFailureCallback_4, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_4(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 1));

        NextTest();
    }

    CHIP_ERROR TestSendOffCommand_5()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_OO_2_2Suite *>(context))->OnSuccessResponse_5();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_OO_2_2Suite *>(context))->OnFailureResponse_5(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_5() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_6()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(
            this, OnSuccessCallback_6, OnFailureCallback_6, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_6(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_6(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 0));

        NextTest();
    }

    CHIP_ERROR TestSendToggleCommand_7()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Toggle::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_OO_2_2Suite *>(context))->OnSuccessResponse_7();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_OO_2_2Suite *>(context))->OnFailureResponse_7(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_7(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_7() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterToggleCommand_8()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(
            this, OnSuccessCallback_8, OnFailureCallback_8, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_8(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_8(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 1));

        NextTest();
    }

    CHIP_ERROR TestSendToggleCommand_9()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Toggle::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_OO_2_2Suite *>(context))->OnSuccessResponse_9();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_OO_2_2Suite *>(context))->OnFailureResponse_9(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_9(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_9() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterToggleCommand_10()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(
            this, OnSuccessCallback_10, OnFailureCallback_10, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_10(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_10(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 0));

        NextTest();
    }

    CHIP_ERROR TestSendOnCommand_11()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_OO_2_2Suite *>(context))->OnSuccessResponse_11();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_OO_2_2Suite *>(context))->OnFailureResponse_11(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_11(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_11() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_12()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(
            this, OnSuccessCallback_12, OnFailureCallback_12, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_12(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_12(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 1));

        NextTest();
    }

    CHIP_ERROR TestSendOffCommand_13()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_OO_2_2Suite *>(context))->OnSuccessResponse_13();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_OO_2_2Suite *>(context))->OnFailureResponse_13(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_13(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_13() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_14()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(
            this, OnSuccessCallback_14, OnFailureCallback_14, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_14(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_14(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 0));

        NextTest();
    }
};

class Test_TC_OO_2_3Suite : public TestCommand
{
public:
    Test_TC_OO_2_3Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_OO_2_3", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_OO_2_3Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_OO_2_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_OO_2_3\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Send On Command\n");
            if (ShouldSkip("CR_ON"))
            {
                NextTest();
                return;
            }
            err = TestSendOnCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Wait 1000ms\n");
            err = TestWait1000ms_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Reads OnOff attribute from DUT\n");
            if (ShouldSkip("A_ONOFF"))
            {
                NextTest();
                return;
            }
            err = TestReadsOnOffAttributeFromDut_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Reads GlobalSceneControl attribute from DUT\n");
            if (ShouldSkip("A_GLOBALSCENECONTROL"))
            {
                NextTest();
                return;
            }
            err = TestReadsGlobalSceneControlAttributeFromDut_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Send On Command\n");
            if (ShouldSkip("CR_ON"))
            {
                NextTest();
                return;
            }
            err = TestSendOnCommand_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Wait 1000ms\n");
            err = TestWait1000ms_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Reads OnOff attribute from DUT\n");
            if (ShouldSkip("A_ONOFF"))
            {
                NextTest();
                return;
            }
            err = TestReadsOnOffAttributeFromDut_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Reads GlobalSceneControl attribute from DUT\n");
            if (ShouldSkip("A_GLOBALSCENECONTROL"))
            {
                NextTest();
                return;
            }
            err = TestReadsGlobalSceneControlAttributeFromDut_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Send On Command\n");
            if (ShouldSkip("CR_ON"))
            {
                NextTest();
                return;
            }
            err = TestSendOnCommand_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Wait 1000ms\n");
            err = TestWait1000ms_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : Reads OnOff attribute from DUT\n");
            if (ShouldSkip("A_ONOFF"))
            {
                NextTest();
                return;
            }
            err = TestReadsOnOffAttributeFromDut_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : Reads GlobalSceneControl attribute from DUT\n");
            if (ShouldSkip("A_GLOBALSCENECONTROL"))
            {
                NextTest();
                return;
            }
            err = TestReadsGlobalSceneControlAttributeFromDut_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : Reads OnTime attribute from DUT\n");
            if (ShouldSkip("A_ONTIME"))
            {
                NextTest();
                return;
            }
            err = TestReadsOnTimeAttributeFromDut_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : Reads OffWaitTime attribute from DUT\n");
            if (ShouldSkip("A_OFFWAITTIME"))
            {
                NextTest();
                return;
            }
            err = TestReadsOffWaitTimeAttributeFromDut_14();
            break;
        case 15:
            ChipLogProgress(chipTool, " ***** Test Step 15 : Send On Command\n");
            if (ShouldSkip("CR_ON"))
            {
                NextTest();
                return;
            }
            err = TestSendOnCommand_15();
            break;
        case 16:
            ChipLogProgress(chipTool, " ***** Test Step 16 : Reads OnOff attribute from DUT\n");
            if (ShouldSkip("A_ONOFF"))
            {
                NextTest();
                return;
            }
            err = TestReadsOnOffAttributeFromDut_16();
            break;
        case 17:
            ChipLogProgress(chipTool, " ***** Test Step 17 : Reads OnTime attribute from DUT\n");
            if (ShouldSkip("A_ONTIME"))
            {
                NextTest();
                return;
            }
            err = TestReadsOnTimeAttributeFromDut_17();
            break;
        case 18:
            ChipLogProgress(chipTool, " ***** Test Step 18 : Reads OffWaitTime attribute from DUT\n");
            if (ShouldSkip("A_OFFWAITTIME"))
            {
                NextTest();
                return;
            }
            err = TestReadsOffWaitTimeAttributeFromDut_18();
            break;
        case 19:
            ChipLogProgress(chipTool, " ***** Test Step 19 : Send Off Command\n");
            if (ShouldSkip("CR_OFF"))
            {
                NextTest();
                return;
            }
            err = TestSendOffCommand_19();
            break;
        case 20:
            ChipLogProgress(chipTool, " ***** Test Step 20 : Reads OnOff attribute from DUT\n");
            if (ShouldSkip("A_ONOFF"))
            {
                NextTest();
                return;
            }
            err = TestReadsOnOffAttributeFromDut_20();
            break;
        case 21:
            ChipLogProgress(chipTool, " ***** Test Step 21 : Reads OnTime attribute from DUT\n");
            if (ShouldSkip("A_ONTIME"))
            {
                NextTest();
                return;
            }
            err = TestReadsOnTimeAttributeFromDut_21();
            break;
        case 22:
            ChipLogProgress(chipTool, " ***** Test Step 22 : Reads OnOff attribute from DUT\n");
            if (ShouldSkip("A_ONOFF"))
            {
                NextTest();
                return;
            }
            err = TestReadsOnOffAttributeFromDut_22();
            break;
        case 23:
            ChipLogProgress(chipTool, " ***** Test Step 23 : Reads OnTime attribute from DUT\n");
            if (ShouldSkip("A_ONTIME"))
            {
                NextTest();
                return;
            }
            err = TestReadsOnTimeAttributeFromDut_23();
            break;
        case 24:
            ChipLogProgress(chipTool, " ***** Test Step 24 : Reads OffWaitTime attribute from DUT\n");
            if (ShouldSkip("A_OFFWAITTIME"))
            {
                NextTest();
                return;
            }
            err = TestReadsOffWaitTimeAttributeFromDut_24();
            break;
        case 25:
            ChipLogProgress(chipTool, " ***** Test Step 25 : Send On Command\n");
            if (ShouldSkip("CR_ON"))
            {
                NextTest();
                return;
            }
            err = TestSendOnCommand_25();
            break;
        case 26:
            ChipLogProgress(chipTool, " ***** Test Step 26 : Reads OnTime attribute from DUT\n");
            if (ShouldSkip("A_ONTIME"))
            {
                NextTest();
                return;
            }
            err = TestReadsOnTimeAttributeFromDut_26();
            break;
        case 27:
            ChipLogProgress(chipTool, " ***** Test Step 27 : Reads OffWaitTime attribute from DUT\n");
            if (ShouldSkip("A_OFFWAITTIME"))
            {
                NextTest();
                return;
            }
            err = TestReadsOffWaitTimeAttributeFromDut_27();
            break;
        case 28:
            ChipLogProgress(chipTool, " ***** Test Step 28 : Send Off Command\n");
            if (ShouldSkip("CR_OFF"))
            {
                NextTest();
                return;
            }
            err = TestSendOffCommand_28();
            break;
        case 29:
            ChipLogProgress(chipTool, " ***** Test Step 29 : Reads OnOff attribute from DUT\n");
            if (ShouldSkip("A_ONOFF"))
            {
                NextTest();
                return;
            }
            err = TestReadsOnOffAttributeFromDut_29();
            break;
        case 30:
            ChipLogProgress(chipTool, " ***** Test Step 30 : Reads OnTime attribute from DUT\n");
            if (ShouldSkip("A_ONTIME"))
            {
                NextTest();
                return;
            }
            err = TestReadsOnTimeAttributeFromDut_30();
            break;
        case 31:
            ChipLogProgress(chipTool, " ***** Test Step 31 : Reads OnOff attribute from DUT\n");
            if (ShouldSkip("A_ONOFF"))
            {
                NextTest();
                return;
            }
            err = TestReadsOnOffAttributeFromDut_31();
            break;
        case 32:
            ChipLogProgress(chipTool, " ***** Test Step 32 : Reads OnTime attribute from DUT\n");
            if (ShouldSkip("A_ONTIME"))
            {
                NextTest();
                return;
            }
            err = TestReadsOnTimeAttributeFromDut_32();
            break;
        case 33:
            ChipLogProgress(chipTool, " ***** Test Step 33 : Send On Command\n");
            if (ShouldSkip("CR_ON"))
            {
                NextTest();
                return;
            }
            err = TestSendOnCommand_33();
            break;
        case 34:
            ChipLogProgress(chipTool, " ***** Test Step 34 : Reads OnOff attribute from DUT\n");
            if (ShouldSkip("A_ONOFF"))
            {
                NextTest();
                return;
            }
            err = TestReadsOnOffAttributeFromDut_34();
            break;
        case 35:
            ChipLogProgress(chipTool, " ***** Test Step 35 : Reads OnTime attribute from DUT\n");
            if (ShouldSkip("A_ONTIME"))
            {
                NextTest();
                return;
            }
            err = TestReadsOnTimeAttributeFromDut_35();
            break;
        case 36:
            ChipLogProgress(chipTool, " ***** Test Step 36 : Reads OffWaitTime attribute from DUT\n");
            if (ShouldSkip("A_OFFWAITTIME"))
            {
                NextTest();
                return;
            }
            err = TestReadsOffWaitTimeAttributeFromDut_36();
            break;
        case 37:
            ChipLogProgress(chipTool, " ***** Test Step 37 : Send Off Command\n");
            if (ShouldSkip("CR_OFF"))
            {
                NextTest();
                return;
            }
            err = TestSendOffCommand_37();
            break;
        case 38:
            ChipLogProgress(chipTool, " ***** Test Step 38 : Reads OnOff attribute from DUT\n");
            if (ShouldSkip("A_ONOFF"))
            {
                NextTest();
                return;
            }
            err = TestReadsOnOffAttributeFromDut_38();
            break;
        case 39:
            ChipLogProgress(chipTool, " ***** Test Step 39 : Reads OnTime attribute from DUT\n");
            if (ShouldSkip("A_ONTIME"))
            {
                NextTest();
                return;
            }
            err = TestReadsOnTimeAttributeFromDut_39();
            break;
        case 40:
            ChipLogProgress(chipTool, " ***** Test Step 40 : Reads OnOff attribute from DUT\n");
            if (ShouldSkip("A_ONOFF"))
            {
                NextTest();
                return;
            }
            err = TestReadsOnOffAttributeFromDut_40();
            break;
        case 41:
            ChipLogProgress(chipTool, " ***** Test Step 41 : Reads OnTime attribute from DUT\n");
            if (ShouldSkip("A_ONTIME"))
            {
                NextTest();
                return;
            }
            err = TestReadsOnTimeAttributeFromDut_41();
            break;
        case 42:
            ChipLogProgress(chipTool, " ***** Test Step 42 : Reads OffWaitTime attribute from DUT\n");
            if (ShouldSkip("A_OFFWAITTIME"))
            {
                NextTest();
                return;
            }
            err = TestReadsOffWaitTimeAttributeFromDut_42();
            break;
        case 43:
            ChipLogProgress(chipTool, " ***** Test Step 43 : Reads OnOff attribute from DUT\n");
            if (ShouldSkip("A_ONOFF"))
            {
                NextTest();
                return;
            }
            err = TestReadsOnOffAttributeFromDut_43();
            break;
        case 44:
            ChipLogProgress(chipTool, " ***** Test Step 44 : Reads OnTime attribute from DUT\n");
            if (ShouldSkip("A_ONTIME"))
            {
                NextTest();
                return;
            }
            err = TestReadsOnTimeAttributeFromDut_44();
            break;
        case 45:
            ChipLogProgress(chipTool, " ***** Test Step 45 : Reads OffWaitTime attribute from DUT\n");
            if (ShouldSkip("A_OFFWAITTIME"))
            {
                NextTest();
                return;
            }
            err = TestReadsOffWaitTimeAttributeFromDut_45();
            break;
        case 46:
            ChipLogProgress(chipTool, " ***** Test Step 46 : Send Off Command\n");
            if (ShouldSkip("CR_OFF"))
            {
                NextTest();
                return;
            }
            err = TestSendOffCommand_46();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 47;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_3(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_OO_2_3Suite *>(context))->OnFailureResponse_3(error);
    }

    static void OnSuccessCallback_3(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_3Suite *>(context))->OnSuccessResponse_3(onOff);
    }

    static void OnFailureCallback_4(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_OO_2_3Suite *>(context))->OnFailureResponse_4(error);
    }

    static void OnSuccessCallback_4(void * context, bool globalSceneControl)
    {
        (static_cast<Test_TC_OO_2_3Suite *>(context))->OnSuccessResponse_4(globalSceneControl);
    }

    static void OnFailureCallback_7(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_OO_2_3Suite *>(context))->OnFailureResponse_7(error);
    }

    static void OnSuccessCallback_7(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_3Suite *>(context))->OnSuccessResponse_7(onOff);
    }

    static void OnFailureCallback_8(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_OO_2_3Suite *>(context))->OnFailureResponse_8(error);
    }

    static void OnSuccessCallback_8(void * context, bool globalSceneControl)
    {
        (static_cast<Test_TC_OO_2_3Suite *>(context))->OnSuccessResponse_8(globalSceneControl);
    }

    static void OnFailureCallback_11(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_OO_2_3Suite *>(context))->OnFailureResponse_11(error);
    }

    static void OnSuccessCallback_11(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_3Suite *>(context))->OnSuccessResponse_11(onOff);
    }

    static void OnFailureCallback_12(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_OO_2_3Suite *>(context))->OnFailureResponse_12(error);
    }

    static void OnSuccessCallback_12(void * context, bool globalSceneControl)
    {
        (static_cast<Test_TC_OO_2_3Suite *>(context))->OnSuccessResponse_12(globalSceneControl);
    }

    static void OnFailureCallback_13(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_OO_2_3Suite *>(context))->OnFailureResponse_13(error);
    }

    static void OnSuccessCallback_13(void * context, uint16_t onTime)
    {
        (static_cast<Test_TC_OO_2_3Suite *>(context))->OnSuccessResponse_13(onTime);
    }

    static void OnFailureCallback_14(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_OO_2_3Suite *>(context))->OnFailureResponse_14(error);
    }

    static void OnSuccessCallback_14(void * context, uint16_t offWaitTime)
    {
        (static_cast<Test_TC_OO_2_3Suite *>(context))->OnSuccessResponse_14(offWaitTime);
    }

    static void OnFailureCallback_16(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_OO_2_3Suite *>(context))->OnFailureResponse_16(error);
    }

    static void OnSuccessCallback_16(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_3Suite *>(context))->OnSuccessResponse_16(onOff);
    }

    static void OnFailureCallback_17(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_OO_2_3Suite *>(context))->OnFailureResponse_17(error);
    }

    static void OnSuccessCallback_17(void * context, uint16_t onTime)
    {
        (static_cast<Test_TC_OO_2_3Suite *>(context))->OnSuccessResponse_17(onTime);
    }

    static void OnFailureCallback_18(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_OO_2_3Suite *>(context))->OnFailureResponse_18(error);
    }

    static void OnSuccessCallback_18(void * context, uint16_t offWaitTime)
    {
        (static_cast<Test_TC_OO_2_3Suite *>(context))->OnSuccessResponse_18(offWaitTime);
    }

    static void OnFailureCallback_20(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_OO_2_3Suite *>(context))->OnFailureResponse_20(error);
    }

    static void OnSuccessCallback_20(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_3Suite *>(context))->OnSuccessResponse_20(onOff);
    }

    static void OnFailureCallback_21(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_OO_2_3Suite *>(context))->OnFailureResponse_21(error);
    }

    static void OnSuccessCallback_21(void * context, uint16_t onTime)
    {
        (static_cast<Test_TC_OO_2_3Suite *>(context))->OnSuccessResponse_21(onTime);
    }

    static void OnFailureCallback_22(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_OO_2_3Suite *>(context))->OnFailureResponse_22(error);
    }

    static void OnSuccessCallback_22(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_3Suite *>(context))->OnSuccessResponse_22(onOff);
    }

    static void OnFailureCallback_23(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_OO_2_3Suite *>(context))->OnFailureResponse_23(error);
    }

    static void OnSuccessCallback_23(void * context, uint16_t onTime)
    {
        (static_cast<Test_TC_OO_2_3Suite *>(context))->OnSuccessResponse_23(onTime);
    }

    static void OnFailureCallback_24(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_OO_2_3Suite *>(context))->OnFailureResponse_24(error);
    }

    static void OnSuccessCallback_24(void * context, uint16_t offWaitTime)
    {
        (static_cast<Test_TC_OO_2_3Suite *>(context))->OnSuccessResponse_24(offWaitTime);
    }

    static void OnFailureCallback_26(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_OO_2_3Suite *>(context))->OnFailureResponse_26(error);
    }

    static void OnSuccessCallback_26(void * context, uint16_t onTime)
    {
        (static_cast<Test_TC_OO_2_3Suite *>(context))->OnSuccessResponse_26(onTime);
    }

    static void OnFailureCallback_27(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_OO_2_3Suite *>(context))->OnFailureResponse_27(error);
    }

    static void OnSuccessCallback_27(void * context, uint16_t offWaitTime)
    {
        (static_cast<Test_TC_OO_2_3Suite *>(context))->OnSuccessResponse_27(offWaitTime);
    }

    static void OnFailureCallback_29(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_OO_2_3Suite *>(context))->OnFailureResponse_29(error);
    }

    static void OnSuccessCallback_29(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_3Suite *>(context))->OnSuccessResponse_29(onOff);
    }

    static void OnFailureCallback_30(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_OO_2_3Suite *>(context))->OnFailureResponse_30(error);
    }

    static void OnSuccessCallback_30(void * context, uint16_t onTime)
    {
        (static_cast<Test_TC_OO_2_3Suite *>(context))->OnSuccessResponse_30(onTime);
    }

    static void OnFailureCallback_31(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_OO_2_3Suite *>(context))->OnFailureResponse_31(error);
    }

    static void OnSuccessCallback_31(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_3Suite *>(context))->OnSuccessResponse_31(onOff);
    }

    static void OnFailureCallback_32(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_OO_2_3Suite *>(context))->OnFailureResponse_32(error);
    }

    static void OnSuccessCallback_32(void * context, uint16_t onTime)
    {
        (static_cast<Test_TC_OO_2_3Suite *>(context))->OnSuccessResponse_32(onTime);
    }

    static void OnFailureCallback_34(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_OO_2_3Suite *>(context))->OnFailureResponse_34(error);
    }

    static void OnSuccessCallback_34(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_3Suite *>(context))->OnSuccessResponse_34(onOff);
    }

    static void OnFailureCallback_35(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_OO_2_3Suite *>(context))->OnFailureResponse_35(error);
    }

    static void OnSuccessCallback_35(void * context, uint16_t onTime)
    {
        (static_cast<Test_TC_OO_2_3Suite *>(context))->OnSuccessResponse_35(onTime);
    }

    static void OnFailureCallback_36(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_OO_2_3Suite *>(context))->OnFailureResponse_36(error);
    }

    static void OnSuccessCallback_36(void * context, uint16_t offWaitTime)
    {
        (static_cast<Test_TC_OO_2_3Suite *>(context))->OnSuccessResponse_36(offWaitTime);
    }

    static void OnFailureCallback_38(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_OO_2_3Suite *>(context))->OnFailureResponse_38(error);
    }

    static void OnSuccessCallback_38(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_3Suite *>(context))->OnSuccessResponse_38(onOff);
    }

    static void OnFailureCallback_39(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_OO_2_3Suite *>(context))->OnFailureResponse_39(error);
    }

    static void OnSuccessCallback_39(void * context, uint16_t onTime)
    {
        (static_cast<Test_TC_OO_2_3Suite *>(context))->OnSuccessResponse_39(onTime);
    }

    static void OnFailureCallback_40(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_OO_2_3Suite *>(context))->OnFailureResponse_40(error);
    }

    static void OnSuccessCallback_40(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_3Suite *>(context))->OnSuccessResponse_40(onOff);
    }

    static void OnFailureCallback_41(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_OO_2_3Suite *>(context))->OnFailureResponse_41(error);
    }

    static void OnSuccessCallback_41(void * context, uint16_t onTime)
    {
        (static_cast<Test_TC_OO_2_3Suite *>(context))->OnSuccessResponse_41(onTime);
    }

    static void OnFailureCallback_42(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_OO_2_3Suite *>(context))->OnFailureResponse_42(error);
    }

    static void OnSuccessCallback_42(void * context, uint16_t offWaitTime)
    {
        (static_cast<Test_TC_OO_2_3Suite *>(context))->OnSuccessResponse_42(offWaitTime);
    }

    static void OnFailureCallback_43(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_OO_2_3Suite *>(context))->OnFailureResponse_43(error);
    }

    static void OnSuccessCallback_43(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_3Suite *>(context))->OnSuccessResponse_43(onOff);
    }

    static void OnFailureCallback_44(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_OO_2_3Suite *>(context))->OnFailureResponse_44(error);
    }

    static void OnSuccessCallback_44(void * context, uint16_t onTime)
    {
        (static_cast<Test_TC_OO_2_3Suite *>(context))->OnSuccessResponse_44(onTime);
    }

    static void OnFailureCallback_45(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_OO_2_3Suite *>(context))->OnFailureResponse_45(error);
    }

    static void OnSuccessCallback_45(void * context, uint16_t offWaitTime)
    {
        (static_cast<Test_TC_OO_2_3Suite *>(context))->OnSuccessResponse_45(offWaitTime);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestSendOnCommand_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_OO_2_3Suite *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_OO_2_3Suite *>(context))->OnFailureResponse_1(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestWait1000ms_2()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForMs(1000);
    }

    CHIP_ERROR TestReadsOnOffAttributeFromDut_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(
            this, OnSuccessCallback_3, OnFailureCallback_3, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 1));

        NextTest();
    }

    CHIP_ERROR TestReadsGlobalSceneControlAttributeFromDut_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::GlobalSceneControl::TypeInfo>(
            this, OnSuccessCallback_4, OnFailureCallback_4, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_4(bool globalSceneControl)
    {
        VerifyOrReturn(CheckValue("globalSceneControl", globalSceneControl, 1));

        NextTest();
    }

    CHIP_ERROR TestSendOnCommand_5()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_OO_2_3Suite *>(context))->OnSuccessResponse_5();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_OO_2_3Suite *>(context))->OnFailureResponse_5(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_5() { NextTest(); }

    CHIP_ERROR TestWait1000ms_6()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForMs(1000);
    }

    CHIP_ERROR TestReadsOnOffAttributeFromDut_7()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(
            this, OnSuccessCallback_7, OnFailureCallback_7, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_7(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_7(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 1));

        NextTest();
    }

    CHIP_ERROR TestReadsGlobalSceneControlAttributeFromDut_8()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::GlobalSceneControl::TypeInfo>(
            this, OnSuccessCallback_8, OnFailureCallback_8, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_8(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_8(bool globalSceneControl)
    {
        VerifyOrReturn(CheckValue("globalSceneControl", globalSceneControl, 1));

        NextTest();
    }

    CHIP_ERROR TestSendOnCommand_9()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_OO_2_3Suite *>(context))->OnSuccessResponse_9();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_OO_2_3Suite *>(context))->OnFailureResponse_9(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_9(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_9() { NextTest(); }

    CHIP_ERROR TestWait1000ms_10()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForMs(1000);
    }

    CHIP_ERROR TestReadsOnOffAttributeFromDut_11()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(
            this, OnSuccessCallback_11, OnFailureCallback_11, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_11(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_11(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 1));

        NextTest();
    }

    CHIP_ERROR TestReadsGlobalSceneControlAttributeFromDut_12()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::GlobalSceneControl::TypeInfo>(
            this, OnSuccessCallback_12, OnFailureCallback_12, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_12(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_12(bool globalSceneControl)
    {
        VerifyOrReturn(CheckValue("globalSceneControl", globalSceneControl, 1));

        NextTest();
    }

    CHIP_ERROR TestReadsOnTimeAttributeFromDut_13()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnTime::TypeInfo>(
            this, OnSuccessCallback_13, OnFailureCallback_13, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_13(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_13(uint16_t onTime)
    {
        VerifyOrReturn(CheckValue("onTime", onTime, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadsOffWaitTimeAttributeFromDut_14()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OffWaitTime::TypeInfo>(
            this, OnSuccessCallback_14, OnFailureCallback_14, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_14(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_14(uint16_t offWaitTime)
    {
        VerifyOrReturn(CheckValue("offWaitTime", offWaitTime, 0U));

        NextTest();
    }

    CHIP_ERROR TestSendOnCommand_15()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_OO_2_3Suite *>(context))->OnSuccessResponse_15();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_OO_2_3Suite *>(context))->OnFailureResponse_15(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_15(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_15() { NextTest(); }

    CHIP_ERROR TestReadsOnOffAttributeFromDut_16()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(
            this, OnSuccessCallback_16, OnFailureCallback_16, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_16(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_16(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 1));

        NextTest();
    }

    CHIP_ERROR TestReadsOnTimeAttributeFromDut_17()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnTime::TypeInfo>(
            this, OnSuccessCallback_17, OnFailureCallback_17, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_17(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_17(uint16_t onTime)
    {
        VerifyOrReturn(CheckValue("onTime", onTime, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadsOffWaitTimeAttributeFromDut_18()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OffWaitTime::TypeInfo>(
            this, OnSuccessCallback_18, OnFailureCallback_18, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_18(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_18(uint16_t offWaitTime)
    {
        VerifyOrReturn(CheckValue("offWaitTime", offWaitTime, 0U));

        NextTest();
    }

    CHIP_ERROR TestSendOffCommand_19()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_OO_2_3Suite *>(context))->OnSuccessResponse_19();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_OO_2_3Suite *>(context))->OnFailureResponse_19(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_19(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_19() { NextTest(); }

    CHIP_ERROR TestReadsOnOffAttributeFromDut_20()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(
            this, OnSuccessCallback_20, OnFailureCallback_20, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_20(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_20(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 0));

        NextTest();
    }

    CHIP_ERROR TestReadsOnTimeAttributeFromDut_21()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnTime::TypeInfo>(
            this, OnSuccessCallback_21, OnFailureCallback_21, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_21(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_21(uint16_t onTime)
    {
        VerifyOrReturn(CheckValue("onTime", onTime, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadsOnOffAttributeFromDut_22()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(
            this, OnSuccessCallback_22, OnFailureCallback_22, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_22(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_22(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 0));

        NextTest();
    }

    CHIP_ERROR TestReadsOnTimeAttributeFromDut_23()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnTime::TypeInfo>(
            this, OnSuccessCallback_23, OnFailureCallback_23, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_23(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_23(uint16_t onTime)
    {
        VerifyOrReturn(CheckValue("onTime", onTime, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadsOffWaitTimeAttributeFromDut_24()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OffWaitTime::TypeInfo>(
            this, OnSuccessCallback_24, OnFailureCallback_24, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_24(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_24(uint16_t offWaitTime)
    {
        VerifyOrReturn(CheckValue("offWaitTime", offWaitTime, 0U));

        NextTest();
    }

    CHIP_ERROR TestSendOnCommand_25()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_OO_2_3Suite *>(context))->OnSuccessResponse_25();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_OO_2_3Suite *>(context))->OnFailureResponse_25(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_25(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_25() { NextTest(); }

    CHIP_ERROR TestReadsOnTimeAttributeFromDut_26()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnTime::TypeInfo>(
            this, OnSuccessCallback_26, OnFailureCallback_26, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_26(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_26(uint16_t onTime)
    {
        VerifyOrReturn(CheckValue("onTime", onTime, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadsOffWaitTimeAttributeFromDut_27()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OffWaitTime::TypeInfo>(
            this, OnSuccessCallback_27, OnFailureCallback_27, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_27(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_27(uint16_t offWaitTime)
    {
        VerifyOrReturn(CheckValue("offWaitTime", offWaitTime, 0U));

        NextTest();
    }

    CHIP_ERROR TestSendOffCommand_28()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_OO_2_3Suite *>(context))->OnSuccessResponse_28();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_OO_2_3Suite *>(context))->OnFailureResponse_28(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_28(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_28() { NextTest(); }

    CHIP_ERROR TestReadsOnOffAttributeFromDut_29()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(
            this, OnSuccessCallback_29, OnFailureCallback_29, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_29(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_29(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 0));

        NextTest();
    }

    CHIP_ERROR TestReadsOnTimeAttributeFromDut_30()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnTime::TypeInfo>(
            this, OnSuccessCallback_30, OnFailureCallback_30, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_30(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_30(uint16_t onTime)
    {
        VerifyOrReturn(CheckValue("onTime", onTime, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadsOnOffAttributeFromDut_31()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(
            this, OnSuccessCallback_31, OnFailureCallback_31, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_31(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_31(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 0));

        NextTest();
    }

    CHIP_ERROR TestReadsOnTimeAttributeFromDut_32()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnTime::TypeInfo>(
            this, OnSuccessCallback_32, OnFailureCallback_32, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_32(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_32(uint16_t onTime)
    {
        VerifyOrReturn(CheckValue("onTime", onTime, 0U));

        NextTest();
    }

    CHIP_ERROR TestSendOnCommand_33()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_OO_2_3Suite *>(context))->OnSuccessResponse_33();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_OO_2_3Suite *>(context))->OnFailureResponse_33(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_33(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_33() { NextTest(); }

    CHIP_ERROR TestReadsOnOffAttributeFromDut_34()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(
            this, OnSuccessCallback_34, OnFailureCallback_34, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_34(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_34(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 1));

        NextTest();
    }

    CHIP_ERROR TestReadsOnTimeAttributeFromDut_35()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnTime::TypeInfo>(
            this, OnSuccessCallback_35, OnFailureCallback_35, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_35(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_35(uint16_t onTime)
    {
        VerifyOrReturn(CheckValue("onTime", onTime, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadsOffWaitTimeAttributeFromDut_36()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OffWaitTime::TypeInfo>(
            this, OnSuccessCallback_36, OnFailureCallback_36, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_36(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_36(uint16_t offWaitTime)
    {
        VerifyOrReturn(CheckValue("offWaitTime", offWaitTime, 0U));

        NextTest();
    }

    CHIP_ERROR TestSendOffCommand_37()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_OO_2_3Suite *>(context))->OnSuccessResponse_37();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_OO_2_3Suite *>(context))->OnFailureResponse_37(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_37(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_37() { NextTest(); }

    CHIP_ERROR TestReadsOnOffAttributeFromDut_38()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(
            this, OnSuccessCallback_38, OnFailureCallback_38, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_38(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_38(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 0));

        NextTest();
    }

    CHIP_ERROR TestReadsOnTimeAttributeFromDut_39()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnTime::TypeInfo>(
            this, OnSuccessCallback_39, OnFailureCallback_39, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_39(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_39(uint16_t onTime)
    {
        VerifyOrReturn(CheckValue("onTime", onTime, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadsOnOffAttributeFromDut_40()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(
            this, OnSuccessCallback_40, OnFailureCallback_40, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_40(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_40(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 0));

        NextTest();
    }

    CHIP_ERROR TestReadsOnTimeAttributeFromDut_41()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnTime::TypeInfo>(
            this, OnSuccessCallback_41, OnFailureCallback_41, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_41(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_41(uint16_t onTime)
    {
        VerifyOrReturn(CheckValue("onTime", onTime, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadsOffWaitTimeAttributeFromDut_42()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OffWaitTime::TypeInfo>(
            this, OnSuccessCallback_42, OnFailureCallback_42, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_42(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_42(uint16_t offWaitTime)
    {
        VerifyOrReturn(CheckValue("offWaitTime", offWaitTime, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadsOnOffAttributeFromDut_43()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(
            this, OnSuccessCallback_43, OnFailureCallback_43, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_43(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_43(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 0));

        NextTest();
    }

    CHIP_ERROR TestReadsOnTimeAttributeFromDut_44()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnTime::TypeInfo>(
            this, OnSuccessCallback_44, OnFailureCallback_44, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_44(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_44(uint16_t onTime)
    {
        VerifyOrReturn(CheckValue("onTime", onTime, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadsOffWaitTimeAttributeFromDut_45()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OffWaitTime::TypeInfo>(
            this, OnSuccessCallback_45, OnFailureCallback_45, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_45(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_45(uint16_t offWaitTime)
    {
        VerifyOrReturn(CheckValue("offWaitTime", offWaitTime, 0U));

        NextTest();
    }

    CHIP_ERROR TestSendOffCommand_46()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_OO_2_3Suite *>(context))->OnSuccessResponse_46();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_OO_2_3Suite *>(context))->OnFailureResponse_46(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_46(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_46() { NextTest(); }
};

class Test_TC_PS_1_1Suite : public TestCommand
{
public:
    Test_TC_PS_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_PS_1_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_PS_1_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_PS_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_PS_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : read the global attribute: ClusterRevision\n");
            err = TestReadTheGlobalAttributeClusterRevision_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read the global attribute constraints: ClusterRevision\n");
            err = TestReadTheGlobalAttributeConstraintsClusterRevision_2();
            break;
        case 3:
            ChipLogProgress(chipTool,
                            " ***** Test Step 3 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : reads back global attribute: ClusterRevision\n");
            err = TestReadsBackGlobalAttributeClusterRevision_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Read the global attribute: AttributeList\n");
            err = TestReadTheGlobalAttributeAttributeList_5();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 6;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_1(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_PS_1_1Suite *>(context))->OnFailureResponse_1(error);
    }

    static void OnSuccessCallback_1(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_PS_1_1Suite *>(context))->OnSuccessResponse_1(clusterRevision);
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_PS_1_1Suite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_PS_1_1Suite *>(context))->OnSuccessResponse_2(clusterRevision);
    }

    static void OnFailureCallback_3(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_PS_1_1Suite *>(context))->OnFailureResponse_3(error);
    }

    static void OnSuccessCallback_3(void * context) { (static_cast<Test_TC_PS_1_1Suite *>(context))->OnSuccessResponse_3(); }

    static void OnFailureCallback_4(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_PS_1_1Suite *>(context))->OnFailureResponse_4(error);
    }

    static void OnSuccessCallback_4(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_PS_1_1Suite *>(context))->OnSuccessResponse_4(clusterRevision);
    }

    static void OnFailureCallback_5(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_PS_1_1Suite *>(context))->OnFailureResponse_5(error);
    }

    static void OnSuccessCallback_5(void * context, const chip::app::DataModel::DecodableList<chip::AttributeId> & attributeList)
    {
        (static_cast<Test_TC_PS_1_1Suite *>(context))->OnSuccessResponse_5(attributeList);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestReadTheGlobalAttributeClusterRevision_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::PowerSourceClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::PowerSource::Attributes::ClusterRevision::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckValue("clusterRevision", clusterRevision, 1U));

        NextTest();
    }

    CHIP_ERROR TestReadTheGlobalAttributeConstraintsClusterRevision_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::PowerSourceClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::PowerSource::Attributes::ClusterRevision::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckConstraintType("clusterRevision", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::PowerSourceClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t clusterRevisionArgument;
        clusterRevisionArgument = 1U;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::PowerSource::Attributes::ClusterRevision::TypeInfo>(
            clusterRevisionArgument, this, OnSuccessCallback_3, OnFailureCallback_3));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_3() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackGlobalAttributeClusterRevision_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::PowerSourceClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::PowerSource::Attributes::ClusterRevision::TypeInfo>(
            this, OnSuccessCallback_4, OnFailureCallback_4, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_4(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckValue("clusterRevision", clusterRevision, 1U));

        NextTest();
    }

    CHIP_ERROR TestReadTheGlobalAttributeAttributeList_5()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::PowerSourceClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::PowerSource::Attributes::AttributeList::TypeInfo>(
            this, OnSuccessCallback_5, OnFailureCallback_5, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_5(const chip::app::DataModel::DecodableList<chip::AttributeId> & attributeList)
    {
        VerifyOrReturn(CheckConstraintType("attributeList", "", "list"));
        NextTest();
    }
};

class Test_TC_PRS_1_1Suite : public TestCommand
{
public:
    Test_TC_PRS_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_PRS_1_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_PRS_1_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_PRS_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_PRS_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read the global attribute constraints: ClusterRevision\n");
            err = TestReadTheGlobalAttributeConstraintsClusterRevision_1();
            break;
        case 2:
            ChipLogProgress(chipTool,
                            " ***** Test Step 2 : Write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read the global attribute constraints: AttributeList\n");
            err = TestReadTheGlobalAttributeConstraintsAttributeList_3();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 4;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_1(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_PRS_1_1Suite *>(context))->OnFailureResponse_1(error);
    }

    static void OnSuccessCallback_1(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_PRS_1_1Suite *>(context))->OnSuccessResponse_1(clusterRevision);
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_PRS_1_1Suite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context) { (static_cast<Test_TC_PRS_1_1Suite *>(context))->OnSuccessResponse_2(); }

    static void OnFailureCallback_3(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_PRS_1_1Suite *>(context))->OnFailureResponse_3(error);
    }

    static void OnSuccessCallback_3(void * context, const chip::app::DataModel::DecodableList<chip::AttributeId> & attributeList)
    {
        (static_cast<Test_TC_PRS_1_1Suite *>(context))->OnSuccessResponse_3(attributeList);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestReadTheGlobalAttributeConstraintsClusterRevision_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::PressureMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::PressureMeasurement::Attributes::ClusterRevision::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckConstraintType("clusterRevision", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::PressureMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t clusterRevisionArgument;
        clusterRevisionArgument = 3U;

        ReturnErrorOnFailure(
            cluster.WriteAttribute<chip::app::Clusters::PressureMeasurement::Attributes::ClusterRevision::TypeInfo>(
                clusterRevisionArgument, this, OnSuccessCallback_2, OnFailureCallback_2));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_2() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadTheGlobalAttributeConstraintsAttributeList_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::PressureMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::PressureMeasurement::Attributes::AttributeList::TypeInfo>(
            this, OnSuccessCallback_3, OnFailureCallback_3, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3(const chip::app::DataModel::DecodableList<chip::AttributeId> & attributeList)
    {
        VerifyOrReturn(CheckConstraintType("attributeList", "", "list"));
        NextTest();
    }
};

class Test_TC_PRS_2_1Suite : public TestCommand
{
public:
    Test_TC_PRS_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_PRS_2_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_PRS_2_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_PRS_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_PRS_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read the mandatory attribute constraints: MeasuredValue\n");
            err = TestReadTheMandatoryAttributeConstraintsMeasuredValue_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Write the default values to mandatory attribute: MeasuredValue\n");
            err = TestWriteTheDefaultValuesToMandatoryAttributeMeasuredValue_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Reads back mandatory attribute: MeasuredValue\n");
            err = TestReadsBackMandatoryAttributeMeasuredValue_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Read the mandatory attribute constraints: MinMeasuredValue\n");
            err = TestReadTheMandatoryAttributeConstraintsMinMeasuredValue_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Write the default values to mandatory attribute: MinMeasuredValue\n");
            err = TestWriteTheDefaultValuesToMandatoryAttributeMinMeasuredValue_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Reads back mandatory attribute: MinMeasuredValue\n");
            err = TestReadsBackMandatoryAttributeMinMeasuredValue_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Read the mandatory attribute constraints: MaxMeasuredValue\n");
            err = TestReadTheMandatoryAttributeConstraintsMaxMeasuredValue_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Write the default values to mandatory attribute: MaxMeasuredValue\n");
            err = TestWriteTheDefaultValuesToMandatoryAttributeMaxMeasuredValue_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Reads back mandatory attribute: MaxMeasuredValue\n");
            err = TestReadsBackMandatoryAttributeMaxMeasuredValue_9();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 10;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_1(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_PRS_2_1Suite *>(context))->OnFailureResponse_1(error);
    }

    static void OnSuccessCallback_1(void * context, const chip::app::DataModel::Nullable<int16_t> & measuredValue)
    {
        (static_cast<Test_TC_PRS_2_1Suite *>(context))->OnSuccessResponse_1(measuredValue);
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_PRS_2_1Suite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context) { (static_cast<Test_TC_PRS_2_1Suite *>(context))->OnSuccessResponse_2(); }

    static void OnFailureCallback_3(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_PRS_2_1Suite *>(context))->OnFailureResponse_3(error);
    }

    static void OnSuccessCallback_3(void * context, const chip::app::DataModel::Nullable<int16_t> & measuredValue)
    {
        (static_cast<Test_TC_PRS_2_1Suite *>(context))->OnSuccessResponse_3(measuredValue);
    }

    static void OnFailureCallback_4(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_PRS_2_1Suite *>(context))->OnFailureResponse_4(error);
    }

    static void OnSuccessCallback_4(void * context, const chip::app::DataModel::Nullable<int16_t> & minMeasuredValue)
    {
        (static_cast<Test_TC_PRS_2_1Suite *>(context))->OnSuccessResponse_4(minMeasuredValue);
    }

    static void OnFailureCallback_5(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_PRS_2_1Suite *>(context))->OnFailureResponse_5(error);
    }

    static void OnSuccessCallback_5(void * context) { (static_cast<Test_TC_PRS_2_1Suite *>(context))->OnSuccessResponse_5(); }

    static void OnFailureCallback_6(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_PRS_2_1Suite *>(context))->OnFailureResponse_6(error);
    }

    static void OnSuccessCallback_6(void * context, const chip::app::DataModel::Nullable<int16_t> & minMeasuredValue)
    {
        (static_cast<Test_TC_PRS_2_1Suite *>(context))->OnSuccessResponse_6(minMeasuredValue);
    }

    static void OnFailureCallback_7(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_PRS_2_1Suite *>(context))->OnFailureResponse_7(error);
    }

    static void OnSuccessCallback_7(void * context, const chip::app::DataModel::Nullable<int16_t> & maxMeasuredValue)
    {
        (static_cast<Test_TC_PRS_2_1Suite *>(context))->OnSuccessResponse_7(maxMeasuredValue);
    }

    static void OnFailureCallback_8(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_PRS_2_1Suite *>(context))->OnFailureResponse_8(error);
    }

    static void OnSuccessCallback_8(void * context) { (static_cast<Test_TC_PRS_2_1Suite *>(context))->OnSuccessResponse_8(); }

    static void OnFailureCallback_9(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_PRS_2_1Suite *>(context))->OnFailureResponse_9(error);
    }

    static void OnSuccessCallback_9(void * context, const chip::app::DataModel::Nullable<int16_t> & maxMeasuredValue)
    {
        (static_cast<Test_TC_PRS_2_1Suite *>(context))->OnSuccessResponse_9(maxMeasuredValue);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestReadTheMandatoryAttributeConstraintsMeasuredValue_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::PressureMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::PressureMeasurement::Attributes::MeasuredValue::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1(const chip::app::DataModel::Nullable<int16_t> & measuredValue)
    {
        VerifyOrReturn(CheckConstraintType("measuredValue", "", "int16"));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryAttributeMeasuredValue_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::PressureMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<int16_t> measuredValueArgument;
        measuredValueArgument.SetNonNull();
        measuredValueArgument.Value() = 0;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::PressureMeasurement::Attributes::MeasuredValue::TypeInfo>(
            measuredValueArgument, this, OnSuccessCallback_2, OnFailureCallback_2));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_2() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackMandatoryAttributeMeasuredValue_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::PressureMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::PressureMeasurement::Attributes::MeasuredValue::TypeInfo>(
            this, OnSuccessCallback_3, OnFailureCallback_3, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3(const chip::app::DataModel::Nullable<int16_t> & measuredValue)
    {
        VerifyOrReturn(CheckValueNonNull("measuredValue", measuredValue));
        VerifyOrReturn(CheckValue("measuredValue.Value()", measuredValue.Value(), 0));

        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeConstraintsMinMeasuredValue_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::PressureMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::PressureMeasurement::Attributes::MinMeasuredValue::TypeInfo>(
                this, OnSuccessCallback_4, OnFailureCallback_4, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_4(const chip::app::DataModel::Nullable<int16_t> & minMeasuredValue)
    {
        VerifyOrReturn(CheckConstraintType("minMeasuredValue", "", "int16"));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryAttributeMinMeasuredValue_5()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::PressureMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<int16_t> minMeasuredValueArgument;
        minMeasuredValueArgument.SetNonNull();
        minMeasuredValueArgument.Value() = 0;

        ReturnErrorOnFailure(
            cluster.WriteAttribute<chip::app::Clusters::PressureMeasurement::Attributes::MinMeasuredValue::TypeInfo>(
                minMeasuredValueArgument, this, OnSuccessCallback_5, OnFailureCallback_5));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_5() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackMandatoryAttributeMinMeasuredValue_6()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::PressureMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::PressureMeasurement::Attributes::MinMeasuredValue::TypeInfo>(
                this, OnSuccessCallback_6, OnFailureCallback_6, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_6(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_6(const chip::app::DataModel::Nullable<int16_t> & minMeasuredValue)
    {
        VerifyOrReturn(CheckValueNonNull("minMeasuredValue", minMeasuredValue));
        VerifyOrReturn(CheckValue("minMeasuredValue.Value()", minMeasuredValue.Value(), 0));

        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeConstraintsMaxMeasuredValue_7()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::PressureMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::PressureMeasurement::Attributes::MaxMeasuredValue::TypeInfo>(
                this, OnSuccessCallback_7, OnFailureCallback_7, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_7(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_7(const chip::app::DataModel::Nullable<int16_t> & maxMeasuredValue)
    {
        VerifyOrReturn(CheckConstraintType("maxMeasuredValue", "", "int16"));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryAttributeMaxMeasuredValue_8()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::PressureMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<int16_t> maxMeasuredValueArgument;
        maxMeasuredValueArgument.SetNonNull();
        maxMeasuredValueArgument.Value() = 0;

        ReturnErrorOnFailure(
            cluster.WriteAttribute<chip::app::Clusters::PressureMeasurement::Attributes::MaxMeasuredValue::TypeInfo>(
                maxMeasuredValueArgument, this, OnSuccessCallback_8, OnFailureCallback_8));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_8(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_8() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackMandatoryAttributeMaxMeasuredValue_9()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::PressureMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::PressureMeasurement::Attributes::MaxMeasuredValue::TypeInfo>(
                this, OnSuccessCallback_9, OnFailureCallback_9, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_9(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_9(const chip::app::DataModel::Nullable<int16_t> & maxMeasuredValue)
    {
        VerifyOrReturn(CheckValueNonNull("maxMeasuredValue", maxMeasuredValue));
        VerifyOrReturn(CheckValue("maxMeasuredValue.Value()", maxMeasuredValue.Value(), 0));

        NextTest();
    }
};

class Test_TC_PCC_1_1Suite : public TestCommand
{
public:
    Test_TC_PCC_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_PCC_1_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_PCC_1_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_PCC_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_PCC_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read the global attribute constraints: ClusterRevision\n");
            err = TestReadTheGlobalAttributeConstraintsClusterRevision_1();
            break;
        case 2:
            ChipLogProgress(chipTool,
                            " ***** Test Step 2 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read the global attribute: AttributeList\n");
            err = TestReadTheGlobalAttributeAttributeList_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : read the optional global attribute: FeatureMap\n");
            err = TestReadTheOptionalGlobalAttributeFeatureMap_4();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 5;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_1(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_PCC_1_1Suite *>(context))->OnFailureResponse_1(error);
    }

    static void OnSuccessCallback_1(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_PCC_1_1Suite *>(context))->OnSuccessResponse_1(clusterRevision);
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_PCC_1_1Suite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context) { (static_cast<Test_TC_PCC_1_1Suite *>(context))->OnSuccessResponse_2(); }

    static void OnFailureCallback_3(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_PCC_1_1Suite *>(context))->OnFailureResponse_3(error);
    }

    static void OnSuccessCallback_3(void * context, const chip::app::DataModel::DecodableList<chip::AttributeId> & attributeList)
    {
        (static_cast<Test_TC_PCC_1_1Suite *>(context))->OnSuccessResponse_3(attributeList);
    }

    static void OnFailureCallback_4(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_PCC_1_1Suite *>(context))->OnFailureResponse_4(error);
    }

    static void OnSuccessCallback_4(void * context, uint32_t featureMap)
    {
        (static_cast<Test_TC_PCC_1_1Suite *>(context))->OnSuccessResponse_4(featureMap);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestReadTheGlobalAttributeConstraintsClusterRevision_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::ClusterRevision::TypeInfo>(
                this, OnSuccessCallback_1, OnFailureCallback_1, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckConstraintType("clusterRevision", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t clusterRevisionArgument;
        clusterRevisionArgument = 3U;

        ReturnErrorOnFailure(
            cluster.WriteAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::ClusterRevision::TypeInfo>(
                clusterRevisionArgument, this, OnSuccessCallback_2, OnFailureCallback_2));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_2() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadTheGlobalAttributeAttributeList_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::AttributeList::TypeInfo>(
                this, OnSuccessCallback_3, OnFailureCallback_3, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3(const chip::app::DataModel::DecodableList<chip::AttributeId> & attributeList)
    {
        VerifyOrReturn(CheckConstraintType("attributeList", "", "list"));
        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalGlobalAttributeFeatureMap_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::FeatureMap::TypeInfo>(
                this, OnSuccessCallback_4, OnFailureCallback_4, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_4(uint32_t featureMap)
    {
        VerifyOrReturn(CheckConstraintType("featureMap", "", "map32"));
        NextTest();
    }
};

class Test_TC_PCC_2_1Suite : public TestCommand
{
public:
    Test_TC_PCC_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_PCC_2_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_PCC_2_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_PCC_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_PCC_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : read the mandatory attribute: MaxPressure\n");
            err = TestReadTheMandatoryAttributeMaxPressure_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : read the mandatory attribute: MaxSpeed\n");
            err = TestReadTheMandatoryAttributeMaxSpeed_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : read the mandatory attribute: MaxFlow\n");
            err = TestReadTheMandatoryAttributeMaxFlow_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : read the mandatory attribute: EffectiveOperationMode\n");
            err = TestReadTheMandatoryAttributeEffectiveOperationMode_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : read the mandatory attribute: EffectiveControlMode\n");
            err = TestReadTheMandatoryAttributeEffectiveControlMode_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : read the mandatory attribute: Capacity\n");
            err = TestReadTheMandatoryAttributeCapacity_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : read the mandatory attribute: MaxPressure\n");
            err = TestReadTheMandatoryAttributeMaxPressure_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : read the mandatory attribute: MaxSpeed\n");
            err = TestReadTheMandatoryAttributeMaxSpeed_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : read the mandatory attribute: MaxFlow\n");
            err = TestReadTheMandatoryAttributeMaxFlow_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : read the mandatory attribute: EffectiveOperationMode\n");
            err = TestReadTheMandatoryAttributeEffectiveOperationMode_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : read the mandatory attribute: EffectiveControlMode\n");
            err = TestReadTheMandatoryAttributeEffectiveControlMode_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : read the mandatory attribute: Capacity\n");
            err = TestReadTheMandatoryAttributeCapacity_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : read the optional attribute: MinConstPressure\n");
            err = TestReadTheOptionalAttributeMinConstPressure_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : read the optional attribute: MaxConstPressure\n");
            err = TestReadTheOptionalAttributeMaxConstPressure_14();
            break;
        case 15:
            ChipLogProgress(chipTool, " ***** Test Step 15 : read the optional attribute: MinCompPressure\n");
            err = TestReadTheOptionalAttributeMinCompPressure_15();
            break;
        case 16:
            ChipLogProgress(chipTool, " ***** Test Step 16 : read the optional attribute: MaxCompPressure\n");
            err = TestReadTheOptionalAttributeMaxCompPressure_16();
            break;
        case 17:
            ChipLogProgress(chipTool, " ***** Test Step 17 : read the optional attribute: MinConstSpeed\n");
            err = TestReadTheOptionalAttributeMinConstSpeed_17();
            break;
        case 18:
            ChipLogProgress(chipTool, " ***** Test Step 18 : read the optional attribute: MaxConstSpeed\n");
            err = TestReadTheOptionalAttributeMaxConstSpeed_18();
            break;
        case 19:
            ChipLogProgress(chipTool, " ***** Test Step 19 : read the optional attribute: MinConstFlow\n");
            err = TestReadTheOptionalAttributeMinConstFlow_19();
            break;
        case 20:
            ChipLogProgress(chipTool, " ***** Test Step 20 : read the optional attribute: MaxConstFlow\n");
            err = TestReadTheOptionalAttributeMaxConstFlow_20();
            break;
        case 21:
            ChipLogProgress(chipTool, " ***** Test Step 21 : read the optional attribute: MinConstTemp\n");
            err = TestReadTheOptionalAttributeMinConstTemp_21();
            break;
        case 22:
            ChipLogProgress(chipTool, " ***** Test Step 22 : read the optional attribute: MaxConstTemp\n");
            err = TestReadTheOptionalAttributeMaxConstTemp_22();
            break;
        case 23:
            ChipLogProgress(chipTool, " ***** Test Step 23 : read the optional attribute: PumpStatus\n");
            err = TestReadTheOptionalAttributePumpStatus_23();
            break;
        case 24:
            ChipLogProgress(chipTool, " ***** Test Step 24 : read the optional attribute: PumpStatus\n");
            err = TestReadTheOptionalAttributePumpStatus_24();
            break;
        case 25:
            ChipLogProgress(chipTool, " ***** Test Step 25 : read the optional attribute: Speed\n");
            err = TestReadTheOptionalAttributeSpeed_25();
            break;
        case 26:
            ChipLogProgress(chipTool, " ***** Test Step 26 : read the optional attribute: LifetimeRunningHours\n");
            err = TestReadTheOptionalAttributeLifetimeRunningHours_26();
            break;
        case 27:
            ChipLogProgress(chipTool, " ***** Test Step 27 : read the optional attribute: LifetimeRunningHours\n");
            err = TestReadTheOptionalAttributeLifetimeRunningHours_27();
            break;
        case 28:
            ChipLogProgress(chipTool, " ***** Test Step 28 : read the optional attribute: Power\n");
            err = TestReadTheOptionalAttributePower_28();
            break;
        case 29:
            ChipLogProgress(chipTool, " ***** Test Step 29 : read the optional attribute: LifetimeEnergyConsumed\n");
            err = TestReadTheOptionalAttributeLifetimeEnergyConsumed_29();
            break;
        case 30:
            ChipLogProgress(chipTool, " ***** Test Step 30 : read the optional attribute: LifetimeEnergyConsumed\n");
            err = TestReadTheOptionalAttributeLifetimeEnergyConsumed_30();
            break;
        case 31:
            ChipLogProgress(chipTool, " ***** Test Step 31 : write to the optional attribute: LifetimeEnergyConsumed\n");
            err = TestWriteToTheOptionalAttributeLifetimeEnergyConsumed_31();
            break;
        case 32:
            ChipLogProgress(chipTool, " ***** Test Step 32 : read the optional attribute: MinConstPressure\n");
            err = TestReadTheOptionalAttributeMinConstPressure_32();
            break;
        case 33:
            ChipLogProgress(chipTool, " ***** Test Step 33 : read the optional attribute: MaxConstPressure\n");
            err = TestReadTheOptionalAttributeMaxConstPressure_33();
            break;
        case 34:
            ChipLogProgress(chipTool, " ***** Test Step 34 : read the optional attribute: MinCompPressure\n");
            err = TestReadTheOptionalAttributeMinCompPressure_34();
            break;
        case 35:
            ChipLogProgress(chipTool, " ***** Test Step 35 : read the optional attribute: MaxCompPressure\n");
            err = TestReadTheOptionalAttributeMaxCompPressure_35();
            break;
        case 36:
            ChipLogProgress(chipTool, " ***** Test Step 36 : read the optional attribute: MinConstSpeed\n");
            err = TestReadTheOptionalAttributeMinConstSpeed_36();
            break;
        case 37:
            ChipLogProgress(chipTool, " ***** Test Step 37 : read the optional attribute: MaxConstSpeed\n");
            err = TestReadTheOptionalAttributeMaxConstSpeed_37();
            break;
        case 38:
            ChipLogProgress(chipTool, " ***** Test Step 38 : read the optional attribute: MinConstFlow\n");
            err = TestReadTheOptionalAttributeMinConstFlow_38();
            break;
        case 39:
            ChipLogProgress(chipTool, " ***** Test Step 39 : read the optional attribute: MaxConstFlow\n");
            err = TestReadTheOptionalAttributeMaxConstFlow_39();
            break;
        case 40:
            ChipLogProgress(chipTool, " ***** Test Step 40 : read the optional attribute: MinConstTemp\n");
            err = TestReadTheOptionalAttributeMinConstTemp_40();
            break;
        case 41:
            ChipLogProgress(chipTool, " ***** Test Step 41 : read the optional attribute: MaxConstTemp\n");
            err = TestReadTheOptionalAttributeMaxConstTemp_41();
            break;
        case 42:
            ChipLogProgress(chipTool, " ***** Test Step 42 : read the optional attribute: PumpStatus\n");
            err = TestReadTheOptionalAttributePumpStatus_42();
            break;
        case 43:
            ChipLogProgress(chipTool, " ***** Test Step 43 : read the optional attribute: PumpStatus\n");
            err = TestReadTheOptionalAttributePumpStatus_43();
            break;
        case 44:
            ChipLogProgress(chipTool, " ***** Test Step 44 : read the optional attribute: Speed\n");
            err = TestReadTheOptionalAttributeSpeed_44();
            break;
        case 45:
            ChipLogProgress(chipTool, " ***** Test Step 45 : read the optional attribute: LifetimeRunningHours\n");
            err = TestReadTheOptionalAttributeLifetimeRunningHours_45();
            break;
        case 46:
            ChipLogProgress(chipTool, " ***** Test Step 46 : read the optional attribute: LifetimeRunningHours\n");
            err = TestReadTheOptionalAttributeLifetimeRunningHours_46();
            break;
        case 47:
            ChipLogProgress(chipTool, " ***** Test Step 47 : read the optional attribute: Power\n");
            err = TestReadTheOptionalAttributePower_47();
            break;
        case 48:
            ChipLogProgress(chipTool, " ***** Test Step 48 : read the optional attribute: LifetimeEnergyConsumed\n");
            err = TestReadTheOptionalAttributeLifetimeEnergyConsumed_48();
            break;
        case 49:
            ChipLogProgress(chipTool, " ***** Test Step 49 : read the optional attribute: LifetimeEnergyConsumed\n");
            err = TestReadTheOptionalAttributeLifetimeEnergyConsumed_49();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 50;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_1(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnFailureResponse_1(error);
    }

    static void OnSuccessCallback_1(void * context, int16_t maxPressure)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnSuccessResponse_1(maxPressure);
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context, uint16_t maxSpeed)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnSuccessResponse_2(maxSpeed);
    }

    static void OnFailureCallback_3(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnFailureResponse_3(error);
    }

    static void OnSuccessCallback_3(void * context, uint16_t maxFlow)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnSuccessResponse_3(maxFlow);
    }

    static void OnFailureCallback_4(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnFailureResponse_4(error);
    }

    static void OnSuccessCallback_4(void * context, uint8_t effectiveOperationMode)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnSuccessResponse_4(effectiveOperationMode);
    }

    static void OnFailureCallback_5(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnFailureResponse_5(error);
    }

    static void OnSuccessCallback_5(void * context, uint8_t effectiveControlMode)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnSuccessResponse_5(effectiveControlMode);
    }

    static void OnFailureCallback_6(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnFailureResponse_6(error);
    }

    static void OnSuccessCallback_6(void * context, int16_t capacity)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnSuccessResponse_6(capacity);
    }

    static void OnFailureCallback_7(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnFailureResponse_7(error);
    }

    static void OnSuccessCallback_7(void * context, int16_t maxPressure)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnSuccessResponse_7(maxPressure);
    }

    static void OnFailureCallback_8(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnFailureResponse_8(error);
    }

    static void OnSuccessCallback_8(void * context, uint16_t maxSpeed)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnSuccessResponse_8(maxSpeed);
    }

    static void OnFailureCallback_9(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnFailureResponse_9(error);
    }

    static void OnSuccessCallback_9(void * context, uint16_t maxFlow)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnSuccessResponse_9(maxFlow);
    }

    static void OnFailureCallback_10(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnFailureResponse_10(error);
    }

    static void OnSuccessCallback_10(void * context, uint8_t effectiveOperationMode)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnSuccessResponse_10(effectiveOperationMode);
    }

    static void OnFailureCallback_11(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnFailureResponse_11(error);
    }

    static void OnSuccessCallback_11(void * context, uint8_t effectiveControlMode)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnSuccessResponse_11(effectiveControlMode);
    }

    static void OnFailureCallback_12(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnFailureResponse_12(error);
    }

    static void OnSuccessCallback_12(void * context, int16_t capacity)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnSuccessResponse_12(capacity);
    }

    static void OnFailureCallback_13(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnFailureResponse_13(error);
    }

    static void OnSuccessCallback_13(void * context, int16_t minConstPressure)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnSuccessResponse_13(minConstPressure);
    }

    static void OnFailureCallback_14(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnFailureResponse_14(error);
    }

    static void OnSuccessCallback_14(void * context, int16_t maxConstPressure)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnSuccessResponse_14(maxConstPressure);
    }

    static void OnFailureCallback_15(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnFailureResponse_15(error);
    }

    static void OnSuccessCallback_15(void * context, int16_t minCompPressure)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnSuccessResponse_15(minCompPressure);
    }

    static void OnFailureCallback_16(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnFailureResponse_16(error);
    }

    static void OnSuccessCallback_16(void * context, int16_t maxCompPressure)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnSuccessResponse_16(maxCompPressure);
    }

    static void OnFailureCallback_17(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnFailureResponse_17(error);
    }

    static void OnSuccessCallback_17(void * context, uint16_t minConstSpeed)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnSuccessResponse_17(minConstSpeed);
    }

    static void OnFailureCallback_18(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnFailureResponse_18(error);
    }

    static void OnSuccessCallback_18(void * context, uint16_t maxConstSpeed)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnSuccessResponse_18(maxConstSpeed);
    }

    static void OnFailureCallback_19(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnFailureResponse_19(error);
    }

    static void OnSuccessCallback_19(void * context, uint16_t minConstFlow)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnSuccessResponse_19(minConstFlow);
    }

    static void OnFailureCallback_20(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnFailureResponse_20(error);
    }

    static void OnSuccessCallback_20(void * context, uint16_t maxConstFlow)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnSuccessResponse_20(maxConstFlow);
    }

    static void OnFailureCallback_21(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnFailureResponse_21(error);
    }

    static void OnSuccessCallback_21(void * context, int16_t minConstTemp)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnSuccessResponse_21(minConstTemp);
    }

    static void OnFailureCallback_22(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnFailureResponse_22(error);
    }

    static void OnSuccessCallback_22(void * context, int16_t maxConstTemp)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnSuccessResponse_22(maxConstTemp);
    }

    static void OnFailureCallback_23(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnFailureResponse_23(error);
    }

    static void OnSuccessCallback_23(void * context, uint16_t pumpStatus)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnSuccessResponse_23(pumpStatus);
    }

    static void OnFailureCallback_24(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnFailureResponse_24(error);
    }

    static void OnSuccessCallback_24(void * context, uint16_t pumpStatus)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnSuccessResponse_24(pumpStatus);
    }

    static void OnFailureCallback_25(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnFailureResponse_25(error);
    }

    static void OnSuccessCallback_25(void * context, uint16_t speed)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnSuccessResponse_25(speed);
    }

    static void OnFailureCallback_26(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnFailureResponse_26(error);
    }

    static void OnSuccessCallback_26(void * context, const chip::app::DataModel::Nullable<uint32_t> & lifetimeRunningHours)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnSuccessResponse_26(lifetimeRunningHours);
    }

    static void OnFailureCallback_27(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnFailureResponse_27(error);
    }

    static void OnSuccessCallback_27(void * context, const chip::app::DataModel::Nullable<uint32_t> & lifetimeRunningHours)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnSuccessResponse_27(lifetimeRunningHours);
    }

    static void OnFailureCallback_28(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnFailureResponse_28(error);
    }

    static void OnSuccessCallback_28(void * context, uint32_t power)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnSuccessResponse_28(power);
    }

    static void OnFailureCallback_29(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnFailureResponse_29(error);
    }

    static void OnSuccessCallback_29(void * context, const chip::app::DataModel::Nullable<uint32_t> & lifetimeEnergyConsumed)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnSuccessResponse_29(lifetimeEnergyConsumed);
    }

    static void OnFailureCallback_30(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnFailureResponse_30(error);
    }

    static void OnSuccessCallback_30(void * context, const chip::app::DataModel::Nullable<uint32_t> & lifetimeEnergyConsumed)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnSuccessResponse_30(lifetimeEnergyConsumed);
    }

    static void OnFailureCallback_31(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnFailureResponse_31(error);
    }

    static void OnSuccessCallback_31(void * context) { (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnSuccessResponse_31(); }

    static void OnFailureCallback_32(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnFailureResponse_32(error);
    }

    static void OnSuccessCallback_32(void * context, int16_t minConstPressure)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnSuccessResponse_32(minConstPressure);
    }

    static void OnFailureCallback_33(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnFailureResponse_33(error);
    }

    static void OnSuccessCallback_33(void * context, int16_t maxConstPressure)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnSuccessResponse_33(maxConstPressure);
    }

    static void OnFailureCallback_34(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnFailureResponse_34(error);
    }

    static void OnSuccessCallback_34(void * context, int16_t minCompPressure)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnSuccessResponse_34(minCompPressure);
    }

    static void OnFailureCallback_35(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnFailureResponse_35(error);
    }

    static void OnSuccessCallback_35(void * context, int16_t maxCompPressure)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnSuccessResponse_35(maxCompPressure);
    }

    static void OnFailureCallback_36(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnFailureResponse_36(error);
    }

    static void OnSuccessCallback_36(void * context, uint16_t minConstSpeed)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnSuccessResponse_36(minConstSpeed);
    }

    static void OnFailureCallback_37(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnFailureResponse_37(error);
    }

    static void OnSuccessCallback_37(void * context, uint16_t maxConstSpeed)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnSuccessResponse_37(maxConstSpeed);
    }

    static void OnFailureCallback_38(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnFailureResponse_38(error);
    }

    static void OnSuccessCallback_38(void * context, uint16_t minConstFlow)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnSuccessResponse_38(minConstFlow);
    }

    static void OnFailureCallback_39(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnFailureResponse_39(error);
    }

    static void OnSuccessCallback_39(void * context, uint16_t maxConstFlow)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnSuccessResponse_39(maxConstFlow);
    }

    static void OnFailureCallback_40(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnFailureResponse_40(error);
    }

    static void OnSuccessCallback_40(void * context, int16_t minConstTemp)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnSuccessResponse_40(minConstTemp);
    }

    static void OnFailureCallback_41(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnFailureResponse_41(error);
    }

    static void OnSuccessCallback_41(void * context, int16_t maxConstTemp)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnSuccessResponse_41(maxConstTemp);
    }

    static void OnFailureCallback_42(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnFailureResponse_42(error);
    }

    static void OnSuccessCallback_42(void * context, uint16_t pumpStatus)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnSuccessResponse_42(pumpStatus);
    }

    static void OnFailureCallback_43(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnFailureResponse_43(error);
    }

    static void OnSuccessCallback_43(void * context, uint16_t pumpStatus)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnSuccessResponse_43(pumpStatus);
    }

    static void OnFailureCallback_44(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnFailureResponse_44(error);
    }

    static void OnSuccessCallback_44(void * context, uint16_t speed)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnSuccessResponse_44(speed);
    }

    static void OnFailureCallback_45(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnFailureResponse_45(error);
    }

    static void OnSuccessCallback_45(void * context, const chip::app::DataModel::Nullable<uint32_t> & lifetimeRunningHours)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnSuccessResponse_45(lifetimeRunningHours);
    }

    static void OnFailureCallback_46(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnFailureResponse_46(error);
    }

    static void OnSuccessCallback_46(void * context, const chip::app::DataModel::Nullable<uint32_t> & lifetimeRunningHours)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnSuccessResponse_46(lifetimeRunningHours);
    }

    static void OnFailureCallback_47(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnFailureResponse_47(error);
    }

    static void OnSuccessCallback_47(void * context, uint32_t power)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnSuccessResponse_47(power);
    }

    static void OnFailureCallback_48(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnFailureResponse_48(error);
    }

    static void OnSuccessCallback_48(void * context, const chip::app::DataModel::Nullable<uint32_t> & lifetimeEnergyConsumed)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnSuccessResponse_48(lifetimeEnergyConsumed);
    }

    static void OnFailureCallback_49(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnFailureResponse_49(error);
    }

    static void OnSuccessCallback_49(void * context, const chip::app::DataModel::Nullable<uint32_t> & lifetimeEnergyConsumed)
    {
        (static_cast<Test_TC_PCC_2_1Suite *>(context))->OnSuccessResponse_49(lifetimeEnergyConsumed);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestReadTheMandatoryAttributeMaxPressure_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::MaxPressure::TypeInfo>(
                this, OnSuccessCallback_1, OnFailureCallback_1, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1(int16_t maxPressure)
    {
        VerifyOrReturn(CheckConstraintType("maxPressure", "", "int16"));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeMaxSpeed_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::MaxSpeed::TypeInfo>(
                this, OnSuccessCallback_2, OnFailureCallback_2, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2(uint16_t maxSpeed)
    {
        VerifyOrReturn(CheckConstraintType("maxSpeed", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeMaxFlow_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::MaxFlow::TypeInfo>(
            this, OnSuccessCallback_3, OnFailureCallback_3, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3(uint16_t maxFlow)
    {
        VerifyOrReturn(CheckConstraintType("maxFlow", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeEffectiveOperationMode_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::EffectiveOperationMode::TypeInfo>(
                this, OnSuccessCallback_4, OnFailureCallback_4, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_4(uint8_t effectiveOperationMode)
    {
        VerifyOrReturn(CheckConstraintType("effectiveOperationMode", "", "enum8"));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeEffectiveControlMode_5()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::EffectiveControlMode::TypeInfo>(
                this, OnSuccessCallback_5, OnFailureCallback_5, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_5(uint8_t effectiveControlMode)
    {
        VerifyOrReturn(CheckConstraintType("effectiveControlMode", "", "enum8"));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeCapacity_6()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::Capacity::TypeInfo>(
                this, OnSuccessCallback_6, OnFailureCallback_6, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_6(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_6(int16_t capacity)
    {
        VerifyOrReturn(CheckConstraintType("capacity", "", "int16"));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeMaxPressure_7()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::MaxPressure::TypeInfo>(
                this, OnSuccessCallback_7, OnFailureCallback_7, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_7(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_7(int16_t maxPressure)
    {
        VerifyOrReturn(CheckConstraintType("maxPressure", "", "int16"));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeMaxSpeed_8()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::MaxSpeed::TypeInfo>(
                this, OnSuccessCallback_8, OnFailureCallback_8, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_8(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_8(uint16_t maxSpeed)
    {
        VerifyOrReturn(CheckConstraintType("maxSpeed", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeMaxFlow_9()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::MaxFlow::TypeInfo>(
            this, OnSuccessCallback_9, OnFailureCallback_9, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_9(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_9(uint16_t maxFlow)
    {
        VerifyOrReturn(CheckConstraintType("maxFlow", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeEffectiveOperationMode_10()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::EffectiveOperationMode::TypeInfo>(
                this, OnSuccessCallback_10, OnFailureCallback_10, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_10(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_10(uint8_t effectiveOperationMode)
    {
        VerifyOrReturn(CheckConstraintType("effectiveOperationMode", "", "enum8"));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeEffectiveControlMode_11()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::EffectiveControlMode::TypeInfo>(
                this, OnSuccessCallback_11, OnFailureCallback_11, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_11(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_11(uint8_t effectiveControlMode)
    {
        VerifyOrReturn(CheckConstraintType("effectiveControlMode", "", "enum8"));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeCapacity_12()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::Capacity::TypeInfo>(
                this, OnSuccessCallback_12, OnFailureCallback_12, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_12(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_12(int16_t capacity)
    {
        VerifyOrReturn(CheckConstraintType("capacity", "", "int16"));
        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeMinConstPressure_13()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::MinConstPressure::TypeInfo>(
                this, OnSuccessCallback_13, OnFailureCallback_13, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_13(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_13(int16_t minConstPressure)
    {
        VerifyOrReturn(CheckConstraintType("minConstPressure", "", "int16"));
        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeMaxConstPressure_14()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::MaxConstPressure::TypeInfo>(
                this, OnSuccessCallback_14, OnFailureCallback_14, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_14(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_14(int16_t maxConstPressure)
    {
        VerifyOrReturn(CheckConstraintType("maxConstPressure", "", "int16"));
        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeMinCompPressure_15()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::MinCompPressure::TypeInfo>(
                this, OnSuccessCallback_15, OnFailureCallback_15, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_15(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_15(int16_t minCompPressure)
    {
        VerifyOrReturn(CheckConstraintType("minCompPressure", "", "int16"));
        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeMaxCompPressure_16()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::MaxCompPressure::TypeInfo>(
                this, OnSuccessCallback_16, OnFailureCallback_16, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_16(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_16(int16_t maxCompPressure)
    {
        VerifyOrReturn(CheckConstraintType("maxCompPressure", "", "int16"));
        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeMinConstSpeed_17()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::MinConstSpeed::TypeInfo>(
                this, OnSuccessCallback_17, OnFailureCallback_17, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_17(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_17(uint16_t minConstSpeed)
    {
        VerifyOrReturn(CheckConstraintType("minConstSpeed", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeMaxConstSpeed_18()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::MaxConstSpeed::TypeInfo>(
                this, OnSuccessCallback_18, OnFailureCallback_18, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_18(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_18(uint16_t maxConstSpeed)
    {
        VerifyOrReturn(CheckConstraintType("maxConstSpeed", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeMinConstFlow_19()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::MinConstFlow::TypeInfo>(
                this, OnSuccessCallback_19, OnFailureCallback_19, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_19(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_19(uint16_t minConstFlow)
    {
        VerifyOrReturn(CheckConstraintType("minConstFlow", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeMaxConstFlow_20()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::MaxConstFlow::TypeInfo>(
                this, OnSuccessCallback_20, OnFailureCallback_20, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_20(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_20(uint16_t maxConstFlow)
    {
        VerifyOrReturn(CheckConstraintType("maxConstFlow", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeMinConstTemp_21()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::MinConstTemp::TypeInfo>(
                this, OnSuccessCallback_21, OnFailureCallback_21, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_21(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_21(int16_t minConstTemp)
    {
        VerifyOrReturn(CheckConstraintType("minConstTemp", "", "int16"));
        VerifyOrReturn(CheckConstraintMinValue<int16_t>("minConstTemp", minConstTemp, -27315));
        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeMaxConstTemp_22()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::MaxConstTemp::TypeInfo>(
                this, OnSuccessCallback_22, OnFailureCallback_22, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_22(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_22(int16_t maxConstTemp)
    {
        VerifyOrReturn(CheckConstraintType("maxConstTemp", "", "int16"));
        VerifyOrReturn(CheckConstraintMinValue<int16_t>("maxConstTemp", maxConstTemp, -27315));
        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributePumpStatus_23()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::PumpStatus::TypeInfo>(
                this, OnSuccessCallback_23, OnFailureCallback_23, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_23(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_23(uint16_t pumpStatus)
    {
        VerifyOrReturn(CheckValue("pumpStatus", pumpStatus, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributePumpStatus_24()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::PumpStatus::TypeInfo>(
                this, OnSuccessCallback_24, OnFailureCallback_24, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_24(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_24(uint16_t pumpStatus)
    {
        VerifyOrReturn(CheckConstraintType("pumpStatus", "", "map16"));
        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeSpeed_25()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::Speed::TypeInfo>(
            this, OnSuccessCallback_25, OnFailureCallback_25, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_25(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_25(uint16_t speed)
    {
        VerifyOrReturn(CheckConstraintType("speed", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeLifetimeRunningHours_26()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::LifetimeRunningHours::TypeInfo>(
                this, OnSuccessCallback_26, OnFailureCallback_26, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_26(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_26(const chip::app::DataModel::Nullable<uint32_t> & lifetimeRunningHours)
    {
        VerifyOrReturn(CheckValueNonNull("lifetimeRunningHours", lifetimeRunningHours));
        VerifyOrReturn(CheckValue("lifetimeRunningHours.Value()", lifetimeRunningHours.Value(), 0UL));

        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeLifetimeRunningHours_27()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::LifetimeRunningHours::TypeInfo>(
                this, OnSuccessCallback_27, OnFailureCallback_27, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_27(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_27(const chip::app::DataModel::Nullable<uint32_t> & lifetimeRunningHours)
    {
        VerifyOrReturn(CheckConstraintType("lifetimeRunningHours", "", "uint24"));
        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributePower_28()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::Power::TypeInfo>(
            this, OnSuccessCallback_28, OnFailureCallback_28, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_28(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_28(uint32_t power)
    {
        VerifyOrReturn(CheckConstraintType("power", "", "uint24"));
        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeLifetimeEnergyConsumed_29()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::LifetimeEnergyConsumed::TypeInfo>(
                this, OnSuccessCallback_29, OnFailureCallback_29, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_29(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_29(const chip::app::DataModel::Nullable<uint32_t> & lifetimeEnergyConsumed)
    {
        VerifyOrReturn(CheckValueNonNull("lifetimeEnergyConsumed", lifetimeEnergyConsumed));
        VerifyOrReturn(CheckValue("lifetimeEnergyConsumed.Value()", lifetimeEnergyConsumed.Value(), 0UL));

        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeLifetimeEnergyConsumed_30()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::LifetimeEnergyConsumed::TypeInfo>(
                this, OnSuccessCallback_30, OnFailureCallback_30, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_30(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_30(const chip::app::DataModel::Nullable<uint32_t> & lifetimeEnergyConsumed)
    {
        VerifyOrReturn(CheckConstraintType("lifetimeEnergyConsumed", "", "uint32"));
        NextTest();
    }

    CHIP_ERROR TestWriteToTheOptionalAttributeLifetimeEnergyConsumed_31()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint32_t> lifetimeEnergyConsumedArgument;
        lifetimeEnergyConsumedArgument.SetNonNull();
        lifetimeEnergyConsumedArgument.Value() = 0UL;

        ReturnErrorOnFailure(
            cluster.WriteAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::LifetimeEnergyConsumed::TypeInfo>(
                lifetimeEnergyConsumedArgument, this, OnSuccessCallback_31, OnFailureCallback_31));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_31(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_31() { NextTest(); }

    CHIP_ERROR TestReadTheOptionalAttributeMinConstPressure_32()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::MinConstPressure::TypeInfo>(
                this, OnSuccessCallback_32, OnFailureCallback_32, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_32(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_32(int16_t minConstPressure)
    {
        VerifyOrReturn(CheckConstraintType("minConstPressure", "", "int16"));
        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeMaxConstPressure_33()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::MaxConstPressure::TypeInfo>(
                this, OnSuccessCallback_33, OnFailureCallback_33, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_33(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_33(int16_t maxConstPressure)
    {
        VerifyOrReturn(CheckConstraintType("maxConstPressure", "", "int16"));
        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeMinCompPressure_34()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::MinCompPressure::TypeInfo>(
                this, OnSuccessCallback_34, OnFailureCallback_34, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_34(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_34(int16_t minCompPressure)
    {
        VerifyOrReturn(CheckConstraintType("minCompPressure", "", "int16"));
        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeMaxCompPressure_35()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::MaxCompPressure::TypeInfo>(
                this, OnSuccessCallback_35, OnFailureCallback_35, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_35(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_35(int16_t maxCompPressure)
    {
        VerifyOrReturn(CheckConstraintType("maxCompPressure", "", "int16"));
        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeMinConstSpeed_36()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::MinConstSpeed::TypeInfo>(
                this, OnSuccessCallback_36, OnFailureCallback_36, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_36(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_36(uint16_t minConstSpeed)
    {
        VerifyOrReturn(CheckConstraintType("minConstSpeed", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeMaxConstSpeed_37()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::MaxConstSpeed::TypeInfo>(
                this, OnSuccessCallback_37, OnFailureCallback_37, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_37(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_37(uint16_t maxConstSpeed)
    {
        VerifyOrReturn(CheckConstraintType("maxConstSpeed", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeMinConstFlow_38()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::MinConstFlow::TypeInfo>(
                this, OnSuccessCallback_38, OnFailureCallback_38, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_38(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_38(uint16_t minConstFlow)
    {
        VerifyOrReturn(CheckConstraintType("minConstFlow", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeMaxConstFlow_39()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::MaxConstFlow::TypeInfo>(
                this, OnSuccessCallback_39, OnFailureCallback_39, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_39(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_39(uint16_t maxConstFlow)
    {
        VerifyOrReturn(CheckConstraintType("maxConstFlow", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeMinConstTemp_40()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::MinConstTemp::TypeInfo>(
                this, OnSuccessCallback_40, OnFailureCallback_40, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_40(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_40(int16_t minConstTemp)
    {
        VerifyOrReturn(CheckConstraintType("minConstTemp", "", "int16"));
        VerifyOrReturn(CheckConstraintMinValue<int16_t>("minConstTemp", minConstTemp, -27315));
        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeMaxConstTemp_41()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::MaxConstTemp::TypeInfo>(
                this, OnSuccessCallback_41, OnFailureCallback_41, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_41(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_41(int16_t maxConstTemp)
    {
        VerifyOrReturn(CheckConstraintType("maxConstTemp", "", "int16"));
        VerifyOrReturn(CheckConstraintMinValue<int16_t>("maxConstTemp", maxConstTemp, -27315));
        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributePumpStatus_42()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::PumpStatus::TypeInfo>(
                this, OnSuccessCallback_42, OnFailureCallback_42, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_42(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_42(uint16_t pumpStatus)
    {
        VerifyOrReturn(CheckValue("pumpStatus", pumpStatus, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributePumpStatus_43()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::PumpStatus::TypeInfo>(
                this, OnSuccessCallback_43, OnFailureCallback_43, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_43(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_43(uint16_t pumpStatus)
    {
        VerifyOrReturn(CheckConstraintType("pumpStatus", "", "map16"));
        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeSpeed_44()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::Speed::TypeInfo>(
            this, OnSuccessCallback_44, OnFailureCallback_44, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_44(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_44(uint16_t speed)
    {
        VerifyOrReturn(CheckConstraintType("speed", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeLifetimeRunningHours_45()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::LifetimeRunningHours::TypeInfo>(
                this, OnSuccessCallback_45, OnFailureCallback_45, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_45(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_45(const chip::app::DataModel::Nullable<uint32_t> & lifetimeRunningHours)
    {
        VerifyOrReturn(CheckValueNonNull("lifetimeRunningHours", lifetimeRunningHours));
        VerifyOrReturn(CheckValue("lifetimeRunningHours.Value()", lifetimeRunningHours.Value(), 0UL));

        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeLifetimeRunningHours_46()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::LifetimeRunningHours::TypeInfo>(
                this, OnSuccessCallback_46, OnFailureCallback_46, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_46(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_46(const chip::app::DataModel::Nullable<uint32_t> & lifetimeRunningHours)
    {
        VerifyOrReturn(CheckConstraintType("lifetimeRunningHours", "", "uint24"));
        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributePower_47()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::Power::TypeInfo>(
            this, OnSuccessCallback_47, OnFailureCallback_47, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_47(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_47(uint32_t power)
    {
        VerifyOrReturn(CheckConstraintType("power", "", "uint24"));
        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeLifetimeEnergyConsumed_48()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::LifetimeEnergyConsumed::TypeInfo>(
                this, OnSuccessCallback_48, OnFailureCallback_48, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_48(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_48(const chip::app::DataModel::Nullable<uint32_t> & lifetimeEnergyConsumed)
    {
        VerifyOrReturn(CheckValueNonNull("lifetimeEnergyConsumed", lifetimeEnergyConsumed));
        VerifyOrReturn(CheckValue("lifetimeEnergyConsumed.Value()", lifetimeEnergyConsumed.Value(), 0UL));

        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeLifetimeEnergyConsumed_49()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::LifetimeEnergyConsumed::TypeInfo>(
                this, OnSuccessCallback_49, OnFailureCallback_49, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_49(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_49(const chip::app::DataModel::Nullable<uint32_t> & lifetimeEnergyConsumed)
    {
        VerifyOrReturn(CheckConstraintType("lifetimeEnergyConsumed", "", "uint32"));
        NextTest();
    }
};

class Test_TC_PCC_2_2Suite : public TestCommand
{
public:
    Test_TC_PCC_2_2Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_PCC_2_2", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_PCC_2_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_PCC_2_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_PCC_2_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Write 1 to the OperationMode attribute to DUT: OperationMode\n");
            if (ShouldSkip("A_OPERATIONMODE"))
            {
                NextTest();
                return;
            }
            err = TestWrite1ToTheOperationModeAttributeToDutOperationMode_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Write 2 to the OperationMode attribute to DUT: OperationMode\n");
            if (ShouldSkip("A_OPERATIONMODE"))
            {
                NextTest();
                return;
            }
            err = TestWrite2ToTheOperationModeAttributeToDutOperationMode_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Write 3 to the OperationMode attribute to DUT: OperationMode\n");
            if (ShouldSkip("A_OPERATIONMODE"))
            {
                NextTest();
                return;
            }
            err = TestWrite3ToTheOperationModeAttributeToDutOperationMode_3();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 4;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_1(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_PCC_2_2Suite *>(context))->OnFailureResponse_1(error);
    }

    static void OnSuccessCallback_1(void * context) { (static_cast<Test_TC_PCC_2_2Suite *>(context))->OnSuccessResponse_1(); }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_PCC_2_2Suite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context) { (static_cast<Test_TC_PCC_2_2Suite *>(context))->OnSuccessResponse_2(); }

    static void OnFailureCallback_3(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_PCC_2_2Suite *>(context))->OnFailureResponse_3(error);
    }

    static void OnSuccessCallback_3(void * context) { (static_cast<Test_TC_PCC_2_2Suite *>(context))->OnSuccessResponse_3(); }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestWrite1ToTheOperationModeAttributeToDutOperationMode_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t operationModeArgument;
        operationModeArgument = 1;

        ReturnErrorOnFailure(
            cluster.WriteAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::OperationMode::TypeInfo>(
                operationModeArgument, this, OnSuccessCallback_1, OnFailureCallback_1));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestWrite2ToTheOperationModeAttributeToDutOperationMode_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t operationModeArgument;
        operationModeArgument = 2;

        ReturnErrorOnFailure(
            cluster.WriteAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::OperationMode::TypeInfo>(
                operationModeArgument, this, OnSuccessCallback_2, OnFailureCallback_2));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestWrite3ToTheOperationModeAttributeToDutOperationMode_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t operationModeArgument;
        operationModeArgument = 3;

        ReturnErrorOnFailure(
            cluster.WriteAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::OperationMode::TypeInfo>(
                operationModeArgument, this, OnSuccessCallback_3, OnFailureCallback_3));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3() { NextTest(); }
};

class Test_TC_PCC_2_3Suite : public TestCommand
{
public:
    Test_TC_PCC_2_3Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_PCC_2_3", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_PCC_2_3Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_PCC_2_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_PCC_2_3\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Write 0 to the OperationMode attribute to DUT\n");
            if (ShouldSkip("A_OPERATIONMODE"))
            {
                NextTest();
                return;
            }
            err = TestWrite0ToTheOperationModeAttributeToDut_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Reads the attribute: EffectiveOperationMode\n");
            if (ShouldSkip("A_EFFECTIVEOPERATIONMODE"))
            {
                NextTest();
                return;
            }
            err = TestReadsTheAttributeEffectiveOperationMode_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Write 0 to the ControlMode attribute to DUT\n");
            if (ShouldSkip("A_CONTROLMODE"))
            {
                NextTest();
                return;
            }
            err = TestWrite0ToTheControlModeAttributeToDut_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Reads the attribute: EffectiveControlMode\n");
            if (ShouldSkip("A_EFFECTIVECONTROLMODE"))
            {
                NextTest();
                return;
            }
            err = TestReadsTheAttributeEffectiveControlMode_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Write 1 to the ControlMode attribute to DUT\n");
            if (ShouldSkip("A_CONTROLMODE"))
            {
                NextTest();
                return;
            }
            err = TestWrite1ToTheControlModeAttributeToDut_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Write 2 to the ControlMode attribute to DUT\n");
            if (ShouldSkip("A_CONTROLMODE"))
            {
                NextTest();
                return;
            }
            err = TestWrite2ToTheControlModeAttributeToDut_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Write 3 to the ControlMode attribute to DUT\n");
            if (ShouldSkip("A_CONTROLMODE"))
            {
                NextTest();
                return;
            }
            err = TestWrite3ToTheControlModeAttributeToDut_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Write 5 to the ControlMode attribute to DUT\n");
            if (ShouldSkip("A_CONTROLMODE"))
            {
                NextTest();
                return;
            }
            err = TestWrite5ToTheControlModeAttributeToDut_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Write 7 to the ControlMode attribute to DUT\n");
            if (ShouldSkip("A_CONTROLMODE"))
            {
                NextTest();
                return;
            }
            err = TestWrite7ToTheControlModeAttributeToDut_9();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 10;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_1(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_PCC_2_3Suite *>(context))->OnFailureResponse_1(error);
    }

    static void OnSuccessCallback_1(void * context) { (static_cast<Test_TC_PCC_2_3Suite *>(context))->OnSuccessResponse_1(); }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_PCC_2_3Suite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context, uint8_t effectiveOperationMode)
    {
        (static_cast<Test_TC_PCC_2_3Suite *>(context))->OnSuccessResponse_2(effectiveOperationMode);
    }

    static void OnFailureCallback_3(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_PCC_2_3Suite *>(context))->OnFailureResponse_3(error);
    }

    static void OnSuccessCallback_3(void * context) { (static_cast<Test_TC_PCC_2_3Suite *>(context))->OnSuccessResponse_3(); }

    static void OnFailureCallback_4(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_PCC_2_3Suite *>(context))->OnFailureResponse_4(error);
    }

    static void OnSuccessCallback_4(void * context, uint8_t effectiveControlMode)
    {
        (static_cast<Test_TC_PCC_2_3Suite *>(context))->OnSuccessResponse_4(effectiveControlMode);
    }

    static void OnFailureCallback_5(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_PCC_2_3Suite *>(context))->OnFailureResponse_5(error);
    }

    static void OnSuccessCallback_5(void * context) { (static_cast<Test_TC_PCC_2_3Suite *>(context))->OnSuccessResponse_5(); }

    static void OnFailureCallback_6(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_PCC_2_3Suite *>(context))->OnFailureResponse_6(error);
    }

    static void OnSuccessCallback_6(void * context) { (static_cast<Test_TC_PCC_2_3Suite *>(context))->OnSuccessResponse_6(); }

    static void OnFailureCallback_7(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_PCC_2_3Suite *>(context))->OnFailureResponse_7(error);
    }

    static void OnSuccessCallback_7(void * context) { (static_cast<Test_TC_PCC_2_3Suite *>(context))->OnSuccessResponse_7(); }

    static void OnFailureCallback_8(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_PCC_2_3Suite *>(context))->OnFailureResponse_8(error);
    }

    static void OnSuccessCallback_8(void * context) { (static_cast<Test_TC_PCC_2_3Suite *>(context))->OnSuccessResponse_8(); }

    static void OnFailureCallback_9(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_PCC_2_3Suite *>(context))->OnFailureResponse_9(error);
    }

    static void OnSuccessCallback_9(void * context) { (static_cast<Test_TC_PCC_2_3Suite *>(context))->OnSuccessResponse_9(); }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestWrite0ToTheOperationModeAttributeToDut_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t operationModeArgument;
        operationModeArgument = 0;

        ReturnErrorOnFailure(
            cluster.WriteAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::OperationMode::TypeInfo>(
                operationModeArgument, this, OnSuccessCallback_1, OnFailureCallback_1));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestReadsTheAttributeEffectiveOperationMode_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::EffectiveOperationMode::TypeInfo>(
                this, OnSuccessCallback_2, OnFailureCallback_2, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2(uint8_t effectiveOperationMode)
    {
        VerifyOrReturn(CheckValue("effectiveOperationMode", effectiveOperationMode, 0));

        NextTest();
    }

    CHIP_ERROR TestWrite0ToTheControlModeAttributeToDut_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t controlModeArgument;
        controlModeArgument = 0;

        ReturnErrorOnFailure(
            cluster.WriteAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::ControlMode::TypeInfo>(
                controlModeArgument, this, OnSuccessCallback_3, OnFailureCallback_3));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestReadsTheAttributeEffectiveControlMode_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::EffectiveControlMode::TypeInfo>(
                this, OnSuccessCallback_4, OnFailureCallback_4, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_4(uint8_t effectiveControlMode)
    {
        VerifyOrReturn(CheckValue("effectiveControlMode", effectiveControlMode, 0));

        NextTest();
    }

    CHIP_ERROR TestWrite1ToTheControlModeAttributeToDut_5()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t controlModeArgument;
        controlModeArgument = 1;

        ReturnErrorOnFailure(
            cluster.WriteAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::ControlMode::TypeInfo>(
                controlModeArgument, this, OnSuccessCallback_5, OnFailureCallback_5));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_5() { NextTest(); }

    CHIP_ERROR TestWrite2ToTheControlModeAttributeToDut_6()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t controlModeArgument;
        controlModeArgument = 2;

        ReturnErrorOnFailure(
            cluster.WriteAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::ControlMode::TypeInfo>(
                controlModeArgument, this, OnSuccessCallback_6, OnFailureCallback_6));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_6(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_6() { NextTest(); }

    CHIP_ERROR TestWrite3ToTheControlModeAttributeToDut_7()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t controlModeArgument;
        controlModeArgument = 3;

        ReturnErrorOnFailure(
            cluster.WriteAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::ControlMode::TypeInfo>(
                controlModeArgument, this, OnSuccessCallback_7, OnFailureCallback_7));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_7(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_7() { NextTest(); }

    CHIP_ERROR TestWrite5ToTheControlModeAttributeToDut_8()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t controlModeArgument;
        controlModeArgument = 5;

        ReturnErrorOnFailure(
            cluster.WriteAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::ControlMode::TypeInfo>(
                controlModeArgument, this, OnSuccessCallback_8, OnFailureCallback_8));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_8(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_8() { NextTest(); }

    CHIP_ERROR TestWrite7ToTheControlModeAttributeToDut_9()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t controlModeArgument;
        controlModeArgument = 7;

        ReturnErrorOnFailure(
            cluster.WriteAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::ControlMode::TypeInfo>(
                controlModeArgument, this, OnSuccessCallback_9, OnFailureCallback_9));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_9(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_9() { NextTest(); }
};

class Test_TC_RH_1_1Suite : public TestCommand
{
public:
    Test_TC_RH_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_RH_1_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_RH_1_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_RH_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_RH_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read the global attribute constraints: ClusterRevision\n");
            err = TestReadTheGlobalAttributeConstraintsClusterRevision_1();
            break;
        case 2:
            ChipLogProgress(chipTool,
                            " ***** Test Step 2 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read the global attribute: AttributeList\n");
            err = TestReadTheGlobalAttributeAttributeList_3();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 4;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_1(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_RH_1_1Suite *>(context))->OnFailureResponse_1(error);
    }

    static void OnSuccessCallback_1(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_RH_1_1Suite *>(context))->OnSuccessResponse_1(clusterRevision);
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_RH_1_1Suite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context) { (static_cast<Test_TC_RH_1_1Suite *>(context))->OnSuccessResponse_2(); }

    static void OnFailureCallback_3(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_RH_1_1Suite *>(context))->OnFailureResponse_3(error);
    }

    static void OnSuccessCallback_3(void * context, const chip::app::DataModel::DecodableList<chip::AttributeId> & attributeList)
    {
        (static_cast<Test_TC_RH_1_1Suite *>(context))->OnSuccessResponse_3(attributeList);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestReadTheGlobalAttributeConstraintsClusterRevision_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::RelativeHumidityMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::RelativeHumidityMeasurement::Attributes::ClusterRevision::TypeInfo>(
                this, OnSuccessCallback_1, OnFailureCallback_1, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckConstraintType("clusterRevision", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::RelativeHumidityMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t clusterRevisionArgument;
        clusterRevisionArgument = 1U;

        ReturnErrorOnFailure(
            cluster.WriteAttribute<chip::app::Clusters::RelativeHumidityMeasurement::Attributes::ClusterRevision::TypeInfo>(
                clusterRevisionArgument, this, OnSuccessCallback_2, OnFailureCallback_2));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_2() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadTheGlobalAttributeAttributeList_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::RelativeHumidityMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::RelativeHumidityMeasurement::Attributes::AttributeList::TypeInfo>(
                this, OnSuccessCallback_3, OnFailureCallback_3, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3(const chip::app::DataModel::DecodableList<chip::AttributeId> & attributeList)
    {
        VerifyOrReturn(CheckConstraintType("attributeList", "", "list"));
        NextTest();
    }
};

class Test_TC_RH_2_1Suite : public TestCommand
{
public:
    Test_TC_RH_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_RH_2_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_RH_2_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_RH_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_RH_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Reads constraints of attribute: MeasuredValue\n");
            err = TestReadsConstraintsOfAttributeMeasuredValue_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Reads constraints of attribute: MinMeasuredValue\n");
            err = TestReadsConstraintsOfAttributeMinMeasuredValue_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Reads the optional attribute: Tolerance\n");
            err = TestReadsTheOptionalAttributeTolerance_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Reads constraints of attribute: Tolerance\n");
            err = TestReadsConstraintsOfAttributeTolerance_4();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 5;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_1(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_RH_2_1Suite *>(context))->OnFailureResponse_1(error);
    }

    static void OnSuccessCallback_1(void * context, uint16_t measuredValue)
    {
        (static_cast<Test_TC_RH_2_1Suite *>(context))->OnSuccessResponse_1(measuredValue);
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_RH_2_1Suite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context, uint16_t minMeasuredValue)
    {
        (static_cast<Test_TC_RH_2_1Suite *>(context))->OnSuccessResponse_2(minMeasuredValue);
    }

    static void OnFailureCallback_3(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_RH_2_1Suite *>(context))->OnFailureResponse_3(error);
    }

    static void OnSuccessCallback_3(void * context, uint16_t tolerance)
    {
        (static_cast<Test_TC_RH_2_1Suite *>(context))->OnSuccessResponse_3(tolerance);
    }

    static void OnFailureCallback_4(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_RH_2_1Suite *>(context))->OnFailureResponse_4(error);
    }

    static void OnSuccessCallback_4(void * context, uint16_t tolerance)
    {
        (static_cast<Test_TC_RH_2_1Suite *>(context))->OnSuccessResponse_4(tolerance);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestReadsConstraintsOfAttributeMeasuredValue_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::RelativeHumidityMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::RelativeHumidityMeasurement::Attributes::MeasuredValue::TypeInfo>(
                this, OnSuccessCallback_1, OnFailureCallback_1, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1(uint16_t measuredValue)
    {
        VerifyOrReturn(CheckConstraintType("measuredValue", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestReadsConstraintsOfAttributeMinMeasuredValue_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::RelativeHumidityMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::RelativeHumidityMeasurement::Attributes::MinMeasuredValue::TypeInfo>(
                this, OnSuccessCallback_2, OnFailureCallback_2, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2(uint16_t minMeasuredValue)
    {
        VerifyOrReturn(CheckConstraintType("minMeasuredValue", "", "uint16"));
        VerifyOrReturn(CheckConstraintMinValue<uint16_t>("minMeasuredValue", minMeasuredValue, 0U));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("minMeasuredValue", minMeasuredValue, 9999U));
        NextTest();
    }

    CHIP_ERROR TestReadsTheOptionalAttributeTolerance_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::RelativeHumidityMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::RelativeHumidityMeasurement::Attributes::Tolerance::TypeInfo>(
                this, OnSuccessCallback_3, OnFailureCallback_3, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_3(uint16_t tolerance)
    {
        VerifyOrReturn(CheckValue("tolerance", tolerance, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadsConstraintsOfAttributeTolerance_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::RelativeHumidityMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::RelativeHumidityMeasurement::Attributes::Tolerance::TypeInfo>(
                this, OnSuccessCallback_4, OnFailureCallback_4, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_4(uint16_t tolerance)
    {
        VerifyOrReturn(CheckConstraintType("tolerance", "", "uint16"));
        VerifyOrReturn(CheckConstraintMinValue<uint16_t>("tolerance", tolerance, 0U));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("tolerance", tolerance, 2048U));
        NextTest();
    }
};

class Test_TC_RH_2_2Suite : public TestCommand
{
public:
    Test_TC_RH_2_2Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_RH_2_2", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_RH_2_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_RH_2_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_RH_2_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Reads MeasuredValue attribute from DUT\n");
            if (ShouldSkip("A_RELATIVEHUMIDITY"))
            {
                NextTest();
                return;
            }
            err = TestReadsMeasuredValueAttributeFromDut_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read the mandatory attribute: MeasuredValue\n");
            if (ShouldSkip("A_RELATIVEHUMIDITY"))
            {
                NextTest();
                return;
            }
            err = TestReadTheMandatoryAttributeMeasuredValue_2();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 3;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_1(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_RH_2_2Suite *>(context))->OnFailureResponse_1(error);
    }

    static void OnSuccessCallback_1(void * context, uint16_t measuredValue)
    {
        (static_cast<Test_TC_RH_2_2Suite *>(context))->OnSuccessResponse_1(measuredValue);
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_RH_2_2Suite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context, uint16_t measuredValue)
    {
        (static_cast<Test_TC_RH_2_2Suite *>(context))->OnSuccessResponse_2(measuredValue);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestReadsMeasuredValueAttributeFromDut_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::RelativeHumidityMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::RelativeHumidityMeasurement::Attributes::MeasuredValue::TypeInfo>(
                this, OnSuccessCallback_1, OnFailureCallback_1, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1(uint16_t measuredValue)
    {
        VerifyOrReturn(CheckConstraintType("measuredValue", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeMeasuredValue_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::RelativeHumidityMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::RelativeHumidityMeasurement::Attributes::MeasuredValue::TypeInfo>(
                this, OnSuccessCallback_2, OnFailureCallback_2, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2(uint16_t measuredValue)
    {
        VerifyOrReturn(CheckConstraintType("measuredValue", "", "uint16"));
        NextTest();
    }
};

class Test_TC_SWTCH_2_1Suite : public TestCommand
{
public:
    Test_TC_SWTCH_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_SWTCH_2_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_SWTCH_2_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_SWTCH_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_SWTCH_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read NumberOfPositions attribute\n");
            err = TestReadNumberOfPositionsAttribute_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read NumberOfPositions attribute\n");
            err = TestReadNumberOfPositionsAttribute_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read CurrentPosition attribute\n");
            err = TestReadCurrentPositionAttribute_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Read CurrentPosition attribute\n");
            err = TestReadCurrentPositionAttribute_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Read MultiPressMax attribute\n");
            err = TestReadMultiPressMaxAttribute_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Read MultiPressMax attribute\n");
            err = TestReadMultiPressMaxAttribute_6();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 7;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_1(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_SWTCH_2_1Suite *>(context))->OnFailureResponse_1(error);
    }

    static void OnSuccessCallback_1(void * context, uint8_t numberOfPositions)
    {
        (static_cast<Test_TC_SWTCH_2_1Suite *>(context))->OnSuccessResponse_1(numberOfPositions);
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_SWTCH_2_1Suite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context, uint8_t numberOfPositions)
    {
        (static_cast<Test_TC_SWTCH_2_1Suite *>(context))->OnSuccessResponse_2(numberOfPositions);
    }

    static void OnFailureCallback_3(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_SWTCH_2_1Suite *>(context))->OnFailureResponse_3(error);
    }

    static void OnSuccessCallback_3(void * context, uint8_t currentPosition)
    {
        (static_cast<Test_TC_SWTCH_2_1Suite *>(context))->OnSuccessResponse_3(currentPosition);
    }

    static void OnFailureCallback_4(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_SWTCH_2_1Suite *>(context))->OnFailureResponse_4(error);
    }

    static void OnSuccessCallback_4(void * context, uint8_t currentPosition)
    {
        (static_cast<Test_TC_SWTCH_2_1Suite *>(context))->OnSuccessResponse_4(currentPosition);
    }

    static void OnFailureCallback_5(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_SWTCH_2_1Suite *>(context))->OnFailureResponse_5(error);
    }

    static void OnSuccessCallback_5(void * context, uint8_t multiPressMax)
    {
        (static_cast<Test_TC_SWTCH_2_1Suite *>(context))->OnSuccessResponse_5(multiPressMax);
    }

    static void OnFailureCallback_6(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_SWTCH_2_1Suite *>(context))->OnFailureResponse_6(error);
    }

    static void OnSuccessCallback_6(void * context, uint8_t multiPressMax)
    {
        (static_cast<Test_TC_SWTCH_2_1Suite *>(context))->OnSuccessResponse_6(multiPressMax);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestReadNumberOfPositionsAttribute_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::SwitchClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Switch::Attributes::NumberOfPositions::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1(uint8_t numberOfPositions)
    {
        VerifyOrReturn(CheckValue("numberOfPositions", numberOfPositions, 2));

        NextTest();
    }

    CHIP_ERROR TestReadNumberOfPositionsAttribute_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::SwitchClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Switch::Attributes::NumberOfPositions::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2(uint8_t numberOfPositions)
    {
        VerifyOrReturn(CheckConstraintType("numberOfPositions", "", "uint8"));
        VerifyOrReturn(CheckConstraintMinValue<uint8_t>("numberOfPositions", numberOfPositions, 2));
        NextTest();
    }

    CHIP_ERROR TestReadCurrentPositionAttribute_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::SwitchClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Switch::Attributes::CurrentPosition::TypeInfo>(
            this, OnSuccessCallback_3, OnFailureCallback_3, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3(uint8_t currentPosition)
    {
        VerifyOrReturn(CheckValue("currentPosition", currentPosition, 0));

        NextTest();
    }

    CHIP_ERROR TestReadCurrentPositionAttribute_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::SwitchClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Switch::Attributes::CurrentPosition::TypeInfo>(
            this, OnSuccessCallback_4, OnFailureCallback_4, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_4(uint8_t currentPosition)
    {
        VerifyOrReturn(CheckConstraintType("currentPosition", "", "uint8"));
        VerifyOrReturn(CheckConstraintMinValue<uint8_t>("currentPosition", currentPosition, 0));
        NextTest();
    }

    CHIP_ERROR TestReadMultiPressMaxAttribute_5()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::SwitchClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Switch::Attributes::MultiPressMax::TypeInfo>(
            this, OnSuccessCallback_5, OnFailureCallback_5, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_5(uint8_t multiPressMax)
    {
        VerifyOrReturn(CheckValue("multiPressMax", multiPressMax, 2));

        NextTest();
    }

    CHIP_ERROR TestReadMultiPressMaxAttribute_6()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::SwitchClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Switch::Attributes::MultiPressMax::TypeInfo>(
            this, OnSuccessCallback_6, OnFailureCallback_6, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_6(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_6(uint8_t multiPressMax)
    {
        VerifyOrReturn(CheckConstraintType("multiPressMax", "", "uint8"));
        VerifyOrReturn(CheckConstraintMinValue<uint8_t>("multiPressMax", multiPressMax, 2));
        NextTest();
    }
};

class Test_TC_SWTCH_2_2Suite : public TestCommand
{
public:
    Test_TC_SWTCH_2_2Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_SWTCH_2_2", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_SWTCH_2_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_SWTCH_2_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_SWTCH_2_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : User interaction needed\n");
            err = TestUserInteractionNeeded_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : User interaction needed\n");
            err = TestUserInteractionNeeded_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read CurrentPosition attribute\n");
            err = TestReadCurrentPositionAttribute_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : User interaction needed\n");
            err = TestUserInteractionNeeded_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : User interaction needed\n");
            err = TestUserInteractionNeeded_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : User interaction needed\n");
            err = TestUserInteractionNeeded_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Read CurrentPosition attribute\n");
            err = TestReadCurrentPositionAttribute_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : User interaction needed\n");
            err = TestUserInteractionNeeded_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : User interaction needed\n");
            err = TestUserInteractionNeeded_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : User interaction needed\n");
            err = TestUserInteractionNeeded_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : User interaction needed\n");
            err = TestUserInteractionNeeded_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : User interaction needed\n");
            err = TestUserInteractionNeeded_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : User interaction needed\n");
            err = TestUserInteractionNeeded_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : User interaction needed\n");
            err = TestUserInteractionNeeded_14();
            break;
        case 15:
            ChipLogProgress(chipTool, " ***** Test Step 15 : Wait 3000ms\n");
            err = TestWait3000ms_15();
            break;
        case 16:
            ChipLogProgress(chipTool, " ***** Test Step 16 : User interaction needed\n");
            err = TestUserInteractionNeeded_16();
            break;
        case 17:
            ChipLogProgress(chipTool, " ***** Test Step 17 : User interaction needed\n");
            err = TestUserInteractionNeeded_17();
            break;
        case 18:
            ChipLogProgress(chipTool, " ***** Test Step 18 : User interaction needed\n");
            err = TestUserInteractionNeeded_18();
            break;
        case 19:
            ChipLogProgress(chipTool, " ***** Test Step 19 : User interaction needed\n");
            err = TestUserInteractionNeeded_19();
            break;
        case 20:
            ChipLogProgress(chipTool, " ***** Test Step 20 : User interaction needed\n");
            err = TestUserInteractionNeeded_20();
            break;
        case 21:
            ChipLogProgress(chipTool, " ***** Test Step 21 : User interaction needed\n");
            err = TestUserInteractionNeeded_21();
            break;
        case 22:
            ChipLogProgress(chipTool, " ***** Test Step 22 : Wait 3000ms\n");
            err = TestWait3000ms_22();
            break;
        case 23:
            ChipLogProgress(chipTool, " ***** Test Step 23 : User interaction needed\n");
            err = TestUserInteractionNeeded_23();
            break;
        case 24:
            ChipLogProgress(chipTool, " ***** Test Step 24 : User interaction needed\n");
            err = TestUserInteractionNeeded_24();
            break;
        case 25:
            ChipLogProgress(chipTool, " ***** Test Step 25 : User interaction needed\n");
            err = TestUserInteractionNeeded_25();
            break;
        case 26:
            ChipLogProgress(chipTool, " ***** Test Step 26 : User interaction needed\n");
            err = TestUserInteractionNeeded_26();
            break;
        case 27:
            ChipLogProgress(chipTool, " ***** Test Step 27 : User interaction needed\n");
            err = TestUserInteractionNeeded_27();
            break;
        case 28:
            ChipLogProgress(chipTool, " ***** Test Step 28 : User interaction needed\n");
            err = TestUserInteractionNeeded_28();
            break;
        case 29:
            ChipLogProgress(chipTool, " ***** Test Step 29 : User interaction needed\n");
            err = TestUserInteractionNeeded_29();
            break;
        case 30:
            ChipLogProgress(chipTool, " ***** Test Step 30 : User interaction needed\n");
            err = TestUserInteractionNeeded_30();
            break;
        case 31:
            ChipLogProgress(chipTool, " ***** Test Step 31 : User interaction needed\n");
            err = TestUserInteractionNeeded_31();
            break;
        case 32:
            ChipLogProgress(chipTool, " ***** Test Step 32 : User interaction needed\n");
            err = TestUserInteractionNeeded_32();
            break;
        case 33:
            ChipLogProgress(chipTool, " ***** Test Step 33 : User interaction needed\n");
            err = TestUserInteractionNeeded_33();
            break;
        case 34:
            ChipLogProgress(chipTool, " ***** Test Step 34 : User interaction needed\n");
            err = TestUserInteractionNeeded_34();
            break;
        case 35:
            ChipLogProgress(chipTool, " ***** Test Step 35 : User interaction needed\n");
            err = TestUserInteractionNeeded_35();
            break;
        case 36:
            ChipLogProgress(chipTool, " ***** Test Step 36 : User interaction needed\n");
            err = TestUserInteractionNeeded_36();
            break;
        case 37:
            ChipLogProgress(chipTool, " ***** Test Step 37 : User interaction needed\n");
            err = TestUserInteractionNeeded_37();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 38;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_3(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_SWTCH_2_2Suite *>(context))->OnFailureResponse_3(error);
    }

    static void OnSuccessCallback_3(void * context, uint8_t currentPosition)
    {
        (static_cast<Test_TC_SWTCH_2_2Suite *>(context))->OnSuccessResponse_3(currentPosition);
    }

    static void OnFailureCallback_7(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_SWTCH_2_2Suite *>(context))->OnFailureResponse_7(error);
    }

    static void OnSuccessCallback_7(void * context, uint8_t currentPosition)
    {
        (static_cast<Test_TC_SWTCH_2_2Suite *>(context))->OnSuccessResponse_7(currentPosition);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestUserInteractionNeeded_1()
    {
        SetIdentity(kIdentityAlpha);
        return UserPrompt("Set up subscription to SwitchLatched event");
    }

    CHIP_ERROR TestUserInteractionNeeded_2()
    {
        SetIdentity(kIdentityAlpha);
        return UserPrompt("Operator sets switch to first position");
    }

    CHIP_ERROR TestReadCurrentPositionAttribute_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::SwitchClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Switch::Attributes::CurrentPosition::TypeInfo>(
            this, OnSuccessCallback_3, OnFailureCallback_3, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3(uint8_t currentPosition)
    {
        VerifyOrReturn(CheckValue("currentPosition", currentPosition, 0));

        NextTest();
    }

    CHIP_ERROR TestUserInteractionNeeded_4()
    {
        SetIdentity(kIdentityAlpha);
        return UserPrompt("Operator sets switch to second position");
    }

    CHIP_ERROR TestUserInteractionNeeded_5()
    {
        SetIdentity(kIdentityAlpha);
        return UserPrompt("Set up subscription to InitialPress event");
    }

    CHIP_ERROR TestUserInteractionNeeded_6()
    {
        SetIdentity(kIdentityAlpha);
        return UserPrompt("Operator does not operate switch");
    }

    CHIP_ERROR TestReadCurrentPositionAttribute_7()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::SwitchClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Switch::Attributes::CurrentPosition::TypeInfo>(
            this, OnSuccessCallback_7, OnFailureCallback_7, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_7(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_7(uint8_t currentPosition)
    {
        VerifyOrReturn(CheckValue("currentPosition", currentPosition, 0));

        NextTest();
    }

    CHIP_ERROR TestUserInteractionNeeded_8()
    {
        SetIdentity(kIdentityAlpha);
        return UserPrompt("Operator sets switch to second position");
    }

    CHIP_ERROR TestUserInteractionNeeded_9()
    {
        SetIdentity(kIdentityAlpha);
        return UserPrompt("Operator does not operate switch (release switch)");
    }

    CHIP_ERROR TestUserInteractionNeeded_10()
    {
        SetIdentity(kIdentityAlpha);
        return UserPrompt("Set up subscription to InitialPress and ShortRelease events");
    }

    CHIP_ERROR TestUserInteractionNeeded_11()
    {
        SetIdentity(kIdentityAlpha);
        return UserPrompt("Operator does not operate switch");
    }

    CHIP_ERROR TestUserInteractionNeeded_12()
    {
        SetIdentity(kIdentityAlpha);
        return UserPrompt("Operator operates switch (press briefly)");
    }

    CHIP_ERROR TestUserInteractionNeeded_13()
    {
        SetIdentity(kIdentityAlpha);
        return UserPrompt("Operator releases switch");
    }

    CHIP_ERROR TestUserInteractionNeeded_14()
    {
        SetIdentity(kIdentityAlpha);
        return UserPrompt("Operator operates switch for 5 seconds");
    }

    CHIP_ERROR TestWait3000ms_15()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForMs(3000);
    }

    CHIP_ERROR TestUserInteractionNeeded_16()
    {
        SetIdentity(kIdentityAlpha);
        return UserPrompt("Operator releases switch");
    }

    CHIP_ERROR TestUserInteractionNeeded_17()
    {
        SetIdentity(kIdentityAlpha);
        return UserPrompt("Set up subscription to InitialPress, LongPress, ShortRelease, LongRelease events");
    }

    CHIP_ERROR TestUserInteractionNeeded_18()
    {
        SetIdentity(kIdentityAlpha);
        return UserPrompt("Operator does not operate switch");
    }

    CHIP_ERROR TestUserInteractionNeeded_19()
    {
        SetIdentity(kIdentityAlpha);
        return UserPrompt("Operator operates switch (press briefly)");
    }

    CHIP_ERROR TestUserInteractionNeeded_20()
    {
        SetIdentity(kIdentityAlpha);
        return UserPrompt("Operator releases switch");
    }

    CHIP_ERROR TestUserInteractionNeeded_21()
    {
        SetIdentity(kIdentityAlpha);
        return UserPrompt("Operator operates switch for 5 seconds");
    }

    CHIP_ERROR TestWait3000ms_22()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForMs(3000);
    }

    CHIP_ERROR TestUserInteractionNeeded_23()
    {
        SetIdentity(kIdentityAlpha);
        return UserPrompt("Operator releases switch");
    }

    CHIP_ERROR TestUserInteractionNeeded_24()
    {
        SetIdentity(kIdentityAlpha);
        return UserPrompt("Set up subscription to InitialPress, ShortRelease, MultiPressOngoing, MultiPressComplete events");
    }

    CHIP_ERROR TestUserInteractionNeeded_25()
    {
        SetIdentity(kIdentityAlpha);
        return UserPrompt("Operator does not operate switch");
    }

    CHIP_ERROR TestUserInteractionNeeded_26()
    {
        SetIdentity(kIdentityAlpha);
        return UserPrompt("Operator operates switch (press briefly)");
    }

    CHIP_ERROR TestUserInteractionNeeded_27()
    {
        SetIdentity(kIdentityAlpha);
        return UserPrompt("Operator releases switch");
    }

    CHIP_ERROR TestUserInteractionNeeded_28()
    {
        SetIdentity(kIdentityAlpha);
        return UserPrompt("Operator operates switch (press briefly)");
    }

    CHIP_ERROR TestUserInteractionNeeded_29()
    {
        SetIdentity(kIdentityAlpha);
        return UserPrompt("Operator releases switch");
    }

    CHIP_ERROR TestUserInteractionNeeded_30()
    {
        SetIdentity(kIdentityAlpha);
        return UserPrompt("Operator operates switch again (press briefly)");
    }

    CHIP_ERROR TestUserInteractionNeeded_31()
    {
        SetIdentity(kIdentityAlpha);
        return UserPrompt("Operator releases switch");
    }

    CHIP_ERROR TestUserInteractionNeeded_32()
    {
        SetIdentity(kIdentityAlpha);
        return UserPrompt("Operator operates switch again (press briefly)");
    }

    CHIP_ERROR TestUserInteractionNeeded_33()
    {
        SetIdentity(kIdentityAlpha);
        return UserPrompt("Operator releases switch");
    }

    CHIP_ERROR TestUserInteractionNeeded_34()
    {
        SetIdentity(kIdentityAlpha);
        return UserPrompt("Operator operates switch again (press briefly)");
    }

    CHIP_ERROR TestUserInteractionNeeded_35()
    {
        SetIdentity(kIdentityAlpha);
        return UserPrompt("Operator releases switch");
    }

    CHIP_ERROR TestUserInteractionNeeded_36()
    {
        SetIdentity(kIdentityAlpha);
        return UserPrompt("Operator operates switch again (press briefly)");
    }

    CHIP_ERROR TestUserInteractionNeeded_37()
    {
        SetIdentity(kIdentityAlpha);
        return UserPrompt("Operator releases switch");
    }
};

class Test_TC_TM_1_1Suite : public TestCommand
{
public:
    Test_TC_TM_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_TM_1_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_TM_1_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_TM_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_TM_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read the global attribute constraints: ClusterRevision\n");
            err = TestReadTheGlobalAttributeConstraintsClusterRevision_1();
            break;
        case 2:
            ChipLogProgress(chipTool,
                            " ***** Test Step 2 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read the global attribute: AttributeList\n");
            err = TestReadTheGlobalAttributeAttributeList_3();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 4;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_1(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TM_1_1Suite *>(context))->OnFailureResponse_1(error);
    }

    static void OnSuccessCallback_1(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_TM_1_1Suite *>(context))->OnSuccessResponse_1(clusterRevision);
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TM_1_1Suite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context) { (static_cast<Test_TC_TM_1_1Suite *>(context))->OnSuccessResponse_2(); }

    static void OnFailureCallback_3(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TM_1_1Suite *>(context))->OnFailureResponse_3(error);
    }

    static void OnSuccessCallback_3(void * context, const chip::app::DataModel::DecodableList<chip::AttributeId> & attributeList)
    {
        (static_cast<Test_TC_TM_1_1Suite *>(context))->OnSuccessResponse_3(attributeList);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestReadTheGlobalAttributeConstraintsClusterRevision_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TemperatureMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::TemperatureMeasurement::Attributes::ClusterRevision::TypeInfo>(
                this, OnSuccessCallback_1, OnFailureCallback_1, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckConstraintType("clusterRevision", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TemperatureMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t clusterRevisionArgument;
        clusterRevisionArgument = 4U;

        ReturnErrorOnFailure(
            cluster.WriteAttribute<chip::app::Clusters::TemperatureMeasurement::Attributes::ClusterRevision::TypeInfo>(
                clusterRevisionArgument, this, OnSuccessCallback_2, OnFailureCallback_2));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_2() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadTheGlobalAttributeAttributeList_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TemperatureMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::TemperatureMeasurement::Attributes::AttributeList::TypeInfo>(
                this, OnSuccessCallback_3, OnFailureCallback_3, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3(const chip::app::DataModel::DecodableList<chip::AttributeId> & attributeList)
    {
        VerifyOrReturn(CheckConstraintType("attributeList", "", "list"));
        NextTest();
    }
};

class Test_TC_TM_2_1Suite : public TestCommand
{
public:
    Test_TC_TM_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_TM_2_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_TM_2_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_TM_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_TM_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : read the mandatory attribute: MeasuredValue\n");
            err = TestReadTheMandatoryAttributeMeasuredValue_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : read the optional attribute: Tolerance\n");
            err = TestReadTheOptionalAttributeTolerance_2();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 3;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_1(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TM_2_1Suite *>(context))->OnFailureResponse_1(error);
    }

    static void OnSuccessCallback_1(void * context, int16_t measuredValue)
    {
        (static_cast<Test_TC_TM_2_1Suite *>(context))->OnSuccessResponse_1(measuredValue);
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TM_2_1Suite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context, uint16_t tolerance)
    {
        (static_cast<Test_TC_TM_2_1Suite *>(context))->OnSuccessResponse_2(tolerance);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestReadTheMandatoryAttributeMeasuredValue_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TemperatureMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::TemperatureMeasurement::Attributes::MeasuredValue::TypeInfo>(
                this, OnSuccessCallback_1, OnFailureCallback_1, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1(int16_t measuredValue)
    {
        VerifyOrReturn(CheckConstraintType("measuredValue", "", "int16"));
        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeTolerance_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TemperatureMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TemperatureMeasurement::Attributes::Tolerance::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_2(uint16_t tolerance)
    {
        VerifyOrReturn(CheckConstraintType("tolerance", "", "uint16"));
        VerifyOrReturn(CheckConstraintMinValue<uint16_t>("tolerance", tolerance, 0U));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("tolerance", tolerance, 2048U));
        NextTest();
    }
};

class Test_TC_TM_2_2Suite : public TestCommand
{
public:
    Test_TC_TM_2_2Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_TM_2_2", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_TM_2_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_TM_2_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_TM_2_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Reads MeasuredValue attribute from DUT\n");
            if (ShouldSkip("A_TEMPERATURE"))
            {
                NextTest();
                return;
            }
            err = TestReadsMeasuredValueAttributeFromDut_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read the mandatory attribute: MeasuredValue\n");
            if (ShouldSkip("A_TEMPERATURE"))
            {
                NextTest();
                return;
            }
            err = TestReadTheMandatoryAttributeMeasuredValue_2();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 3;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_1(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TM_2_2Suite *>(context))->OnFailureResponse_1(error);
    }

    static void OnSuccessCallback_1(void * context, int16_t measuredValue)
    {
        (static_cast<Test_TC_TM_2_2Suite *>(context))->OnSuccessResponse_1(measuredValue);
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TM_2_2Suite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context, int16_t measuredValue)
    {
        (static_cast<Test_TC_TM_2_2Suite *>(context))->OnSuccessResponse_2(measuredValue);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestReadsMeasuredValueAttributeFromDut_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TemperatureMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::TemperatureMeasurement::Attributes::MeasuredValue::TypeInfo>(
                this, OnSuccessCallback_1, OnFailureCallback_1, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1(int16_t measuredValue)
    {
        VerifyOrReturn(CheckConstraintType("measuredValue", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeMeasuredValue_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TemperatureMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::TemperatureMeasurement::Attributes::MeasuredValue::TypeInfo>(
                this, OnSuccessCallback_2, OnFailureCallback_2, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2(int16_t measuredValue)
    {
        VerifyOrReturn(CheckConstraintType("measuredValue", "", "uint16"));
        NextTest();
    }
};

class Test_TC_TSTAT_1_1Suite : public TestCommand
{
public:
    Test_TC_TSTAT_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_TSTAT_1_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_TSTAT_1_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_TSTAT_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_TSTAT_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read the global attribute constraints: ClusterRevision\n");
            err = TestReadTheGlobalAttributeConstraintsClusterRevision_1();
            break;
        case 2:
            ChipLogProgress(chipTool,
                            " ***** Test Step 2 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read the global attribute: AttributeList\n");
            err = TestReadTheGlobalAttributeAttributeList_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Read the optional global attribute constraints: FeatureMap\n");
            err = TestReadTheOptionalGlobalAttributeConstraintsFeatureMap_4();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 5;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_1(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_1_1Suite *>(context))->OnFailureResponse_1(error);
    }

    static void OnSuccessCallback_1(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_TSTAT_1_1Suite *>(context))->OnSuccessResponse_1(clusterRevision);
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_1_1Suite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context) { (static_cast<Test_TC_TSTAT_1_1Suite *>(context))->OnSuccessResponse_2(); }

    static void OnFailureCallback_3(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_1_1Suite *>(context))->OnFailureResponse_3(error);
    }

    static void OnSuccessCallback_3(void * context, const chip::app::DataModel::DecodableList<chip::AttributeId> & attributeList)
    {
        (static_cast<Test_TC_TSTAT_1_1Suite *>(context))->OnSuccessResponse_3(attributeList);
    }

    static void OnFailureCallback_4(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_1_1Suite *>(context))->OnFailureResponse_4(error);
    }

    static void OnSuccessCallback_4(void * context, uint32_t featureMap)
    {
        (static_cast<Test_TC_TSTAT_1_1Suite *>(context))->OnSuccessResponse_4(featureMap);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestReadTheGlobalAttributeConstraintsClusterRevision_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::ClusterRevision::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckConstraintType("clusterRevision", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t clusterRevisionArgument;
        clusterRevisionArgument = 5U;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::ClusterRevision::TypeInfo>(
            clusterRevisionArgument, this, OnSuccessCallback_2, OnFailureCallback_2));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_2() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadTheGlobalAttributeAttributeList_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::AttributeList::TypeInfo>(
            this, OnSuccessCallback_3, OnFailureCallback_3, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3(const chip::app::DataModel::DecodableList<chip::AttributeId> & attributeList)
    {
        VerifyOrReturn(CheckConstraintType("attributeList", "", "list"));
        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalGlobalAttributeConstraintsFeatureMap_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::FeatureMap::TypeInfo>(
            this, OnSuccessCallback_4, OnFailureCallback_4, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_4(uint32_t featureMap)
    {
        VerifyOrReturn(CheckConstraintType("featureMap", "", "map32"));
        NextTest();
    }
};

class Test_TC_TSTAT_2_1Suite : public TestCommand
{
public:
    Test_TC_TSTAT_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_TSTAT_2_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_TSTAT_2_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_TSTAT_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_TSTAT_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool,
                            " ***** Test Step 1 : Reads constraints of mandatory attributes from DUT: LocalTemperature\n");
            err = TestReadsConstraintsOfMandatoryAttributesFromDutLocalTemperature_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Reads mandatory attributes from DUT: AbsMinHeatSetpointLimit\n");
            err = TestReadsMandatoryAttributesFromDutAbsMinHeatSetpointLimit_2();
            break;
        case 3:
            ChipLogProgress(chipTool,
                            " ***** Test Step 3 : Reads constraints of mandatory attributes from DUT: AbsMinHeatSetpointLimit\n");
            err = TestReadsConstraintsOfMandatoryAttributesFromDutAbsMinHeatSetpointLimit_3();
            break;
        case 4:
            ChipLogProgress(chipTool,
                            " ***** Test Step 4 : Writes the respective default value to mandatory attributes to DUT: "
                            "AbsMinHeatSetpointLimit\n");
            err = TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutAbsMinHeatSetpointLimit_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Read back mandatory attributes from DUT: AbsMinHeatSetpointLimit\n");
            err = TestReadBackMandatoryAttributesFromDutAbsMinHeatSetpointLimit_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Reads mandatory attributes from DUT: AbsMaxHeatSetpointLimit\n");
            err = TestReadsMandatoryAttributesFromDutAbsMaxHeatSetpointLimit_6();
            break;
        case 7:
            ChipLogProgress(chipTool,
                            " ***** Test Step 7 : Reads constraints of mandatory attributes from DUT: AbsMaxHeatSetpointLimit\n");
            err = TestReadsConstraintsOfMandatoryAttributesFromDutAbsMaxHeatSetpointLimit_7();
            break;
        case 8:
            ChipLogProgress(chipTool,
                            " ***** Test Step 8 : Writes the respective default value to mandatory attributes to DUT: "
                            "AbsMaxHeatSetpointLimit\n");
            err = TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutAbsMaxHeatSetpointLimit_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Read back mandatory attributes from DUT: AbsMaxHeatSetpointLimit\n");
            err = TestReadBackMandatoryAttributesFromDutAbsMaxHeatSetpointLimit_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Reads mandatory attributes from DUT: AbsMinCoolSetpointLimit\n");
            err = TestReadsMandatoryAttributesFromDutAbsMinCoolSetpointLimit_10();
            break;
        case 11:
            ChipLogProgress(chipTool,
                            " ***** Test Step 11 : Reads constraints of mandatory attributes from DUT: AbsMinCoolSetpointLimit\n");
            err = TestReadsConstraintsOfMandatoryAttributesFromDutAbsMinCoolSetpointLimit_11();
            break;
        case 12:
            ChipLogProgress(chipTool,
                            " ***** Test Step 12 : Writes the respective default value to mandatory attributes to DUT: "
                            "AbsMinCoolSetpointLimit\n");
            err = TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutAbsMinCoolSetpointLimit_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : Read back mandatory attributes from DUT: AbsMinCoolSetpointLimit\n");
            err = TestReadBackMandatoryAttributesFromDutAbsMinCoolSetpointLimit_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : Reads mandatory attributes from DUT: AbsMaxCoolSetpointLimit\n");
            err = TestReadsMandatoryAttributesFromDutAbsMaxCoolSetpointLimit_14();
            break;
        case 15:
            ChipLogProgress(chipTool,
                            " ***** Test Step 15 : Reads constraints of mandatory attributes from DUT: AbsMaxCoolSetpointLimit\n");
            err = TestReadsConstraintsOfMandatoryAttributesFromDutAbsMaxCoolSetpointLimit_15();
            break;
        case 16:
            ChipLogProgress(chipTool,
                            " ***** Test Step 16 : Writes the respective default value to mandatory attributes to DUT: "
                            "AbsMaxCoolSetpointLimit\n");
            err = TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutAbsMaxCoolSetpointLimit_16();
            break;
        case 17:
            ChipLogProgress(chipTool, " ***** Test Step 17 : Read back mandatory attributes from DUT: AbsMaxCoolSetpointLimit\n");
            err = TestReadBackMandatoryAttributesFromDutAbsMaxCoolSetpointLimit_17();
            break;
        case 18:
            ChipLogProgress(chipTool, " ***** Test Step 18 : Reads mandatory attributes from DUT: OccupiedCoolingSetpoint\n");
            err = TestReadsMandatoryAttributesFromDutOccupiedCoolingSetpoint_18();
            break;
        case 19:
            ChipLogProgress(chipTool,
                            " ***** Test Step 19 : Reads constraints of mandatory attributes from DUT: OccupiedCoolingSetpoint\n");
            err = TestReadsConstraintsOfMandatoryAttributesFromDutOccupiedCoolingSetpoint_19();
            break;
        case 20:
            ChipLogProgress(chipTool,
                            " ***** Test Step 20 : Writes the respective default value to mandatory attributes to DUT: "
                            "OccupiedCoolingSetpoint\n");
            err = TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutOccupiedCoolingSetpoint_20();
            break;
        case 21:
            ChipLogProgress(chipTool, " ***** Test Step 21 : Read back mandatory attributes from DUT: OccupiedCoolingSetpoint\n");
            err = TestReadBackMandatoryAttributesFromDutOccupiedCoolingSetpoint_21();
            break;
        case 22:
            ChipLogProgress(chipTool, " ***** Test Step 22 : Reads mandatory attributes from DUT: OccupiedHeatingSetpoint\n");
            err = TestReadsMandatoryAttributesFromDutOccupiedHeatingSetpoint_22();
            break;
        case 23:
            ChipLogProgress(chipTool,
                            " ***** Test Step 23 : Reads constraints of mandatory attributes from DUT: OccupiedHeatingSetpoint\n");
            err = TestReadsConstraintsOfMandatoryAttributesFromDutOccupiedHeatingSetpoint_23();
            break;
        case 24:
            ChipLogProgress(chipTool,
                            " ***** Test Step 24 : Writes the respective default value to mandatory attributes to DUT: "
                            "OccupiedHeatingSetpoint\n");
            err = TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutOccupiedHeatingSetpoint_24();
            break;
        case 25:
            ChipLogProgress(chipTool, " ***** Test Step 25 : Read back mandatory attributes from DUT: OccupiedHeatingSetpoint\n");
            err = TestReadBackMandatoryAttributesFromDutOccupiedHeatingSetpoint_25();
            break;
        case 26:
            ChipLogProgress(chipTool, " ***** Test Step 26 : Reads mandatory attributes from DUT: MinHeatSetpointLimit\n");
            err = TestReadsMandatoryAttributesFromDutMinHeatSetpointLimit_26();
            break;
        case 27:
            ChipLogProgress(chipTool,
                            " ***** Test Step 27 : Reads constraints of mandatory attributes from DUT: MinHeatSetpointLimit\n");
            err = TestReadsConstraintsOfMandatoryAttributesFromDutMinHeatSetpointLimit_27();
            break;
        case 28:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 28 : Writes the respective default value to mandatory attributes to DUT: MinHeatSetpointLimit\n");
            err = TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutMinHeatSetpointLimit_28();
            break;
        case 29:
            ChipLogProgress(chipTool, " ***** Test Step 29 : Read back mandatory attributes from DUT: MinHeatSetpointLimit\n");
            err = TestReadBackMandatoryAttributesFromDutMinHeatSetpointLimit_29();
            break;
        case 30:
            ChipLogProgress(chipTool, " ***** Test Step 30 : Reads mandatory attributes from DUT: MaxHeatSetpointLimit\n");
            err = TestReadsMandatoryAttributesFromDutMaxHeatSetpointLimit_30();
            break;
        case 31:
            ChipLogProgress(chipTool,
                            " ***** Test Step 31 : Reads constraints of mandatory attributes from DUT: MaxHeatSetpointLimit\n");
            err = TestReadsConstraintsOfMandatoryAttributesFromDutMaxHeatSetpointLimit_31();
            break;
        case 32:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 32 : Writes the respective default value to mandatory attributes to DUT: MaxHeatSetpointLimit\n");
            err = TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutMaxHeatSetpointLimit_32();
            break;
        case 33:
            ChipLogProgress(chipTool, " ***** Test Step 33 : Read back mandatory attributes from DUT: MaxHeatSetpointLimit\n");
            err = TestReadBackMandatoryAttributesFromDutMaxHeatSetpointLimit_33();
            break;
        case 34:
            ChipLogProgress(chipTool, " ***** Test Step 34 : Reads mandatory attributes from DUT: MinCoolSetpointLimit\n");
            err = TestReadsMandatoryAttributesFromDutMinCoolSetpointLimit_34();
            break;
        case 35:
            ChipLogProgress(chipTool,
                            " ***** Test Step 35 : Reads constraints of mandatory attributes from DUT: MinCoolSetpointLimit\n");
            err = TestReadsConstraintsOfMandatoryAttributesFromDutMinCoolSetpointLimit_35();
            break;
        case 36:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 36 : Writes the respective default value to mandatory attributes to DUT: MinCoolSetpointLimit\n");
            err = TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutMinCoolSetpointLimit_36();
            break;
        case 37:
            ChipLogProgress(chipTool, " ***** Test Step 37 : Read back mandatory attributes from DUT: MinCoolSetpointLimit\n");
            err = TestReadBackMandatoryAttributesFromDutMinCoolSetpointLimit_37();
            break;
        case 38:
            ChipLogProgress(chipTool, " ***** Test Step 38 : Reads mandatory attributes from DUT: MaxCoolSetpointLimit\n");
            err = TestReadsMandatoryAttributesFromDutMaxCoolSetpointLimit_38();
            break;
        case 39:
            ChipLogProgress(chipTool,
                            " ***** Test Step 39 : Reads constraints of mandatory attributes from DUT: MaxCoolSetpointLimit\n");
            err = TestReadsConstraintsOfMandatoryAttributesFromDutMaxCoolSetpointLimit_39();
            break;
        case 40:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 40 : Writes the respective default value to mandatory attributes to DUT: MaxCoolSetpointLimit\n");
            err = TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutMaxCoolSetpointLimit_40();
            break;
        case 41:
            ChipLogProgress(chipTool, " ***** Test Step 41 : Read back mandatory attributes from DUT: MaxCoolSetpointLimit\n");
            err = TestReadBackMandatoryAttributesFromDutMaxCoolSetpointLimit_41();
            break;
        case 42:
            ChipLogProgress(chipTool, " ***** Test Step 42 : Reads mandatory attributes from DUT: ControlSequenceOfOperation\n");
            err = TestReadsMandatoryAttributesFromDutControlSequenceOfOperation_42();
            break;
        case 43:
            ChipLogProgress(
                chipTool, " ***** Test Step 43 : Reads constraints of mandatory attributes from DUT: ControlSequenceOfOperation\n");
            err = TestReadsConstraintsOfMandatoryAttributesFromDutControlSequenceOfOperation_43();
            break;
        case 44:
            ChipLogProgress(chipTool,
                            " ***** Test Step 44 : Writes the respective default value to mandatory attributes to DUT: "
                            "ControlSequenceOfOperation\n");
            err = TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutControlSequenceOfOperation_44();
            break;
        case 45:
            ChipLogProgress(chipTool,
                            " ***** Test Step 45 : Read back mandatory attributes from DUT: ControlSequenceOfOperation\n");
            err = TestReadBackMandatoryAttributesFromDutControlSequenceOfOperation_45();
            break;
        case 46:
            ChipLogProgress(chipTool, " ***** Test Step 46 : Reads mandatory attributes from DUT: SystemMode\n");
            err = TestReadsMandatoryAttributesFromDutSystemMode_46();
            break;
        case 47:
            ChipLogProgress(chipTool, " ***** Test Step 47 : Reads constraints of mandatory attributes from DUT: SystemMode\n");
            err = TestReadsConstraintsOfMandatoryAttributesFromDutSystemMode_47();
            break;
        case 48:
            ChipLogProgress(
                chipTool, " ***** Test Step 48 : Writes the respective default value to mandatory attributes to DUT: SystemMode\n");
            err = TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutSystemMode_48();
            break;
        case 49:
            ChipLogProgress(chipTool, " ***** Test Step 49 : Read back mandatory attributes from DUT: SystemMode\n");
            err = TestReadBackMandatoryAttributesFromDutSystemMode_49();
            break;
        case 50:
            ChipLogProgress(chipTool, " ***** Test Step 50 : Reads optional attributes from DUT: MinSetpointDeadBand\n");
            err = TestReadsOptionalAttributesFromDutMinSetpointDeadBand_50();
            break;
        case 51:
            ChipLogProgress(chipTool,
                            " ***** Test Step 51 : Reads constraints of optional attributes from DUT: MinSetpointDeadBand\n");
            err = TestReadsConstraintsOfOptionalAttributesFromDutMinSetpointDeadBand_51();
            break;
        case 52:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 52 : Writes the respective default value to optional attributes to DUT: MinSetpointDeadBand\n");
            err = TestWritesTheRespectiveDefaultValueToOptionalAttributesToDutMinSetpointDeadBand_52();
            break;
        case 53:
            ChipLogProgress(chipTool, " ***** Test Step 53 : Read back optional attributes from DUT: MinSetpointDeadBand\n");
            err = TestReadBackOptionalAttributesFromDutMinSetpointDeadBand_53();
            break;
        case 54:
            ChipLogProgress(chipTool, " ***** Test Step 54 : Reads constraints of optional attributes from DUT: StartOfWeek\n");
            err = TestReadsConstraintsOfOptionalAttributesFromDutStartOfWeek_54();
            break;
        case 55:
            ChipLogProgress(
                chipTool, " ***** Test Step 55 : Writes the respective default value to optional attributes to DUT: StartOfWeek\n");
            err = TestWritesTheRespectiveDefaultValueToOptionalAttributesToDutStartOfWeek_55();
            break;
        case 56:
            ChipLogProgress(chipTool, " ***** Test Step 56 : Read back optional attributes from DUT: StartOfWeek\n");
            err = TestReadBackOptionalAttributesFromDutStartOfWeek_56();
            break;
        case 57:
            ChipLogProgress(chipTool,
                            " ***** Test Step 57 : Reads constraints of optional attributes from DUT: NumberOfWeeklyTransitions\n");
            err = TestReadsConstraintsOfOptionalAttributesFromDutNumberOfWeeklyTransitions_57();
            break;
        case 58:
            ChipLogProgress(chipTool,
                            " ***** Test Step 58 : Writes the respective default value to optional attributes to DUT: "
                            "NumberOfWeeklyTransitions\n");
            err = TestWritesTheRespectiveDefaultValueToOptionalAttributesToDutNumberOfWeeklyTransitions_58();
            break;
        case 59:
            ChipLogProgress(chipTool,
                            " ***** Test Step 59 : Reads constraints of optional attributes from DUT: NumberOfDailyTransitions\n");
            err = TestReadsConstraintsOfOptionalAttributesFromDutNumberOfDailyTransitions_59();
            break;
        case 60:
            ChipLogProgress(chipTool,
                            " ***** Test Step 60 : Writes the respective default value to optional attributes to DUT: "
                            "NumberOfDailyTransitions\n");
            err = TestWritesTheRespectiveDefaultValueToOptionalAttributesToDutNumberOfDailyTransitions_60();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 61;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_1(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnFailureResponse_1(error);
    }

    static void OnSuccessCallback_1(void * context, int16_t localTemperature)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnSuccessResponse_1(localTemperature);
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context, int16_t absMinHeatSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnSuccessResponse_2(absMinHeatSetpointLimit);
    }

    static void OnFailureCallback_3(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnFailureResponse_3(error);
    }

    static void OnSuccessCallback_3(void * context, int16_t absMinHeatSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnSuccessResponse_3(absMinHeatSetpointLimit);
    }

    static void OnFailureCallback_4(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnFailureResponse_4(error);
    }

    static void OnSuccessCallback_4(void * context) { (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnSuccessResponse_4(); }

    static void OnFailureCallback_5(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnFailureResponse_5(error);
    }

    static void OnSuccessCallback_5(void * context, int16_t absMinHeatSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnSuccessResponse_5(absMinHeatSetpointLimit);
    }

    static void OnFailureCallback_6(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnFailureResponse_6(error);
    }

    static void OnSuccessCallback_6(void * context, int16_t absMaxHeatSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnSuccessResponse_6(absMaxHeatSetpointLimit);
    }

    static void OnFailureCallback_7(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnFailureResponse_7(error);
    }

    static void OnSuccessCallback_7(void * context, int16_t absMaxHeatSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnSuccessResponse_7(absMaxHeatSetpointLimit);
    }

    static void OnFailureCallback_8(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnFailureResponse_8(error);
    }

    static void OnSuccessCallback_8(void * context) { (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnSuccessResponse_8(); }

    static void OnFailureCallback_9(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnFailureResponse_9(error);
    }

    static void OnSuccessCallback_9(void * context, int16_t absMaxHeatSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnSuccessResponse_9(absMaxHeatSetpointLimit);
    }

    static void OnFailureCallback_10(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnFailureResponse_10(error);
    }

    static void OnSuccessCallback_10(void * context, int16_t absMinCoolSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnSuccessResponse_10(absMinCoolSetpointLimit);
    }

    static void OnFailureCallback_11(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnFailureResponse_11(error);
    }

    static void OnSuccessCallback_11(void * context, int16_t absMinCoolSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnSuccessResponse_11(absMinCoolSetpointLimit);
    }

    static void OnFailureCallback_12(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnFailureResponse_12(error);
    }

    static void OnSuccessCallback_12(void * context) { (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnSuccessResponse_12(); }

    static void OnFailureCallback_13(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnFailureResponse_13(error);
    }

    static void OnSuccessCallback_13(void * context, int16_t absMinCoolSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnSuccessResponse_13(absMinCoolSetpointLimit);
    }

    static void OnFailureCallback_14(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnFailureResponse_14(error);
    }

    static void OnSuccessCallback_14(void * context, int16_t absMaxCoolSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnSuccessResponse_14(absMaxCoolSetpointLimit);
    }

    static void OnFailureCallback_15(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnFailureResponse_15(error);
    }

    static void OnSuccessCallback_15(void * context, int16_t absMaxCoolSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnSuccessResponse_15(absMaxCoolSetpointLimit);
    }

    static void OnFailureCallback_16(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnFailureResponse_16(error);
    }

    static void OnSuccessCallback_16(void * context) { (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnSuccessResponse_16(); }

    static void OnFailureCallback_17(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnFailureResponse_17(error);
    }

    static void OnSuccessCallback_17(void * context, int16_t absMaxCoolSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnSuccessResponse_17(absMaxCoolSetpointLimit);
    }

    static void OnFailureCallback_18(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnFailureResponse_18(error);
    }

    static void OnSuccessCallback_18(void * context, int16_t occupiedCoolingSetpoint)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnSuccessResponse_18(occupiedCoolingSetpoint);
    }

    static void OnFailureCallback_19(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnFailureResponse_19(error);
    }

    static void OnSuccessCallback_19(void * context, int16_t occupiedCoolingSetpoint)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnSuccessResponse_19(occupiedCoolingSetpoint);
    }

    static void OnFailureCallback_20(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnFailureResponse_20(error);
    }

    static void OnSuccessCallback_20(void * context) { (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnSuccessResponse_20(); }

    static void OnFailureCallback_21(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnFailureResponse_21(error);
    }

    static void OnSuccessCallback_21(void * context, int16_t occupiedCoolingSetpoint)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnSuccessResponse_21(occupiedCoolingSetpoint);
    }

    static void OnFailureCallback_22(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnFailureResponse_22(error);
    }

    static void OnSuccessCallback_22(void * context, int16_t occupiedHeatingSetpoint)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnSuccessResponse_22(occupiedHeatingSetpoint);
    }

    static void OnFailureCallback_23(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnFailureResponse_23(error);
    }

    static void OnSuccessCallback_23(void * context, int16_t occupiedHeatingSetpoint)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnSuccessResponse_23(occupiedHeatingSetpoint);
    }

    static void OnFailureCallback_24(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnFailureResponse_24(error);
    }

    static void OnSuccessCallback_24(void * context) { (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnSuccessResponse_24(); }

    static void OnFailureCallback_25(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnFailureResponse_25(error);
    }

    static void OnSuccessCallback_25(void * context, int16_t occupiedHeatingSetpoint)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnSuccessResponse_25(occupiedHeatingSetpoint);
    }

    static void OnFailureCallback_26(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnFailureResponse_26(error);
    }

    static void OnSuccessCallback_26(void * context, int16_t minHeatSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnSuccessResponse_26(minHeatSetpointLimit);
    }

    static void OnFailureCallback_27(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnFailureResponse_27(error);
    }

    static void OnSuccessCallback_27(void * context, int16_t minHeatSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnSuccessResponse_27(minHeatSetpointLimit);
    }

    static void OnFailureCallback_28(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnFailureResponse_28(error);
    }

    static void OnSuccessCallback_28(void * context) { (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnSuccessResponse_28(); }

    static void OnFailureCallback_29(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnFailureResponse_29(error);
    }

    static void OnSuccessCallback_29(void * context, int16_t minHeatSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnSuccessResponse_29(minHeatSetpointLimit);
    }

    static void OnFailureCallback_30(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnFailureResponse_30(error);
    }

    static void OnSuccessCallback_30(void * context, int16_t maxHeatSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnSuccessResponse_30(maxHeatSetpointLimit);
    }

    static void OnFailureCallback_31(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnFailureResponse_31(error);
    }

    static void OnSuccessCallback_31(void * context, int16_t maxHeatSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnSuccessResponse_31(maxHeatSetpointLimit);
    }

    static void OnFailureCallback_32(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnFailureResponse_32(error);
    }

    static void OnSuccessCallback_32(void * context) { (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnSuccessResponse_32(); }

    static void OnFailureCallback_33(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnFailureResponse_33(error);
    }

    static void OnSuccessCallback_33(void * context, int16_t maxHeatSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnSuccessResponse_33(maxHeatSetpointLimit);
    }

    static void OnFailureCallback_34(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnFailureResponse_34(error);
    }

    static void OnSuccessCallback_34(void * context, int16_t minCoolSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnSuccessResponse_34(minCoolSetpointLimit);
    }

    static void OnFailureCallback_35(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnFailureResponse_35(error);
    }

    static void OnSuccessCallback_35(void * context, int16_t minCoolSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnSuccessResponse_35(minCoolSetpointLimit);
    }

    static void OnFailureCallback_36(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnFailureResponse_36(error);
    }

    static void OnSuccessCallback_36(void * context) { (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnSuccessResponse_36(); }

    static void OnFailureCallback_37(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnFailureResponse_37(error);
    }

    static void OnSuccessCallback_37(void * context, int16_t minCoolSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnSuccessResponse_37(minCoolSetpointLimit);
    }

    static void OnFailureCallback_38(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnFailureResponse_38(error);
    }

    static void OnSuccessCallback_38(void * context, int16_t maxCoolSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnSuccessResponse_38(maxCoolSetpointLimit);
    }

    static void OnFailureCallback_39(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnFailureResponse_39(error);
    }

    static void OnSuccessCallback_39(void * context, int16_t maxCoolSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnSuccessResponse_39(maxCoolSetpointLimit);
    }

    static void OnFailureCallback_40(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnFailureResponse_40(error);
    }

    static void OnSuccessCallback_40(void * context) { (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnSuccessResponse_40(); }

    static void OnFailureCallback_41(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnFailureResponse_41(error);
    }

    static void OnSuccessCallback_41(void * context, int16_t maxCoolSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnSuccessResponse_41(maxCoolSetpointLimit);
    }

    static void OnFailureCallback_42(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnFailureResponse_42(error);
    }

    static void OnSuccessCallback_42(void * context, uint8_t controlSequenceOfOperation)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnSuccessResponse_42(controlSequenceOfOperation);
    }

    static void OnFailureCallback_43(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnFailureResponse_43(error);
    }

    static void OnSuccessCallback_43(void * context, uint8_t controlSequenceOfOperation)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnSuccessResponse_43(controlSequenceOfOperation);
    }

    static void OnFailureCallback_44(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnFailureResponse_44(error);
    }

    static void OnSuccessCallback_44(void * context) { (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnSuccessResponse_44(); }

    static void OnFailureCallback_45(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnFailureResponse_45(error);
    }

    static void OnSuccessCallback_45(void * context, uint8_t controlSequenceOfOperation)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnSuccessResponse_45(controlSequenceOfOperation);
    }

    static void OnFailureCallback_46(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnFailureResponse_46(error);
    }

    static void OnSuccessCallback_46(void * context, uint8_t systemMode)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnSuccessResponse_46(systemMode);
    }

    static void OnFailureCallback_47(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnFailureResponse_47(error);
    }

    static void OnSuccessCallback_47(void * context, uint8_t systemMode)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnSuccessResponse_47(systemMode);
    }

    static void OnFailureCallback_48(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnFailureResponse_48(error);
    }

    static void OnSuccessCallback_48(void * context) { (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnSuccessResponse_48(); }

    static void OnFailureCallback_49(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnFailureResponse_49(error);
    }

    static void OnSuccessCallback_49(void * context, uint8_t systemMode)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnSuccessResponse_49(systemMode);
    }

    static void OnFailureCallback_50(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnFailureResponse_50(error);
    }

    static void OnSuccessCallback_50(void * context, int8_t minSetpointDeadBand)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnSuccessResponse_50(minSetpointDeadBand);
    }

    static void OnFailureCallback_51(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnFailureResponse_51(error);
    }

    static void OnSuccessCallback_51(void * context, int8_t minSetpointDeadBand)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnSuccessResponse_51(minSetpointDeadBand);
    }

    static void OnFailureCallback_52(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnFailureResponse_52(error);
    }

    static void OnSuccessCallback_52(void * context) { (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnSuccessResponse_52(); }

    static void OnFailureCallback_53(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnFailureResponse_53(error);
    }

    static void OnSuccessCallback_53(void * context, int8_t minSetpointDeadBand)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnSuccessResponse_53(minSetpointDeadBand);
    }

    static void OnFailureCallback_54(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnFailureResponse_54(error);
    }

    static void OnSuccessCallback_54(void * context, uint8_t startOfWeek)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnSuccessResponse_54(startOfWeek);
    }

    static void OnFailureCallback_55(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnFailureResponse_55(error);
    }

    static void OnSuccessCallback_55(void * context) { (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnSuccessResponse_55(); }

    static void OnFailureCallback_56(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnFailureResponse_56(error);
    }

    static void OnSuccessCallback_56(void * context, uint8_t startOfWeek)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnSuccessResponse_56(startOfWeek);
    }

    static void OnFailureCallback_57(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnFailureResponse_57(error);
    }

    static void OnSuccessCallback_57(void * context, uint8_t numberOfWeeklyTransitions)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnSuccessResponse_57(numberOfWeeklyTransitions);
    }

    static void OnFailureCallback_58(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnFailureResponse_58(error);
    }

    static void OnSuccessCallback_58(void * context) { (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnSuccessResponse_58(); }

    static void OnFailureCallback_59(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnFailureResponse_59(error);
    }

    static void OnSuccessCallback_59(void * context, uint8_t numberOfDailyTransitions)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnSuccessResponse_59(numberOfDailyTransitions);
    }

    static void OnFailureCallback_60(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnFailureResponse_60(error);
    }

    static void OnSuccessCallback_60(void * context) { (static_cast<Test_TC_TSTAT_2_1Suite *>(context))->OnSuccessResponse_60(); }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestReadsConstraintsOfMandatoryAttributesFromDutLocalTemperature_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::LocalTemperature::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1(int16_t localTemperature)
    {
        VerifyOrReturn(CheckConstraintType("localTemperature", "", "int16"));
        NextTest();
    }

    CHIP_ERROR TestReadsMandatoryAttributesFromDutAbsMinHeatSetpointLimit_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::AbsMinHeatSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2(int16_t absMinHeatSetpointLimit)
    {
        VerifyOrReturn(CheckValue("absMinHeatSetpointLimit", absMinHeatSetpointLimit, 700));

        NextTest();
    }

    CHIP_ERROR TestReadsConstraintsOfMandatoryAttributesFromDutAbsMinHeatSetpointLimit_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::AbsMinHeatSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_3, OnFailureCallback_3, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3(int16_t absMinHeatSetpointLimit)
    {
        VerifyOrReturn(CheckConstraintType("absMinHeatSetpointLimit", "", "int16"));
        VerifyOrReturn(CheckConstraintMinValue<int16_t>("absMinHeatSetpointLimit", absMinHeatSetpointLimit, 700));
        VerifyOrReturn(CheckConstraintMaxValue<int16_t>("absMinHeatSetpointLimit", absMinHeatSetpointLimit, 3000));
        NextTest();
    }

    CHIP_ERROR TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutAbsMinHeatSetpointLimit_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t absMinHeatSetpointLimitArgument;
        absMinHeatSetpointLimitArgument = 700;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::AbsMinHeatSetpointLimit::TypeInfo>(
            absMinHeatSetpointLimitArgument, this, OnSuccessCallback_4, OnFailureCallback_4));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_4() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadBackMandatoryAttributesFromDutAbsMinHeatSetpointLimit_5()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::AbsMinHeatSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_5, OnFailureCallback_5, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_5(int16_t absMinHeatSetpointLimit)
    {
        VerifyOrReturn(CheckValue("absMinHeatSetpointLimit", absMinHeatSetpointLimit, 700));

        NextTest();
    }

    CHIP_ERROR TestReadsMandatoryAttributesFromDutAbsMaxHeatSetpointLimit_6()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::AbsMaxHeatSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_6, OnFailureCallback_6, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_6(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_6(int16_t absMaxHeatSetpointLimit)
    {
        VerifyOrReturn(CheckValue("absMaxHeatSetpointLimit", absMaxHeatSetpointLimit, 3000));

        NextTest();
    }

    CHIP_ERROR TestReadsConstraintsOfMandatoryAttributesFromDutAbsMaxHeatSetpointLimit_7()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::AbsMaxHeatSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_7, OnFailureCallback_7, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_7(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_7(int16_t absMaxHeatSetpointLimit)
    {
        VerifyOrReturn(CheckConstraintType("absMaxHeatSetpointLimit", "", "int16"));
        VerifyOrReturn(CheckConstraintMinValue<int16_t>("absMaxHeatSetpointLimit", absMaxHeatSetpointLimit, 700));
        VerifyOrReturn(CheckConstraintMaxValue<int16_t>("absMaxHeatSetpointLimit", absMaxHeatSetpointLimit, 3000));
        NextTest();
    }

    CHIP_ERROR TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutAbsMaxHeatSetpointLimit_8()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t absMaxHeatSetpointLimitArgument;
        absMaxHeatSetpointLimitArgument = 3000;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::AbsMaxHeatSetpointLimit::TypeInfo>(
            absMaxHeatSetpointLimitArgument, this, OnSuccessCallback_8, OnFailureCallback_8));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_8(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_8() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadBackMandatoryAttributesFromDutAbsMaxHeatSetpointLimit_9()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::AbsMaxHeatSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_9, OnFailureCallback_9, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_9(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_9(int16_t absMaxHeatSetpointLimit)
    {
        VerifyOrReturn(CheckValue("absMaxHeatSetpointLimit", absMaxHeatSetpointLimit, 3000));

        NextTest();
    }

    CHIP_ERROR TestReadsMandatoryAttributesFromDutAbsMinCoolSetpointLimit_10()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::AbsMinCoolSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_10, OnFailureCallback_10, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_10(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_10(int16_t absMinCoolSetpointLimit)
    {
        VerifyOrReturn(CheckValue("absMinCoolSetpointLimit", absMinCoolSetpointLimit, 1600));

        NextTest();
    }

    CHIP_ERROR TestReadsConstraintsOfMandatoryAttributesFromDutAbsMinCoolSetpointLimit_11()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::AbsMinCoolSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_11, OnFailureCallback_11, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_11(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_11(int16_t absMinCoolSetpointLimit)
    {
        VerifyOrReturn(CheckConstraintType("absMinCoolSetpointLimit", "", "int16"));
        VerifyOrReturn(CheckConstraintMinValue<int16_t>("absMinCoolSetpointLimit", absMinCoolSetpointLimit, 1600));
        VerifyOrReturn(CheckConstraintMaxValue<int16_t>("absMinCoolSetpointLimit", absMinCoolSetpointLimit, 3200));
        NextTest();
    }

    CHIP_ERROR TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutAbsMinCoolSetpointLimit_12()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t absMinCoolSetpointLimitArgument;
        absMinCoolSetpointLimitArgument = 1600;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::AbsMinCoolSetpointLimit::TypeInfo>(
            absMinCoolSetpointLimitArgument, this, OnSuccessCallback_12, OnFailureCallback_12));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_12(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_12() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadBackMandatoryAttributesFromDutAbsMinCoolSetpointLimit_13()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::AbsMinCoolSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_13, OnFailureCallback_13, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_13(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_13(int16_t absMinCoolSetpointLimit)
    {
        VerifyOrReturn(CheckValue("absMinCoolSetpointLimit", absMinCoolSetpointLimit, 1600));

        NextTest();
    }

    CHIP_ERROR TestReadsMandatoryAttributesFromDutAbsMaxCoolSetpointLimit_14()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::AbsMaxCoolSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_14, OnFailureCallback_14, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_14(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_14(int16_t absMaxCoolSetpointLimit)
    {
        VerifyOrReturn(CheckValue("absMaxCoolSetpointLimit", absMaxCoolSetpointLimit, 3200));

        NextTest();
    }

    CHIP_ERROR TestReadsConstraintsOfMandatoryAttributesFromDutAbsMaxCoolSetpointLimit_15()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::AbsMaxCoolSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_15, OnFailureCallback_15, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_15(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_15(int16_t absMaxCoolSetpointLimit)
    {
        VerifyOrReturn(CheckConstraintType("absMaxCoolSetpointLimit", "", "int16"));
        VerifyOrReturn(CheckConstraintMinValue<int16_t>("absMaxCoolSetpointLimit", absMaxCoolSetpointLimit, 1600));
        VerifyOrReturn(CheckConstraintMaxValue<int16_t>("absMaxCoolSetpointLimit", absMaxCoolSetpointLimit, 3200));
        NextTest();
    }

    CHIP_ERROR TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutAbsMaxCoolSetpointLimit_16()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t absMaxCoolSetpointLimitArgument;
        absMaxCoolSetpointLimitArgument = 3200;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::AbsMaxCoolSetpointLimit::TypeInfo>(
            absMaxCoolSetpointLimitArgument, this, OnSuccessCallback_16, OnFailureCallback_16));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_16(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_16() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadBackMandatoryAttributesFromDutAbsMaxCoolSetpointLimit_17()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::AbsMaxCoolSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_17, OnFailureCallback_17, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_17(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_17(int16_t absMaxCoolSetpointLimit)
    {
        VerifyOrReturn(CheckValue("absMaxCoolSetpointLimit", absMaxCoolSetpointLimit, 3200));

        NextTest();
    }

    CHIP_ERROR TestReadsMandatoryAttributesFromDutOccupiedCoolingSetpoint_18()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::OccupiedCoolingSetpoint::TypeInfo>(
            this, OnSuccessCallback_18, OnFailureCallback_18, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_18(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_18(int16_t occupiedCoolingSetpoint)
    {
        VerifyOrReturn(CheckValue("occupiedCoolingSetpoint", occupiedCoolingSetpoint, 2600));

        NextTest();
    }

    CHIP_ERROR TestReadsConstraintsOfMandatoryAttributesFromDutOccupiedCoolingSetpoint_19()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::OccupiedCoolingSetpoint::TypeInfo>(
            this, OnSuccessCallback_19, OnFailureCallback_19, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_19(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_19(int16_t occupiedCoolingSetpoint)
    {
        VerifyOrReturn(CheckConstraintType("occupiedCoolingSetpoint", "", "int16"));
        VerifyOrReturn(CheckConstraintMinValue<int16_t>("occupiedCoolingSetpoint", occupiedCoolingSetpoint, 1600));
        VerifyOrReturn(CheckConstraintMaxValue<int16_t>("occupiedCoolingSetpoint", occupiedCoolingSetpoint, 2600));
        NextTest();
    }

    CHIP_ERROR TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutOccupiedCoolingSetpoint_20()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t occupiedCoolingSetpointArgument;
        occupiedCoolingSetpointArgument = 2600;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::OccupiedCoolingSetpoint::TypeInfo>(
            occupiedCoolingSetpointArgument, this, OnSuccessCallback_20, OnFailureCallback_20));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_20(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_20() { NextTest(); }

    CHIP_ERROR TestReadBackMandatoryAttributesFromDutOccupiedCoolingSetpoint_21()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::OccupiedCoolingSetpoint::TypeInfo>(
            this, OnSuccessCallback_21, OnFailureCallback_21, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_21(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_21(int16_t occupiedCoolingSetpoint)
    {
        VerifyOrReturn(CheckValue("occupiedCoolingSetpoint", occupiedCoolingSetpoint, 2600));

        NextTest();
    }

    CHIP_ERROR TestReadsMandatoryAttributesFromDutOccupiedHeatingSetpoint_22()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::OccupiedHeatingSetpoint::TypeInfo>(
            this, OnSuccessCallback_22, OnFailureCallback_22, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_22(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_22(int16_t occupiedHeatingSetpoint)
    {
        VerifyOrReturn(CheckValue("occupiedHeatingSetpoint", occupiedHeatingSetpoint, 2000));

        NextTest();
    }

    CHIP_ERROR TestReadsConstraintsOfMandatoryAttributesFromDutOccupiedHeatingSetpoint_23()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::OccupiedHeatingSetpoint::TypeInfo>(
            this, OnSuccessCallback_23, OnFailureCallback_23, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_23(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_23(int16_t occupiedHeatingSetpoint)
    {
        VerifyOrReturn(CheckConstraintType("occupiedHeatingSetpoint", "", "int16"));
        VerifyOrReturn(CheckConstraintMinValue<int16_t>("occupiedHeatingSetpoint", occupiedHeatingSetpoint, 700));
        VerifyOrReturn(CheckConstraintMaxValue<int16_t>("occupiedHeatingSetpoint", occupiedHeatingSetpoint, 2600));
        NextTest();
    }

    CHIP_ERROR TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutOccupiedHeatingSetpoint_24()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t occupiedHeatingSetpointArgument;
        occupiedHeatingSetpointArgument = 2000;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::OccupiedHeatingSetpoint::TypeInfo>(
            occupiedHeatingSetpointArgument, this, OnSuccessCallback_24, OnFailureCallback_24));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_24(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_24() { NextTest(); }

    CHIP_ERROR TestReadBackMandatoryAttributesFromDutOccupiedHeatingSetpoint_25()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::OccupiedHeatingSetpoint::TypeInfo>(
            this, OnSuccessCallback_25, OnFailureCallback_25, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_25(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_25(int16_t occupiedHeatingSetpoint)
    {
        VerifyOrReturn(CheckValue("occupiedHeatingSetpoint", occupiedHeatingSetpoint, 2000));

        NextTest();
    }

    CHIP_ERROR TestReadsMandatoryAttributesFromDutMinHeatSetpointLimit_26()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::MinHeatSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_26, OnFailureCallback_26, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_26(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_26(int16_t minHeatSetpointLimit)
    {
        VerifyOrReturn(CheckValue("minHeatSetpointLimit", minHeatSetpointLimit, 700));

        NextTest();
    }

    CHIP_ERROR TestReadsConstraintsOfMandatoryAttributesFromDutMinHeatSetpointLimit_27()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::MinHeatSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_27, OnFailureCallback_27, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_27(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_27(int16_t minHeatSetpointLimit)
    {
        VerifyOrReturn(CheckConstraintType("minHeatSetpointLimit", "", "int16"));
        VerifyOrReturn(CheckConstraintMinValue<int16_t>("minHeatSetpointLimit", minHeatSetpointLimit, 700));
        VerifyOrReturn(CheckConstraintMaxValue<int16_t>("minHeatSetpointLimit", minHeatSetpointLimit, 3000));
        NextTest();
    }

    CHIP_ERROR TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutMinHeatSetpointLimit_28()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t minHeatSetpointLimitArgument;
        minHeatSetpointLimitArgument = 700;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::MinHeatSetpointLimit::TypeInfo>(
            minHeatSetpointLimitArgument, this, OnSuccessCallback_28, OnFailureCallback_28));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_28(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_28() { NextTest(); }

    CHIP_ERROR TestReadBackMandatoryAttributesFromDutMinHeatSetpointLimit_29()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::MinHeatSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_29, OnFailureCallback_29, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_29(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_29(int16_t minHeatSetpointLimit)
    {
        VerifyOrReturn(CheckValue("minHeatSetpointLimit", minHeatSetpointLimit, 700));

        NextTest();
    }

    CHIP_ERROR TestReadsMandatoryAttributesFromDutMaxHeatSetpointLimit_30()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::MaxHeatSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_30, OnFailureCallback_30, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_30(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_30(int16_t maxHeatSetpointLimit)
    {
        VerifyOrReturn(CheckValue("maxHeatSetpointLimit", maxHeatSetpointLimit, 3000));

        NextTest();
    }

    CHIP_ERROR TestReadsConstraintsOfMandatoryAttributesFromDutMaxHeatSetpointLimit_31()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::MaxHeatSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_31, OnFailureCallback_31, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_31(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_31(int16_t maxHeatSetpointLimit)
    {
        VerifyOrReturn(CheckConstraintType("maxHeatSetpointLimit", "", "int16"));
        VerifyOrReturn(CheckConstraintMinValue<int16_t>("maxHeatSetpointLimit", maxHeatSetpointLimit, 700));
        VerifyOrReturn(CheckConstraintMaxValue<int16_t>("maxHeatSetpointLimit", maxHeatSetpointLimit, 3000));
        NextTest();
    }

    CHIP_ERROR TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutMaxHeatSetpointLimit_32()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t maxHeatSetpointLimitArgument;
        maxHeatSetpointLimitArgument = 3000;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::MaxHeatSetpointLimit::TypeInfo>(
            maxHeatSetpointLimitArgument, this, OnSuccessCallback_32, OnFailureCallback_32));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_32(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_32() { NextTest(); }

    CHIP_ERROR TestReadBackMandatoryAttributesFromDutMaxHeatSetpointLimit_33()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::MaxHeatSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_33, OnFailureCallback_33, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_33(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_33(int16_t maxHeatSetpointLimit)
    {
        VerifyOrReturn(CheckValue("maxHeatSetpointLimit", maxHeatSetpointLimit, 3000));

        NextTest();
    }

    CHIP_ERROR TestReadsMandatoryAttributesFromDutMinCoolSetpointLimit_34()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::MinCoolSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_34, OnFailureCallback_34, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_34(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_34(int16_t minCoolSetpointLimit)
    {
        VerifyOrReturn(CheckValue("minCoolSetpointLimit", minCoolSetpointLimit, 1600));

        NextTest();
    }

    CHIP_ERROR TestReadsConstraintsOfMandatoryAttributesFromDutMinCoolSetpointLimit_35()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::MinCoolSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_35, OnFailureCallback_35, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_35(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_35(int16_t minCoolSetpointLimit)
    {
        VerifyOrReturn(CheckConstraintType("minCoolSetpointLimit", "", "int16"));
        VerifyOrReturn(CheckConstraintMinValue<int16_t>("minCoolSetpointLimit", minCoolSetpointLimit, 1600));
        VerifyOrReturn(CheckConstraintMaxValue<int16_t>("minCoolSetpointLimit", minCoolSetpointLimit, 3200));
        NextTest();
    }

    CHIP_ERROR TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutMinCoolSetpointLimit_36()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t minCoolSetpointLimitArgument;
        minCoolSetpointLimitArgument = 1600;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::MinCoolSetpointLimit::TypeInfo>(
            minCoolSetpointLimitArgument, this, OnSuccessCallback_36, OnFailureCallback_36));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_36(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_36() { NextTest(); }

    CHIP_ERROR TestReadBackMandatoryAttributesFromDutMinCoolSetpointLimit_37()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::MinCoolSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_37, OnFailureCallback_37, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_37(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_37(int16_t minCoolSetpointLimit)
    {
        VerifyOrReturn(CheckValue("minCoolSetpointLimit", minCoolSetpointLimit, 1600));

        NextTest();
    }

    CHIP_ERROR TestReadsMandatoryAttributesFromDutMaxCoolSetpointLimit_38()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::MaxCoolSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_38, OnFailureCallback_38, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_38(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_38(int16_t maxCoolSetpointLimit)
    {
        VerifyOrReturn(CheckValue("maxCoolSetpointLimit", maxCoolSetpointLimit, 3200));

        NextTest();
    }

    CHIP_ERROR TestReadsConstraintsOfMandatoryAttributesFromDutMaxCoolSetpointLimit_39()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::MaxCoolSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_39, OnFailureCallback_39, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_39(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_39(int16_t maxCoolSetpointLimit)
    {
        VerifyOrReturn(CheckConstraintType("maxCoolSetpointLimit", "", "int16"));
        VerifyOrReturn(CheckConstraintMinValue<int16_t>("maxCoolSetpointLimit", maxCoolSetpointLimit, 1600));
        VerifyOrReturn(CheckConstraintMaxValue<int16_t>("maxCoolSetpointLimit", maxCoolSetpointLimit, 3200));
        NextTest();
    }

    CHIP_ERROR TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutMaxCoolSetpointLimit_40()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t maxCoolSetpointLimitArgument;
        maxCoolSetpointLimitArgument = 3200;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::MaxCoolSetpointLimit::TypeInfo>(
            maxCoolSetpointLimitArgument, this, OnSuccessCallback_40, OnFailureCallback_40));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_40(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_40() { NextTest(); }

    CHIP_ERROR TestReadBackMandatoryAttributesFromDutMaxCoolSetpointLimit_41()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::MaxCoolSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_41, OnFailureCallback_41, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_41(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_41(int16_t maxCoolSetpointLimit)
    {
        VerifyOrReturn(CheckValue("maxCoolSetpointLimit", maxCoolSetpointLimit, 3200));

        NextTest();
    }

    CHIP_ERROR TestReadsMandatoryAttributesFromDutControlSequenceOfOperation_42()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::ControlSequenceOfOperation::TypeInfo>(
                this, OnSuccessCallback_42, OnFailureCallback_42, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_42(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_42(uint8_t controlSequenceOfOperation)
    {
        VerifyOrReturn(CheckValue("controlSequenceOfOperation", controlSequenceOfOperation, 4));

        NextTest();
    }

    CHIP_ERROR TestReadsConstraintsOfMandatoryAttributesFromDutControlSequenceOfOperation_43()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::ControlSequenceOfOperation::TypeInfo>(
                this, OnSuccessCallback_43, OnFailureCallback_43, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_43(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_43(uint8_t controlSequenceOfOperation)
    {
        VerifyOrReturn(CheckConstraintType("controlSequenceOfOperation", "", "enum8"));
        VerifyOrReturn(CheckConstraintMinValue<uint8_t>("controlSequenceOfOperation", controlSequenceOfOperation, 0));
        VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("controlSequenceOfOperation", controlSequenceOfOperation, 5));
        NextTest();
    }

    CHIP_ERROR TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutControlSequenceOfOperation_44()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t controlSequenceOfOperationArgument;
        controlSequenceOfOperationArgument = 4;

        ReturnErrorOnFailure(
            cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::ControlSequenceOfOperation::TypeInfo>(
                controlSequenceOfOperationArgument, this, OnSuccessCallback_44, OnFailureCallback_44));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_44(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_44() { NextTest(); }

    CHIP_ERROR TestReadBackMandatoryAttributesFromDutControlSequenceOfOperation_45()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::ControlSequenceOfOperation::TypeInfo>(
                this, OnSuccessCallback_45, OnFailureCallback_45, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_45(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_45(uint8_t controlSequenceOfOperation)
    {
        VerifyOrReturn(CheckValue("controlSequenceOfOperation", controlSequenceOfOperation, 4));

        NextTest();
    }

    CHIP_ERROR TestReadsMandatoryAttributesFromDutSystemMode_46()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::SystemMode::TypeInfo>(
            this, OnSuccessCallback_46, OnFailureCallback_46, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_46(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_46(uint8_t systemMode)
    {
        VerifyOrReturn(CheckValue("systemMode", systemMode, 1));

        NextTest();
    }

    CHIP_ERROR TestReadsConstraintsOfMandatoryAttributesFromDutSystemMode_47()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::SystemMode::TypeInfo>(
            this, OnSuccessCallback_47, OnFailureCallback_47, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_47(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_47(uint8_t systemMode)
    {
        VerifyOrReturn(CheckConstraintType("systemMode", "", "enum8"));
        VerifyOrReturn(CheckConstraintMinValue<uint8_t>("systemMode", systemMode, 0));
        VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("systemMode", systemMode, 9));
        NextTest();
    }

    CHIP_ERROR TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutSystemMode_48()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t systemModeArgument;
        systemModeArgument = 1;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::SystemMode::TypeInfo>(
            systemModeArgument, this, OnSuccessCallback_48, OnFailureCallback_48));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_48(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_48() { NextTest(); }

    CHIP_ERROR TestReadBackMandatoryAttributesFromDutSystemMode_49()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::SystemMode::TypeInfo>(
            this, OnSuccessCallback_49, OnFailureCallback_49, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_49(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_49(uint8_t systemMode)
    {
        VerifyOrReturn(CheckValue("systemMode", systemMode, 1));

        NextTest();
    }

    CHIP_ERROR TestReadsOptionalAttributesFromDutMinSetpointDeadBand_50()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::MinSetpointDeadBand::TypeInfo>(
            this, OnSuccessCallback_50, OnFailureCallback_50, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_50(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_50(int8_t minSetpointDeadBand)
    {
        VerifyOrReturn(CheckValue("minSetpointDeadBand", minSetpointDeadBand, 25));

        NextTest();
    }

    CHIP_ERROR TestReadsConstraintsOfOptionalAttributesFromDutMinSetpointDeadBand_51()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::MinSetpointDeadBand::TypeInfo>(
            this, OnSuccessCallback_51, OnFailureCallback_51, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_51(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_51(int8_t minSetpointDeadBand)
    {
        VerifyOrReturn(CheckConstraintType("minSetpointDeadBand", "", "int8"));
        VerifyOrReturn(CheckConstraintMinValue<int8_t>("minSetpointDeadBand", minSetpointDeadBand, 0));
        VerifyOrReturn(CheckConstraintMaxValue<int8_t>("minSetpointDeadBand", minSetpointDeadBand, 25));
        NextTest();
    }

    CHIP_ERROR TestWritesTheRespectiveDefaultValueToOptionalAttributesToDutMinSetpointDeadBand_52()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int8_t minSetpointDeadBandArgument;
        minSetpointDeadBandArgument = 25;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::MinSetpointDeadBand::TypeInfo>(
            minSetpointDeadBandArgument, this, OnSuccessCallback_52, OnFailureCallback_52));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_52(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_52() { NextTest(); }

    CHIP_ERROR TestReadBackOptionalAttributesFromDutMinSetpointDeadBand_53()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::MinSetpointDeadBand::TypeInfo>(
            this, OnSuccessCallback_53, OnFailureCallback_53, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_53(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_53(int8_t minSetpointDeadBand)
    {
        VerifyOrReturn(CheckValue("minSetpointDeadBand", minSetpointDeadBand, 25));

        NextTest();
    }

    CHIP_ERROR TestReadsConstraintsOfOptionalAttributesFromDutStartOfWeek_54()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::StartOfWeek::TypeInfo>(
            this, OnSuccessCallback_54, OnFailureCallback_54, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_54(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_54(uint8_t startOfWeek)
    {
        VerifyOrReturn(CheckConstraintType("startOfWeek", "", "enum8"));
        VerifyOrReturn(CheckConstraintMinValue<uint8_t>("startOfWeek", startOfWeek, 0));
        VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("startOfWeek", startOfWeek, 6));
        NextTest();
    }

    CHIP_ERROR TestWritesTheRespectiveDefaultValueToOptionalAttributesToDutStartOfWeek_55()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t startOfWeekArgument;
        startOfWeekArgument = 0;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::StartOfWeek::TypeInfo>(
            startOfWeekArgument, this, OnSuccessCallback_55, OnFailureCallback_55));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_55(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_55() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadBackOptionalAttributesFromDutStartOfWeek_56()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::StartOfWeek::TypeInfo>(
            this, OnSuccessCallback_56, OnFailureCallback_56, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_56(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_56(uint8_t startOfWeek)
    {
        VerifyOrReturn(CheckValue("startOfWeek", startOfWeek, 0));

        NextTest();
    }

    CHIP_ERROR TestReadsConstraintsOfOptionalAttributesFromDutNumberOfWeeklyTransitions_57()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::NumberOfWeeklyTransitions::TypeInfo>(
                this, OnSuccessCallback_57, OnFailureCallback_57, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_57(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_57(uint8_t numberOfWeeklyTransitions)
    {
        VerifyOrReturn(CheckConstraintType("numberOfWeeklyTransitions", "", "uint8"));
        NextTest();
    }

    CHIP_ERROR TestWritesTheRespectiveDefaultValueToOptionalAttributesToDutNumberOfWeeklyTransitions_58()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t numberOfWeeklyTransitionsArgument;
        numberOfWeeklyTransitionsArgument = 0;

        ReturnErrorOnFailure(
            cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::NumberOfWeeklyTransitions::TypeInfo>(
                numberOfWeeklyTransitionsArgument, this, OnSuccessCallback_58, OnFailureCallback_58));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_58(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_58() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsConstraintsOfOptionalAttributesFromDutNumberOfDailyTransitions_59()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::NumberOfDailyTransitions::TypeInfo>(
            this, OnSuccessCallback_59, OnFailureCallback_59, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_59(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_59(uint8_t numberOfDailyTransitions)
    {
        VerifyOrReturn(CheckConstraintType("numberOfDailyTransitions", "", "uint8"));
        NextTest();
    }

    CHIP_ERROR TestWritesTheRespectiveDefaultValueToOptionalAttributesToDutNumberOfDailyTransitions_60()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t numberOfDailyTransitionsArgument;
        numberOfDailyTransitionsArgument = 0;

        ReturnErrorOnFailure(
            cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::NumberOfDailyTransitions::TypeInfo>(
                numberOfDailyTransitionsArgument, this, OnSuccessCallback_60, OnFailureCallback_60));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_60(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_60() { ThrowSuccessResponse(); }
};

class Test_TC_TSTAT_2_2Suite : public TestCommand
{
public:
    Test_TC_TSTAT_2_2Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_TSTAT_2_2", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_TSTAT_2_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_TSTAT_2_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_TSTAT_2_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool,
                            " ***** Test Step 1 : Reads OccupiedCoolingSetpoint attribute from Server DUT and verifies that the "
                            "value is within range\n");
            if (ShouldSkip("A_OCCUPIEDCOOLINGSETPOINT"))
            {
                NextTest();
                return;
            }
            err = TestReadsOccupiedCoolingSetpointAttributeFromServerDutAndVerifiesThatTheValueIsWithinRange_1();
            break;
        case 2:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 2 : Writes a value back that is different but valid for OccupiedCoolingSetpoint attribute\n");
            if (ShouldSkip("A_OCCUPIEDCOOLINGSETPOINT"))
            {
                NextTest();
                return;
            }
            err = TestWritesAValueBackThatIsDifferentButValidForOccupiedCoolingSetpointAttribute_2();
            break;
        case 3:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 3 : Reads it back again to confirm the successful write of OccupiedCoolingSetpoint attribute\n");
            if (ShouldSkip("A_OCCUPIEDCOOLINGSETPOINT"))
            {
                NextTest();
                return;
            }
            err = TestReadsItBackAgainToConfirmTheSuccessfulWriteOfOccupiedCoolingSetpointAttribute_3();
            break;
        case 4:
            ChipLogProgress(chipTool,
                            " ***** Test Step 4 : Writes the limit of MinCoolSetpointLimit to OccupiedCoolingSetpoint attribute\n");
            if (ShouldSkip("A_OCCUPIEDCOOLINGSETPOINT"))
            {
                NextTest();
                return;
            }
            err = TestWritesTheLimitOfMinCoolSetpointLimitToOccupiedCoolingSetpointAttribute_4();
            break;
        case 5:
            ChipLogProgress(chipTool,
                            " ***** Test Step 5 : Writes the limit of MaxCoolSetpointLimit to OccupiedCoolingSetpoint attribute\n");
            if (ShouldSkip("A_OCCUPIEDCOOLINGSETPOINT"))
            {
                NextTest();
                return;
            }
            err = TestWritesTheLimitOfMaxCoolSetpointLimitToOccupiedCoolingSetpointAttribute_5();
            break;
        case 6:
            ChipLogProgress(chipTool,
                            " ***** Test Step 6 : Reads OccupiedHeatingSetpoint attribute from Server DUT and verifies that the "
                            "value is within range\n");
            if (ShouldSkip("A_OCCUPIEDHEATINGSETPOINT"))
            {
                NextTest();
                return;
            }
            err = TestReadsOccupiedHeatingSetpointAttributeFromServerDutAndVerifiesThatTheValueIsWithinRange_6();
            break;
        case 7:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 7 : Writes a value back that is different but valid for OccupiedHeatingSetpoint attribute\n");
            if (ShouldSkip("A_OCCUPIEDHEATINGSETPOINT"))
            {
                NextTest();
                return;
            }
            err = TestWritesAValueBackThatIsDifferentButValidForOccupiedHeatingSetpointAttribute_7();
            break;
        case 8:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 8 : Reads it back again to confirm the successful write of OccupiedHeatingSetpoint attribute\n");
            if (ShouldSkip("A_OCCUPIEDHEATINGSETPOINT"))
            {
                NextTest();
                return;
            }
            err = TestReadsItBackAgainToConfirmTheSuccessfulWriteOfOccupiedHeatingSetpointAttribute_8();
            break;
        case 9:
            ChipLogProgress(chipTool,
                            " ***** Test Step 9 : Writes the limit of MinHeatSetpointLimit to OccupiedHeatingSetpoint attribute\n");
            if (ShouldSkip("A_OCCUPIEDHEATINGSETPOINT"))
            {
                NextTest();
                return;
            }
            err = TestWritesTheLimitOfMinHeatSetpointLimitToOccupiedHeatingSetpointAttribute_9();
            break;
        case 10:
            ChipLogProgress(
                chipTool, " ***** Test Step 10 : Writes the limit of MaxHeatSetpointLimit to OccupiedHeatingSetpoint attribute\n");
            if (ShouldSkip("A_OCCUPIEDHEATINGSETPOINT"))
            {
                NextTest();
                return;
            }
            err = TestWritesTheLimitOfMaxHeatSetpointLimitToOccupiedHeatingSetpointAttribute_10();
            break;
        case 11:
            ChipLogProgress(chipTool,
                            " ***** Test Step 11 : Reads MinHeatSetpointLimit attribute from Server DUT and verifies that the "
                            "value is within range\n");
            if (ShouldSkip("A_MINHEATSETPOINTLIMIT"))
            {
                NextTest();
                return;
            }
            err = TestReadsMinHeatSetpointLimitAttributeFromServerDutAndVerifiesThatTheValueIsWithinRange_11();
            break;
        case 12:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 12 : Writes a value back that is different but valid for MinHeatSetpointLimit attribute\n");
            if (ShouldSkip("A_MINHEATSETPOINTLIMIT"))
            {
                NextTest();
                return;
            }
            err = TestWritesAValueBackThatIsDifferentButValidForMinHeatSetpointLimitAttribute_12();
            break;
        case 13:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 13 : Reads it back again to confirm the successful write of MinHeatSetpointLimit attribute\n");
            if (ShouldSkip("A_MINHEATSETPOINTLIMIT"))
            {
                NextTest();
                return;
            }
            err = TestReadsItBackAgainToConfirmTheSuccessfulWriteOfMinHeatSetpointLimitAttribute_13();
            break;
        case 14:
            ChipLogProgress(
                chipTool, " ***** Test Step 14 : Writes the limit of AbsMinHeatSetpointLimit to MinHeatSetpointLimit attribute\n");
            if (ShouldSkip("A_MINHEATSETPOINTLIMIT"))
            {
                NextTest();
                return;
            }
            err = TestWritesTheLimitOfAbsMinHeatSetpointLimitToMinHeatSetpointLimitAttribute_14();
            break;
        case 15:
            ChipLogProgress(
                chipTool, " ***** Test Step 15 : Writes the limit of AbsMaxHeatSetpointLimit to MinHeatSetpointLimit attribute\n");
            if (ShouldSkip("A_MINHEATSETPOINTLIMIT"))
            {
                NextTest();
                return;
            }
            err = TestWritesTheLimitOfAbsMaxHeatSetpointLimitToMinHeatSetpointLimitAttribute_15();
            break;
        case 16:
            ChipLogProgress(chipTool,
                            " ***** Test Step 16 : Reads MaxHeatSetpointLimit attribute from Server DUT and verifies that the "
                            "value is within range\n");
            if (ShouldSkip("A_MAXHEATSETPOINTLIMIT"))
            {
                NextTest();
                return;
            }
            err = TestReadsMaxHeatSetpointLimitAttributeFromServerDutAndVerifiesThatTheValueIsWithinRange_16();
            break;
        case 17:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 17 : Writes a value back that is different but valid for MaxHeatSetpointLimit attribute\n");
            if (ShouldSkip("A_MAXHEATSETPOINTLIMIT"))
            {
                NextTest();
                return;
            }
            err = TestWritesAValueBackThatIsDifferentButValidForMaxHeatSetpointLimitAttribute_17();
            break;
        case 18:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 18 : Reads it back again to confirm the successful write of MaxHeatSetpointLimit attribute\n");
            if (ShouldSkip("A_MAXHEATSETPOINTLIMIT"))
            {
                NextTest();
                return;
            }
            err = TestReadsItBackAgainToConfirmTheSuccessfulWriteOfMaxHeatSetpointLimitAttribute_18();
            break;
        case 19:
            ChipLogProgress(
                chipTool, " ***** Test Step 19 : Writes the limit of AbsMinHeatSetpointLimit to MaxHeatSetpointLimit attribute\n");
            if (ShouldSkip("A_MAXHEATSETPOINTLIMIT"))
            {
                NextTest();
                return;
            }
            err = TestWritesTheLimitOfAbsMinHeatSetpointLimitToMaxHeatSetpointLimitAttribute_19();
            break;
        case 20:
            ChipLogProgress(
                chipTool, " ***** Test Step 20 : Writes the limit of AbsMaxHeatSetpointLimit to MaxHeatSetpointLimit attribute\n");
            if (ShouldSkip("A_MAXHEATSETPOINTLIMIT"))
            {
                NextTest();
                return;
            }
            err = TestWritesTheLimitOfAbsMaxHeatSetpointLimitToMaxHeatSetpointLimitAttribute_20();
            break;
        case 21:
            ChipLogProgress(chipTool,
                            " ***** Test Step 21 : Reads MinCoolSetpointLimit attribute from Server DUT and verifies that the "
                            "value is within range\n");
            if (ShouldSkip("A_MINCOOLSETPOINTLIMIT"))
            {
                NextTest();
                return;
            }
            err = TestReadsMinCoolSetpointLimitAttributeFromServerDutAndVerifiesThatTheValueIsWithinRange_21();
            break;
        case 22:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 22 : Writes a value back that is different but valid for MinCoolSetpointLimit attribute\n");
            if (ShouldSkip("A_MINCOOLSETPOINTLIMIT"))
            {
                NextTest();
                return;
            }
            err = TestWritesAValueBackThatIsDifferentButValidForMinCoolSetpointLimitAttribute_22();
            break;
        case 23:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 23 : Reads it back again to confirm the successful write of MinCoolSetpointLimit attribute\n");
            if (ShouldSkip("A_MINCOOLSETPOINTLIMIT"))
            {
                NextTest();
                return;
            }
            err = TestReadsItBackAgainToConfirmTheSuccessfulWriteOfMinCoolSetpointLimitAttribute_23();
            break;
        case 24:
            ChipLogProgress(
                chipTool, " ***** Test Step 24 : Writes the limit of AbsMinCoolSetpointLimit to MinCoolSetpointLimit attribute\n");
            if (ShouldSkip("A_MINCOOLSETPOINTLIMIT"))
            {
                NextTest();
                return;
            }
            err = TestWritesTheLimitOfAbsMinCoolSetpointLimitToMinCoolSetpointLimitAttribute_24();
            break;
        case 25:
            ChipLogProgress(chipTool,
                            " ***** Test Step 25 : Writes the limit of MaxCoolSetpointLimit to MinCoolSetpointLimit attribute\n");
            if (ShouldSkip("A_MINCOOLSETPOINTLIMIT"))
            {
                NextTest();
                return;
            }
            err = TestWritesTheLimitOfMaxCoolSetpointLimitToMinCoolSetpointLimitAttribute_25();
            break;
        case 26:
            ChipLogProgress(chipTool,
                            " ***** Test Step 26 : Reads MaxCoolSetpointLimit attribute from Server DUT and verifies that the "
                            "value is within range\n");
            if (ShouldSkip("A_MAXCOOLSETPOINTLIMIT"))
            {
                NextTest();
                return;
            }
            err = TestReadsMaxCoolSetpointLimitAttributeFromServerDutAndVerifiesThatTheValueIsWithinRange_26();
            break;
        case 27:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 27 : Writes a value back that is different but valid for MaxCoolSetpointLimit attribute\n");
            if (ShouldSkip("A_MAXCOOLSETPOINTLIMIT"))
            {
                NextTest();
                return;
            }
            err = TestWritesAValueBackThatIsDifferentButValidForMaxCoolSetpointLimitAttribute_27();
            break;
        case 28:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 28 : Reads it back again to confirm the successful write of MaxCoolSetpointLimit attribute\n");
            if (ShouldSkip("A_MAXCOOLSETPOINTLIMIT"))
            {
                NextTest();
                return;
            }
            err = TestReadsItBackAgainToConfirmTheSuccessfulWriteOfMaxCoolSetpointLimitAttribute_28();
            break;
        case 29:
            ChipLogProgress(
                chipTool, " ***** Test Step 29 : Writes the limit of AbsMinCoolSetpointLimit to MaxCoolSetpointLimit attribute\n");
            if (ShouldSkip("A_MAXCOOLSETPOINTLIMIT"))
            {
                NextTest();
                return;
            }
            err = TestWritesTheLimitOfAbsMinCoolSetpointLimitToMaxCoolSetpointLimitAttribute_29();
            break;
        case 30:
            ChipLogProgress(chipTool,
                            " ***** Test Step 30 : Writes the limit of MaxCoolSetpointLimit to MaxCoolSetpointLimit attribute\n");
            if (ShouldSkip("A_MAXCOOLSETPOINTLIMIT"))
            {
                NextTest();
                return;
            }
            err = TestWritesTheLimitOfMaxCoolSetpointLimitToMaxCoolSetpointLimitAttribute_30();
            break;
        case 31:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 31 : Writes (sets back) the limit of MinHeatSetpointLimit to MinHeatSetpointLimit attribute\n");
            if (ShouldSkip("A_MINHEATSETPOINTLIMIT"))
            {
                NextTest();
                return;
            }
            err = TestWritesSetsBackTheLimitOfMinHeatSetpointLimitToMinHeatSetpointLimitAttribute_31();
            break;
        case 32:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 32 : Writes (sets back) the limit of MaxHeatSetpointLimit to MinHeatSetpointLimit attribute\n");
            if (ShouldSkip("A_MINHEATSETPOINTLIMIT"))
            {
                NextTest();
                return;
            }
            err = TestWritesSetsBackTheLimitOfMaxHeatSetpointLimitToMinHeatSetpointLimitAttribute_32();
            break;
        case 33:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 33 : Writes (sets back) the limit of MinHeatSetpointLimit to MaxHeatSetpointLimit attribute\n");
            if (ShouldSkip("A_MINHEATSETPOINTLIMIT"))
            {
                NextTest();
                return;
            }
            err = TestWritesSetsBackTheLimitOfMinHeatSetpointLimitToMaxHeatSetpointLimitAttribute_33();
            break;
        case 34:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 34 : Writes (sets back) the limit of MaxHeatSetpointLimit to MaxHeatSetpointLimit attribute\n");
            if (ShouldSkip("A_MINHEATSETPOINTLIMIT"))
            {
                NextTest();
                return;
            }
            err = TestWritesSetsBackTheLimitOfMaxHeatSetpointLimitToMaxHeatSetpointLimitAttribute_34();
            break;
        case 35:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 35 : Writes (sets back) the limit of MinCoolSetpointLimit to MinCoolSetpointLimit attribute\n");
            if (ShouldSkip("A_MINCOOLSETPOINTLIMIT"))
            {
                NextTest();
                return;
            }
            err = TestWritesSetsBackTheLimitOfMinCoolSetpointLimitToMinCoolSetpointLimitAttribute_35();
            break;
        case 36:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 36 : Writes (sets back) the limit of MaxCoolSetpointLimit to MinCoolSetpointLimit attribute\n");
            if (ShouldSkip("A_MINCOOLSETPOINTLIMIT"))
            {
                NextTest();
                return;
            }
            err = TestWritesSetsBackTheLimitOfMaxCoolSetpointLimitToMinCoolSetpointLimitAttribute_36();
            break;
        case 37:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 37 : Writes (sets back) the limit of MinCoolSetpointLimit to MaxCoolSetpointLimit attribute\n");
            if (ShouldSkip("A_MAXCOOLSETPOINTLIMIT"))
            {
                NextTest();
                return;
            }
            err = TestWritesSetsBackTheLimitOfMinCoolSetpointLimitToMaxCoolSetpointLimitAttribute_37();
            break;
        case 38:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 38 : Writes (sets back) the limit of MaxCoolSetpointLimit to MaxCoolSetpointLimit attribute\n");
            if (ShouldSkip("A_MAXCOOLSETPOINTLIMIT"))
            {
                NextTest();
                return;
            }
            err = TestWritesSetsBackTheLimitOfMaxCoolSetpointLimitToMaxCoolSetpointLimitAttribute_38();
            break;
        case 39:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 39 : Reads ControlSequenceOfOperation from Server DUT and verifies that the value is valid\n");
            if (ShouldSkip("A_CONTROLSEQUENCEOFOPERATION"))
            {
                NextTest();
                return;
            }
            err = TestReadsControlSequenceOfOperationFromServerDutAndVerifiesThatTheValueIsValid_39();
            break;
        case 40:
            ChipLogProgress(
                chipTool, " ***** Test Step 40 : Write Attribute command for ControlSequenceOfOperation with a new valid value\n");
            if (ShouldSkip("A_CONTROLSEQUENCEOFOPERATION"))
            {
                NextTest();
                return;
            }
            err = TestWriteAttributeCommandForControlSequenceOfOperationWithANewValidValue_40();
            break;
        case 41:
            ChipLogProgress(chipTool, " ***** Test Step 41 : Read it back again to confirm the successful write\n");
            if (ShouldSkip("A_CONTROLSEQUENCEOFOPERATION"))
            {
                NextTest();
                return;
            }
            err = TestReadItBackAgainToConfirmTheSuccessfulWrite_41();
            break;
        case 42:
            ChipLogProgress(chipTool, " ***** Test Step 42 : Sets OccupiedHeatingSetpoint to default value\n");
            if (ShouldSkip("A_OCCUPIEDHEATINGSETPOINT"))
            {
                NextTest();
                return;
            }
            err = TestSetsOccupiedHeatingSetpointToDefaultValue_42();
            break;
        case 43:
            ChipLogProgress(chipTool, " ***** Test Step 43 : Sets OccupiedHeatingSetpoint to default value\n");
            if (ShouldSkip("A_OCCUPIEDHEATINGSETPOINT"))
            {
                NextTest();
                return;
            }
            err = TestSetsOccupiedHeatingSetpointToDefaultValue_43();
            break;
        case 44:
            ChipLogProgress(chipTool, " ***** Test Step 44 : Sets OccupiedCoolingSetpoint to default value\n");
            if (ShouldSkip("A_OCCUPIEDCOOLINGSETPOINT"))
            {
                NextTest();
                return;
            }
            err = TestSetsOccupiedCoolingSetpointToDefaultValue_44();
            break;
        case 45:
            ChipLogProgress(chipTool, " ***** Test Step 45 : Sets OccupiedCoolingSetpoint to default value\n");
            if (ShouldSkip("A_OCCUPIEDCOOLINGSETPOINT"))
            {
                NextTest();
                return;
            }
            err = TestSetsOccupiedCoolingSetpointToDefaultValue_45();
            break;
        case 46:
            ChipLogProgress(chipTool, " ***** Test Step 46 : Sets OccupiedCoolingSetpoint to default value\n");
            if (ShouldSkip("A_OCCUPIEDCOOLINGSETPOINT"))
            {
                NextTest();
                return;
            }
            err = TestSetsOccupiedCoolingSetpointToDefaultValue_46();
            break;
        case 47:
            ChipLogProgress(chipTool, " ***** Test Step 47 : Sets OccupiedHeatingSetpoint to default value\n");
            if (ShouldSkip("A_OCCUPIEDHEATINGSETPOINT"))
            {
                NextTest();
                return;
            }
            err = TestSetsOccupiedHeatingSetpointToDefaultValue_47();
            break;
        case 48:
            ChipLogProgress(chipTool, " ***** Test Step 48 : Sets OccupiedCoolingSetpoint to default value\n");
            if (ShouldSkip("A_OCCUPIEDCOOLINGSETPOINT"))
            {
                NextTest();
                return;
            }
            err = TestSetsOccupiedCoolingSetpointToDefaultValue_48();
            break;
        case 49:
            ChipLogProgress(chipTool, " ***** Test Step 49 : Sets OccupiedHeatingSetpoint to default value\n");
            if (ShouldSkip("A_OCCUPIEDHEATINGSETPOINT"))
            {
                NextTest();
                return;
            }
            err = TestSetsOccupiedHeatingSetpointToDefaultValue_49();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 50;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_1(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnFailureResponse_1(error);
    }

    static void OnSuccessCallback_1(void * context, int16_t occupiedCoolingSetpoint)
    {
        (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnSuccessResponse_1(occupiedCoolingSetpoint);
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context) { (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnSuccessResponse_2(); }

    static void OnFailureCallback_3(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnFailureResponse_3(error);
    }

    static void OnSuccessCallback_3(void * context, int16_t occupiedCoolingSetpoint)
    {
        (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnSuccessResponse_3(occupiedCoolingSetpoint);
    }

    static void OnFailureCallback_4(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnFailureResponse_4(error);
    }

    static void OnSuccessCallback_4(void * context) { (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnSuccessResponse_4(); }

    static void OnFailureCallback_5(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnFailureResponse_5(error);
    }

    static void OnSuccessCallback_5(void * context) { (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnSuccessResponse_5(); }

    static void OnFailureCallback_6(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnFailureResponse_6(error);
    }

    static void OnSuccessCallback_6(void * context, int16_t occupiedHeatingSetpoint)
    {
        (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnSuccessResponse_6(occupiedHeatingSetpoint);
    }

    static void OnFailureCallback_7(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnFailureResponse_7(error);
    }

    static void OnSuccessCallback_7(void * context) { (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnSuccessResponse_7(); }

    static void OnFailureCallback_8(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnFailureResponse_8(error);
    }

    static void OnSuccessCallback_8(void * context, int16_t occupiedHeatingSetpoint)
    {
        (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnSuccessResponse_8(occupiedHeatingSetpoint);
    }

    static void OnFailureCallback_9(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnFailureResponse_9(error);
    }

    static void OnSuccessCallback_9(void * context) { (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnSuccessResponse_9(); }

    static void OnFailureCallback_10(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnFailureResponse_10(error);
    }

    static void OnSuccessCallback_10(void * context) { (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnSuccessResponse_10(); }

    static void OnFailureCallback_11(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnFailureResponse_11(error);
    }

    static void OnSuccessCallback_11(void * context, int16_t minHeatSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnSuccessResponse_11(minHeatSetpointLimit);
    }

    static void OnFailureCallback_12(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnFailureResponse_12(error);
    }

    static void OnSuccessCallback_12(void * context) { (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnSuccessResponse_12(); }

    static void OnFailureCallback_13(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnFailureResponse_13(error);
    }

    static void OnSuccessCallback_13(void * context, int16_t minHeatSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnSuccessResponse_13(minHeatSetpointLimit);
    }

    static void OnFailureCallback_14(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnFailureResponse_14(error);
    }

    static void OnSuccessCallback_14(void * context) { (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnSuccessResponse_14(); }

    static void OnFailureCallback_15(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnFailureResponse_15(error);
    }

    static void OnSuccessCallback_15(void * context) { (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnSuccessResponse_15(); }

    static void OnFailureCallback_16(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnFailureResponse_16(error);
    }

    static void OnSuccessCallback_16(void * context, int16_t maxHeatSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnSuccessResponse_16(maxHeatSetpointLimit);
    }

    static void OnFailureCallback_17(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnFailureResponse_17(error);
    }

    static void OnSuccessCallback_17(void * context) { (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnSuccessResponse_17(); }

    static void OnFailureCallback_18(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnFailureResponse_18(error);
    }

    static void OnSuccessCallback_18(void * context, int16_t maxHeatSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnSuccessResponse_18(maxHeatSetpointLimit);
    }

    static void OnFailureCallback_19(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnFailureResponse_19(error);
    }

    static void OnSuccessCallback_19(void * context) { (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnSuccessResponse_19(); }

    static void OnFailureCallback_20(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnFailureResponse_20(error);
    }

    static void OnSuccessCallback_20(void * context) { (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnSuccessResponse_20(); }

    static void OnFailureCallback_21(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnFailureResponse_21(error);
    }

    static void OnSuccessCallback_21(void * context, int16_t minCoolSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnSuccessResponse_21(minCoolSetpointLimit);
    }

    static void OnFailureCallback_22(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnFailureResponse_22(error);
    }

    static void OnSuccessCallback_22(void * context) { (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnSuccessResponse_22(); }

    static void OnFailureCallback_23(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnFailureResponse_23(error);
    }

    static void OnSuccessCallback_23(void * context, int16_t minCoolSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnSuccessResponse_23(minCoolSetpointLimit);
    }

    static void OnFailureCallback_24(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnFailureResponse_24(error);
    }

    static void OnSuccessCallback_24(void * context) { (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnSuccessResponse_24(); }

    static void OnFailureCallback_25(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnFailureResponse_25(error);
    }

    static void OnSuccessCallback_25(void * context) { (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnSuccessResponse_25(); }

    static void OnFailureCallback_26(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnFailureResponse_26(error);
    }

    static void OnSuccessCallback_26(void * context, int16_t maxCoolSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnSuccessResponse_26(maxCoolSetpointLimit);
    }

    static void OnFailureCallback_27(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnFailureResponse_27(error);
    }

    static void OnSuccessCallback_27(void * context) { (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnSuccessResponse_27(); }

    static void OnFailureCallback_28(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnFailureResponse_28(error);
    }

    static void OnSuccessCallback_28(void * context, int16_t maxCoolSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnSuccessResponse_28(maxCoolSetpointLimit);
    }

    static void OnFailureCallback_29(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnFailureResponse_29(error);
    }

    static void OnSuccessCallback_29(void * context) { (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnSuccessResponse_29(); }

    static void OnFailureCallback_30(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnFailureResponse_30(error);
    }

    static void OnSuccessCallback_30(void * context) { (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnSuccessResponse_30(); }

    static void OnFailureCallback_31(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnFailureResponse_31(error);
    }

    static void OnSuccessCallback_31(void * context) { (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnSuccessResponse_31(); }

    static void OnFailureCallback_32(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnFailureResponse_32(error);
    }

    static void OnSuccessCallback_32(void * context) { (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnSuccessResponse_32(); }

    static void OnFailureCallback_33(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnFailureResponse_33(error);
    }

    static void OnSuccessCallback_33(void * context) { (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnSuccessResponse_33(); }

    static void OnFailureCallback_34(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnFailureResponse_34(error);
    }

    static void OnSuccessCallback_34(void * context) { (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnSuccessResponse_34(); }

    static void OnFailureCallback_35(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnFailureResponse_35(error);
    }

    static void OnSuccessCallback_35(void * context) { (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnSuccessResponse_35(); }

    static void OnFailureCallback_36(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnFailureResponse_36(error);
    }

    static void OnSuccessCallback_36(void * context) { (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnSuccessResponse_36(); }

    static void OnFailureCallback_37(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnFailureResponse_37(error);
    }

    static void OnSuccessCallback_37(void * context) { (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnSuccessResponse_37(); }

    static void OnFailureCallback_38(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnFailureResponse_38(error);
    }

    static void OnSuccessCallback_38(void * context) { (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnSuccessResponse_38(); }

    static void OnFailureCallback_39(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnFailureResponse_39(error);
    }

    static void OnSuccessCallback_39(void * context, uint8_t controlSequenceOfOperation)
    {
        (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnSuccessResponse_39(controlSequenceOfOperation);
    }

    static void OnFailureCallback_40(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnFailureResponse_40(error);
    }

    static void OnSuccessCallback_40(void * context) { (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnSuccessResponse_40(); }

    static void OnFailureCallback_41(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnFailureResponse_41(error);
    }

    static void OnSuccessCallback_41(void * context, uint8_t controlSequenceOfOperation)
    {
        (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnSuccessResponse_41(controlSequenceOfOperation);
    }

    static void OnFailureCallback_42(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnFailureResponse_42(error);
    }

    static void OnSuccessCallback_42(void * context) { (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnSuccessResponse_42(); }

    static void OnFailureCallback_43(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnFailureResponse_43(error);
    }

    static void OnSuccessCallback_43(void * context) { (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnSuccessResponse_43(); }

    static void OnFailureCallback_44(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnFailureResponse_44(error);
    }

    static void OnSuccessCallback_44(void * context) { (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnSuccessResponse_44(); }

    static void OnFailureCallback_45(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnFailureResponse_45(error);
    }

    static void OnSuccessCallback_45(void * context) { (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnSuccessResponse_45(); }

    static void OnFailureCallback_46(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnFailureResponse_46(error);
    }

    static void OnSuccessCallback_46(void * context) { (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnSuccessResponse_46(); }

    static void OnFailureCallback_47(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnFailureResponse_47(error);
    }

    static void OnSuccessCallback_47(void * context) { (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnSuccessResponse_47(); }

    static void OnFailureCallback_48(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnFailureResponse_48(error);
    }

    static void OnSuccessCallback_48(void * context) { (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnSuccessResponse_48(); }

    static void OnFailureCallback_49(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnFailureResponse_49(error);
    }

    static void OnSuccessCallback_49(void * context) { (static_cast<Test_TC_TSTAT_2_2Suite *>(context))->OnSuccessResponse_49(); }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestReadsOccupiedCoolingSetpointAttributeFromServerDutAndVerifiesThatTheValueIsWithinRange_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::OccupiedCoolingSetpoint::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1(int16_t occupiedCoolingSetpoint)
    {
        VerifyOrReturn(CheckValue("occupiedCoolingSetpoint", occupiedCoolingSetpoint, 2600));
        VerifyOrReturn(CheckConstraintType("occupiedCoolingSetpoint", "", "int16"));
        VerifyOrReturn(CheckConstraintMinValue<int16_t>("occupiedCoolingSetpoint", occupiedCoolingSetpoint, 1600));
        VerifyOrReturn(CheckConstraintMaxValue<int16_t>("occupiedCoolingSetpoint", occupiedCoolingSetpoint, 2600));
        NextTest();
    }

    CHIP_ERROR TestWritesAValueBackThatIsDifferentButValidForOccupiedCoolingSetpointAttribute_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t occupiedCoolingSetpointArgument;
        occupiedCoolingSetpointArgument = 2000;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::OccupiedCoolingSetpoint::TypeInfo>(
            occupiedCoolingSetpointArgument, this, OnSuccessCallback_2, OnFailureCallback_2));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestReadsItBackAgainToConfirmTheSuccessfulWriteOfOccupiedCoolingSetpointAttribute_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::OccupiedCoolingSetpoint::TypeInfo>(
            this, OnSuccessCallback_3, OnFailureCallback_3, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3(int16_t occupiedCoolingSetpoint)
    {
        VerifyOrReturn(CheckValue("occupiedCoolingSetpoint", occupiedCoolingSetpoint, 2000));

        NextTest();
    }

    CHIP_ERROR TestWritesTheLimitOfMinCoolSetpointLimitToOccupiedCoolingSetpointAttribute_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t occupiedCoolingSetpointArgument;
        occupiedCoolingSetpointArgument = 1600;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::OccupiedCoolingSetpoint::TypeInfo>(
            occupiedCoolingSetpointArgument, this, OnSuccessCallback_4, OnFailureCallback_4));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestWritesTheLimitOfMaxCoolSetpointLimitToOccupiedCoolingSetpointAttribute_5()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t occupiedCoolingSetpointArgument;
        occupiedCoolingSetpointArgument = 2600;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::OccupiedCoolingSetpoint::TypeInfo>(
            occupiedCoolingSetpointArgument, this, OnSuccessCallback_5, OnFailureCallback_5));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_5() { NextTest(); }

    CHIP_ERROR TestReadsOccupiedHeatingSetpointAttributeFromServerDutAndVerifiesThatTheValueIsWithinRange_6()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::OccupiedHeatingSetpoint::TypeInfo>(
            this, OnSuccessCallback_6, OnFailureCallback_6, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_6(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_6(int16_t occupiedHeatingSetpoint)
    {
        VerifyOrReturn(CheckValue("occupiedHeatingSetpoint", occupiedHeatingSetpoint, 2000));
        VerifyOrReturn(CheckConstraintType("occupiedHeatingSetpoint", "", "int16"));
        VerifyOrReturn(CheckConstraintMinValue<int16_t>("occupiedHeatingSetpoint", occupiedHeatingSetpoint, 700));
        VerifyOrReturn(CheckConstraintMaxValue<int16_t>("occupiedHeatingSetpoint", occupiedHeatingSetpoint, 3000));
        NextTest();
    }

    CHIP_ERROR TestWritesAValueBackThatIsDifferentButValidForOccupiedHeatingSetpointAttribute_7()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t occupiedHeatingSetpointArgument;
        occupiedHeatingSetpointArgument = 2100;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::OccupiedHeatingSetpoint::TypeInfo>(
            occupiedHeatingSetpointArgument, this, OnSuccessCallback_7, OnFailureCallback_7));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_7(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_7() { NextTest(); }

    CHIP_ERROR TestReadsItBackAgainToConfirmTheSuccessfulWriteOfOccupiedHeatingSetpointAttribute_8()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::OccupiedHeatingSetpoint::TypeInfo>(
            this, OnSuccessCallback_8, OnFailureCallback_8, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_8(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_8(int16_t occupiedHeatingSetpoint)
    {
        VerifyOrReturn(CheckValue("occupiedHeatingSetpoint", occupiedHeatingSetpoint, 2100));

        NextTest();
    }

    CHIP_ERROR TestWritesTheLimitOfMinHeatSetpointLimitToOccupiedHeatingSetpointAttribute_9()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t occupiedHeatingSetpointArgument;
        occupiedHeatingSetpointArgument = 700;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::OccupiedHeatingSetpoint::TypeInfo>(
            occupiedHeatingSetpointArgument, this, OnSuccessCallback_9, OnFailureCallback_9));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_9(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_9() { NextTest(); }

    CHIP_ERROR TestWritesTheLimitOfMaxHeatSetpointLimitToOccupiedHeatingSetpointAttribute_10()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t occupiedHeatingSetpointArgument;
        occupiedHeatingSetpointArgument = 3000;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::OccupiedHeatingSetpoint::TypeInfo>(
            occupiedHeatingSetpointArgument, this, OnSuccessCallback_10, OnFailureCallback_10));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_10(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_10() { NextTest(); }

    CHIP_ERROR TestReadsMinHeatSetpointLimitAttributeFromServerDutAndVerifiesThatTheValueIsWithinRange_11()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::MinHeatSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_11, OnFailureCallback_11, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_11(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_11(int16_t minHeatSetpointLimit)
    {
        VerifyOrReturn(CheckValue("minHeatSetpointLimit", minHeatSetpointLimit, 700));
        VerifyOrReturn(CheckConstraintType("minHeatSetpointLimit", "", "int16"));
        VerifyOrReturn(CheckConstraintMinValue<int16_t>("minHeatSetpointLimit", minHeatSetpointLimit, 700));
        VerifyOrReturn(CheckConstraintMaxValue<int16_t>("minHeatSetpointLimit", minHeatSetpointLimit, 3000));
        NextTest();
    }

    CHIP_ERROR TestWritesAValueBackThatIsDifferentButValidForMinHeatSetpointLimitAttribute_12()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t minHeatSetpointLimitArgument;
        minHeatSetpointLimitArgument = 2000;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::MinHeatSetpointLimit::TypeInfo>(
            minHeatSetpointLimitArgument, this, OnSuccessCallback_12, OnFailureCallback_12));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_12(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_12() { NextTest(); }

    CHIP_ERROR TestReadsItBackAgainToConfirmTheSuccessfulWriteOfMinHeatSetpointLimitAttribute_13()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::MinHeatSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_13, OnFailureCallback_13, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_13(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_13(int16_t minHeatSetpointLimit)
    {
        VerifyOrReturn(CheckValue("minHeatSetpointLimit", minHeatSetpointLimit, 2000));

        NextTest();
    }

    CHIP_ERROR TestWritesTheLimitOfAbsMinHeatSetpointLimitToMinHeatSetpointLimitAttribute_14()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t minHeatSetpointLimitArgument;
        minHeatSetpointLimitArgument = 700;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::MinHeatSetpointLimit::TypeInfo>(
            minHeatSetpointLimitArgument, this, OnSuccessCallback_14, OnFailureCallback_14));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_14(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_14() { NextTest(); }

    CHIP_ERROR TestWritesTheLimitOfAbsMaxHeatSetpointLimitToMinHeatSetpointLimitAttribute_15()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t minHeatSetpointLimitArgument;
        minHeatSetpointLimitArgument = 3000;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::MinHeatSetpointLimit::TypeInfo>(
            minHeatSetpointLimitArgument, this, OnSuccessCallback_15, OnFailureCallback_15));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_15(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_15() { NextTest(); }

    CHIP_ERROR TestReadsMaxHeatSetpointLimitAttributeFromServerDutAndVerifiesThatTheValueIsWithinRange_16()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::MaxHeatSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_16, OnFailureCallback_16, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_16(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_16(int16_t maxHeatSetpointLimit)
    {
        VerifyOrReturn(CheckValue("maxHeatSetpointLimit", maxHeatSetpointLimit, 3000));
        VerifyOrReturn(CheckConstraintType("maxHeatSetpointLimit", "", "int16"));
        VerifyOrReturn(CheckConstraintMinValue<int16_t>("maxHeatSetpointLimit", maxHeatSetpointLimit, 700));
        VerifyOrReturn(CheckConstraintMaxValue<int16_t>("maxHeatSetpointLimit", maxHeatSetpointLimit, 3000));
        NextTest();
    }

    CHIP_ERROR TestWritesAValueBackThatIsDifferentButValidForMaxHeatSetpointLimitAttribute_17()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t maxHeatSetpointLimitArgument;
        maxHeatSetpointLimitArgument = 2000;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::MaxHeatSetpointLimit::TypeInfo>(
            maxHeatSetpointLimitArgument, this, OnSuccessCallback_17, OnFailureCallback_17));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_17(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_17() { NextTest(); }

    CHIP_ERROR TestReadsItBackAgainToConfirmTheSuccessfulWriteOfMaxHeatSetpointLimitAttribute_18()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::MaxHeatSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_18, OnFailureCallback_18, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_18(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_18(int16_t maxHeatSetpointLimit)
    {
        VerifyOrReturn(CheckValue("maxHeatSetpointLimit", maxHeatSetpointLimit, 2000));

        NextTest();
    }

    CHIP_ERROR TestWritesTheLimitOfAbsMinHeatSetpointLimitToMaxHeatSetpointLimitAttribute_19()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t maxHeatSetpointLimitArgument;
        maxHeatSetpointLimitArgument = 700;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::MaxHeatSetpointLimit::TypeInfo>(
            maxHeatSetpointLimitArgument, this, OnSuccessCallback_19, OnFailureCallback_19));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_19(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_19() { NextTest(); }

    CHIP_ERROR TestWritesTheLimitOfAbsMaxHeatSetpointLimitToMaxHeatSetpointLimitAttribute_20()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t maxHeatSetpointLimitArgument;
        maxHeatSetpointLimitArgument = 3000;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::MaxHeatSetpointLimit::TypeInfo>(
            maxHeatSetpointLimitArgument, this, OnSuccessCallback_20, OnFailureCallback_20));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_20(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_20() { NextTest(); }

    CHIP_ERROR TestReadsMinCoolSetpointLimitAttributeFromServerDutAndVerifiesThatTheValueIsWithinRange_21()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::MinCoolSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_21, OnFailureCallback_21, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_21(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_21(int16_t minCoolSetpointLimit)
    {
        VerifyOrReturn(CheckValue("minCoolSetpointLimit", minCoolSetpointLimit, 1600));
        VerifyOrReturn(CheckConstraintType("minCoolSetpointLimit", "", "int16"));
        VerifyOrReturn(CheckConstraintMinValue<int16_t>("minCoolSetpointLimit", minCoolSetpointLimit, 1600));
        VerifyOrReturn(CheckConstraintMaxValue<int16_t>("minCoolSetpointLimit", minCoolSetpointLimit, 3200));
        NextTest();
    }

    CHIP_ERROR TestWritesAValueBackThatIsDifferentButValidForMinCoolSetpointLimitAttribute_22()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t minCoolSetpointLimitArgument;
        minCoolSetpointLimitArgument = 2000;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::MinCoolSetpointLimit::TypeInfo>(
            minCoolSetpointLimitArgument, this, OnSuccessCallback_22, OnFailureCallback_22));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_22(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_22() { NextTest(); }

    CHIP_ERROR TestReadsItBackAgainToConfirmTheSuccessfulWriteOfMinCoolSetpointLimitAttribute_23()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::MinCoolSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_23, OnFailureCallback_23, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_23(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_23(int16_t minCoolSetpointLimit)
    {
        VerifyOrReturn(CheckValue("minCoolSetpointLimit", minCoolSetpointLimit, 2000));

        NextTest();
    }

    CHIP_ERROR TestWritesTheLimitOfAbsMinCoolSetpointLimitToMinCoolSetpointLimitAttribute_24()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t minCoolSetpointLimitArgument;
        minCoolSetpointLimitArgument = 1600;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::MinCoolSetpointLimit::TypeInfo>(
            minCoolSetpointLimitArgument, this, OnSuccessCallback_24, OnFailureCallback_24));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_24(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_24() { NextTest(); }

    CHIP_ERROR TestWritesTheLimitOfMaxCoolSetpointLimitToMinCoolSetpointLimitAttribute_25()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t minCoolSetpointLimitArgument;
        minCoolSetpointLimitArgument = 3200;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::MinCoolSetpointLimit::TypeInfo>(
            minCoolSetpointLimitArgument, this, OnSuccessCallback_25, OnFailureCallback_25));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_25(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_25() { NextTest(); }

    CHIP_ERROR TestReadsMaxCoolSetpointLimitAttributeFromServerDutAndVerifiesThatTheValueIsWithinRange_26()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::MaxCoolSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_26, OnFailureCallback_26, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_26(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_26(int16_t maxCoolSetpointLimit)
    {
        VerifyOrReturn(CheckValue("maxCoolSetpointLimit", maxCoolSetpointLimit, 3200));
        VerifyOrReturn(CheckConstraintType("maxCoolSetpointLimit", "", "int16"));
        VerifyOrReturn(CheckConstraintMinValue<int16_t>("maxCoolSetpointLimit", maxCoolSetpointLimit, 1600));
        VerifyOrReturn(CheckConstraintMaxValue<int16_t>("maxCoolSetpointLimit", maxCoolSetpointLimit, 3200));
        NextTest();
    }

    CHIP_ERROR TestWritesAValueBackThatIsDifferentButValidForMaxCoolSetpointLimitAttribute_27()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t maxCoolSetpointLimitArgument;
        maxCoolSetpointLimitArgument = 2000;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::MaxCoolSetpointLimit::TypeInfo>(
            maxCoolSetpointLimitArgument, this, OnSuccessCallback_27, OnFailureCallback_27));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_27(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_27() { NextTest(); }

    CHIP_ERROR TestReadsItBackAgainToConfirmTheSuccessfulWriteOfMaxCoolSetpointLimitAttribute_28()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::MaxCoolSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_28, OnFailureCallback_28, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_28(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_28(int16_t maxCoolSetpointLimit)
    {
        VerifyOrReturn(CheckValue("maxCoolSetpointLimit", maxCoolSetpointLimit, 2000));

        NextTest();
    }

    CHIP_ERROR TestWritesTheLimitOfAbsMinCoolSetpointLimitToMaxCoolSetpointLimitAttribute_29()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t maxCoolSetpointLimitArgument;
        maxCoolSetpointLimitArgument = 1600;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::MaxCoolSetpointLimit::TypeInfo>(
            maxCoolSetpointLimitArgument, this, OnSuccessCallback_29, OnFailureCallback_29));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_29(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_29() { NextTest(); }

    CHIP_ERROR TestWritesTheLimitOfMaxCoolSetpointLimitToMaxCoolSetpointLimitAttribute_30()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t maxCoolSetpointLimitArgument;
        maxCoolSetpointLimitArgument = 3200;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::MaxCoolSetpointLimit::TypeInfo>(
            maxCoolSetpointLimitArgument, this, OnSuccessCallback_30, OnFailureCallback_30));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_30(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_30() { NextTest(); }

    CHIP_ERROR TestWritesSetsBackTheLimitOfMinHeatSetpointLimitToMinHeatSetpointLimitAttribute_31()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t minHeatSetpointLimitArgument;
        minHeatSetpointLimitArgument = 700;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::MinHeatSetpointLimit::TypeInfo>(
            minHeatSetpointLimitArgument, this, OnSuccessCallback_31, OnFailureCallback_31));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_31(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_31() { NextTest(); }

    CHIP_ERROR TestWritesSetsBackTheLimitOfMaxHeatSetpointLimitToMinHeatSetpointLimitAttribute_32()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t minHeatSetpointLimitArgument;
        minHeatSetpointLimitArgument = 3000;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::MinHeatSetpointLimit::TypeInfo>(
            minHeatSetpointLimitArgument, this, OnSuccessCallback_32, OnFailureCallback_32));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_32(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_32() { NextTest(); }

    CHIP_ERROR TestWritesSetsBackTheLimitOfMinHeatSetpointLimitToMaxHeatSetpointLimitAttribute_33()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t maxHeatSetpointLimitArgument;
        maxHeatSetpointLimitArgument = 700;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::MaxHeatSetpointLimit::TypeInfo>(
            maxHeatSetpointLimitArgument, this, OnSuccessCallback_33, OnFailureCallback_33));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_33(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_33() { NextTest(); }

    CHIP_ERROR TestWritesSetsBackTheLimitOfMaxHeatSetpointLimitToMaxHeatSetpointLimitAttribute_34()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t maxHeatSetpointLimitArgument;
        maxHeatSetpointLimitArgument = 3000;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::MaxHeatSetpointLimit::TypeInfo>(
            maxHeatSetpointLimitArgument, this, OnSuccessCallback_34, OnFailureCallback_34));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_34(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_34() { NextTest(); }

    CHIP_ERROR TestWritesSetsBackTheLimitOfMinCoolSetpointLimitToMinCoolSetpointLimitAttribute_35()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t minCoolSetpointLimitArgument;
        minCoolSetpointLimitArgument = 1600;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::MinCoolSetpointLimit::TypeInfo>(
            minCoolSetpointLimitArgument, this, OnSuccessCallback_35, OnFailureCallback_35));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_35(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_35() { NextTest(); }

    CHIP_ERROR TestWritesSetsBackTheLimitOfMaxCoolSetpointLimitToMinCoolSetpointLimitAttribute_36()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t minCoolSetpointLimitArgument;
        minCoolSetpointLimitArgument = 3200;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::MinCoolSetpointLimit::TypeInfo>(
            minCoolSetpointLimitArgument, this, OnSuccessCallback_36, OnFailureCallback_36));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_36(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_36() { NextTest(); }

    CHIP_ERROR TestWritesSetsBackTheLimitOfMinCoolSetpointLimitToMaxCoolSetpointLimitAttribute_37()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t maxCoolSetpointLimitArgument;
        maxCoolSetpointLimitArgument = 1600;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::MaxCoolSetpointLimit::TypeInfo>(
            maxCoolSetpointLimitArgument, this, OnSuccessCallback_37, OnFailureCallback_37));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_37(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_37() { NextTest(); }

    CHIP_ERROR TestWritesSetsBackTheLimitOfMaxCoolSetpointLimitToMaxCoolSetpointLimitAttribute_38()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t maxCoolSetpointLimitArgument;
        maxCoolSetpointLimitArgument = 3200;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::MaxCoolSetpointLimit::TypeInfo>(
            maxCoolSetpointLimitArgument, this, OnSuccessCallback_38, OnFailureCallback_38));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_38(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_38() { NextTest(); }

    CHIP_ERROR TestReadsControlSequenceOfOperationFromServerDutAndVerifiesThatTheValueIsValid_39()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::ControlSequenceOfOperation::TypeInfo>(
                this, OnSuccessCallback_39, OnFailureCallback_39, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_39(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_39(uint8_t controlSequenceOfOperation)
    {
        VerifyOrReturn(CheckValue("controlSequenceOfOperation", controlSequenceOfOperation, 4));
        VerifyOrReturn(CheckConstraintType("controlSequenceOfOperation", "", "enum8"));
        VerifyOrReturn(CheckConstraintMinValue<uint8_t>("controlSequenceOfOperation", controlSequenceOfOperation, 0));
        VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("controlSequenceOfOperation", controlSequenceOfOperation, 5));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeCommandForControlSequenceOfOperationWithANewValidValue_40()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t controlSequenceOfOperationArgument;
        controlSequenceOfOperationArgument = 2;

        ReturnErrorOnFailure(
            cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::ControlSequenceOfOperation::TypeInfo>(
                controlSequenceOfOperationArgument, this, OnSuccessCallback_40, OnFailureCallback_40));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_40(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_40() { NextTest(); }

    CHIP_ERROR TestReadItBackAgainToConfirmTheSuccessfulWrite_41()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::ControlSequenceOfOperation::TypeInfo>(
                this, OnSuccessCallback_41, OnFailureCallback_41, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_41(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_41(uint8_t controlSequenceOfOperation)
    {
        VerifyOrReturn(CheckValue("controlSequenceOfOperation", controlSequenceOfOperation, 2));

        NextTest();
    }

    CHIP_ERROR TestSetsOccupiedHeatingSetpointToDefaultValue_42()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t occupiedHeatingSetpointArgument;
        occupiedHeatingSetpointArgument = 2000;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::OccupiedHeatingSetpoint::TypeInfo>(
            occupiedHeatingSetpointArgument, this, OnSuccessCallback_42, OnFailureCallback_42));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_42(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_42() { NextTest(); }

    CHIP_ERROR TestSetsOccupiedHeatingSetpointToDefaultValue_43()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t occupiedHeatingSetpointArgument;
        occupiedHeatingSetpointArgument = 2000;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::OccupiedHeatingSetpoint::TypeInfo>(
            occupiedHeatingSetpointArgument, this, OnSuccessCallback_43, OnFailureCallback_43));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_43(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_43() { NextTest(); }

    CHIP_ERROR TestSetsOccupiedCoolingSetpointToDefaultValue_44()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t occupiedCoolingSetpointArgument;
        occupiedCoolingSetpointArgument = 2600;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::OccupiedCoolingSetpoint::TypeInfo>(
            occupiedCoolingSetpointArgument, this, OnSuccessCallback_44, OnFailureCallback_44));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_44(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_44() { NextTest(); }

    CHIP_ERROR TestSetsOccupiedCoolingSetpointToDefaultValue_45()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t occupiedCoolingSetpointArgument;
        occupiedCoolingSetpointArgument = 2600;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::OccupiedCoolingSetpoint::TypeInfo>(
            occupiedCoolingSetpointArgument, this, OnSuccessCallback_45, OnFailureCallback_45));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_45(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_45() { NextTest(); }

    CHIP_ERROR TestSetsOccupiedCoolingSetpointToDefaultValue_46()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t occupiedCoolingSetpointArgument;
        occupiedCoolingSetpointArgument = 2600;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::OccupiedCoolingSetpoint::TypeInfo>(
            occupiedCoolingSetpointArgument, this, OnSuccessCallback_46, OnFailureCallback_46));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_46(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_46() { NextTest(); }

    CHIP_ERROR TestSetsOccupiedHeatingSetpointToDefaultValue_47()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t occupiedHeatingSetpointArgument;
        occupiedHeatingSetpointArgument = 2000;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::OccupiedHeatingSetpoint::TypeInfo>(
            occupiedHeatingSetpointArgument, this, OnSuccessCallback_47, OnFailureCallback_47));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_47(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_47() { NextTest(); }

    CHIP_ERROR TestSetsOccupiedCoolingSetpointToDefaultValue_48()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t occupiedCoolingSetpointArgument;
        occupiedCoolingSetpointArgument = 2600;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::OccupiedCoolingSetpoint::TypeInfo>(
            occupiedCoolingSetpointArgument, this, OnSuccessCallback_48, OnFailureCallback_48));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_48(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_48() { NextTest(); }

    CHIP_ERROR TestSetsOccupiedHeatingSetpointToDefaultValue_49()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t occupiedHeatingSetpointArgument;
        occupiedHeatingSetpointArgument = 2000;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::OccupiedHeatingSetpoint::TypeInfo>(
            occupiedHeatingSetpointArgument, this, OnSuccessCallback_49, OnFailureCallback_49));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_49(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_49() { NextTest(); }
};

class Test_TC_TSUIC_1_1Suite : public TestCommand
{
public:
    Test_TC_TSUIC_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_TSUIC_1_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_TSUIC_1_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_TSUIC_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_TSUIC_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read the global attribute constraints: ClusterRevision\n");
            err = TestReadTheGlobalAttributeConstraintsClusterRevision_1();
            break;
        case 2:
            ChipLogProgress(chipTool,
                            " ***** Test Step 2 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read the global attribute: AttributeList\n");
            err = TestReadTheGlobalAttributeAttributeList_3();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 4;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_1(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSUIC_1_1Suite *>(context))->OnFailureResponse_1(error);
    }

    static void OnSuccessCallback_1(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_TSUIC_1_1Suite *>(context))->OnSuccessResponse_1(clusterRevision);
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSUIC_1_1Suite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context) { (static_cast<Test_TC_TSUIC_1_1Suite *>(context))->OnSuccessResponse_2(); }

    static void OnFailureCallback_3(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSUIC_1_1Suite *>(context))->OnFailureResponse_3(error);
    }

    static void OnSuccessCallback_3(void * context, const chip::app::DataModel::DecodableList<chip::AttributeId> & attributeList)
    {
        (static_cast<Test_TC_TSUIC_1_1Suite *>(context))->OnSuccessResponse_3(attributeList);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestReadTheGlobalAttributeConstraintsClusterRevision_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::ClusterRevision::TypeInfo>(
                this, OnSuccessCallback_1, OnFailureCallback_1, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckConstraintType("clusterRevision", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t clusterRevisionArgument;
        clusterRevisionArgument = 2U;

        ReturnErrorOnFailure(
            cluster
                .WriteAttribute<chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::ClusterRevision::TypeInfo>(
                    clusterRevisionArgument, this, OnSuccessCallback_2, OnFailureCallback_2));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_2() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadTheGlobalAttributeAttributeList_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::AttributeList::TypeInfo>(
                this, OnSuccessCallback_3, OnFailureCallback_3, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3(const chip::app::DataModel::DecodableList<chip::AttributeId> & attributeList)
    {
        VerifyOrReturn(CheckConstraintType("attributeList", "", "list"));
        NextTest();
    }
};

class Test_TC_TSUIC_2_1Suite : public TestCommand
{
public:
    Test_TC_TSUIC_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_TSUIC_2_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_TSUIC_2_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_TSUIC_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_TSUIC_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : read the mandatory attribute: TemperatureDisplayMode\n");
            err = TestReadTheMandatoryAttributeTemperatureDisplayMode_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : read the mandatory attribute: TemperatureDisplayMode\n");
            err = TestReadTheMandatoryAttributeTemperatureDisplayMode_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : write to the mandatory attribute: TemperatureDisplayMode\n");
            err = TestWriteToTheMandatoryAttributeTemperatureDisplayMode_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : read the mandatory attribute: TemperatureDisplayMode\n");
            err = TestReadTheMandatoryAttributeTemperatureDisplayMode_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : read the mandatory attribute: TemperatureDisplayMode\n");
            err = TestReadTheMandatoryAttributeTemperatureDisplayMode_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : read the mandatory attribute: KeypadLockout\n");
            err = TestReadTheMandatoryAttributeKeypadLockout_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : read the mandatory attribute: KeypadLockout\n");
            err = TestReadTheMandatoryAttributeKeypadLockout_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : write to the mandatory attribute: KeypadLockout\n");
            err = TestWriteToTheMandatoryAttributeKeypadLockout_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : read the mandatory attribute: KeypadLockout\n");
            err = TestReadTheMandatoryAttributeKeypadLockout_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : read the mandatory attribute: KeypadLockout\n");
            err = TestReadTheMandatoryAttributeKeypadLockout_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : read the optional attribute: ScheduleProgrammingVisibility\n");
            err = TestReadTheOptionalAttributeScheduleProgrammingVisibility_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : read the optional attribute: ScheduleProgrammingVisibility\n");
            err = TestReadTheOptionalAttributeScheduleProgrammingVisibility_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : write to the mandatory attribute: ScheduleProgrammingVisibility\n");
            err = TestWriteToTheMandatoryAttributeScheduleProgrammingVisibility_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : read the optional attribute: ScheduleProgrammingVisibility\n");
            err = TestReadTheOptionalAttributeScheduleProgrammingVisibility_14();
            break;
        case 15:
            ChipLogProgress(chipTool, " ***** Test Step 15 : read the optional attribute: ScheduleProgrammingVisibility\n");
            err = TestReadTheOptionalAttributeScheduleProgrammingVisibility_15();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 16;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_1(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSUIC_2_1Suite *>(context))->OnFailureResponse_1(error);
    }

    static void OnSuccessCallback_1(void * context, uint8_t temperatureDisplayMode)
    {
        (static_cast<Test_TC_TSUIC_2_1Suite *>(context))->OnSuccessResponse_1(temperatureDisplayMode);
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSUIC_2_1Suite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context, uint8_t temperatureDisplayMode)
    {
        (static_cast<Test_TC_TSUIC_2_1Suite *>(context))->OnSuccessResponse_2(temperatureDisplayMode);
    }

    static void OnFailureCallback_3(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSUIC_2_1Suite *>(context))->OnFailureResponse_3(error);
    }

    static void OnSuccessCallback_3(void * context) { (static_cast<Test_TC_TSUIC_2_1Suite *>(context))->OnSuccessResponse_3(); }

    static void OnFailureCallback_4(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSUIC_2_1Suite *>(context))->OnFailureResponse_4(error);
    }

    static void OnSuccessCallback_4(void * context, uint8_t temperatureDisplayMode)
    {
        (static_cast<Test_TC_TSUIC_2_1Suite *>(context))->OnSuccessResponse_4(temperatureDisplayMode);
    }

    static void OnFailureCallback_5(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSUIC_2_1Suite *>(context))->OnFailureResponse_5(error);
    }

    static void OnSuccessCallback_5(void * context, uint8_t temperatureDisplayMode)
    {
        (static_cast<Test_TC_TSUIC_2_1Suite *>(context))->OnSuccessResponse_5(temperatureDisplayMode);
    }

    static void OnFailureCallback_6(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSUIC_2_1Suite *>(context))->OnFailureResponse_6(error);
    }

    static void OnSuccessCallback_6(void * context, uint8_t keypadLockout)
    {
        (static_cast<Test_TC_TSUIC_2_1Suite *>(context))->OnSuccessResponse_6(keypadLockout);
    }

    static void OnFailureCallback_7(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSUIC_2_1Suite *>(context))->OnFailureResponse_7(error);
    }

    static void OnSuccessCallback_7(void * context, uint8_t keypadLockout)
    {
        (static_cast<Test_TC_TSUIC_2_1Suite *>(context))->OnSuccessResponse_7(keypadLockout);
    }

    static void OnFailureCallback_8(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSUIC_2_1Suite *>(context))->OnFailureResponse_8(error);
    }

    static void OnSuccessCallback_8(void * context) { (static_cast<Test_TC_TSUIC_2_1Suite *>(context))->OnSuccessResponse_8(); }

    static void OnFailureCallback_9(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSUIC_2_1Suite *>(context))->OnFailureResponse_9(error);
    }

    static void OnSuccessCallback_9(void * context, uint8_t keypadLockout)
    {
        (static_cast<Test_TC_TSUIC_2_1Suite *>(context))->OnSuccessResponse_9(keypadLockout);
    }

    static void OnFailureCallback_10(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSUIC_2_1Suite *>(context))->OnFailureResponse_10(error);
    }

    static void OnSuccessCallback_10(void * context, uint8_t keypadLockout)
    {
        (static_cast<Test_TC_TSUIC_2_1Suite *>(context))->OnSuccessResponse_10(keypadLockout);
    }

    static void OnFailureCallback_11(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSUIC_2_1Suite *>(context))->OnFailureResponse_11(error);
    }

    static void OnSuccessCallback_11(void * context, uint8_t scheduleProgrammingVisibility)
    {
        (static_cast<Test_TC_TSUIC_2_1Suite *>(context))->OnSuccessResponse_11(scheduleProgrammingVisibility);
    }

    static void OnFailureCallback_12(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSUIC_2_1Suite *>(context))->OnFailureResponse_12(error);
    }

    static void OnSuccessCallback_12(void * context, uint8_t scheduleProgrammingVisibility)
    {
        (static_cast<Test_TC_TSUIC_2_1Suite *>(context))->OnSuccessResponse_12(scheduleProgrammingVisibility);
    }

    static void OnFailureCallback_13(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSUIC_2_1Suite *>(context))->OnFailureResponse_13(error);
    }

    static void OnSuccessCallback_13(void * context) { (static_cast<Test_TC_TSUIC_2_1Suite *>(context))->OnSuccessResponse_13(); }

    static void OnFailureCallback_14(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSUIC_2_1Suite *>(context))->OnFailureResponse_14(error);
    }

    static void OnSuccessCallback_14(void * context, uint8_t scheduleProgrammingVisibility)
    {
        (static_cast<Test_TC_TSUIC_2_1Suite *>(context))->OnSuccessResponse_14(scheduleProgrammingVisibility);
    }

    static void OnFailureCallback_15(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSUIC_2_1Suite *>(context))->OnFailureResponse_15(error);
    }

    static void OnSuccessCallback_15(void * context, uint8_t scheduleProgrammingVisibility)
    {
        (static_cast<Test_TC_TSUIC_2_1Suite *>(context))->OnSuccessResponse_15(scheduleProgrammingVisibility);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestReadTheMandatoryAttributeTemperatureDisplayMode_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<
                chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::TemperatureDisplayMode::TypeInfo>(
                this, OnSuccessCallback_1, OnFailureCallback_1, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1(uint8_t temperatureDisplayMode)
    {
        VerifyOrReturn(CheckValue("temperatureDisplayMode", temperatureDisplayMode, 0));

        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeTemperatureDisplayMode_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<
                chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::TemperatureDisplayMode::TypeInfo>(
                this, OnSuccessCallback_2, OnFailureCallback_2, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2(uint8_t temperatureDisplayMode)
    {
        VerifyOrReturn(CheckConstraintType("temperatureDisplayMode", "", "enum8"));
        NextTest();
    }

    CHIP_ERROR TestWriteToTheMandatoryAttributeTemperatureDisplayMode_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t temperatureDisplayModeArgument;
        temperatureDisplayModeArgument = 0;

        ReturnErrorOnFailure(
            cluster.WriteAttribute<
                chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::TemperatureDisplayMode::TypeInfo>(
                temperatureDisplayModeArgument, this, OnSuccessCallback_3, OnFailureCallback_3));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestReadTheMandatoryAttributeTemperatureDisplayMode_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<
                chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::TemperatureDisplayMode::TypeInfo>(
                this, OnSuccessCallback_4, OnFailureCallback_4, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_4(uint8_t temperatureDisplayMode)
    {
        VerifyOrReturn(CheckValue("temperatureDisplayMode", temperatureDisplayMode, 0));

        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeTemperatureDisplayMode_5()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<
                chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::TemperatureDisplayMode::TypeInfo>(
                this, OnSuccessCallback_5, OnFailureCallback_5, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_5(uint8_t temperatureDisplayMode)
    {
        VerifyOrReturn(CheckConstraintType("temperatureDisplayMode", "", "enum8"));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeKeypadLockout_6()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::KeypadLockout::TypeInfo>(
                this, OnSuccessCallback_6, OnFailureCallback_6, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_6(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_6(uint8_t keypadLockout)
    {
        VerifyOrReturn(CheckValue("keypadLockout", keypadLockout, 0));

        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeKeypadLockout_7()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::KeypadLockout::TypeInfo>(
                this, OnSuccessCallback_7, OnFailureCallback_7, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_7(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_7(uint8_t keypadLockout)
    {
        VerifyOrReturn(CheckConstraintType("keypadLockout", "", "enum8"));
        NextTest();
    }

    CHIP_ERROR TestWriteToTheMandatoryAttributeKeypadLockout_8()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t keypadLockoutArgument;
        keypadLockoutArgument = 0;

        ReturnErrorOnFailure(
            cluster.WriteAttribute<chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::KeypadLockout::TypeInfo>(
                keypadLockoutArgument, this, OnSuccessCallback_8, OnFailureCallback_8));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_8(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_8() { NextTest(); }

    CHIP_ERROR TestReadTheMandatoryAttributeKeypadLockout_9()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::KeypadLockout::TypeInfo>(
                this, OnSuccessCallback_9, OnFailureCallback_9, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_9(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_9(uint8_t keypadLockout)
    {
        VerifyOrReturn(CheckValue("keypadLockout", keypadLockout, 0));

        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeKeypadLockout_10()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::KeypadLockout::TypeInfo>(
                this, OnSuccessCallback_10, OnFailureCallback_10, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_10(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_10(uint8_t keypadLockout)
    {
        VerifyOrReturn(CheckConstraintType("keypadLockout", "", "enum8"));
        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeScheduleProgrammingVisibility_11()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<
                chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::ScheduleProgrammingVisibility::TypeInfo>(
                this, OnSuccessCallback_11, OnFailureCallback_11, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_11(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_11(uint8_t scheduleProgrammingVisibility)
    {
        VerifyOrReturn(CheckValue("scheduleProgrammingVisibility", scheduleProgrammingVisibility, 0));

        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeScheduleProgrammingVisibility_12()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<
                chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::ScheduleProgrammingVisibility::TypeInfo>(
                this, OnSuccessCallback_12, OnFailureCallback_12, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_12(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_12(uint8_t scheduleProgrammingVisibility)
    {
        VerifyOrReturn(CheckConstraintType("scheduleProgrammingVisibility", "", "enum8"));
        NextTest();
    }

    CHIP_ERROR TestWriteToTheMandatoryAttributeScheduleProgrammingVisibility_13()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t scheduleProgrammingVisibilityArgument;
        scheduleProgrammingVisibilityArgument = 0;

        ReturnErrorOnFailure(
            cluster.WriteAttribute<
                chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::ScheduleProgrammingVisibility::TypeInfo>(
                scheduleProgrammingVisibilityArgument, this, OnSuccessCallback_13, OnFailureCallback_13));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_13(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_13() { NextTest(); }

    CHIP_ERROR TestReadTheOptionalAttributeScheduleProgrammingVisibility_14()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<
                chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::ScheduleProgrammingVisibility::TypeInfo>(
                this, OnSuccessCallback_14, OnFailureCallback_14, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_14(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_14(uint8_t scheduleProgrammingVisibility)
    {
        VerifyOrReturn(CheckValue("scheduleProgrammingVisibility", scheduleProgrammingVisibility, 0));

        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeScheduleProgrammingVisibility_15()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<
                chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::ScheduleProgrammingVisibility::TypeInfo>(
                this, OnSuccessCallback_15, OnFailureCallback_15, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_15(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_15(uint8_t scheduleProgrammingVisibility)
    {
        VerifyOrReturn(CheckConstraintType("scheduleProgrammingVisibility", "", "enum8"));
        NextTest();
    }
};

class Test_TC_TSUIC_2_2Suite : public TestCommand
{
public:
    Test_TC_TSUIC_2_2Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_TSUIC_2_2", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_TSUIC_2_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_TSUIC_2_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_TSUIC_2_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Writes a value of 0 to TemperatureDisplayMode attribute of DUT\n");
            if (ShouldSkip("A_TEMPERATURE_DISPLAY_MODE"))
            {
                NextTest();
                return;
            }
            err = TestWritesAValueOf0ToTemperatureDisplayModeAttributeOfDut_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Writes a value of 1 to TemperatureDisplayMode attribute of DUT\n");
            if (ShouldSkip("A_TEMPERATURE_DISPLAY_MODE"))
            {
                NextTest();
                return;
            }
            err = TestWritesAValueOf1ToTemperatureDisplayModeAttributeOfDut_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Writes a value of 0 to KeypadLockout attribute of DUT\n");
            if (ShouldSkip("A_KEYPAD_LOCKOUT"))
            {
                NextTest();
                return;
            }
            err = TestWritesAValueOf0ToKeypadLockoutAttributeOfDut_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Writes a value of 1 to KeypadLockout attribute of DUT\n");
            if (ShouldSkip("A_KEYPAD_LOCKOUT"))
            {
                NextTest();
                return;
            }
            err = TestWritesAValueOf1ToKeypadLockoutAttributeOfDut_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Writes a value of 2 to KeypadLockout attribute of DUT\n");
            if (ShouldSkip("A_KEYPAD_LOCKOUT"))
            {
                NextTest();
                return;
            }
            err = TestWritesAValueOf2ToKeypadLockoutAttributeOfDut_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Writes a value of 3 to KeypadLockout attribute of DUT\n");
            if (ShouldSkip("A_KEYPAD_LOCKOUT"))
            {
                NextTest();
                return;
            }
            err = TestWritesAValueOf3ToKeypadLockoutAttributeOfDut_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Writes a value of 4 to KeypadLockout attribute of DUT\n");
            if (ShouldSkip("A_KEYPAD_LOCKOUT"))
            {
                NextTest();
                return;
            }
            err = TestWritesAValueOf4ToKeypadLockoutAttributeOfDut_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Writes a value of 5 to KeypadLockout attribute of DUT\n");
            if (ShouldSkip("A_KEYPAD_LOCKOUT"))
            {
                NextTest();
                return;
            }
            err = TestWritesAValueOf5ToKeypadLockoutAttributeOfDut_8();
            break;
        case 9:
            ChipLogProgress(chipTool,
                            " ***** Test Step 9 : Writes a value of 0 to ScheduleProgrammingVisibility attribute of DUT\n");
            if (ShouldSkip("A_SCHEDULE_PROGRAMMING_VISIBILITY"))
            {
                NextTest();
                return;
            }
            err = TestWritesAValueOf0ToScheduleProgrammingVisibilityAttributeOfDut_9();
            break;
        case 10:
            ChipLogProgress(chipTool,
                            " ***** Test Step 10 : Writes a value of 1 to ScheduleProgrammingVisibility attribute of DUT\n");
            if (ShouldSkip("A_SCHEDULE_PROGRAMMING_VISIBILITY"))
            {
                NextTest();
                return;
            }
            err = TestWritesAValueOf1ToScheduleProgrammingVisibilityAttributeOfDut_10();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 11;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_1(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSUIC_2_2Suite *>(context))->OnFailureResponse_1(error);
    }

    static void OnSuccessCallback_1(void * context) { (static_cast<Test_TC_TSUIC_2_2Suite *>(context))->OnSuccessResponse_1(); }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSUIC_2_2Suite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context) { (static_cast<Test_TC_TSUIC_2_2Suite *>(context))->OnSuccessResponse_2(); }

    static void OnFailureCallback_3(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSUIC_2_2Suite *>(context))->OnFailureResponse_3(error);
    }

    static void OnSuccessCallback_3(void * context) { (static_cast<Test_TC_TSUIC_2_2Suite *>(context))->OnSuccessResponse_3(); }

    static void OnFailureCallback_4(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSUIC_2_2Suite *>(context))->OnFailureResponse_4(error);
    }

    static void OnSuccessCallback_4(void * context) { (static_cast<Test_TC_TSUIC_2_2Suite *>(context))->OnSuccessResponse_4(); }

    static void OnFailureCallback_5(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSUIC_2_2Suite *>(context))->OnFailureResponse_5(error);
    }

    static void OnSuccessCallback_5(void * context) { (static_cast<Test_TC_TSUIC_2_2Suite *>(context))->OnSuccessResponse_5(); }

    static void OnFailureCallback_6(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSUIC_2_2Suite *>(context))->OnFailureResponse_6(error);
    }

    static void OnSuccessCallback_6(void * context) { (static_cast<Test_TC_TSUIC_2_2Suite *>(context))->OnSuccessResponse_6(); }

    static void OnFailureCallback_7(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSUIC_2_2Suite *>(context))->OnFailureResponse_7(error);
    }

    static void OnSuccessCallback_7(void * context) { (static_cast<Test_TC_TSUIC_2_2Suite *>(context))->OnSuccessResponse_7(); }

    static void OnFailureCallback_8(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSUIC_2_2Suite *>(context))->OnFailureResponse_8(error);
    }

    static void OnSuccessCallback_8(void * context) { (static_cast<Test_TC_TSUIC_2_2Suite *>(context))->OnSuccessResponse_8(); }

    static void OnFailureCallback_9(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSUIC_2_2Suite *>(context))->OnFailureResponse_9(error);
    }

    static void OnSuccessCallback_9(void * context) { (static_cast<Test_TC_TSUIC_2_2Suite *>(context))->OnSuccessResponse_9(); }

    static void OnFailureCallback_10(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_TSUIC_2_2Suite *>(context))->OnFailureResponse_10(error);
    }

    static void OnSuccessCallback_10(void * context) { (static_cast<Test_TC_TSUIC_2_2Suite *>(context))->OnSuccessResponse_10(); }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestWritesAValueOf0ToTemperatureDisplayModeAttributeOfDut_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t temperatureDisplayModeArgument;
        temperatureDisplayModeArgument = 0;

        ReturnErrorOnFailure(
            cluster.WriteAttribute<
                chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::TemperatureDisplayMode::TypeInfo>(
                temperatureDisplayModeArgument, this, OnSuccessCallback_1, OnFailureCallback_1));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestWritesAValueOf1ToTemperatureDisplayModeAttributeOfDut_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t temperatureDisplayModeArgument;
        temperatureDisplayModeArgument = 1;

        ReturnErrorOnFailure(
            cluster.WriteAttribute<
                chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::TemperatureDisplayMode::TypeInfo>(
                temperatureDisplayModeArgument, this, OnSuccessCallback_2, OnFailureCallback_2));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestWritesAValueOf0ToKeypadLockoutAttributeOfDut_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t keypadLockoutArgument;
        keypadLockoutArgument = 0;

        ReturnErrorOnFailure(
            cluster.WriteAttribute<chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::KeypadLockout::TypeInfo>(
                keypadLockoutArgument, this, OnSuccessCallback_3, OnFailureCallback_3));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestWritesAValueOf1ToKeypadLockoutAttributeOfDut_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t keypadLockoutArgument;
        keypadLockoutArgument = 1;

        ReturnErrorOnFailure(
            cluster.WriteAttribute<chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::KeypadLockout::TypeInfo>(
                keypadLockoutArgument, this, OnSuccessCallback_4, OnFailureCallback_4));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestWritesAValueOf2ToKeypadLockoutAttributeOfDut_5()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t keypadLockoutArgument;
        keypadLockoutArgument = 2;

        ReturnErrorOnFailure(
            cluster.WriteAttribute<chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::KeypadLockout::TypeInfo>(
                keypadLockoutArgument, this, OnSuccessCallback_5, OnFailureCallback_5));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_5() { NextTest(); }

    CHIP_ERROR TestWritesAValueOf3ToKeypadLockoutAttributeOfDut_6()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t keypadLockoutArgument;
        keypadLockoutArgument = 3;

        ReturnErrorOnFailure(
            cluster.WriteAttribute<chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::KeypadLockout::TypeInfo>(
                keypadLockoutArgument, this, OnSuccessCallback_6, OnFailureCallback_6));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_6(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_6() { NextTest(); }

    CHIP_ERROR TestWritesAValueOf4ToKeypadLockoutAttributeOfDut_7()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t keypadLockoutArgument;
        keypadLockoutArgument = 4;

        ReturnErrorOnFailure(
            cluster.WriteAttribute<chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::KeypadLockout::TypeInfo>(
                keypadLockoutArgument, this, OnSuccessCallback_7, OnFailureCallback_7));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_7(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_7() { NextTest(); }

    CHIP_ERROR TestWritesAValueOf5ToKeypadLockoutAttributeOfDut_8()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t keypadLockoutArgument;
        keypadLockoutArgument = 5;

        ReturnErrorOnFailure(
            cluster.WriteAttribute<chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::KeypadLockout::TypeInfo>(
                keypadLockoutArgument, this, OnSuccessCallback_8, OnFailureCallback_8));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_8(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_8() { NextTest(); }

    CHIP_ERROR TestWritesAValueOf0ToScheduleProgrammingVisibilityAttributeOfDut_9()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t scheduleProgrammingVisibilityArgument;
        scheduleProgrammingVisibilityArgument = 0;

        ReturnErrorOnFailure(
            cluster.WriteAttribute<
                chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::ScheduleProgrammingVisibility::TypeInfo>(
                scheduleProgrammingVisibilityArgument, this, OnSuccessCallback_9, OnFailureCallback_9));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_9(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_9() { NextTest(); }

    CHIP_ERROR TestWritesAValueOf1ToScheduleProgrammingVisibilityAttributeOfDut_10()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t scheduleProgrammingVisibilityArgument;
        scheduleProgrammingVisibilityArgument = 1;

        ReturnErrorOnFailure(
            cluster.WriteAttribute<
                chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::ScheduleProgrammingVisibility::TypeInfo>(
                scheduleProgrammingVisibilityArgument, this, OnSuccessCallback_10, OnFailureCallback_10));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_10(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_10() { NextTest(); }
};

class Test_TC_DIAG_TH_NW_1_1Suite : public TestCommand
{
public:
    Test_TC_DIAG_TH_NW_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_DIAG_TH_NW_1_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_DIAG_TH_NW_1_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_DIAG_TH_NW_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_DIAG_TH_NW_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Sends ResetCounts command\n");
            err = TestSendsResetCountsCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read the Overruncount attribute\n");
            err = TestReadTheOverruncountAttribute_2();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 3;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_DIAG_TH_NW_1_1Suite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context, uint64_t overrunCount)
    {
        (static_cast<Test_TC_DIAG_TH_NW_1_1Suite *>(context))->OnSuccessResponse_2(overrunCount);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestSendsResetCountsCommand_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        using RequestType               = chip::app::Clusters::ThreadNetworkDiagnostics::Commands::ResetCounts::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_DIAG_TH_NW_1_1Suite *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_DIAG_TH_NW_1_1Suite *>(context))->OnFailureResponse_1(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestReadTheOverruncountAttribute_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        chip::Controller::ThreadNetworkDiagnosticsClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::ThreadNetworkDiagnostics::Attributes::OverrunCount::TypeInfo>(
                this, OnSuccessCallback_2, OnFailureCallback_2, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2(uint64_t overrunCount)
    {
        VerifyOrReturn(CheckValue("overrunCount", overrunCount, 0ULL));

        NextTest();
    }
};

class Test_TC_WIFIDIAG_1_1Suite : public TestCommand
{
public:
    Test_TC_WIFIDIAG_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_WIFIDIAG_1_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_WIFIDIAG_1_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_WIFIDIAG_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_WIFIDIAG_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Reads NetworkInterface structure attribute from DUT\n");
            err = TestReadsNetworkInterfaceStructureAttributeFromDut_1();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 2;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_1(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WIFIDIAG_1_1Suite *>(context))->OnFailureResponse_1(error);
    }

    static void OnSuccessCallback_1(
        void * context,
        const chip::app::DataModel::DecodableList<
            chip::app::Clusters::GeneralDiagnostics::Structs::NetworkInterfaceType::DecodableType> & networkInterfaces)
    {
        (static_cast<Test_TC_WIFIDIAG_1_1Suite *>(context))->OnSuccessResponse_1(networkInterfaces);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestReadsNetworkInterfaceStructureAttributeFromDut_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        chip::Controller::GeneralDiagnosticsClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::GeneralDiagnostics::Attributes::NetworkInterfaces::TypeInfo>(
                this, OnSuccessCallback_1, OnFailureCallback_1, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void
    OnSuccessResponse_1(const chip::app::DataModel::DecodableList<
                        chip::app::Clusters::GeneralDiagnostics::Structs::NetworkInterfaceType::DecodableType> & networkInterfaces)
    {
        VerifyOrReturn(CheckConstraintType("networkInterfaces", "", "list"));
        NextTest();
    }
};

class Test_TC_WIFIDIAG_3_1Suite : public TestCommand
{
public:
    Test_TC_WIFIDIAG_3_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_WIFIDIAG_3_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_WIFIDIAG_3_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_WIFIDIAG_3_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_WIFIDIAG_3_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }
};

class Test_TC_WNCV_1_1Suite : public TestCommand
{
public:
    Test_TC_WNCV_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_WNCV_1_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_WNCV_1_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_WNCV_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_WNCV_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : 2: read the global attribute: ClusterRevision\n");
            err = Test2ReadTheGlobalAttributeClusterRevision_1();
            break;
        case 2:
            ChipLogProgress(chipTool,
                            " ***** Test Step 2 : 3a: write a value into the RO mandatory global attribute: ClusterRevision\n");
            err = Test3aWriteAValueIntoTheRoMandatoryGlobalAttributeClusterRevision_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : 3b: reads back global attribute: ClusterRevision\n");
            err = Test3bReadsBackGlobalAttributeClusterRevision_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Read the global attribute: AttributeList\n");
            err = TestReadTheGlobalAttributeAttributeList_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : 2: read the global attribute: FeatureMap\n");
            err = Test2ReadTheGlobalAttributeFeatureMap_5();
            break;
        case 6:
            ChipLogProgress(chipTool,
                            " ***** Test Step 6 : 3a: write the default value to optional global attribute: FeatureMap\n");
            err = Test3aWriteTheDefaultValueToOptionalGlobalAttributeFeatureMap_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : 3b: reads back global attribute: FeatureMap\n");
            err = Test3bReadsBackGlobalAttributeFeatureMap_7();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 8;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_1(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_1_1Suite *>(context))->OnFailureResponse_1(error);
    }

    static void OnSuccessCallback_1(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_WNCV_1_1Suite *>(context))->OnSuccessResponse_1(clusterRevision);
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_1_1Suite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context) { (static_cast<Test_TC_WNCV_1_1Suite *>(context))->OnSuccessResponse_2(); }

    static void OnFailureCallback_3(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_1_1Suite *>(context))->OnFailureResponse_3(error);
    }

    static void OnSuccessCallback_3(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_WNCV_1_1Suite *>(context))->OnSuccessResponse_3(clusterRevision);
    }

    static void OnFailureCallback_4(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_1_1Suite *>(context))->OnFailureResponse_4(error);
    }

    static void OnSuccessCallback_4(void * context, const chip::app::DataModel::DecodableList<chip::AttributeId> & attributeList)
    {
        (static_cast<Test_TC_WNCV_1_1Suite *>(context))->OnSuccessResponse_4(attributeList);
    }

    static void OnFailureCallback_5(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_1_1Suite *>(context))->OnFailureResponse_5(error);
    }

    static void OnSuccessCallback_5(void * context, uint32_t featureMap)
    {
        (static_cast<Test_TC_WNCV_1_1Suite *>(context))->OnSuccessResponse_5(featureMap);
    }

    static void OnFailureCallback_6(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_1_1Suite *>(context))->OnFailureResponse_6(error);
    }

    static void OnSuccessCallback_6(void * context) { (static_cast<Test_TC_WNCV_1_1Suite *>(context))->OnSuccessResponse_6(); }

    static void OnFailureCallback_7(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_1_1Suite *>(context))->OnFailureResponse_7(error);
    }

    static void OnSuccessCallback_7(void * context, uint32_t featureMap)
    {
        (static_cast<Test_TC_WNCV_1_1Suite *>(context))->OnSuccessResponse_7(featureMap);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR Test2ReadTheGlobalAttributeClusterRevision_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::ClusterRevision::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckConstraintType("clusterRevision", "", "uint16"));
        VerifyOrReturn(CheckConstraintMinValue<uint16_t>("clusterRevision", clusterRevision, 5U));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("clusterRevision", clusterRevision, 200U));
        NextTest();
    }

    CHIP_ERROR Test3aWriteAValueIntoTheRoMandatoryGlobalAttributeClusterRevision_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t clusterRevisionArgument;
        clusterRevisionArgument = 201U;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::WindowCovering::Attributes::ClusterRevision::TypeInfo>(
            clusterRevisionArgument, this, OnSuccessCallback_2, OnFailureCallback_2));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_2() { ThrowSuccessResponse(); }

    CHIP_ERROR Test3bReadsBackGlobalAttributeClusterRevision_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::ClusterRevision::TypeInfo>(
            this, OnSuccessCallback_3, OnFailureCallback_3, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckConstraintType("clusterRevision", "", "uint16"));
        VerifyOrReturn(CheckConstraintNotValue("clusterRevision", clusterRevision, 201U));

        NextTest();
    }

    CHIP_ERROR TestReadTheGlobalAttributeAttributeList_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::AttributeList::TypeInfo>(
            this, OnSuccessCallback_4, OnFailureCallback_4, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_4(const chip::app::DataModel::DecodableList<chip::AttributeId> & attributeList)
    {
        VerifyOrReturn(CheckConstraintType("attributeList", "", "list"));
        NextTest();
    }

    CHIP_ERROR Test2ReadTheGlobalAttributeFeatureMap_5()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::FeatureMap::TypeInfo>(
            this, OnSuccessCallback_5, OnFailureCallback_5, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_5(uint32_t featureMap)
    {
        VerifyOrReturn(CheckConstraintType("featureMap", "", "uint32"));
        VerifyOrReturn(CheckConstraintMinValue<uint32_t>("featureMap", featureMap, 0UL));
        VerifyOrReturn(CheckConstraintMaxValue<uint32_t>("featureMap", featureMap, 32768UL));
        NextTest();
    }

    CHIP_ERROR Test3aWriteTheDefaultValueToOptionalGlobalAttributeFeatureMap_6()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint32_t featureMapArgument;
        featureMapArgument = 32769UL;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::WindowCovering::Attributes::FeatureMap::TypeInfo>(
            featureMapArgument, this, OnSuccessCallback_6, OnFailureCallback_6));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_6(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_6() { ThrowSuccessResponse(); }

    CHIP_ERROR Test3bReadsBackGlobalAttributeFeatureMap_7()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::FeatureMap::TypeInfo>(
            this, OnSuccessCallback_7, OnFailureCallback_7, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_7(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_7(uint32_t featureMap)
    {
        VerifyOrReturn(CheckConstraintType("featureMap", "", "uint32"));
        VerifyOrReturn(CheckConstraintNotValue("featureMap", featureMap, 32769UL));

        NextTest();
    }
};

class Test_TC_WNCV_2_1Suite : public TestCommand
{
public:
    Test_TC_WNCV_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_WNCV_2_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_WNCV_2_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_WNCV_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_WNCV_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : 2: read the RO mandatory attribute default: Type\n");
            err = Test2ReadTheRoMandatoryAttributeDefaultType_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : 3a: write a value into the RO mandatory attribute: Type\n");
            err = Test3aWriteAValueIntoTheRoMandatoryAttributeType_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : 3b: reads back the RO mandatory attribute: Type\n");
            err = Test3bReadsBackTheRoMandatoryAttributeType_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : 2: read the RO mandatory attribute default: ConfigStatus\n");
            err = Test2ReadTheRoMandatoryAttributeDefaultConfigStatus_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : 3a: write a value into the RO mandatory attribute: ConfigStatus\n");
            err = Test3aWriteAValueIntoTheRoMandatoryAttributeConfigStatus_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : 3b: reads back the RO mandatory attribute: ConfigStatus\n");
            err = Test3bReadsBackTheRoMandatoryAttributeConfigStatus_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : 2: read the RO mandatory attribute default: OperationalStatus\n");
            err = Test2ReadTheRoMandatoryAttributeDefaultOperationalStatus_7();
            break;
        case 8:
            ChipLogProgress(chipTool,
                            " ***** Test Step 8 : 3a: write a value into the RO mandatory attribute: OperationalStatus\n");
            err = Test3aWriteAValueIntoTheRoMandatoryAttributeOperationalStatus_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : 3b: reads back the RO mandatory attribute: OperationalStatus\n");
            err = Test3bReadsBackTheRoMandatoryAttributeOperationalStatus_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : 2: read the RO mandatory attribute default: EndProductType\n");
            err = Test2ReadTheRoMandatoryAttributeDefaultEndProductType_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : 3a: write a value into the RO mandatory attribute: EndProductType\n");
            err = Test3aWriteAValueIntoTheRoMandatoryAttributeEndProductType_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : 3b: reads back the RO mandatory attribute: EndProductType\n");
            err = Test3bReadsBackTheRoMandatoryAttributeEndProductType_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : 2: read the RW mandatory attribute default: Mode\n");
            err = Test2ReadTheRwMandatoryAttributeDefaultMode_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : 3a: write a value into the RW mandatory attribute:: Mode\n");
            err = Test3aWriteAValueIntoTheRwMandatoryAttributeMode_14();
            break;
        case 15:
            ChipLogProgress(chipTool, " ***** Test Step 15 : 3b: reads back the RW mandatory attribute: Mode\n");
            err = Test3bReadsBackTheRwMandatoryAttributeMode_15();
            break;
        case 16:
            ChipLogProgress(chipTool,
                            " ***** Test Step 16 : 2: read the RO optional attribute default: TargetPositionLiftPercent100ths\n");
            err = Test2ReadTheRoOptionalAttributeDefaultTargetPositionLiftPercent100ths_16();
            break;
        case 17:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 17 : 3a: write a value into the RO optional attribute: TargetPositionLiftPercent100ths\n");
            err = Test3aWriteAValueIntoTheRoOptionalAttributeTargetPositionLiftPercent100ths_17();
            break;
        case 18:
            ChipLogProgress(chipTool,
                            " ***** Test Step 18 : 3b: reads back the RO optional attribute: TargetPositionLiftPercent100ths\n");
            err = Test3bReadsBackTheRoOptionalAttributeTargetPositionLiftPercent100ths_18();
            break;
        case 19:
            ChipLogProgress(chipTool,
                            " ***** Test Step 19 : 2: read the RO optional attribute default: TargetPositionTiltPercent100ths\n");
            err = Test2ReadTheRoOptionalAttributeDefaultTargetPositionTiltPercent100ths_19();
            break;
        case 20:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 20 : 3a: write a value into the RO optional attribute: TargetPositionTiltPercent100ths\n");
            err = Test3aWriteAValueIntoTheRoOptionalAttributeTargetPositionTiltPercent100ths_20();
            break;
        case 21:
            ChipLogProgress(chipTool,
                            " ***** Test Step 21 : 3b: reads back the RO optional attribute: TargetPositionTiltPercent100ths\n");
            err = Test3bReadsBackTheRoOptionalAttributeTargetPositionTiltPercent100ths_21();
            break;
        case 22:
            ChipLogProgress(chipTool,
                            " ***** Test Step 22 : 2: read the RO optional attribute default: CurrentPositionLiftPercent100ths\n");
            err = Test2ReadTheRoOptionalAttributeDefaultCurrentPositionLiftPercent100ths_22();
            break;
        case 23:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 23 : 3a: write a value into the RO optional attribute: CurrentPositionLiftPercent100ths\n");
            err = Test3aWriteAValueIntoTheRoOptionalAttributeCurrentPositionLiftPercent100ths_23();
            break;
        case 24:
            ChipLogProgress(chipTool,
                            " ***** Test Step 24 : 3b: reads back the RO optional attribute: CurrentPositionLiftPercent100ths\n");
            err = Test3bReadsBackTheRoOptionalAttributeCurrentPositionLiftPercent100ths_24();
            break;
        case 25:
            ChipLogProgress(chipTool,
                            " ***** Test Step 25 : 2: read the RO optional attribute default: CurrentPositionTiltPercent100ths\n");
            err = Test2ReadTheRoOptionalAttributeDefaultCurrentPositionTiltPercent100ths_25();
            break;
        case 26:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 26 : 3a: write a value into the RO optional attribute: CurrentPositionTiltPercent100ths\n");
            err = Test3aWriteAValueIntoTheRoOptionalAttributeCurrentPositionTiltPercent100ths_26();
            break;
        case 27:
            ChipLogProgress(chipTool,
                            " ***** Test Step 27 : 3b: reads back the RO optional attribute: CurrentPositionTiltPercent100ths\n");
            err = Test3bReadsBackTheRoOptionalAttributeCurrentPositionTiltPercent100ths_27();
            break;
        case 28:
            ChipLogProgress(chipTool, " ***** Test Step 28 : 2: read the RO optional attribute default: InstalledOpenLimitLift\n");
            err = Test2ReadTheRoOptionalAttributeDefaultInstalledOpenLimitLift_28();
            break;
        case 29:
            ChipLogProgress(chipTool,
                            " ***** Test Step 29 : 3a: write a value into the RO optional attribute: InstalledOpenLimitLift\n");
            err = Test3aWriteAValueIntoTheRoOptionalAttributeInstalledOpenLimitLift_29();
            break;
        case 30:
            ChipLogProgress(chipTool, " ***** Test Step 30 : 3b: reads back the RO optional attribute: InstalledOpenLimitLift\n");
            err = Test3bReadsBackTheRoOptionalAttributeInstalledOpenLimitLift_30();
            break;
        case 31:
            ChipLogProgress(chipTool,
                            " ***** Test Step 31 : 2: read the RO optional attribute default: InstalledClosedLimitLift\n");
            err = Test2ReadTheRoOptionalAttributeDefaultInstalledClosedLimitLift_31();
            break;
        case 32:
            ChipLogProgress(chipTool,
                            " ***** Test Step 32 : 3a: write a value into the RO optional attribute: InstalledClosedLimitLift\n");
            err = Test3aWriteAValueIntoTheRoOptionalAttributeInstalledClosedLimitLift_32();
            break;
        case 33:
            ChipLogProgress(chipTool, " ***** Test Step 33 : 3b: reads back the RO optional attribute: InstalledClosedLimitLift\n");
            err = Test3bReadsBackTheRoOptionalAttributeInstalledClosedLimitLift_33();
            break;
        case 34:
            ChipLogProgress(chipTool, " ***** Test Step 34 : 2: read the RO optional attribute default: InstalledOpenLimitTilt\n");
            err = Test2ReadTheRoOptionalAttributeDefaultInstalledOpenLimitTilt_34();
            break;
        case 35:
            ChipLogProgress(chipTool,
                            " ***** Test Step 35 : 3a: write a value into the RO optional attribute: InstalledOpenLimitTilt\n");
            err = Test3aWriteAValueIntoTheRoOptionalAttributeInstalledOpenLimitTilt_35();
            break;
        case 36:
            ChipLogProgress(chipTool, " ***** Test Step 36 : 3b: reads back the RO optional attribute: InstalledOpenLimitTilt\n");
            err = Test3bReadsBackTheRoOptionalAttributeInstalledOpenLimitTilt_36();
            break;
        case 37:
            ChipLogProgress(chipTool,
                            " ***** Test Step 37 : 2: read the RO optional attribute default: InstalledClosedLimitTilt\n");
            err = Test2ReadTheRoOptionalAttributeDefaultInstalledClosedLimitTilt_37();
            break;
        case 38:
            ChipLogProgress(chipTool,
                            " ***** Test Step 38 : 3a: write a value into the RO optional attribute: InstalledClosedLimitTilt\n");
            err = Test3aWriteAValueIntoTheRoOptionalAttributeInstalledClosedLimitTilt_38();
            break;
        case 39:
            ChipLogProgress(chipTool, " ***** Test Step 39 : 3b: reads back the RO optional attribute: InstalledClosedLimitTilt\n");
            err = Test3bReadsBackTheRoOptionalAttributeInstalledClosedLimitTilt_39();
            break;
        case 40:
            ChipLogProgress(chipTool, " ***** Test Step 40 : 4: read the RO mandatory attribute default: SafetyStatus\n");
            err = Test4ReadTheRoMandatoryAttributeDefaultSafetyStatus_40();
            break;
        case 41:
            ChipLogProgress(chipTool, " ***** Test Step 41 : 5a: write a value into the RO mandatory attribute: SafetyStatus\n");
            err = Test5aWriteAValueIntoTheRoMandatoryAttributeSafetyStatus_41();
            break;
        case 42:
            ChipLogProgress(chipTool, " ***** Test Step 42 : 5b: reads back the RO mandatory attribute: SafetyStatus\n");
            err = Test5bReadsBackTheRoMandatoryAttributeSafetyStatus_42();
            break;
        case 43:
            ChipLogProgress(chipTool, " ***** Test Step 43 : 4: read the RO optional attribute default: CurrentPositionLift\n");
            err = Test4ReadTheRoOptionalAttributeDefaultCurrentPositionLift_43();
            break;
        case 44:
            ChipLogProgress(chipTool,
                            " ***** Test Step 44 : 5a: write a value into the RO optional attribute: CurrentPositionLift\n");
            err = Test5aWriteAValueIntoTheRoOptionalAttributeCurrentPositionLift_44();
            break;
        case 45:
            ChipLogProgress(chipTool, " ***** Test Step 45 : 5b: reads back the RO optional attribute: CurrentPositionLift\n");
            err = Test5bReadsBackTheRoOptionalAttributeCurrentPositionLift_45();
            break;
        case 46:
            ChipLogProgress(chipTool, " ***** Test Step 46 : 4: read the RO optional attribute default: CurrentPositionTilt\n");
            err = Test4ReadTheRoOptionalAttributeDefaultCurrentPositionTilt_46();
            break;
        case 47:
            ChipLogProgress(chipTool,
                            " ***** Test Step 47 : 5a: write a value into the RO optional attribute: CurrentPositionTilt\n");
            err = Test5aWriteAValueIntoTheRoOptionalAttributeCurrentPositionTilt_47();
            break;
        case 48:
            ChipLogProgress(chipTool, " ***** Test Step 48 : 5b: reads back the RO optional attribute: CurrentPositionTilt\n");
            err = Test5bReadsBackTheRoOptionalAttributeCurrentPositionTilt_48();
            break;
        case 49:
            ChipLogProgress(chipTool,
                            " ***** Test Step 49 : 4: read the RO optional attribute default: CurrentPositionLiftPercentage\n");
            err = Test4ReadTheRoOptionalAttributeDefaultCurrentPositionLiftPercentage_49();
            break;
        case 50:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 50 : 5a: write a value into the RO optional attribute: CurrentPositionLiftPercentage\n");
            err = Test5aWriteAValueIntoTheRoOptionalAttributeCurrentPositionLiftPercentage_50();
            break;
        case 51:
            ChipLogProgress(chipTool,
                            " ***** Test Step 51 : 5b: reads back the RO optional attribute: CurrentPositionLiftPercentage\n");
            err = Test5bReadsBackTheRoOptionalAttributeCurrentPositionLiftPercentage_51();
            break;
        case 52:
            ChipLogProgress(chipTool,
                            " ***** Test Step 52 : 4: read the RO optional attribute default: CurrentPositionTiltPercentage\n");
            err = Test4ReadTheRoOptionalAttributeDefaultCurrentPositionTiltPercentage_52();
            break;
        case 53:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 53 : 5a: write a value into the RO optional attribute: CurrentPositionTiltPercentage\n");
            err = Test5aWriteAValueIntoTheRoOptionalAttributeCurrentPositionTiltPercentage_53();
            break;
        case 54:
            ChipLogProgress(chipTool,
                            " ***** Test Step 54 : 5b: reads back the RO optional attribute: CurrentPositionTiltPercentage\n");
            err = Test5bReadsBackTheRoOptionalAttributeCurrentPositionTiltPercentage_54();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 55;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_1(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnFailureResponse_1(error);
    }

    static void OnSuccessCallback_1(void * context, uint8_t type)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnSuccessResponse_1(type);
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context) { (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnSuccessResponse_2(); }

    static void OnFailureCallback_3(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnFailureResponse_3(error);
    }

    static void OnSuccessCallback_3(void * context, uint8_t type)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnSuccessResponse_3(type);
    }

    static void OnFailureCallback_4(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnFailureResponse_4(error);
    }

    static void OnSuccessCallback_4(void * context, uint8_t configStatus)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnSuccessResponse_4(configStatus);
    }

    static void OnFailureCallback_5(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnFailureResponse_5(error);
    }

    static void OnSuccessCallback_5(void * context) { (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnSuccessResponse_5(); }

    static void OnFailureCallback_6(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnFailureResponse_6(error);
    }

    static void OnSuccessCallback_6(void * context, uint8_t configStatus)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnSuccessResponse_6(configStatus);
    }

    static void OnFailureCallback_7(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnFailureResponse_7(error);
    }

    static void OnSuccessCallback_7(void * context, uint8_t operationalStatus)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnSuccessResponse_7(operationalStatus);
    }

    static void OnFailureCallback_8(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnFailureResponse_8(error);
    }

    static void OnSuccessCallback_8(void * context) { (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnSuccessResponse_8(); }

    static void OnFailureCallback_9(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnFailureResponse_9(error);
    }

    static void OnSuccessCallback_9(void * context, uint8_t operationalStatus)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnSuccessResponse_9(operationalStatus);
    }

    static void OnFailureCallback_10(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnFailureResponse_10(error);
    }

    static void OnSuccessCallback_10(void * context, uint8_t endProductType)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnSuccessResponse_10(endProductType);
    }

    static void OnFailureCallback_11(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnFailureResponse_11(error);
    }

    static void OnSuccessCallback_11(void * context) { (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnSuccessResponse_11(); }

    static void OnFailureCallback_12(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnFailureResponse_12(error);
    }

    static void OnSuccessCallback_12(void * context, uint8_t endProductType)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnSuccessResponse_12(endProductType);
    }

    static void OnFailureCallback_13(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnFailureResponse_13(error);
    }

    static void OnSuccessCallback_13(void * context, uint8_t mode)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnSuccessResponse_13(mode);
    }

    static void OnFailureCallback_14(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnFailureResponse_14(error);
    }

    static void OnSuccessCallback_14(void * context) { (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnSuccessResponse_14(); }

    static void OnFailureCallback_15(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnFailureResponse_15(error);
    }

    static void OnSuccessCallback_15(void * context, uint8_t mode)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnSuccessResponse_15(mode);
    }

    static void OnFailureCallback_16(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnFailureResponse_16(error);
    }

    static void OnSuccessCallback_16(void * context,
                                     const chip::app::DataModel::Nullable<chip::Percent100ths> & targetPositionLiftPercent100ths)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnSuccessResponse_16(targetPositionLiftPercent100ths);
    }

    static void OnFailureCallback_17(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnFailureResponse_17(error);
    }

    static void OnSuccessCallback_17(void * context) { (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnSuccessResponse_17(); }

    static void OnFailureCallback_18(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnFailureResponse_18(error);
    }

    static void OnSuccessCallback_18(void * context,
                                     const chip::app::DataModel::Nullable<chip::Percent100ths> & targetPositionLiftPercent100ths)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnSuccessResponse_18(targetPositionLiftPercent100ths);
    }

    static void OnFailureCallback_19(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnFailureResponse_19(error);
    }

    static void OnSuccessCallback_19(void * context,
                                     const chip::app::DataModel::Nullable<chip::Percent100ths> & targetPositionTiltPercent100ths)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnSuccessResponse_19(targetPositionTiltPercent100ths);
    }

    static void OnFailureCallback_20(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnFailureResponse_20(error);
    }

    static void OnSuccessCallback_20(void * context) { (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnSuccessResponse_20(); }

    static void OnFailureCallback_21(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnFailureResponse_21(error);
    }

    static void OnSuccessCallback_21(void * context,
                                     const chip::app::DataModel::Nullable<chip::Percent100ths> & targetPositionTiltPercent100ths)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnSuccessResponse_21(targetPositionTiltPercent100ths);
    }

    static void OnFailureCallback_22(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnFailureResponse_22(error);
    }

    static void OnSuccessCallback_22(void * context,
                                     const chip::app::DataModel::Nullable<chip::Percent100ths> & currentPositionLiftPercent100ths)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnSuccessResponse_22(currentPositionLiftPercent100ths);
    }

    static void OnFailureCallback_23(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnFailureResponse_23(error);
    }

    static void OnSuccessCallback_23(void * context) { (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnSuccessResponse_23(); }

    static void OnFailureCallback_24(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnFailureResponse_24(error);
    }

    static void OnSuccessCallback_24(void * context,
                                     const chip::app::DataModel::Nullable<chip::Percent100ths> & currentPositionLiftPercent100ths)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnSuccessResponse_24(currentPositionLiftPercent100ths);
    }

    static void OnFailureCallback_25(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnFailureResponse_25(error);
    }

    static void OnSuccessCallback_25(void * context,
                                     const chip::app::DataModel::Nullable<chip::Percent100ths> & currentPositionTiltPercent100ths)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnSuccessResponse_25(currentPositionTiltPercent100ths);
    }

    static void OnFailureCallback_26(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnFailureResponse_26(error);
    }

    static void OnSuccessCallback_26(void * context) { (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnSuccessResponse_26(); }

    static void OnFailureCallback_27(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnFailureResponse_27(error);
    }

    static void OnSuccessCallback_27(void * context,
                                     const chip::app::DataModel::Nullable<chip::Percent100ths> & currentPositionTiltPercent100ths)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnSuccessResponse_27(currentPositionTiltPercent100ths);
    }

    static void OnFailureCallback_28(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnFailureResponse_28(error);
    }

    static void OnSuccessCallback_28(void * context, uint16_t installedOpenLimitLift)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnSuccessResponse_28(installedOpenLimitLift);
    }

    static void OnFailureCallback_29(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnFailureResponse_29(error);
    }

    static void OnSuccessCallback_29(void * context) { (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnSuccessResponse_29(); }

    static void OnFailureCallback_30(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnFailureResponse_30(error);
    }

    static void OnSuccessCallback_30(void * context, uint16_t installedOpenLimitLift)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnSuccessResponse_30(installedOpenLimitLift);
    }

    static void OnFailureCallback_31(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnFailureResponse_31(error);
    }

    static void OnSuccessCallback_31(void * context, uint16_t installedClosedLimitLift)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnSuccessResponse_31(installedClosedLimitLift);
    }

    static void OnFailureCallback_32(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnFailureResponse_32(error);
    }

    static void OnSuccessCallback_32(void * context) { (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnSuccessResponse_32(); }

    static void OnFailureCallback_33(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnFailureResponse_33(error);
    }

    static void OnSuccessCallback_33(void * context, uint16_t installedClosedLimitLift)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnSuccessResponse_33(installedClosedLimitLift);
    }

    static void OnFailureCallback_34(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnFailureResponse_34(error);
    }

    static void OnSuccessCallback_34(void * context, uint16_t installedOpenLimitTilt)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnSuccessResponse_34(installedOpenLimitTilt);
    }

    static void OnFailureCallback_35(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnFailureResponse_35(error);
    }

    static void OnSuccessCallback_35(void * context) { (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnSuccessResponse_35(); }

    static void OnFailureCallback_36(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnFailureResponse_36(error);
    }

    static void OnSuccessCallback_36(void * context, uint16_t installedOpenLimitTilt)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnSuccessResponse_36(installedOpenLimitTilt);
    }

    static void OnFailureCallback_37(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnFailureResponse_37(error);
    }

    static void OnSuccessCallback_37(void * context, uint16_t installedClosedLimitTilt)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnSuccessResponse_37(installedClosedLimitTilt);
    }

    static void OnFailureCallback_38(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnFailureResponse_38(error);
    }

    static void OnSuccessCallback_38(void * context) { (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnSuccessResponse_38(); }

    static void OnFailureCallback_39(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnFailureResponse_39(error);
    }

    static void OnSuccessCallback_39(void * context, uint16_t installedClosedLimitTilt)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnSuccessResponse_39(installedClosedLimitTilt);
    }

    static void OnFailureCallback_40(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnFailureResponse_40(error);
    }

    static void OnSuccessCallback_40(void * context, uint16_t safetyStatus)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnSuccessResponse_40(safetyStatus);
    }

    static void OnFailureCallback_41(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnFailureResponse_41(error);
    }

    static void OnSuccessCallback_41(void * context) { (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnSuccessResponse_41(); }

    static void OnFailureCallback_42(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnFailureResponse_42(error);
    }

    static void OnSuccessCallback_42(void * context, uint16_t safetyStatus)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnSuccessResponse_42(safetyStatus);
    }

    static void OnFailureCallback_43(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnFailureResponse_43(error);
    }

    static void OnSuccessCallback_43(void * context, const chip::app::DataModel::Nullable<uint16_t> & currentPositionLift)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnSuccessResponse_43(currentPositionLift);
    }

    static void OnFailureCallback_44(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnFailureResponse_44(error);
    }

    static void OnSuccessCallback_44(void * context) { (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnSuccessResponse_44(); }

    static void OnFailureCallback_45(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnFailureResponse_45(error);
    }

    static void OnSuccessCallback_45(void * context, const chip::app::DataModel::Nullable<uint16_t> & currentPositionLift)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnSuccessResponse_45(currentPositionLift);
    }

    static void OnFailureCallback_46(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnFailureResponse_46(error);
    }

    static void OnSuccessCallback_46(void * context, const chip::app::DataModel::Nullable<uint16_t> & currentPositionTilt)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnSuccessResponse_46(currentPositionTilt);
    }

    static void OnFailureCallback_47(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnFailureResponse_47(error);
    }

    static void OnSuccessCallback_47(void * context) { (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnSuccessResponse_47(); }

    static void OnFailureCallback_48(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnFailureResponse_48(error);
    }

    static void OnSuccessCallback_48(void * context, const chip::app::DataModel::Nullable<uint16_t> & currentPositionTilt)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnSuccessResponse_48(currentPositionTilt);
    }

    static void OnFailureCallback_49(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnFailureResponse_49(error);
    }

    static void OnSuccessCallback_49(void * context,
                                     const chip::app::DataModel::Nullable<chip::Percent> & currentPositionLiftPercentage)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnSuccessResponse_49(currentPositionLiftPercentage);
    }

    static void OnFailureCallback_50(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnFailureResponse_50(error);
    }

    static void OnSuccessCallback_50(void * context) { (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnSuccessResponse_50(); }

    static void OnFailureCallback_51(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnFailureResponse_51(error);
    }

    static void OnSuccessCallback_51(void * context,
                                     const chip::app::DataModel::Nullable<chip::Percent> & currentPositionLiftPercentage)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnSuccessResponse_51(currentPositionLiftPercentage);
    }

    static void OnFailureCallback_52(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnFailureResponse_52(error);
    }

    static void OnSuccessCallback_52(void * context,
                                     const chip::app::DataModel::Nullable<chip::Percent> & currentPositionTiltPercentage)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnSuccessResponse_52(currentPositionTiltPercentage);
    }

    static void OnFailureCallback_53(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnFailureResponse_53(error);
    }

    static void OnSuccessCallback_53(void * context) { (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnSuccessResponse_53(); }

    static void OnFailureCallback_54(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnFailureResponse_54(error);
    }

    static void OnSuccessCallback_54(void * context,
                                     const chip::app::DataModel::Nullable<chip::Percent> & currentPositionTiltPercentage)
    {
        (static_cast<Test_TC_WNCV_2_1Suite *>(context))->OnSuccessResponse_54(currentPositionTiltPercentage);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR Test2ReadTheRoMandatoryAttributeDefaultType_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::Type::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1(uint8_t type)
    {
        VerifyOrReturn(CheckConstraintType("type", "", "enum8"));
        VerifyOrReturn(CheckConstraintMinValue<uint8_t>("type", type, 0));
        VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("type", type, 9));
        NextTest();
    }

    CHIP_ERROR Test3aWriteAValueIntoTheRoMandatoryAttributeType_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t typeArgument;
        typeArgument = 250;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::WindowCovering::Attributes::Type::TypeInfo>(
            typeArgument, this, OnSuccessCallback_2, OnFailureCallback_2));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_2() { ThrowSuccessResponse(); }

    CHIP_ERROR Test3bReadsBackTheRoMandatoryAttributeType_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::Type::TypeInfo>(
            this, OnSuccessCallback_3, OnFailureCallback_3, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3(uint8_t type)
    {
        VerifyOrReturn(CheckConstraintType("type", "", "enum8"));
        VerifyOrReturn(CheckConstraintNotValue("type", type, 250));

        NextTest();
    }

    CHIP_ERROR Test2ReadTheRoMandatoryAttributeDefaultConfigStatus_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::ConfigStatus::TypeInfo>(
            this, OnSuccessCallback_4, OnFailureCallback_4, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_4(uint8_t configStatus)
    {
        VerifyOrReturn(CheckConstraintType("configStatus", "", "map8"));
        VerifyOrReturn(CheckConstraintMinValue<uint8_t>("configStatus", configStatus, 0));
        VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("configStatus", configStatus, 63));
        NextTest();
    }

    CHIP_ERROR Test3aWriteAValueIntoTheRoMandatoryAttributeConfigStatus_5()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t configStatusArgument;
        configStatusArgument = 128;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::WindowCovering::Attributes::ConfigStatus::TypeInfo>(
            configStatusArgument, this, OnSuccessCallback_5, OnFailureCallback_5));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_5() { ThrowSuccessResponse(); }

    CHIP_ERROR Test3bReadsBackTheRoMandatoryAttributeConfigStatus_6()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::ConfigStatus::TypeInfo>(
            this, OnSuccessCallback_6, OnFailureCallback_6, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_6(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_6(uint8_t configStatus)
    {
        VerifyOrReturn(CheckConstraintType("configStatus", "", "map8"));
        VerifyOrReturn(CheckConstraintNotValue("configStatus", configStatus, 128));

        NextTest();
    }

    CHIP_ERROR Test2ReadTheRoMandatoryAttributeDefaultOperationalStatus_7()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::OperationalStatus::TypeInfo>(
            this, OnSuccessCallback_7, OnFailureCallback_7, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_7(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_7(uint8_t operationalStatus)
    {
        VerifyOrReturn(CheckConstraintType("operationalStatus", "", "map8"));
        VerifyOrReturn(CheckConstraintMinValue<uint8_t>("operationalStatus", operationalStatus, 0));
        VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("operationalStatus", operationalStatus, 63));
        NextTest();
    }

    CHIP_ERROR Test3aWriteAValueIntoTheRoMandatoryAttributeOperationalStatus_8()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t operationalStatusArgument;
        operationalStatusArgument = 128;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::WindowCovering::Attributes::OperationalStatus::TypeInfo>(
            operationalStatusArgument, this, OnSuccessCallback_8, OnFailureCallback_8));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_8(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_8() { ThrowSuccessResponse(); }

    CHIP_ERROR Test3bReadsBackTheRoMandatoryAttributeOperationalStatus_9()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::OperationalStatus::TypeInfo>(
            this, OnSuccessCallback_9, OnFailureCallback_9, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_9(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_9(uint8_t operationalStatus)
    {
        VerifyOrReturn(CheckConstraintType("operationalStatus", "", "map8"));
        VerifyOrReturn(CheckConstraintNotValue("operationalStatus", operationalStatus, 128));

        NextTest();
    }

    CHIP_ERROR Test2ReadTheRoMandatoryAttributeDefaultEndProductType_10()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::EndProductType::TypeInfo>(
            this, OnSuccessCallback_10, OnFailureCallback_10, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_10(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_10(uint8_t endProductType)
    {
        VerifyOrReturn(CheckConstraintType("endProductType", "", "enum8"));
        VerifyOrReturn(CheckConstraintMinValue<uint8_t>("endProductType", endProductType, 0));
        VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("endProductType", endProductType, 23));
        NextTest();
    }

    CHIP_ERROR Test3aWriteAValueIntoTheRoMandatoryAttributeEndProductType_11()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t endProductTypeArgument;
        endProductTypeArgument = 250;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::WindowCovering::Attributes::EndProductType::TypeInfo>(
            endProductTypeArgument, this, OnSuccessCallback_11, OnFailureCallback_11));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_11(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_11() { ThrowSuccessResponse(); }

    CHIP_ERROR Test3bReadsBackTheRoMandatoryAttributeEndProductType_12()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::EndProductType::TypeInfo>(
            this, OnSuccessCallback_12, OnFailureCallback_12, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_12(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_12(uint8_t endProductType)
    {
        VerifyOrReturn(CheckConstraintType("endProductType", "", "enum8"));
        VerifyOrReturn(CheckConstraintNotValue("endProductType", endProductType, 250));

        NextTest();
    }

    CHIP_ERROR Test2ReadTheRwMandatoryAttributeDefaultMode_13()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::Mode::TypeInfo>(
            this, OnSuccessCallback_13, OnFailureCallback_13, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_13(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_13(uint8_t mode)
    {
        VerifyOrReturn(CheckConstraintType("mode", "", "map8"));
        VerifyOrReturn(CheckConstraintMinValue<uint8_t>("mode", mode, 0));
        VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("mode", mode, 15));
        NextTest();
    }

    CHIP_ERROR Test3aWriteAValueIntoTheRwMandatoryAttributeMode_14()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t modeArgument;
        modeArgument = 8;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::WindowCovering::Attributes::Mode::TypeInfo>(
            modeArgument, this, OnSuccessCallback_14, OnFailureCallback_14));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_14(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_14() { NextTest(); }

    CHIP_ERROR Test3bReadsBackTheRwMandatoryAttributeMode_15()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::Mode::TypeInfo>(
            this, OnSuccessCallback_15, OnFailureCallback_15, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_15(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_15(uint8_t mode)
    {
        VerifyOrReturn(CheckValue("mode", mode, 8));

        NextTest();
    }

    CHIP_ERROR Test2ReadTheRoOptionalAttributeDefaultTargetPositionLiftPercent100ths_16()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::TargetPositionLiftPercent100ths::TypeInfo>(
                this, OnSuccessCallback_16, OnFailureCallback_16, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_16(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_16(const chip::app::DataModel::Nullable<chip::Percent100ths> & targetPositionLiftPercent100ths)
    {
        VerifyOrReturn(CheckConstraintType("targetPositionLiftPercent100ths", "", "Percent100ths"));
        VerifyOrReturn(
            CheckConstraintMinValue<chip::Percent100ths>("targetPositionLiftPercent100ths", targetPositionLiftPercent100ths, 0U));
        VerifyOrReturn(CheckConstraintMaxValue<chip::Percent100ths>("targetPositionLiftPercent100ths",
                                                                    targetPositionLiftPercent100ths, 10000U));
        NextTest();
    }

    CHIP_ERROR Test3aWriteAValueIntoTheRoOptionalAttributeTargetPositionLiftPercent100ths_17()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<chip::Percent100ths> targetPositionLiftPercent100thsArgument;
        targetPositionLiftPercent100thsArgument.SetNonNull();
        targetPositionLiftPercent100thsArgument.Value() = 20000U;

        ReturnErrorOnFailure(
            cluster.WriteAttribute<chip::app::Clusters::WindowCovering::Attributes::TargetPositionLiftPercent100ths::TypeInfo>(
                targetPositionLiftPercent100thsArgument, this, OnSuccessCallback_17, OnFailureCallback_17));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_17(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_17() { ThrowSuccessResponse(); }

    CHIP_ERROR Test3bReadsBackTheRoOptionalAttributeTargetPositionLiftPercent100ths_18()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::TargetPositionLiftPercent100ths::TypeInfo>(
                this, OnSuccessCallback_18, OnFailureCallback_18, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_18(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_18(const chip::app::DataModel::Nullable<chip::Percent100ths> & targetPositionLiftPercent100ths)
    {
        VerifyOrReturn(CheckConstraintType("targetPositionLiftPercent100ths", "", "Percent100ths"));
        VerifyOrReturn(CheckConstraintNotValue("targetPositionLiftPercent100ths", targetPositionLiftPercent100ths, 20000U));

        NextTest();
    }

    CHIP_ERROR Test2ReadTheRoOptionalAttributeDefaultTargetPositionTiltPercent100ths_19()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::TargetPositionTiltPercent100ths::TypeInfo>(
                this, OnSuccessCallback_19, OnFailureCallback_19, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_19(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_19(const chip::app::DataModel::Nullable<chip::Percent100ths> & targetPositionTiltPercent100ths)
    {
        VerifyOrReturn(CheckConstraintType("targetPositionTiltPercent100ths", "", "Percent100ths"));
        VerifyOrReturn(
            CheckConstraintMinValue<chip::Percent100ths>("targetPositionTiltPercent100ths", targetPositionTiltPercent100ths, 0U));
        VerifyOrReturn(CheckConstraintMaxValue<chip::Percent100ths>("targetPositionTiltPercent100ths",
                                                                    targetPositionTiltPercent100ths, 10000U));
        NextTest();
    }

    CHIP_ERROR Test3aWriteAValueIntoTheRoOptionalAttributeTargetPositionTiltPercent100ths_20()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<chip::Percent100ths> targetPositionTiltPercent100thsArgument;
        targetPositionTiltPercent100thsArgument.SetNonNull();
        targetPositionTiltPercent100thsArgument.Value() = 20000U;

        ReturnErrorOnFailure(
            cluster.WriteAttribute<chip::app::Clusters::WindowCovering::Attributes::TargetPositionTiltPercent100ths::TypeInfo>(
                targetPositionTiltPercent100thsArgument, this, OnSuccessCallback_20, OnFailureCallback_20));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_20(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_20() { ThrowSuccessResponse(); }

    CHIP_ERROR Test3bReadsBackTheRoOptionalAttributeTargetPositionTiltPercent100ths_21()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::TargetPositionTiltPercent100ths::TypeInfo>(
                this, OnSuccessCallback_21, OnFailureCallback_21, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_21(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_21(const chip::app::DataModel::Nullable<chip::Percent100ths> & targetPositionTiltPercent100ths)
    {
        VerifyOrReturn(CheckConstraintType("targetPositionTiltPercent100ths", "", "Percent100ths"));
        VerifyOrReturn(CheckConstraintNotValue("targetPositionTiltPercent100ths", targetPositionTiltPercent100ths, 20000U));

        NextTest();
    }

    CHIP_ERROR Test2ReadTheRoOptionalAttributeDefaultCurrentPositionLiftPercent100ths_22()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::CurrentPositionLiftPercent100ths::TypeInfo>(
                this, OnSuccessCallback_22, OnFailureCallback_22, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_22(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_22(const chip::app::DataModel::Nullable<chip::Percent100ths> & currentPositionLiftPercent100ths)
    {
        VerifyOrReturn(CheckConstraintType("currentPositionLiftPercent100ths", "", "Percent100ths"));
        VerifyOrReturn(
            CheckConstraintMinValue<chip::Percent100ths>("currentPositionLiftPercent100ths", currentPositionLiftPercent100ths, 0U));
        VerifyOrReturn(CheckConstraintMaxValue<chip::Percent100ths>("currentPositionLiftPercent100ths",
                                                                    currentPositionLiftPercent100ths, 10000U));
        NextTest();
    }

    CHIP_ERROR Test3aWriteAValueIntoTheRoOptionalAttributeCurrentPositionLiftPercent100ths_23()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<chip::Percent100ths> currentPositionLiftPercent100thsArgument;
        currentPositionLiftPercent100thsArgument.SetNonNull();
        currentPositionLiftPercent100thsArgument.Value() = 20000U;

        ReturnErrorOnFailure(
            cluster.WriteAttribute<chip::app::Clusters::WindowCovering::Attributes::CurrentPositionLiftPercent100ths::TypeInfo>(
                currentPositionLiftPercent100thsArgument, this, OnSuccessCallback_23, OnFailureCallback_23));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_23(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_23() { ThrowSuccessResponse(); }

    CHIP_ERROR Test3bReadsBackTheRoOptionalAttributeCurrentPositionLiftPercent100ths_24()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::CurrentPositionLiftPercent100ths::TypeInfo>(
                this, OnSuccessCallback_24, OnFailureCallback_24, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_24(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_24(const chip::app::DataModel::Nullable<chip::Percent100ths> & currentPositionLiftPercent100ths)
    {
        VerifyOrReturn(CheckConstraintType("currentPositionLiftPercent100ths", "", "Percent100ths"));
        VerifyOrReturn(CheckConstraintNotValue("currentPositionLiftPercent100ths", currentPositionLiftPercent100ths, 20000U));

        NextTest();
    }

    CHIP_ERROR Test2ReadTheRoOptionalAttributeDefaultCurrentPositionTiltPercent100ths_25()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::CurrentPositionTiltPercent100ths::TypeInfo>(
                this, OnSuccessCallback_25, OnFailureCallback_25, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_25(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_25(const chip::app::DataModel::Nullable<chip::Percent100ths> & currentPositionTiltPercent100ths)
    {
        VerifyOrReturn(CheckConstraintType("currentPositionTiltPercent100ths", "", "Percent100ths"));
        VerifyOrReturn(
            CheckConstraintMinValue<chip::Percent100ths>("currentPositionTiltPercent100ths", currentPositionTiltPercent100ths, 0U));
        VerifyOrReturn(CheckConstraintMaxValue<chip::Percent100ths>("currentPositionTiltPercent100ths",
                                                                    currentPositionTiltPercent100ths, 10000U));
        NextTest();
    }

    CHIP_ERROR Test3aWriteAValueIntoTheRoOptionalAttributeCurrentPositionTiltPercent100ths_26()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<chip::Percent100ths> currentPositionTiltPercent100thsArgument;
        currentPositionTiltPercent100thsArgument.SetNonNull();
        currentPositionTiltPercent100thsArgument.Value() = 20000U;

        ReturnErrorOnFailure(
            cluster.WriteAttribute<chip::app::Clusters::WindowCovering::Attributes::CurrentPositionTiltPercent100ths::TypeInfo>(
                currentPositionTiltPercent100thsArgument, this, OnSuccessCallback_26, OnFailureCallback_26));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_26(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_26() { ThrowSuccessResponse(); }

    CHIP_ERROR Test3bReadsBackTheRoOptionalAttributeCurrentPositionTiltPercent100ths_27()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::CurrentPositionTiltPercent100ths::TypeInfo>(
                this, OnSuccessCallback_27, OnFailureCallback_27, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_27(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_27(const chip::app::DataModel::Nullable<chip::Percent100ths> & currentPositionTiltPercent100ths)
    {
        VerifyOrReturn(CheckConstraintType("currentPositionTiltPercent100ths", "", "Percent100ths"));
        VerifyOrReturn(CheckConstraintNotValue("currentPositionTiltPercent100ths", currentPositionTiltPercent100ths, 20000U));

        NextTest();
    }

    CHIP_ERROR Test2ReadTheRoOptionalAttributeDefaultInstalledOpenLimitLift_28()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::InstalledOpenLimitLift::TypeInfo>(
                this, OnSuccessCallback_28, OnFailureCallback_28, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_28(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_28(uint16_t installedOpenLimitLift)
    {
        VerifyOrReturn(CheckConstraintType("installedOpenLimitLift", "", "uint16"));
        VerifyOrReturn(CheckConstraintMinValue<uint16_t>("installedOpenLimitLift", installedOpenLimitLift, 0U));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("installedOpenLimitLift", installedOpenLimitLift, 65535U));
        NextTest();
    }

    CHIP_ERROR Test3aWriteAValueIntoTheRoOptionalAttributeInstalledOpenLimitLift_29()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t installedOpenLimitLiftArgument;
        installedOpenLimitLiftArgument = 255U;

        ReturnErrorOnFailure(
            cluster.WriteAttribute<chip::app::Clusters::WindowCovering::Attributes::InstalledOpenLimitLift::TypeInfo>(
                installedOpenLimitLiftArgument, this, OnSuccessCallback_29, OnFailureCallback_29));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_29(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_29() { ThrowSuccessResponse(); }

    CHIP_ERROR Test3bReadsBackTheRoOptionalAttributeInstalledOpenLimitLift_30()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::InstalledOpenLimitLift::TypeInfo>(
                this, OnSuccessCallback_30, OnFailureCallback_30, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_30(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_30(uint16_t installedOpenLimitLift)
    {
        VerifyOrReturn(CheckConstraintType("installedOpenLimitLift", "", "uint16"));
        VerifyOrReturn(CheckConstraintMinValue<uint16_t>("installedOpenLimitLift", installedOpenLimitLift, 0U));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("installedOpenLimitLift", installedOpenLimitLift, 65535U));
        NextTest();
    }

    CHIP_ERROR Test2ReadTheRoOptionalAttributeDefaultInstalledClosedLimitLift_31()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::InstalledClosedLimitLift::TypeInfo>(
                this, OnSuccessCallback_31, OnFailureCallback_31, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_31(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_31(uint16_t installedClosedLimitLift)
    {
        VerifyOrReturn(CheckConstraintType("installedClosedLimitLift", "", "uint16"));
        VerifyOrReturn(CheckConstraintMinValue<uint16_t>("installedClosedLimitLift", installedClosedLimitLift, 0U));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("installedClosedLimitLift", installedClosedLimitLift, 65535U));
        NextTest();
    }

    CHIP_ERROR Test3aWriteAValueIntoTheRoOptionalAttributeInstalledClosedLimitLift_32()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t installedClosedLimitLiftArgument;
        installedClosedLimitLiftArgument = 255U;

        ReturnErrorOnFailure(
            cluster.WriteAttribute<chip::app::Clusters::WindowCovering::Attributes::InstalledClosedLimitLift::TypeInfo>(
                installedClosedLimitLiftArgument, this, OnSuccessCallback_32, OnFailureCallback_32));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_32(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_32() { ThrowSuccessResponse(); }

    CHIP_ERROR Test3bReadsBackTheRoOptionalAttributeInstalledClosedLimitLift_33()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::InstalledClosedLimitLift::TypeInfo>(
                this, OnSuccessCallback_33, OnFailureCallback_33, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_33(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_33(uint16_t installedClosedLimitLift)
    {
        VerifyOrReturn(CheckConstraintType("installedClosedLimitLift", "", "uint16"));
        VerifyOrReturn(CheckConstraintMinValue<uint16_t>("installedClosedLimitLift", installedClosedLimitLift, 0U));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("installedClosedLimitLift", installedClosedLimitLift, 65535U));
        NextTest();
    }

    CHIP_ERROR Test2ReadTheRoOptionalAttributeDefaultInstalledOpenLimitTilt_34()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::InstalledOpenLimitTilt::TypeInfo>(
                this, OnSuccessCallback_34, OnFailureCallback_34, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_34(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_34(uint16_t installedOpenLimitTilt)
    {
        VerifyOrReturn(CheckConstraintType("installedOpenLimitTilt", "", "uint16"));
        VerifyOrReturn(CheckConstraintMinValue<uint16_t>("installedOpenLimitTilt", installedOpenLimitTilt, 0U));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("installedOpenLimitTilt", installedOpenLimitTilt, 65535U));
        NextTest();
    }

    CHIP_ERROR Test3aWriteAValueIntoTheRoOptionalAttributeInstalledOpenLimitTilt_35()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t installedOpenLimitTiltArgument;
        installedOpenLimitTiltArgument = 255U;

        ReturnErrorOnFailure(
            cluster.WriteAttribute<chip::app::Clusters::WindowCovering::Attributes::InstalledOpenLimitTilt::TypeInfo>(
                installedOpenLimitTiltArgument, this, OnSuccessCallback_35, OnFailureCallback_35));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_35(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_35() { ThrowSuccessResponse(); }

    CHIP_ERROR Test3bReadsBackTheRoOptionalAttributeInstalledOpenLimitTilt_36()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::InstalledOpenLimitTilt::TypeInfo>(
                this, OnSuccessCallback_36, OnFailureCallback_36, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_36(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_36(uint16_t installedOpenLimitTilt)
    {
        VerifyOrReturn(CheckConstraintType("installedOpenLimitTilt", "", "uint16"));
        VerifyOrReturn(CheckConstraintMinValue<uint16_t>("installedOpenLimitTilt", installedOpenLimitTilt, 0U));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("installedOpenLimitTilt", installedOpenLimitTilt, 65535U));
        NextTest();
    }

    CHIP_ERROR Test2ReadTheRoOptionalAttributeDefaultInstalledClosedLimitTilt_37()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::InstalledClosedLimitTilt::TypeInfo>(
                this, OnSuccessCallback_37, OnFailureCallback_37, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_37(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_37(uint16_t installedClosedLimitTilt)
    {
        VerifyOrReturn(CheckConstraintType("installedClosedLimitTilt", "", "uint16"));
        VerifyOrReturn(CheckConstraintMinValue<uint16_t>("installedClosedLimitTilt", installedClosedLimitTilt, 0U));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("installedClosedLimitTilt", installedClosedLimitTilt, 65535U));
        NextTest();
    }

    CHIP_ERROR Test3aWriteAValueIntoTheRoOptionalAttributeInstalledClosedLimitTilt_38()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t installedClosedLimitTiltArgument;
        installedClosedLimitTiltArgument = 255U;

        ReturnErrorOnFailure(
            cluster.WriteAttribute<chip::app::Clusters::WindowCovering::Attributes::InstalledClosedLimitTilt::TypeInfo>(
                installedClosedLimitTiltArgument, this, OnSuccessCallback_38, OnFailureCallback_38));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_38(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_38() { ThrowSuccessResponse(); }

    CHIP_ERROR Test3bReadsBackTheRoOptionalAttributeInstalledClosedLimitTilt_39()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::InstalledClosedLimitTilt::TypeInfo>(
                this, OnSuccessCallback_39, OnFailureCallback_39, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_39(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_39(uint16_t installedClosedLimitTilt)
    {
        VerifyOrReturn(CheckConstraintType("installedClosedLimitTilt", "", "uint16"));
        VerifyOrReturn(CheckConstraintMinValue<uint16_t>("installedClosedLimitTilt", installedClosedLimitTilt, 0U));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("installedClosedLimitTilt", installedClosedLimitTilt, 65535U));
        NextTest();
    }

    CHIP_ERROR Test4ReadTheRoMandatoryAttributeDefaultSafetyStatus_40()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::SafetyStatus::TypeInfo>(
            this, OnSuccessCallback_40, OnFailureCallback_40, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_40(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_40(uint16_t safetyStatus)
    {
        VerifyOrReturn(CheckConstraintType("safetyStatus", "", "map16"));
        VerifyOrReturn(CheckConstraintMinValue<uint16_t>("safetyStatus", safetyStatus, 0U));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("safetyStatus", safetyStatus, 2047U));
        NextTest();
    }

    CHIP_ERROR Test5aWriteAValueIntoTheRoMandatoryAttributeSafetyStatus_41()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t safetyStatusArgument;
        safetyStatusArgument = 4096U;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::WindowCovering::Attributes::SafetyStatus::TypeInfo>(
            safetyStatusArgument, this, OnSuccessCallback_41, OnFailureCallback_41));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_41(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_41() { ThrowSuccessResponse(); }

    CHIP_ERROR Test5bReadsBackTheRoMandatoryAttributeSafetyStatus_42()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::SafetyStatus::TypeInfo>(
            this, OnSuccessCallback_42, OnFailureCallback_42, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_42(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_42(uint16_t safetyStatus)
    {
        VerifyOrReturn(CheckConstraintType("safetyStatus", "", "map16"));
        VerifyOrReturn(CheckConstraintNotValue("safetyStatus", safetyStatus, 4096U));

        NextTest();
    }

    CHIP_ERROR Test4ReadTheRoOptionalAttributeDefaultCurrentPositionLift_43()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::CurrentPositionLift::TypeInfo>(
            this, OnSuccessCallback_43, OnFailureCallback_43, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_43(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_43(const chip::app::DataModel::Nullable<uint16_t> & currentPositionLift)
    {
        VerifyOrReturn(CheckConstraintType("currentPositionLift", "", "uint16"));
        VerifyOrReturn(CheckConstraintMinValue<uint16_t>("currentPositionLift", currentPositionLift, 0U));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("currentPositionLift", currentPositionLift, 65535U));
        NextTest();
    }

    CHIP_ERROR Test5aWriteAValueIntoTheRoOptionalAttributeCurrentPositionLift_44()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint16_t> currentPositionLiftArgument;
        currentPositionLiftArgument.SetNonNull();
        currentPositionLiftArgument.Value() = 255U;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::WindowCovering::Attributes::CurrentPositionLift::TypeInfo>(
            currentPositionLiftArgument, this, OnSuccessCallback_44, OnFailureCallback_44));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_44(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_44() { ThrowSuccessResponse(); }

    CHIP_ERROR Test5bReadsBackTheRoOptionalAttributeCurrentPositionLift_45()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::CurrentPositionLift::TypeInfo>(
            this, OnSuccessCallback_45, OnFailureCallback_45, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_45(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_45(const chip::app::DataModel::Nullable<uint16_t> & currentPositionLift)
    {
        VerifyOrReturn(CheckConstraintType("currentPositionLift", "", "uint16"));
        VerifyOrReturn(CheckConstraintMinValue<uint16_t>("currentPositionLift", currentPositionLift, 0U));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("currentPositionLift", currentPositionLift, 65535U));
        NextTest();
    }

    CHIP_ERROR Test4ReadTheRoOptionalAttributeDefaultCurrentPositionTilt_46()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::CurrentPositionTilt::TypeInfo>(
            this, OnSuccessCallback_46, OnFailureCallback_46, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_46(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_46(const chip::app::DataModel::Nullable<uint16_t> & currentPositionTilt)
    {
        VerifyOrReturn(CheckConstraintType("currentPositionTilt", "", "uint16"));
        VerifyOrReturn(CheckConstraintMinValue<uint16_t>("currentPositionTilt", currentPositionTilt, 0U));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("currentPositionTilt", currentPositionTilt, 65535U));
        NextTest();
    }

    CHIP_ERROR Test5aWriteAValueIntoTheRoOptionalAttributeCurrentPositionTilt_47()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint16_t> currentPositionTiltArgument;
        currentPositionTiltArgument.SetNonNull();
        currentPositionTiltArgument.Value() = 255U;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::WindowCovering::Attributes::CurrentPositionTilt::TypeInfo>(
            currentPositionTiltArgument, this, OnSuccessCallback_47, OnFailureCallback_47));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_47(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_47() { ThrowSuccessResponse(); }

    CHIP_ERROR Test5bReadsBackTheRoOptionalAttributeCurrentPositionTilt_48()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::CurrentPositionTilt::TypeInfo>(
            this, OnSuccessCallback_48, OnFailureCallback_48, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_48(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_48(const chip::app::DataModel::Nullable<uint16_t> & currentPositionTilt)
    {
        VerifyOrReturn(CheckConstraintType("currentPositionTilt", "", "uint16"));
        VerifyOrReturn(CheckConstraintMinValue<uint16_t>("currentPositionTilt", currentPositionTilt, 0U));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("currentPositionTilt", currentPositionTilt, 65535U));
        NextTest();
    }

    CHIP_ERROR Test4ReadTheRoOptionalAttributeDefaultCurrentPositionLiftPercentage_49()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::CurrentPositionLiftPercentage::TypeInfo>(
                this, OnSuccessCallback_49, OnFailureCallback_49, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_49(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_49(const chip::app::DataModel::Nullable<chip::Percent> & currentPositionLiftPercentage)
    {
        VerifyOrReturn(CheckConstraintType("currentPositionLiftPercentage", "", "Percent"));
        VerifyOrReturn(CheckConstraintMinValue<chip::Percent>("currentPositionLiftPercentage", currentPositionLiftPercentage, 0));
        VerifyOrReturn(CheckConstraintMaxValue<chip::Percent>("currentPositionLiftPercentage", currentPositionLiftPercentage, 100));
        NextTest();
    }

    CHIP_ERROR Test5aWriteAValueIntoTheRoOptionalAttributeCurrentPositionLiftPercentage_50()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<chip::Percent> currentPositionLiftPercentageArgument;
        currentPositionLiftPercentageArgument.SetNonNull();
        currentPositionLiftPercentageArgument.Value() = 200;

        ReturnErrorOnFailure(
            cluster.WriteAttribute<chip::app::Clusters::WindowCovering::Attributes::CurrentPositionLiftPercentage::TypeInfo>(
                currentPositionLiftPercentageArgument, this, OnSuccessCallback_50, OnFailureCallback_50));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_50(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_50() { ThrowSuccessResponse(); }

    CHIP_ERROR Test5bReadsBackTheRoOptionalAttributeCurrentPositionLiftPercentage_51()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::CurrentPositionLiftPercentage::TypeInfo>(
                this, OnSuccessCallback_51, OnFailureCallback_51, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_51(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_51(const chip::app::DataModel::Nullable<chip::Percent> & currentPositionLiftPercentage)
    {
        VerifyOrReturn(CheckConstraintType("currentPositionLiftPercentage", "", "Percent"));
        VerifyOrReturn(CheckConstraintNotValue("currentPositionLiftPercentage", currentPositionLiftPercentage, 200));

        NextTest();
    }

    CHIP_ERROR Test4ReadTheRoOptionalAttributeDefaultCurrentPositionTiltPercentage_52()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::CurrentPositionTiltPercentage::TypeInfo>(
                this, OnSuccessCallback_52, OnFailureCallback_52, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_52(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_52(const chip::app::DataModel::Nullable<chip::Percent> & currentPositionTiltPercentage)
    {
        VerifyOrReturn(CheckConstraintType("currentPositionTiltPercentage", "", "Percent"));
        VerifyOrReturn(CheckConstraintMinValue<chip::Percent>("currentPositionTiltPercentage", currentPositionTiltPercentage, 0));
        VerifyOrReturn(CheckConstraintMaxValue<chip::Percent>("currentPositionTiltPercentage", currentPositionTiltPercentage, 100));
        NextTest();
    }

    CHIP_ERROR Test5aWriteAValueIntoTheRoOptionalAttributeCurrentPositionTiltPercentage_53()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<chip::Percent> currentPositionTiltPercentageArgument;
        currentPositionTiltPercentageArgument.SetNonNull();
        currentPositionTiltPercentageArgument.Value() = 200;

        ReturnErrorOnFailure(
            cluster.WriteAttribute<chip::app::Clusters::WindowCovering::Attributes::CurrentPositionTiltPercentage::TypeInfo>(
                currentPositionTiltPercentageArgument, this, OnSuccessCallback_53, OnFailureCallback_53));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_53(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_53() { ThrowSuccessResponse(); }

    CHIP_ERROR Test5bReadsBackTheRoOptionalAttributeCurrentPositionTiltPercentage_54()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::CurrentPositionTiltPercentage::TypeInfo>(
                this, OnSuccessCallback_54, OnFailureCallback_54, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_54(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_54(const chip::app::DataModel::Nullable<chip::Percent> & currentPositionTiltPercentage)
    {
        VerifyOrReturn(CheckConstraintType("currentPositionTiltPercentage", "", "Percent"));
        VerifyOrReturn(CheckConstraintNotValue("currentPositionTiltPercentage", currentPositionTiltPercentage, 200));

        NextTest();
    }
};

class Test_TC_WNCV_2_2Suite : public TestCommand
{
public:
    Test_TC_WNCV_2_2Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_WNCV_2_2", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_WNCV_2_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_WNCV_2_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_WNCV_2_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }
};

class Test_TC_WNCV_2_4Suite : public TestCommand
{
public:
    Test_TC_WNCV_2_4Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_WNCV_2_4", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_WNCV_2_4Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_WNCV_2_4\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_WNCV_2_4\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Reads Type attribute from DUT\n");
            if (ShouldSkip("A_TYPE"))
            {
                NextTest();
                return;
            }
            err = TestReadsTypeAttributeFromDut_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Reads Type attribute constraints\n");
            if (ShouldSkip("A_TYPE"))
            {
                NextTest();
                return;
            }
            err = TestReadsTypeAttributeConstraints_2();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 3;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_1(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_2_4Suite *>(context))->OnFailureResponse_1(error);
    }

    static void OnSuccessCallback_1(void * context, uint8_t type)
    {
        (static_cast<Test_TC_WNCV_2_4Suite *>(context))->OnSuccessResponse_1(type);
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_2_4Suite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context, uint8_t type)
    {
        (static_cast<Test_TC_WNCV_2_4Suite *>(context))->OnSuccessResponse_2(type);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestReadsTypeAttributeFromDut_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::Type::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1(uint8_t type)
    {
        VerifyOrReturn(CheckValue("type", type, 0));

        NextTest();
    }

    CHIP_ERROR TestReadsTypeAttributeConstraints_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::Type::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2(uint8_t type)
    {
        VerifyOrReturn(CheckConstraintType("type", "", "enum8"));
        VerifyOrReturn(CheckConstraintMinValue<uint8_t>("type", type, 0));
        VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("type", type, 9));
        NextTest();
    }
};

class Test_TC_WNCV_2_5Suite : public TestCommand
{
public:
    Test_TC_WNCV_2_5Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_WNCV_2_5", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_WNCV_2_5Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_WNCV_2_5\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_WNCV_2_5\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Reads EndProductType attribute from DUT\n");
            if (ShouldSkip("A_ENDPRODUCTTYPE"))
            {
                NextTest();
                return;
            }
            err = TestReadsEndProductTypeAttributeFromDut_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Reads EndProductType attribute constraints from DUT\n");
            if (ShouldSkip("A_ENDPRODUCTTYPE"))
            {
                NextTest();
                return;
            }
            err = TestReadsEndProductTypeAttributeConstraintsFromDut_2();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 3;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_1(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_2_5Suite *>(context))->OnFailureResponse_1(error);
    }

    static void OnSuccessCallback_1(void * context, uint8_t endProductType)
    {
        (static_cast<Test_TC_WNCV_2_5Suite *>(context))->OnSuccessResponse_1(endProductType);
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_2_5Suite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context, uint8_t endProductType)
    {
        (static_cast<Test_TC_WNCV_2_5Suite *>(context))->OnSuccessResponse_2(endProductType);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestReadsEndProductTypeAttributeFromDut_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::EndProductType::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1(uint8_t endProductType)
    {
        VerifyOrReturn(CheckValue("endProductType", endProductType, 0));

        NextTest();
    }

    CHIP_ERROR TestReadsEndProductTypeAttributeConstraintsFromDut_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::EndProductType::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2(uint8_t endProductType)
    {
        VerifyOrReturn(CheckConstraintType("endProductType", "", "enum8"));
        VerifyOrReturn(CheckConstraintMinValue<uint8_t>("endProductType", endProductType, 0));
        VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("endProductType", endProductType, 23));
        NextTest();
    }
};

class Test_TC_WNCV_3_1Suite : public TestCommand
{
public:
    Test_TC_WNCV_3_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_WNCV_3_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_WNCV_3_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_WNCV_3_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_WNCV_3_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : 0: Wait for the commissioned device to be retrieved\n");
            err = Test0WaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 1 : 1a: TH sends DownOrClose command to preposition the DUT in the opposite direction\n");
            err = Test1aThSendsDownOrCloseCommandToPrepositionTheDutInTheOppositeDirection_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : 1b: TH Waits for 10 seconds movement(s) on the device\n");
            err = Test1bThWaitsFor10SecondsMovementsOnTheDevice_2();
            break;
        case 3:
            ChipLogProgress(chipTool,
                            " ***** Test Step 3 : 1c: If (PA & LF) TH reads CurrentPositionLiftPercent100ths attribute from DUT\n");
            if (ShouldSkip("WNCV_LF && WNCV_PA_LF"))
            {
                NextTest();
                return;
            }
            err = Test1cIfPaLfThReadsCurrentPositionLiftPercent100thsAttributeFromDut_3();
            break;
        case 4:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 4 : 1d: If (PA & LF) TH reads CurrentPositionLiftPercentage optional attribute from DUT\n");
            if (ShouldSkip("WNCV_LF && WNCV_PA_LF && A_CURRENTPOSITIONLIFTPERCENTAGE"))
            {
                NextTest();
                return;
            }
            err = Test1dIfPaLfThReadsCurrentPositionLiftPercentageOptionalAttributeFromDut_4();
            break;
        case 5:
            ChipLogProgress(chipTool,
                            " ***** Test Step 5 : 1e: If (PA & TL) TH reads CurrentPositionTiltPercent100ths attribute from DUT\n");
            if (ShouldSkip("WNCV_TL && WNCV_PA_TL"))
            {
                NextTest();
                return;
            }
            err = Test1eIfPaTlThReadsCurrentPositionTiltPercent100thsAttributeFromDut_5();
            break;
        case 6:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 6 : 1f: If (PA & TL) TH reads CurrentPositionTiltPercentage optional attribute from DUT\n");
            if (ShouldSkip("WNCV_TL && WNCV_PA_TL && A_CURRENTPOSITIONTILTPERCENTAGE"))
            {
                NextTest();
                return;
            }
            err = Test1fIfPaTlThReadsCurrentPositionTiltPercentageOptionalAttributeFromDut_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Report: 2: Subscribe to DUT reports on OperationalStatus attribute\n");
            err = TestReport2SubscribeToDutReportsOnOperationalStatusAttribute_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : 2: Subscribe to DUT reports on OperationalStatus attribute\n");
            err = Test2SubscribeToDutReportsOnOperationalStatusAttribute_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : 2a: TH sends UpOrOpen command to DUT\n");
            err = Test2aThSendsUpOrOpenCommandToDut_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : 2b: DUT updates its attributes\n");
            err = Test2bDutUpdatesItsAttributes_10();
            break;
        case 11:
            ChipLogProgress(chipTool,
                            " ***** Test Step 11 : 2c: If (PA & LF) TH reads TargetPositionLiftPercent100ths attribute from DUT\n");
            if (ShouldSkip("WNCV_LF && WNCV_PA_LF"))
            {
                NextTest();
                return;
            }
            err = Test2cIfPaLfThReadsTargetPositionLiftPercent100thsAttributeFromDut_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : 2e: TH leave the device moving for 2 seconds\n");
            err = Test2eThLeaveTheDeviceMovingFor2Seconds_12();
            break;
        case 13:
            ChipLogProgress(chipTool,
                            " ***** Test Step 13 : 3a1: Verify DUT reports OperationalStatus attribute to TH after a UpOrOpen\n");
            err = Test3a1VerifyDutReportsOperationalStatusAttributeToThAfterAUpOrOpen_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : 3a2: DUT updates its attributes\n");
            err = Test3a2DutUpdatesItsAttributes_14();
            break;
        case 15:
            ChipLogProgress(
                chipTool, " ***** Test Step 15 : 3b: If (PA & LF) TH reads CurrentPositionLiftPercent100ths attribute from DUT\n");
            if (ShouldSkip("WNCV_LF && WNCV_PA_LF"))
            {
                NextTest();
                return;
            }
            err = Test3bIfPaLfThReadsCurrentPositionLiftPercent100thsAttributeFromDut_15();
            break;
        case 16:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 16 : 3c: If (PA & LF) TH reads CurrentPositionLiftPercentage optional attribute from DUT\n");
            if (ShouldSkip("WNCV_LF && WNCV_PA_LF && A_CURRENTPOSITIONLIFTPERCENTAGE"))
            {
                NextTest();
                return;
            }
            err = Test3cIfPaLfThReadsCurrentPositionLiftPercentageOptionalAttributeFromDut_16();
            break;
        case 17:
            ChipLogProgress(
                chipTool, " ***** Test Step 17 : 3d: If (PA & TL) TH reads CurrentPositionTiltPercent100ths attribute from DUT\n");
            if (ShouldSkip("WNCV_TL && WNCV_PA_TL"))
            {
                NextTest();
                return;
            }
            err = Test3dIfPaTlThReadsCurrentPositionTiltPercent100thsAttributeFromDut_17();
            break;
        case 18:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 18 : 3e: If (PA & LF) TH reads CurrentPositionTiltPercentage optional attribute from DUT\n");
            if (ShouldSkip("WNCV_TL && WNCV_PA_TL && A_CURRENTPOSITIONTILTPERCENTAGE"))
            {
                NextTest();
                return;
            }
            err = Test3eIfPaLfThReadsCurrentPositionTiltPercentageOptionalAttributeFromDut_18();
            break;
        case 19:
            ChipLogProgress(chipTool, " ***** Test Step 19 : 4a: TH sends a StopMotion command to DUT\n");
            err = Test4aThSendsAStopMotionCommandToDut_19();
            break;
        case 20:
            ChipLogProgress(chipTool,
                            " ***** Test Step 20 : 4b: TH waits for 3 seconds the end of inertial movement(s) on the device\n");
            err = Test4bThWaitsFor3SecondsTheEndOfInertialMovementsOnTheDevice_20();
            break;
        case 21:
            ChipLogProgress(chipTool,
                            " ***** Test Step 21 : 4c: Verify DUT update OperationalStatus attribute to TH after a StopMotion\n");
            err = Test4cVerifyDutUpdateOperationalStatusAttributeToThAfterAStopMotion_21();
            break;
        case 22:
            ChipLogProgress(chipTool, " ***** Test Step 22 : 5a: TH waits for x seconds attributes update on the device\n");
            err = Test5aThWaitsForXSecondsAttributesUpdateOnTheDevice_22();
            break;
        case 23:
            ChipLogProgress(chipTool,
                            " ***** Test Step 23 : 5b: If (PA & LF) TH reads TargetPositionLiftPercent100ths attribute from DUT\n");
            if (ShouldSkip("WNCV_LF && WNCV_PA_LF"))
            {
                NextTest();
                return;
            }
            err = Test5bIfPaLfThReadsTargetPositionLiftPercent100thsAttributeFromDut_23();
            break;
        case 24:
            ChipLogProgress(chipTool,
                            " ***** Test Step 24 : 5c: If (PA & TL) TH reads TargetPositionTiltPercent100ths attribute from DUT\n");
            if (ShouldSkip("WNCV_TL && WNCV_PA_TL"))
            {
                NextTest();
                return;
            }
            err = Test5cIfPaTlThReadsTargetPositionTiltPercent100thsAttributeFromDut_24();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 25;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    typedef void (*Test_Test_TC_WNCV_3_1_OperationalStatus_ReportCallback)(void * context, uint8_t value);
    Test_Test_TC_WNCV_3_1_OperationalStatus_ReportCallback mTest_Test_TC_WNCV_3_1_OperationalStatus_Reported = nullptr;

    static void OnFailureCallback_3(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_3_1Suite *>(context))->OnFailureResponse_3(error);
    }

    static void OnSuccessCallback_3(void * context,
                                    const chip::app::DataModel::Nullable<chip::Percent100ths> & currentPositionLiftPercent100ths)
    {
        (static_cast<Test_TC_WNCV_3_1Suite *>(context))->OnSuccessResponse_3(currentPositionLiftPercent100ths);
    }

    static void OnFailureCallback_4(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_3_1Suite *>(context))->OnFailureResponse_4(error);
    }

    static void OnSuccessCallback_4(void * context,
                                    const chip::app::DataModel::Nullable<chip::Percent> & currentPositionLiftPercentage)
    {
        (static_cast<Test_TC_WNCV_3_1Suite *>(context))->OnSuccessResponse_4(currentPositionLiftPercentage);
    }

    static void OnFailureCallback_5(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_3_1Suite *>(context))->OnFailureResponse_5(error);
    }

    static void OnSuccessCallback_5(void * context,
                                    const chip::app::DataModel::Nullable<chip::Percent100ths> & currentPositionTiltPercent100ths)
    {
        (static_cast<Test_TC_WNCV_3_1Suite *>(context))->OnSuccessResponse_5(currentPositionTiltPercent100ths);
    }

    static void OnFailureCallback_6(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_3_1Suite *>(context))->OnFailureResponse_6(error);
    }

    static void OnSuccessCallback_6(void * context,
                                    const chip::app::DataModel::Nullable<chip::Percent> & currentPositionTiltPercentage)
    {
        (static_cast<Test_TC_WNCV_3_1Suite *>(context))->OnSuccessResponse_6(currentPositionTiltPercentage);
    }

    static void OnFailureCallback_7(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_3_1Suite *>(context))->OnFailureResponse_7(error);
    }

    static void OnSuccessCallback_7(void * context, uint8_t operationalStatus)
    {
        (static_cast<Test_TC_WNCV_3_1Suite *>(context))->OnSuccessResponse_7(operationalStatus);
    }

    bool mReceivedReport_7 = false;

    static void OnFailureCallback_8(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_3_1Suite *>(context))->OnFailureResponse_8(error);
    }

    static void OnSuccessCallback_8(void * context, uint8_t operationalStatus)
    {
        (static_cast<Test_TC_WNCV_3_1Suite *>(context))->OnSuccessResponse_8(operationalStatus);
    }

    static void OnSubscriptionEstablished_8(void * context)
    {
        (static_cast<Test_TC_WNCV_3_1Suite *>(context))->OnSubscriptionEstablishedResponse_8();
    }

    static void OnFailureCallback_11(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_3_1Suite *>(context))->OnFailureResponse_11(error);
    }

    static void OnSuccessCallback_11(void * context,
                                     const chip::app::DataModel::Nullable<chip::Percent100ths> & targetPositionLiftPercent100ths)
    {
        (static_cast<Test_TC_WNCV_3_1Suite *>(context))->OnSuccessResponse_11(targetPositionLiftPercent100ths);
    }

    static void OnFailureCallback_13(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_3_1Suite *>(context))->OnFailureResponse_13(error);
    }

    static void OnSuccessCallback_13(void * context, uint8_t operationalStatus)
    {
        (static_cast<Test_TC_WNCV_3_1Suite *>(context))->OnSuccessResponse_13(operationalStatus);
    }

    bool mReceivedReport_13 = false;

    static void OnFailureCallback_15(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_3_1Suite *>(context))->OnFailureResponse_15(error);
    }

    static void OnSuccessCallback_15(void * context,
                                     const chip::app::DataModel::Nullable<chip::Percent100ths> & currentPositionLiftPercent100ths)
    {
        (static_cast<Test_TC_WNCV_3_1Suite *>(context))->OnSuccessResponse_15(currentPositionLiftPercent100ths);
    }

    static void OnFailureCallback_16(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_3_1Suite *>(context))->OnFailureResponse_16(error);
    }

    static void OnSuccessCallback_16(void * context,
                                     const chip::app::DataModel::Nullable<chip::Percent> & currentPositionLiftPercentage)
    {
        (static_cast<Test_TC_WNCV_3_1Suite *>(context))->OnSuccessResponse_16(currentPositionLiftPercentage);
    }

    static void OnFailureCallback_17(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_3_1Suite *>(context))->OnFailureResponse_17(error);
    }

    static void OnSuccessCallback_17(void * context,
                                     const chip::app::DataModel::Nullable<chip::Percent100ths> & currentPositionTiltPercent100ths)
    {
        (static_cast<Test_TC_WNCV_3_1Suite *>(context))->OnSuccessResponse_17(currentPositionTiltPercent100ths);
    }

    static void OnFailureCallback_18(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_3_1Suite *>(context))->OnFailureResponse_18(error);
    }

    static void OnSuccessCallback_18(void * context,
                                     const chip::app::DataModel::Nullable<chip::Percent> & currentPositionTiltPercentage)
    {
        (static_cast<Test_TC_WNCV_3_1Suite *>(context))->OnSuccessResponse_18(currentPositionTiltPercentage);
    }

    static void OnFailureCallback_21(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_3_1Suite *>(context))->OnFailureResponse_21(error);
    }

    static void OnSuccessCallback_21(void * context, uint8_t operationalStatus)
    {
        (static_cast<Test_TC_WNCV_3_1Suite *>(context))->OnSuccessResponse_21(operationalStatus);
    }

    static void OnFailureCallback_23(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_3_1Suite *>(context))->OnFailureResponse_23(error);
    }

    static void OnSuccessCallback_23(void * context,
                                     const chip::app::DataModel::Nullable<chip::Percent100ths> & targetPositionLiftPercent100ths)
    {
        (static_cast<Test_TC_WNCV_3_1Suite *>(context))->OnSuccessResponse_23(targetPositionLiftPercent100ths);
    }

    static void OnFailureCallback_24(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_3_1Suite *>(context))->OnFailureResponse_24(error);
    }

    static void OnSuccessCallback_24(void * context,
                                     const chip::app::DataModel::Nullable<chip::Percent100ths> & targetPositionTiltPercent100ths)
    {
        (static_cast<Test_TC_WNCV_3_1Suite *>(context))->OnSuccessResponse_24(targetPositionTiltPercent100ths);
    }

    //
    // Tests methods
    //

    CHIP_ERROR Test0WaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR Test1aThSendsDownOrCloseCommandToPrepositionTheDutInTheOppositeDirection_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::WindowCovering::Commands::DownOrClose::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_WNCV_3_1Suite *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_WNCV_3_1Suite *>(context))->OnFailureResponse_1(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR Test1bThWaitsFor10SecondsMovementsOnTheDevice_2()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForMs(10000);
    }

    CHIP_ERROR Test1cIfPaLfThReadsCurrentPositionLiftPercent100thsAttributeFromDut_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::CurrentPositionLiftPercent100ths::TypeInfo>(
                this, OnSuccessCallback_3, OnFailureCallback_3, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3(const chip::app::DataModel::Nullable<chip::Percent100ths> & currentPositionLiftPercent100ths)
    {
        VerifyOrReturn(CheckConstraintType("currentPositionLiftPercent100ths", "", "uint16"));
        VerifyOrReturn(
            CheckConstraintMinValue<chip::Percent100ths>("currentPositionLiftPercent100ths", currentPositionLiftPercent100ths, 1U));
        VerifyOrReturn(CheckConstraintMaxValue<chip::Percent100ths>("currentPositionLiftPercent100ths",
                                                                    currentPositionLiftPercent100ths, 10000U));
        NextTest();
    }

    CHIP_ERROR Test1dIfPaLfThReadsCurrentPositionLiftPercentageOptionalAttributeFromDut_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::CurrentPositionLiftPercentage::TypeInfo>(
                this, OnSuccessCallback_4, OnFailureCallback_4, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_4(const chip::app::DataModel::Nullable<chip::Percent> & currentPositionLiftPercentage)
    {
        VerifyOrReturn(CheckConstraintType("currentPositionLiftPercentage", "", "uint8"));
        VerifyOrReturn(CheckConstraintMinValue<chip::Percent>("currentPositionLiftPercentage", currentPositionLiftPercentage, 1));
        VerifyOrReturn(CheckConstraintMaxValue<chip::Percent>("currentPositionLiftPercentage", currentPositionLiftPercentage, 100));
        NextTest();
    }

    CHIP_ERROR Test1eIfPaTlThReadsCurrentPositionTiltPercent100thsAttributeFromDut_5()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::CurrentPositionTiltPercent100ths::TypeInfo>(
                this, OnSuccessCallback_5, OnFailureCallback_5, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_5(const chip::app::DataModel::Nullable<chip::Percent100ths> & currentPositionTiltPercent100ths)
    {
        VerifyOrReturn(CheckConstraintType("currentPositionTiltPercent100ths", "", "uint16"));
        VerifyOrReturn(
            CheckConstraintMinValue<chip::Percent100ths>("currentPositionTiltPercent100ths", currentPositionTiltPercent100ths, 1U));
        VerifyOrReturn(CheckConstraintMaxValue<chip::Percent100ths>("currentPositionTiltPercent100ths",
                                                                    currentPositionTiltPercent100ths, 10000U));
        NextTest();
    }

    CHIP_ERROR Test1fIfPaTlThReadsCurrentPositionTiltPercentageOptionalAttributeFromDut_6()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::CurrentPositionTiltPercentage::TypeInfo>(
                this, OnSuccessCallback_6, OnFailureCallback_6, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_6(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_6(const chip::app::DataModel::Nullable<chip::Percent> & currentPositionTiltPercentage)
    {
        VerifyOrReturn(CheckConstraintType("currentPositionTiltPercentage", "", "uint8"));
        VerifyOrReturn(CheckConstraintMinValue<chip::Percent>("currentPositionTiltPercentage", currentPositionTiltPercentage, 1));
        VerifyOrReturn(CheckConstraintMaxValue<chip::Percent>("currentPositionTiltPercentage", currentPositionTiltPercentage, 100));
        NextTest();
    }

    CHIP_ERROR TestReport2SubscribeToDutReportsOnOperationalStatusAttribute_7()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        mTest_Test_TC_WNCV_3_1_OperationalStatus_Reported = OnSuccessCallback_7;
        return WaitForMs(0);
    }

    void OnFailureResponse_7(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_7(uint8_t operationalStatus)
    {
        mReceivedReport_7 = true;
        VerifyOrReturn(CheckConstraintType("operationalStatus", "", "map8"));
    }

    CHIP_ERROR Test2SubscribeToDutReportsOnOperationalStatusAttribute_8()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t minIntervalArgument;
        minIntervalArgument = 4U;
        uint16_t maxIntervalArgument;
        maxIntervalArgument = 5U;

        ReturnErrorOnFailure(
            cluster.SubscribeAttribute<chip::app::Clusters::WindowCovering::Attributes::OperationalStatus::TypeInfo>(
                this, OnSuccessCallback_8, OnFailureCallback_8, minIntervalArgument, maxIntervalArgument,
                OnSubscriptionEstablished_8, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_8(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_8(uint8_t value)
    {
        if (mTest_Test_TC_WNCV_3_1_OperationalStatus_Reported)
        {
            auto callback                                     = mTest_Test_TC_WNCV_3_1_OperationalStatus_Reported;
            mTest_Test_TC_WNCV_3_1_OperationalStatus_Reported = nullptr;
            callback(this, value);
        }
    }

    void OnSubscriptionEstablishedResponse_8()
    {
        VerifyOrReturn(mReceivedReport_7, Exit("Initial report not received!"));
        NextTest();
    }

    CHIP_ERROR Test2aThSendsUpOrOpenCommandToDut_9()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::WindowCovering::Commands::UpOrOpen::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_WNCV_3_1Suite *>(context))->OnSuccessResponse_9();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_WNCV_3_1Suite *>(context))->OnFailureResponse_9(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_9(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_9() { NextTest(); }

    CHIP_ERROR Test2bDutUpdatesItsAttributes_10()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForMs(100);
    }

    CHIP_ERROR Test2cIfPaLfThReadsTargetPositionLiftPercent100thsAttributeFromDut_11()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::TargetPositionLiftPercent100ths::TypeInfo>(
                this, OnSuccessCallback_11, OnFailureCallback_11, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_11(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_11(const chip::app::DataModel::Nullable<chip::Percent100ths> & targetPositionLiftPercent100ths)
    {
        VerifyOrReturn(CheckValueNonNull("targetPositionLiftPercent100ths", targetPositionLiftPercent100ths));
        VerifyOrReturn(CheckValue("targetPositionLiftPercent100ths.Value()", targetPositionLiftPercent100ths.Value(), 0U));

        NextTest();
    }

    CHIP_ERROR Test2eThLeaveTheDeviceMovingFor2Seconds_12()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForMs(2000);
    }

    CHIP_ERROR Test3a1VerifyDutReportsOperationalStatusAttributeToThAfterAUpOrOpen_13()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        mTest_Test_TC_WNCV_3_1_OperationalStatus_Reported = OnSuccessCallback_13;
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_13(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_13(uint8_t operationalStatus)
    {
        mReceivedReport_13 = true;
        VerifyOrReturn(CheckConstraintType("operationalStatus", "", "map8"));
        VerifyOrReturn(CheckConstraintMinValue<uint8_t>("operationalStatus", operationalStatus, 5));
        VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("operationalStatus", operationalStatus, 21));
        NextTest();
    }

    CHIP_ERROR Test3a2DutUpdatesItsAttributes_14()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForMs(2000);
    }

    CHIP_ERROR Test3bIfPaLfThReadsCurrentPositionLiftPercent100thsAttributeFromDut_15()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::CurrentPositionLiftPercent100ths::TypeInfo>(
                this, OnSuccessCallback_15, OnFailureCallback_15, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_15(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_15(const chip::app::DataModel::Nullable<chip::Percent100ths> & currentPositionLiftPercent100ths)
    {
        VerifyOrReturn(CheckConstraintType("currentPositionLiftPercent100ths", "", "uint16"));
        VerifyOrReturn(
            CheckConstraintMinValue<chip::Percent100ths>("currentPositionLiftPercent100ths", currentPositionLiftPercent100ths, 0U));
        VerifyOrReturn(CheckConstraintMaxValue<chip::Percent100ths>("currentPositionLiftPercent100ths",
                                                                    currentPositionLiftPercent100ths, 9999U));
        NextTest();
    }

    CHIP_ERROR Test3cIfPaLfThReadsCurrentPositionLiftPercentageOptionalAttributeFromDut_16()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::CurrentPositionLiftPercentage::TypeInfo>(
                this, OnSuccessCallback_16, OnFailureCallback_16, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_16(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_16(const chip::app::DataModel::Nullable<chip::Percent> & currentPositionLiftPercentage)
    {
        VerifyOrReturn(CheckConstraintType("currentPositionLiftPercentage", "", "uint8"));
        VerifyOrReturn(CheckConstraintMinValue<chip::Percent>("currentPositionLiftPercentage", currentPositionLiftPercentage, 0));
        VerifyOrReturn(CheckConstraintMaxValue<chip::Percent>("currentPositionLiftPercentage", currentPositionLiftPercentage, 99));
        NextTest();
    }

    CHIP_ERROR Test3dIfPaTlThReadsCurrentPositionTiltPercent100thsAttributeFromDut_17()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::CurrentPositionTiltPercent100ths::TypeInfo>(
                this, OnSuccessCallback_17, OnFailureCallback_17, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_17(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_17(const chip::app::DataModel::Nullable<chip::Percent100ths> & currentPositionTiltPercent100ths)
    {
        VerifyOrReturn(CheckConstraintType("currentPositionTiltPercent100ths", "", "uint16"));
        VerifyOrReturn(
            CheckConstraintMinValue<chip::Percent100ths>("currentPositionTiltPercent100ths", currentPositionTiltPercent100ths, 0U));
        VerifyOrReturn(CheckConstraintMaxValue<chip::Percent100ths>("currentPositionTiltPercent100ths",
                                                                    currentPositionTiltPercent100ths, 9999U));
        NextTest();
    }

    CHIP_ERROR Test3eIfPaLfThReadsCurrentPositionTiltPercentageOptionalAttributeFromDut_18()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::CurrentPositionTiltPercentage::TypeInfo>(
                this, OnSuccessCallback_18, OnFailureCallback_18, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_18(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_18(const chip::app::DataModel::Nullable<chip::Percent> & currentPositionTiltPercentage)
    {
        VerifyOrReturn(CheckConstraintType("currentPositionTiltPercentage", "", "uint8"));
        VerifyOrReturn(CheckConstraintMinValue<chip::Percent>("currentPositionTiltPercentage", currentPositionTiltPercentage, 0));
        VerifyOrReturn(CheckConstraintMaxValue<chip::Percent>("currentPositionTiltPercentage", currentPositionTiltPercentage, 99));
        NextTest();
    }

    CHIP_ERROR Test4aThSendsAStopMotionCommandToDut_19()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::WindowCovering::Commands::StopMotion::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_WNCV_3_1Suite *>(context))->OnSuccessResponse_19();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_WNCV_3_1Suite *>(context))->OnFailureResponse_19(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_19(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_19() { NextTest(); }

    CHIP_ERROR Test4bThWaitsFor3SecondsTheEndOfInertialMovementsOnTheDevice_20()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForMs(3000);
    }

    CHIP_ERROR Test4cVerifyDutUpdateOperationalStatusAttributeToThAfterAStopMotion_21()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::OperationalStatus::TypeInfo>(
            this, OnSuccessCallback_21, OnFailureCallback_21, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_21(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_21(uint8_t operationalStatus)
    {
        VerifyOrReturn(CheckValue("operationalStatus", operationalStatus, 0));

        NextTest();
    }

    CHIP_ERROR Test5aThWaitsForXSecondsAttributesUpdateOnTheDevice_22()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForMs(1000);
    }

    CHIP_ERROR Test5bIfPaLfThReadsTargetPositionLiftPercent100thsAttributeFromDut_23()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::TargetPositionLiftPercent100ths::TypeInfo>(
                this, OnSuccessCallback_23, OnFailureCallback_23, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_23(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_23(const chip::app::DataModel::Nullable<chip::Percent100ths> & targetPositionLiftPercent100ths)
    {
        VerifyOrReturn(CheckConstraintType("targetPositionLiftPercent100ths", "", "uint16"));
        VerifyOrReturn(
            CheckConstraintMinValue<chip::Percent100ths>("targetPositionLiftPercent100ths", targetPositionLiftPercent100ths, 0U));
        VerifyOrReturn(CheckConstraintMaxValue<chip::Percent100ths>("targetPositionLiftPercent100ths",
                                                                    targetPositionLiftPercent100ths, 9999U));
        NextTest();
    }

    CHIP_ERROR Test5cIfPaTlThReadsTargetPositionTiltPercent100thsAttributeFromDut_24()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::TargetPositionTiltPercent100ths::TypeInfo>(
                this, OnSuccessCallback_24, OnFailureCallback_24, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_24(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_24(const chip::app::DataModel::Nullable<chip::Percent100ths> & targetPositionTiltPercent100ths)
    {
        VerifyOrReturn(CheckConstraintType("targetPositionTiltPercent100ths", "", "uint16"));
        VerifyOrReturn(
            CheckConstraintMinValue<chip::Percent100ths>("targetPositionTiltPercent100ths", targetPositionTiltPercent100ths, 0U));
        VerifyOrReturn(CheckConstraintMaxValue<chip::Percent100ths>("targetPositionTiltPercent100ths",
                                                                    targetPositionTiltPercent100ths, 9999U));
        NextTest();
    }
};

class Test_TC_WNCV_3_2Suite : public TestCommand
{
public:
    Test_TC_WNCV_3_2Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_WNCV_3_2", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_WNCV_3_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_WNCV_3_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_WNCV_3_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : 0: Wait for the commissioned device to be retrieved\n");
            err = Test0WaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(
                chipTool, " ***** Test Step 1 : 1a: TH sends UpOrOpen command to preposition the DUT in the opposite direction\n");
            err = Test1aThSendsUpOrOpenCommandToPrepositionTheDutInTheOppositeDirection_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : 1b: TH Waits for 10 seconds movement(s) on the device\n");
            err = Test1bThWaitsFor10SecondsMovementsOnTheDevice_2();
            break;
        case 3:
            ChipLogProgress(chipTool,
                            " ***** Test Step 3 : 1c: If (PA & LF) TH reads CurrentPositionLiftPercent100ths attribute from DUT\n");
            if (ShouldSkip("WNCV_LF && WNCV_PA_LF"))
            {
                NextTest();
                return;
            }
            err = Test1cIfPaLfThReadsCurrentPositionLiftPercent100thsAttributeFromDut_3();
            break;
        case 4:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 4 : 1d: If (PA & LF) TH reads CurrentPositionLiftPercentage optional attribute from DUT\n");
            if (ShouldSkip("WNCV_LF && WNCV_PA_LF && A_CURRENTPOSITIONLIFTPERCENTAGE"))
            {
                NextTest();
                return;
            }
            err = Test1dIfPaLfThReadsCurrentPositionLiftPercentageOptionalAttributeFromDut_4();
            break;
        case 5:
            ChipLogProgress(chipTool,
                            " ***** Test Step 5 : 1e: If (PA & TL) TH reads CurrentPositionTiltPercent100ths attribute from DUT\n");
            if (ShouldSkip("WNCV_TL && WNCV_PA_TL"))
            {
                NextTest();
                return;
            }
            err = Test1eIfPaTlThReadsCurrentPositionTiltPercent100thsAttributeFromDut_5();
            break;
        case 6:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 6 : 1f: If (PA & TL) TH reads CurrentPositionTiltPercentage optional attribute from DUT\n");
            if (ShouldSkip("WNCV_TL && WNCV_PA_TL && A_CURRENTPOSITIONTILTPERCENTAGE"))
            {
                NextTest();
                return;
            }
            err = Test1fIfPaTlThReadsCurrentPositionTiltPercentageOptionalAttributeFromDut_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Report: 2: Subscribe to DUT reports on OperationalStatus attribute\n");
            err = TestReport2SubscribeToDutReportsOnOperationalStatusAttribute_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : 2: Subscribe to DUT reports on OperationalStatus attribute\n");
            err = Test2SubscribeToDutReportsOnOperationalStatusAttribute_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : 2a: TH sends DownOrClose command to DUT\n");
            err = Test2aThSendsDownOrCloseCommandToDut_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : 2b: DUT updates its attributes\n");
            err = Test2bDutUpdatesItsAttributes_10();
            break;
        case 11:
            ChipLogProgress(chipTool,
                            " ***** Test Step 11 : 2c: If (PA & LF) TH reads TargetPositionLiftPercent100ths attribute from DUT\n");
            if (ShouldSkip("WNCV_LF && WNCV_PA_LF"))
            {
                NextTest();
                return;
            }
            err = Test2cIfPaLfThReadsTargetPositionLiftPercent100thsAttributeFromDut_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : 2e: TH leave the device moving for 2 seconds\n");
            err = Test2eThLeaveTheDeviceMovingFor2Seconds_12();
            break;
        case 13:
            ChipLogProgress(chipTool,
                            " ***** Test Step 13 : 3a: Verify DUT reports OperationalStatus attribute to TH after a DownOrClose\n");
            err = Test3aVerifyDutReportsOperationalStatusAttributeToThAfterADownOrClose_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : 3a2: DUT updates its attributes\n");
            err = Test3a2DutUpdatesItsAttributes_14();
            break;
        case 15:
            ChipLogProgress(
                chipTool, " ***** Test Step 15 : 3b: If (PA & LF) TH reads CurrentPositionLiftPercent100ths attribute from DUT\n");
            if (ShouldSkip("WNCV_LF && WNCV_PA_LF"))
            {
                NextTest();
                return;
            }
            err = Test3bIfPaLfThReadsCurrentPositionLiftPercent100thsAttributeFromDut_15();
            break;
        case 16:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 16 : 3c: If (PA & LF) TH reads CurrentPositionLiftPercentage optional attribute from DUT\n");
            if (ShouldSkip("WNCV_LF && WNCV_PA_LF && A_CURRENTPOSITIONLIFTPERCENTAGE"))
            {
                NextTest();
                return;
            }
            err = Test3cIfPaLfThReadsCurrentPositionLiftPercentageOptionalAttributeFromDut_16();
            break;
        case 17:
            ChipLogProgress(
                chipTool, " ***** Test Step 17 : 3d: If (PA & TL) TH reads CurrentPositionTiltPercent100ths attribute from DUT\n");
            if (ShouldSkip("WNCV_TL && WNCV_PA_TL"))
            {
                NextTest();
                return;
            }
            err = Test3dIfPaTlThReadsCurrentPositionTiltPercent100thsAttributeFromDut_17();
            break;
        case 18:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 18 : 3e: If (PA & LF) TH reads CurrentPositionTiltPercentage optional attribute from DUT\n");
            if (ShouldSkip("WNCV_TL && WNCV_PA_TL && A_CURRENTPOSITIONTILTPERCENTAGE"))
            {
                NextTest();
                return;
            }
            err = Test3eIfPaLfThReadsCurrentPositionTiltPercentageOptionalAttributeFromDut_18();
            break;
        case 19:
            ChipLogProgress(chipTool, " ***** Test Step 19 : 4a: TH sends a StopMotion command to DUT\n");
            err = Test4aThSendsAStopMotionCommandToDut_19();
            break;
        case 20:
            ChipLogProgress(chipTool,
                            " ***** Test Step 20 : 4b: TH waits for 3 seconds the end of inertial movement(s) on the device\n");
            err = Test4bThWaitsFor3SecondsTheEndOfInertialMovementsOnTheDevice_20();
            break;
        case 21:
            ChipLogProgress(chipTool,
                            " ***** Test Step 21 : 4c: Verify DUT update OperationalStatus attribute to TH after a StopMotion\n");
            err = Test4cVerifyDutUpdateOperationalStatusAttributeToThAfterAStopMotion_21();
            break;
        case 22:
            ChipLogProgress(chipTool, " ***** Test Step 22 : 5a: TH waits for x seconds attributes update on the device\n");
            err = Test5aThWaitsForXSecondsAttributesUpdateOnTheDevice_22();
            break;
        case 23:
            ChipLogProgress(chipTool,
                            " ***** Test Step 23 : 5b: If (PA & LF) TH reads TargetPositionLiftPercent100ths attribute from DUT\n");
            if (ShouldSkip("WNCV_LF && WNCV_PA_LF"))
            {
                NextTest();
                return;
            }
            err = Test5bIfPaLfThReadsTargetPositionLiftPercent100thsAttributeFromDut_23();
            break;
        case 24:
            ChipLogProgress(chipTool,
                            " ***** Test Step 24 : 5c: If (PA & TL) TH reads TargetPositionTiltPercent100ths attribute from DUT\n");
            if (ShouldSkip("WNCV_TL && WNCV_PA_TL"))
            {
                NextTest();
                return;
            }
            err = Test5cIfPaTlThReadsTargetPositionTiltPercent100thsAttributeFromDut_24();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 25;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    typedef void (*Test_Test_TC_WNCV_3_2_OperationalStatus_ReportCallback)(void * context, uint8_t value);
    Test_Test_TC_WNCV_3_2_OperationalStatus_ReportCallback mTest_Test_TC_WNCV_3_2_OperationalStatus_Reported = nullptr;

    static void OnFailureCallback_3(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_3_2Suite *>(context))->OnFailureResponse_3(error);
    }

    static void OnSuccessCallback_3(void * context,
                                    const chip::app::DataModel::Nullable<chip::Percent100ths> & currentPositionLiftPercent100ths)
    {
        (static_cast<Test_TC_WNCV_3_2Suite *>(context))->OnSuccessResponse_3(currentPositionLiftPercent100ths);
    }

    static void OnFailureCallback_4(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_3_2Suite *>(context))->OnFailureResponse_4(error);
    }

    static void OnSuccessCallback_4(void * context,
                                    const chip::app::DataModel::Nullable<chip::Percent> & currentPositionLiftPercentage)
    {
        (static_cast<Test_TC_WNCV_3_2Suite *>(context))->OnSuccessResponse_4(currentPositionLiftPercentage);
    }

    static void OnFailureCallback_5(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_3_2Suite *>(context))->OnFailureResponse_5(error);
    }

    static void OnSuccessCallback_5(void * context,
                                    const chip::app::DataModel::Nullable<chip::Percent100ths> & currentPositionTiltPercent100ths)
    {
        (static_cast<Test_TC_WNCV_3_2Suite *>(context))->OnSuccessResponse_5(currentPositionTiltPercent100ths);
    }

    static void OnFailureCallback_6(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_3_2Suite *>(context))->OnFailureResponse_6(error);
    }

    static void OnSuccessCallback_6(void * context,
                                    const chip::app::DataModel::Nullable<chip::Percent> & currentPositionTiltPercentage)
    {
        (static_cast<Test_TC_WNCV_3_2Suite *>(context))->OnSuccessResponse_6(currentPositionTiltPercentage);
    }

    static void OnFailureCallback_7(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_3_2Suite *>(context))->OnFailureResponse_7(error);
    }

    static void OnSuccessCallback_7(void * context, uint8_t operationalStatus)
    {
        (static_cast<Test_TC_WNCV_3_2Suite *>(context))->OnSuccessResponse_7(operationalStatus);
    }

    bool mReceivedReport_7 = false;

    static void OnFailureCallback_8(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_3_2Suite *>(context))->OnFailureResponse_8(error);
    }

    static void OnSuccessCallback_8(void * context, uint8_t operationalStatus)
    {
        (static_cast<Test_TC_WNCV_3_2Suite *>(context))->OnSuccessResponse_8(operationalStatus);
    }

    static void OnSubscriptionEstablished_8(void * context)
    {
        (static_cast<Test_TC_WNCV_3_2Suite *>(context))->OnSubscriptionEstablishedResponse_8();
    }

    static void OnFailureCallback_11(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_3_2Suite *>(context))->OnFailureResponse_11(error);
    }

    static void OnSuccessCallback_11(void * context,
                                     const chip::app::DataModel::Nullable<chip::Percent100ths> & targetPositionLiftPercent100ths)
    {
        (static_cast<Test_TC_WNCV_3_2Suite *>(context))->OnSuccessResponse_11(targetPositionLiftPercent100ths);
    }

    static void OnFailureCallback_13(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_3_2Suite *>(context))->OnFailureResponse_13(error);
    }

    static void OnSuccessCallback_13(void * context, uint8_t operationalStatus)
    {
        (static_cast<Test_TC_WNCV_3_2Suite *>(context))->OnSuccessResponse_13(operationalStatus);
    }

    bool mReceivedReport_13 = false;

    static void OnFailureCallback_15(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_3_2Suite *>(context))->OnFailureResponse_15(error);
    }

    static void OnSuccessCallback_15(void * context,
                                     const chip::app::DataModel::Nullable<chip::Percent100ths> & currentPositionLiftPercent100ths)
    {
        (static_cast<Test_TC_WNCV_3_2Suite *>(context))->OnSuccessResponse_15(currentPositionLiftPercent100ths);
    }

    static void OnFailureCallback_16(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_3_2Suite *>(context))->OnFailureResponse_16(error);
    }

    static void OnSuccessCallback_16(void * context,
                                     const chip::app::DataModel::Nullable<chip::Percent> & currentPositionLiftPercentage)
    {
        (static_cast<Test_TC_WNCV_3_2Suite *>(context))->OnSuccessResponse_16(currentPositionLiftPercentage);
    }

    static void OnFailureCallback_17(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_3_2Suite *>(context))->OnFailureResponse_17(error);
    }

    static void OnSuccessCallback_17(void * context,
                                     const chip::app::DataModel::Nullable<chip::Percent100ths> & currentPositionTiltPercent100ths)
    {
        (static_cast<Test_TC_WNCV_3_2Suite *>(context))->OnSuccessResponse_17(currentPositionTiltPercent100ths);
    }

    static void OnFailureCallback_18(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_3_2Suite *>(context))->OnFailureResponse_18(error);
    }

    static void OnSuccessCallback_18(void * context,
                                     const chip::app::DataModel::Nullable<chip::Percent> & currentPositionTiltPercentage)
    {
        (static_cast<Test_TC_WNCV_3_2Suite *>(context))->OnSuccessResponse_18(currentPositionTiltPercentage);
    }

    static void OnFailureCallback_21(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_3_2Suite *>(context))->OnFailureResponse_21(error);
    }

    static void OnSuccessCallback_21(void * context, uint8_t operationalStatus)
    {
        (static_cast<Test_TC_WNCV_3_2Suite *>(context))->OnSuccessResponse_21(operationalStatus);
    }

    static void OnFailureCallback_23(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_3_2Suite *>(context))->OnFailureResponse_23(error);
    }

    static void OnSuccessCallback_23(void * context,
                                     const chip::app::DataModel::Nullable<chip::Percent100ths> & targetPositionLiftPercent100ths)
    {
        (static_cast<Test_TC_WNCV_3_2Suite *>(context))->OnSuccessResponse_23(targetPositionLiftPercent100ths);
    }

    static void OnFailureCallback_24(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_3_2Suite *>(context))->OnFailureResponse_24(error);
    }

    static void OnSuccessCallback_24(void * context,
                                     const chip::app::DataModel::Nullable<chip::Percent100ths> & targetPositionTiltPercent100ths)
    {
        (static_cast<Test_TC_WNCV_3_2Suite *>(context))->OnSuccessResponse_24(targetPositionTiltPercent100ths);
    }

    //
    // Tests methods
    //

    CHIP_ERROR Test0WaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR Test1aThSendsUpOrOpenCommandToPrepositionTheDutInTheOppositeDirection_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::WindowCovering::Commands::UpOrOpen::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_WNCV_3_2Suite *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_WNCV_3_2Suite *>(context))->OnFailureResponse_1(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR Test1bThWaitsFor10SecondsMovementsOnTheDevice_2()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForMs(10000);
    }

    CHIP_ERROR Test1cIfPaLfThReadsCurrentPositionLiftPercent100thsAttributeFromDut_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::CurrentPositionLiftPercent100ths::TypeInfo>(
                this, OnSuccessCallback_3, OnFailureCallback_3, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3(const chip::app::DataModel::Nullable<chip::Percent100ths> & currentPositionLiftPercent100ths)
    {
        VerifyOrReturn(CheckConstraintType("currentPositionLiftPercent100ths", "", "uint16"));
        VerifyOrReturn(
            CheckConstraintMinValue<chip::Percent100ths>("currentPositionLiftPercent100ths", currentPositionLiftPercent100ths, 0U));
        VerifyOrReturn(CheckConstraintMaxValue<chip::Percent100ths>("currentPositionLiftPercent100ths",
                                                                    currentPositionLiftPercent100ths, 9999U));
        NextTest();
    }

    CHIP_ERROR Test1dIfPaLfThReadsCurrentPositionLiftPercentageOptionalAttributeFromDut_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::CurrentPositionLiftPercentage::TypeInfo>(
                this, OnSuccessCallback_4, OnFailureCallback_4, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_4(const chip::app::DataModel::Nullable<chip::Percent> & currentPositionLiftPercentage)
    {
        VerifyOrReturn(CheckConstraintType("currentPositionLiftPercentage", "", "uint8"));
        VerifyOrReturn(CheckConstraintMinValue<chip::Percent>("currentPositionLiftPercentage", currentPositionLiftPercentage, 0));
        VerifyOrReturn(CheckConstraintMaxValue<chip::Percent>("currentPositionLiftPercentage", currentPositionLiftPercentage, 99));
        NextTest();
    }

    CHIP_ERROR Test1eIfPaTlThReadsCurrentPositionTiltPercent100thsAttributeFromDut_5()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::CurrentPositionTiltPercent100ths::TypeInfo>(
                this, OnSuccessCallback_5, OnFailureCallback_5, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_5(const chip::app::DataModel::Nullable<chip::Percent100ths> & currentPositionTiltPercent100ths)
    {
        VerifyOrReturn(CheckConstraintType("currentPositionTiltPercent100ths", "", "uint16"));
        VerifyOrReturn(
            CheckConstraintMinValue<chip::Percent100ths>("currentPositionTiltPercent100ths", currentPositionTiltPercent100ths, 0U));
        VerifyOrReturn(CheckConstraintMaxValue<chip::Percent100ths>("currentPositionTiltPercent100ths",
                                                                    currentPositionTiltPercent100ths, 9999U));
        NextTest();
    }

    CHIP_ERROR Test1fIfPaTlThReadsCurrentPositionTiltPercentageOptionalAttributeFromDut_6()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::CurrentPositionTiltPercentage::TypeInfo>(
                this, OnSuccessCallback_6, OnFailureCallback_6, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_6(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_6(const chip::app::DataModel::Nullable<chip::Percent> & currentPositionTiltPercentage)
    {
        VerifyOrReturn(CheckConstraintType("currentPositionTiltPercentage", "", "uint8"));
        VerifyOrReturn(CheckConstraintMinValue<chip::Percent>("currentPositionTiltPercentage", currentPositionTiltPercentage, 0));
        VerifyOrReturn(CheckConstraintMaxValue<chip::Percent>("currentPositionTiltPercentage", currentPositionTiltPercentage, 99));
        NextTest();
    }

    CHIP_ERROR TestReport2SubscribeToDutReportsOnOperationalStatusAttribute_7()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        mTest_Test_TC_WNCV_3_2_OperationalStatus_Reported = OnSuccessCallback_7;
        return WaitForMs(0);
    }

    void OnFailureResponse_7(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_7(uint8_t operationalStatus)
    {
        mReceivedReport_7 = true;
        VerifyOrReturn(CheckConstraintType("operationalStatus", "", "map8"));
    }

    CHIP_ERROR Test2SubscribeToDutReportsOnOperationalStatusAttribute_8()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t minIntervalArgument;
        minIntervalArgument = 4U;
        uint16_t maxIntervalArgument;
        maxIntervalArgument = 5U;

        ReturnErrorOnFailure(
            cluster.SubscribeAttribute<chip::app::Clusters::WindowCovering::Attributes::OperationalStatus::TypeInfo>(
                this, OnSuccessCallback_8, OnFailureCallback_8, minIntervalArgument, maxIntervalArgument,
                OnSubscriptionEstablished_8, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_8(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_8(uint8_t value)
    {
        if (mTest_Test_TC_WNCV_3_2_OperationalStatus_Reported)
        {
            auto callback                                     = mTest_Test_TC_WNCV_3_2_OperationalStatus_Reported;
            mTest_Test_TC_WNCV_3_2_OperationalStatus_Reported = nullptr;
            callback(this, value);
        }
    }

    void OnSubscriptionEstablishedResponse_8()
    {
        VerifyOrReturn(mReceivedReport_7, Exit("Initial report not received!"));
        NextTest();
    }

    CHIP_ERROR Test2aThSendsDownOrCloseCommandToDut_9()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::WindowCovering::Commands::DownOrClose::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_WNCV_3_2Suite *>(context))->OnSuccessResponse_9();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_WNCV_3_2Suite *>(context))->OnFailureResponse_9(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_9(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_9() { NextTest(); }

    CHIP_ERROR Test2bDutUpdatesItsAttributes_10()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForMs(100);
    }

    CHIP_ERROR Test2cIfPaLfThReadsTargetPositionLiftPercent100thsAttributeFromDut_11()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::TargetPositionLiftPercent100ths::TypeInfo>(
                this, OnSuccessCallback_11, OnFailureCallback_11, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_11(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_11(const chip::app::DataModel::Nullable<chip::Percent100ths> & targetPositionLiftPercent100ths)
    {
        VerifyOrReturn(CheckValueNonNull("targetPositionLiftPercent100ths", targetPositionLiftPercent100ths));
        VerifyOrReturn(CheckValue("targetPositionLiftPercent100ths.Value()", targetPositionLiftPercent100ths.Value(), 10000U));

        NextTest();
    }

    CHIP_ERROR Test2eThLeaveTheDeviceMovingFor2Seconds_12()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForMs(2000);
    }

    CHIP_ERROR Test3aVerifyDutReportsOperationalStatusAttributeToThAfterADownOrClose_13()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        mTest_Test_TC_WNCV_3_2_OperationalStatus_Reported = OnSuccessCallback_13;
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_13(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_13(uint8_t operationalStatus)
    {
        mReceivedReport_13 = true;
        VerifyOrReturn(CheckConstraintType("operationalStatus", "", "map8"));
        VerifyOrReturn(CheckConstraintMinValue<uint8_t>("operationalStatus", operationalStatus, 10));
        VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("operationalStatus", operationalStatus, 42));
        NextTest();
    }

    CHIP_ERROR Test3a2DutUpdatesItsAttributes_14()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForMs(2000);
    }

    CHIP_ERROR Test3bIfPaLfThReadsCurrentPositionLiftPercent100thsAttributeFromDut_15()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::CurrentPositionLiftPercent100ths::TypeInfo>(
                this, OnSuccessCallback_15, OnFailureCallback_15, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_15(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_15(const chip::app::DataModel::Nullable<chip::Percent100ths> & currentPositionLiftPercent100ths)
    {
        VerifyOrReturn(CheckConstraintType("currentPositionLiftPercent100ths", "", "uint16"));
        VerifyOrReturn(
            CheckConstraintMinValue<chip::Percent100ths>("currentPositionLiftPercent100ths", currentPositionLiftPercent100ths, 1U));
        VerifyOrReturn(CheckConstraintMaxValue<chip::Percent100ths>("currentPositionLiftPercent100ths",
                                                                    currentPositionLiftPercent100ths, 10000U));
        NextTest();
    }

    CHIP_ERROR Test3cIfPaLfThReadsCurrentPositionLiftPercentageOptionalAttributeFromDut_16()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::CurrentPositionLiftPercentage::TypeInfo>(
                this, OnSuccessCallback_16, OnFailureCallback_16, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_16(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_16(const chip::app::DataModel::Nullable<chip::Percent> & currentPositionLiftPercentage)
    {
        VerifyOrReturn(CheckConstraintType("currentPositionLiftPercentage", "", "uint8"));
        VerifyOrReturn(CheckConstraintMinValue<chip::Percent>("currentPositionLiftPercentage", currentPositionLiftPercentage, 1));
        VerifyOrReturn(CheckConstraintMaxValue<chip::Percent>("currentPositionLiftPercentage", currentPositionLiftPercentage, 100));
        NextTest();
    }

    CHIP_ERROR Test3dIfPaTlThReadsCurrentPositionTiltPercent100thsAttributeFromDut_17()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::CurrentPositionTiltPercent100ths::TypeInfo>(
                this, OnSuccessCallback_17, OnFailureCallback_17, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_17(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_17(const chip::app::DataModel::Nullable<chip::Percent100ths> & currentPositionTiltPercent100ths)
    {
        VerifyOrReturn(CheckConstraintType("currentPositionTiltPercent100ths", "", "uint16"));
        VerifyOrReturn(
            CheckConstraintMinValue<chip::Percent100ths>("currentPositionTiltPercent100ths", currentPositionTiltPercent100ths, 1U));
        VerifyOrReturn(CheckConstraintMaxValue<chip::Percent100ths>("currentPositionTiltPercent100ths",
                                                                    currentPositionTiltPercent100ths, 10000U));
        NextTest();
    }

    CHIP_ERROR Test3eIfPaLfThReadsCurrentPositionTiltPercentageOptionalAttributeFromDut_18()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::CurrentPositionTiltPercentage::TypeInfo>(
                this, OnSuccessCallback_18, OnFailureCallback_18, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_18(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_18(const chip::app::DataModel::Nullable<chip::Percent> & currentPositionTiltPercentage)
    {
        VerifyOrReturn(CheckConstraintType("currentPositionTiltPercentage", "", "uint8"));
        VerifyOrReturn(CheckConstraintMinValue<chip::Percent>("currentPositionTiltPercentage", currentPositionTiltPercentage, 1));
        VerifyOrReturn(CheckConstraintMaxValue<chip::Percent>("currentPositionTiltPercentage", currentPositionTiltPercentage, 100));
        NextTest();
    }

    CHIP_ERROR Test4aThSendsAStopMotionCommandToDut_19()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::WindowCovering::Commands::StopMotion::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_WNCV_3_2Suite *>(context))->OnSuccessResponse_19();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_WNCV_3_2Suite *>(context))->OnFailureResponse_19(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_19(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_19() { NextTest(); }

    CHIP_ERROR Test4bThWaitsFor3SecondsTheEndOfInertialMovementsOnTheDevice_20()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForMs(3000);
    }

    CHIP_ERROR Test4cVerifyDutUpdateOperationalStatusAttributeToThAfterAStopMotion_21()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::OperationalStatus::TypeInfo>(
            this, OnSuccessCallback_21, OnFailureCallback_21, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_21(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_21(uint8_t operationalStatus)
    {
        VerifyOrReturn(CheckValue("operationalStatus", operationalStatus, 0));

        NextTest();
    }

    CHIP_ERROR Test5aThWaitsForXSecondsAttributesUpdateOnTheDevice_22()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForMs(1000);
    }

    CHIP_ERROR Test5bIfPaLfThReadsTargetPositionLiftPercent100thsAttributeFromDut_23()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::TargetPositionLiftPercent100ths::TypeInfo>(
                this, OnSuccessCallback_23, OnFailureCallback_23, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_23(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_23(const chip::app::DataModel::Nullable<chip::Percent100ths> & targetPositionLiftPercent100ths)
    {
        VerifyOrReturn(CheckConstraintType("targetPositionLiftPercent100ths", "", "uint16"));
        VerifyOrReturn(
            CheckConstraintMinValue<chip::Percent100ths>("targetPositionLiftPercent100ths", targetPositionLiftPercent100ths, 1U));
        VerifyOrReturn(CheckConstraintMaxValue<chip::Percent100ths>("targetPositionLiftPercent100ths",
                                                                    targetPositionLiftPercent100ths, 10000U));
        NextTest();
    }

    CHIP_ERROR Test5cIfPaTlThReadsTargetPositionTiltPercent100thsAttributeFromDut_24()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::TargetPositionTiltPercent100ths::TypeInfo>(
                this, OnSuccessCallback_24, OnFailureCallback_24, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_24(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_24(const chip::app::DataModel::Nullable<chip::Percent100ths> & targetPositionTiltPercent100ths)
    {
        VerifyOrReturn(CheckConstraintType("targetPositionTiltPercent100ths", "", "uint16"));
        VerifyOrReturn(
            CheckConstraintMinValue<chip::Percent100ths>("targetPositionTiltPercent100ths", targetPositionTiltPercent100ths, 1U));
        VerifyOrReturn(CheckConstraintMaxValue<chip::Percent100ths>("targetPositionTiltPercent100ths",
                                                                    targetPositionTiltPercent100ths, 10000U));
        NextTest();
    }
};

class Test_TC_WNCV_3_3Suite : public TestCommand
{
public:
    Test_TC_WNCV_3_3Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_WNCV_3_3", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_WNCV_3_3Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_WNCV_3_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_WNCV_3_3\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : 0: Wait for the commissioned device to be retrieved\n");
            err = Test0WaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 1 : 1a: TH sends DownOrClose command to preposition the DUT in the opposite direction\n");
            err = Test1aThSendsDownOrCloseCommandToPrepositionTheDutInTheOppositeDirection_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : 1b: TH Waits for 6-8 seconds movement(s) on the device\n");
            err = Test1bThWaitsFor68SecondsMovementsOnTheDevice_2();
            break;
        case 3:
            ChipLogProgress(
                chipTool, " ***** Test Step 3 : 1c: TH sends UpOrOpen command to preposition the DUT in the opposite direction\n");
            err = Test1cThSendsUpOrOpenCommandToPrepositionTheDutInTheOppositeDirection_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : 1d: TH Waits for 2 seconds movement(s) on the device\n");
            err = Test1dThWaitsFor2SecondsMovementsOnTheDevice_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Report: 2: Subscribe to DUT reports on OperationalStatus attribute\n");
            err = TestReport2SubscribeToDutReportsOnOperationalStatusAttribute_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : 2: Subscribe to DUT reports on OperationalStatus attribute\n");
            err = Test2SubscribeToDutReportsOnOperationalStatusAttribute_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : 2a: TH sends a StopMotion command to DUT\n");
            err = Test2aThSendsAStopMotionCommandToDut_7();
            break;
        case 8:
            ChipLogProgress(chipTool,
                            " ***** Test Step 8 : 2b: TH waits for 3 seconds the end of inertial movement(s) on the device\n");
            err = Test2bThWaitsFor3SecondsTheEndOfInertialMovementsOnTheDevice_8();
            break;
        case 9:
            ChipLogProgress(chipTool,
                            " ***** Test Step 9 : 2c: Verify DUT reports OperationalStatus attribute to TH after a StopMotion\n");
            err = Test2cVerifyDutReportsOperationalStatusAttributeToThAfterAStopMotion_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : 2d: TH waits for 100ms - 3s attributes update on the device\n");
            err = Test2dThWaitsFor100ms3sAttributesUpdateOnTheDevice_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : 2e: TH reads OperationalStatus attribute from DUT\n");
            err = Test2eThReadsOperationalStatusAttributeFromDut_11();
            break;
        case 12:
            ChipLogProgress(
                chipTool, " ***** Test Step 12 : 3a: If (PA & LF) TH reads CurrentPositionLiftPercent100ths attribute from DUT\n");
            if (ShouldSkip("WNCV_LF && WNCV_PA_LF"))
            {
                NextTest();
                return;
            }
            err = Test3aIfPaLfThReadsCurrentPositionLiftPercent100thsAttributeFromDut_12();
            break;
        case 13:
            ChipLogProgress(chipTool,
                            " ***** Test Step 13 : 3b: If (PA & LF) TH reads TargetPositionLiftPercent100ths attribute 3c: it Must "
                            "be equal with CurrentPositionLiftPercent100ths from DUT\n");
            if (ShouldSkip("WNCV_LF && WNCV_PA_LF"))
            {
                NextTest();
                return;
            }
            err =
                Test3bIfPaLfThReadsTargetPositionLiftPercent100thsAttribute3cItMustBeEqualWithCurrentPositionLiftPercent100thsFromDut_13();
            break;
        case 14:
            ChipLogProgress(
                chipTool, " ***** Test Step 14 : 4a: If (PA & TL) TH reads CurrentPositionTiltPercent100ths attribute from DUT\n");
            if (ShouldSkip("WNCV_TL && WNCV_PA_TL"))
            {
                NextTest();
                return;
            }
            err = Test4aIfPaTlThReadsCurrentPositionTiltPercent100thsAttributeFromDut_14();
            break;
        case 15:
            ChipLogProgress(chipTool,
                            " ***** Test Step 15 : 4b: If (PA & TL) TH reads TargetPositionTiltPercent100ths attribute 4c: it Must "
                            "be equal with CurrentPositionTiltPercent100ths from DUT\n");
            if (ShouldSkip("WNCV_TL && WNCV_PA_TL"))
            {
                NextTest();
                return;
            }
            err =
                Test4bIfPaTlThReadsTargetPositionTiltPercent100thsAttribute4cItMustBeEqualWithCurrentPositionTiltPercent100thsFromDut_15();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 16;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::app::DataModel::Nullable<chip::Percent100ths> attrCurrentPositionLift;
    chip::app::DataModel::Nullable<chip::Percent100ths> attrCurrentPositionTilt;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    typedef void (*Test_Test_TC_WNCV_3_3_OperationalStatus_ReportCallback)(void * context, uint8_t value);
    Test_Test_TC_WNCV_3_3_OperationalStatus_ReportCallback mTest_Test_TC_WNCV_3_3_OperationalStatus_Reported = nullptr;

    static void OnFailureCallback_5(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_3_3Suite *>(context))->OnFailureResponse_5(error);
    }

    static void OnSuccessCallback_5(void * context, uint8_t operationalStatus)
    {
        (static_cast<Test_TC_WNCV_3_3Suite *>(context))->OnSuccessResponse_5(operationalStatus);
    }

    bool mReceivedReport_5 = false;

    static void OnFailureCallback_6(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_3_3Suite *>(context))->OnFailureResponse_6(error);
    }

    static void OnSuccessCallback_6(void * context, uint8_t operationalStatus)
    {
        (static_cast<Test_TC_WNCV_3_3Suite *>(context))->OnSuccessResponse_6(operationalStatus);
    }

    static void OnSubscriptionEstablished_6(void * context)
    {
        (static_cast<Test_TC_WNCV_3_3Suite *>(context))->OnSubscriptionEstablishedResponse_6();
    }

    static void OnFailureCallback_9(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_3_3Suite *>(context))->OnFailureResponse_9(error);
    }

    static void OnSuccessCallback_9(void * context, uint8_t operationalStatus)
    {
        (static_cast<Test_TC_WNCV_3_3Suite *>(context))->OnSuccessResponse_9(operationalStatus);
    }

    bool mReceivedReport_9 = false;

    static void OnFailureCallback_11(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_3_3Suite *>(context))->OnFailureResponse_11(error);
    }

    static void OnSuccessCallback_11(void * context, uint8_t operationalStatus)
    {
        (static_cast<Test_TC_WNCV_3_3Suite *>(context))->OnSuccessResponse_11(operationalStatus);
    }

    static void OnFailureCallback_12(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_3_3Suite *>(context))->OnFailureResponse_12(error);
    }

    static void OnSuccessCallback_12(void * context,
                                     const chip::app::DataModel::Nullable<chip::Percent100ths> & currentPositionLiftPercent100ths)
    {
        (static_cast<Test_TC_WNCV_3_3Suite *>(context))->OnSuccessResponse_12(currentPositionLiftPercent100ths);
    }

    static void OnFailureCallback_13(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_3_3Suite *>(context))->OnFailureResponse_13(error);
    }

    static void OnSuccessCallback_13(void * context,
                                     const chip::app::DataModel::Nullable<chip::Percent100ths> & targetPositionLiftPercent100ths)
    {
        (static_cast<Test_TC_WNCV_3_3Suite *>(context))->OnSuccessResponse_13(targetPositionLiftPercent100ths);
    }

    static void OnFailureCallback_14(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_3_3Suite *>(context))->OnFailureResponse_14(error);
    }

    static void OnSuccessCallback_14(void * context,
                                     const chip::app::DataModel::Nullable<chip::Percent100ths> & currentPositionTiltPercent100ths)
    {
        (static_cast<Test_TC_WNCV_3_3Suite *>(context))->OnSuccessResponse_14(currentPositionTiltPercent100ths);
    }

    static void OnFailureCallback_15(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_3_3Suite *>(context))->OnFailureResponse_15(error);
    }

    static void OnSuccessCallback_15(void * context,
                                     const chip::app::DataModel::Nullable<chip::Percent100ths> & targetPositionTiltPercent100ths)
    {
        (static_cast<Test_TC_WNCV_3_3Suite *>(context))->OnSuccessResponse_15(targetPositionTiltPercent100ths);
    }

    //
    // Tests methods
    //

    CHIP_ERROR Test0WaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR Test1aThSendsDownOrCloseCommandToPrepositionTheDutInTheOppositeDirection_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::WindowCovering::Commands::DownOrClose::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_WNCV_3_3Suite *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_WNCV_3_3Suite *>(context))->OnFailureResponse_1(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR Test1bThWaitsFor68SecondsMovementsOnTheDevice_2()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForMs(6000);
    }

    CHIP_ERROR Test1cThSendsUpOrOpenCommandToPrepositionTheDutInTheOppositeDirection_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::WindowCovering::Commands::UpOrOpen::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_WNCV_3_3Suite *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_WNCV_3_3Suite *>(context))->OnFailureResponse_3(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR Test1dThWaitsFor2SecondsMovementsOnTheDevice_4()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForMs(2000);
    }

    CHIP_ERROR TestReport2SubscribeToDutReportsOnOperationalStatusAttribute_5()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        mTest_Test_TC_WNCV_3_3_OperationalStatus_Reported = OnSuccessCallback_5;
        return WaitForMs(0);
    }

    void OnFailureResponse_5(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_5(uint8_t operationalStatus)
    {
        mReceivedReport_5 = true;
        VerifyOrReturn(CheckConstraintType("operationalStatus", "", "map8"));
    }

    CHIP_ERROR Test2SubscribeToDutReportsOnOperationalStatusAttribute_6()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t minIntervalArgument;
        minIntervalArgument = 4U;
        uint16_t maxIntervalArgument;
        maxIntervalArgument = 5U;

        ReturnErrorOnFailure(
            cluster.SubscribeAttribute<chip::app::Clusters::WindowCovering::Attributes::OperationalStatus::TypeInfo>(
                this, OnSuccessCallback_6, OnFailureCallback_6, minIntervalArgument, maxIntervalArgument,
                OnSubscriptionEstablished_6, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_6(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_6(uint8_t value)
    {
        if (mTest_Test_TC_WNCV_3_3_OperationalStatus_Reported)
        {
            auto callback                                     = mTest_Test_TC_WNCV_3_3_OperationalStatus_Reported;
            mTest_Test_TC_WNCV_3_3_OperationalStatus_Reported = nullptr;
            callback(this, value);
        }
    }

    void OnSubscriptionEstablishedResponse_6()
    {
        VerifyOrReturn(mReceivedReport_5, Exit("Initial report not received!"));
        NextTest();
    }

    CHIP_ERROR Test2aThSendsAStopMotionCommandToDut_7()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::WindowCovering::Commands::StopMotion::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_WNCV_3_3Suite *>(context))->OnSuccessResponse_7();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_WNCV_3_3Suite *>(context))->OnFailureResponse_7(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_7(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_7() { NextTest(); }

    CHIP_ERROR Test2bThWaitsFor3SecondsTheEndOfInertialMovementsOnTheDevice_8()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForMs(3000);
    }

    CHIP_ERROR Test2cVerifyDutReportsOperationalStatusAttributeToThAfterAStopMotion_9()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        mTest_Test_TC_WNCV_3_3_OperationalStatus_Reported = OnSuccessCallback_9;
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_9(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_9(uint8_t operationalStatus)
    {
        mReceivedReport_9 = true;
        VerifyOrReturn(CheckValue("operationalStatus", operationalStatus, 0));

        NextTest();
    }

    CHIP_ERROR Test2dThWaitsFor100ms3sAttributesUpdateOnTheDevice_10()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForMs(2000);
    }

    CHIP_ERROR Test2eThReadsOperationalStatusAttributeFromDut_11()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::OperationalStatus::TypeInfo>(
            this, OnSuccessCallback_11, OnFailureCallback_11, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_11(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_11(uint8_t operationalStatus)
    {
        VerifyOrReturn(CheckValue("operationalStatus", operationalStatus, 0));

        NextTest();
    }

    CHIP_ERROR Test3aIfPaLfThReadsCurrentPositionLiftPercent100thsAttributeFromDut_12()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::CurrentPositionLiftPercent100ths::TypeInfo>(
                this, OnSuccessCallback_12, OnFailureCallback_12, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_12(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_12(const chip::app::DataModel::Nullable<chip::Percent100ths> & currentPositionLiftPercent100ths)
    {
        VerifyOrReturn(
            CheckConstraintMinValue<chip::Percent100ths>("currentPositionLiftPercent100ths", currentPositionLiftPercent100ths, 0U));
        VerifyOrReturn(CheckConstraintMaxValue<chip::Percent100ths>("currentPositionLiftPercent100ths",
                                                                    currentPositionLiftPercent100ths, 10000U));
        attrCurrentPositionLift = currentPositionLiftPercent100ths;
        NextTest();
    }

    CHIP_ERROR
    Test3bIfPaLfThReadsTargetPositionLiftPercent100thsAttribute3cItMustBeEqualWithCurrentPositionLiftPercent100thsFromDut_13()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::TargetPositionLiftPercent100ths::TypeInfo>(
                this, OnSuccessCallback_13, OnFailureCallback_13, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_13(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_13(const chip::app::DataModel::Nullable<chip::Percent100ths> & targetPositionLiftPercent100ths)
    {
        if (attrCurrentPositionLift.IsNull())
        {
            VerifyOrReturn(CheckValueNull("targetPositionLiftPercent100ths", targetPositionLiftPercent100ths));
        }
        else
        {
            VerifyOrReturn(CheckValueNonNull("targetPositionLiftPercent100ths", targetPositionLiftPercent100ths));
            VerifyOrReturn(CheckValue("targetPositionLiftPercent100ths.Value()", targetPositionLiftPercent100ths.Value(),
                                      attrCurrentPositionLift.Value()));
        }

        NextTest();
    }

    CHIP_ERROR Test4aIfPaTlThReadsCurrentPositionTiltPercent100thsAttributeFromDut_14()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::CurrentPositionTiltPercent100ths::TypeInfo>(
                this, OnSuccessCallback_14, OnFailureCallback_14, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_14(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_14(const chip::app::DataModel::Nullable<chip::Percent100ths> & currentPositionTiltPercent100ths)
    {
        VerifyOrReturn(
            CheckConstraintMinValue<chip::Percent100ths>("currentPositionTiltPercent100ths", currentPositionTiltPercent100ths, 0U));
        VerifyOrReturn(CheckConstraintMaxValue<chip::Percent100ths>("currentPositionTiltPercent100ths",
                                                                    currentPositionTiltPercent100ths, 10000U));
        attrCurrentPositionTilt = currentPositionTiltPercent100ths;
        NextTest();
    }

    CHIP_ERROR
    Test4bIfPaTlThReadsTargetPositionTiltPercent100thsAttribute4cItMustBeEqualWithCurrentPositionTiltPercent100thsFromDut_15()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::TargetPositionTiltPercent100ths::TypeInfo>(
                this, OnSuccessCallback_15, OnFailureCallback_15, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_15(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_15(const chip::app::DataModel::Nullable<chip::Percent100ths> & targetPositionTiltPercent100ths)
    {
        if (attrCurrentPositionTilt.IsNull())
        {
            VerifyOrReturn(CheckValueNull("targetPositionTiltPercent100ths", targetPositionTiltPercent100ths));
        }
        else
        {
            VerifyOrReturn(CheckValueNonNull("targetPositionTiltPercent100ths", targetPositionTiltPercent100ths));
            VerifyOrReturn(CheckValue("targetPositionTiltPercent100ths.Value()", targetPositionTiltPercent100ths.Value(),
                                      attrCurrentPositionTilt.Value()));
        }

        NextTest();
    }
};

class Test_TC_WNCV_3_4Suite : public TestCommand
{
public:
    Test_TC_WNCV_3_4Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_WNCV_3_4", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("fastMotionDuration", 0, UINT16_MAX, &mFastMotionDuration);
        AddArgument("fullMotionDuration", 0, UINT16_MAX, &mFullMotionDuration);
    }

    ~Test_TC_WNCV_3_4Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_WNCV_3_4\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_WNCV_3_4\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : 0: Wait for the commissioned device to be retrieved\n");
            err = Test0WaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 1 : 1a: TH sends DownOrClose command to preposition the DUT in the opposite direction\n");
            err = Test1aThSendsDownOrCloseCommandToPrepositionTheDutInTheOppositeDirection_1();
            break;
        case 2:
            ChipLogProgress(chipTool,
                            " ***** Test Step 2 : 1b: TH Waits for fastMotionDuration seconds movement(s) on the device\n");
            err = Test1bThWaitsForFastMotionDurationSecondsMovementsOnTheDevice_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : 2a: TH sends UpOrOpen command to DUT\n");
            err = Test2aThSendsUpOrOpenCommandToDut_3();
            break;
        case 4:
            ChipLogProgress(chipTool,
                            " ***** Test Step 4 : 2b: TH Waits for fullMotionDuration seconds movement(s) on the device\n");
            err = Test2bThWaitsForFullMotionDurationSecondsMovementsOnTheDevice_4();
            break;
        case 5:
            ChipLogProgress(chipTool,
                            " ***** Test Step 5 : 3a: If (PA & LF) TH reads CurrentPositionLiftPercent100ths attribute from DUT\n");
            if (ShouldSkip("WNCV_LF && WNCV_PA_LF"))
            {
                NextTest();
                return;
            }
            err = Test3aIfPaLfThReadsCurrentPositionLiftPercent100thsAttributeFromDut_5();
            break;
        case 6:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 6 : 3b: If (PA & LF) TH reads CurrentPositionLiftPercentage optional attribute from DUT\n");
            if (ShouldSkip("WNCV_LF && WNCV_PA_LF && A_CURRENTPOSITIONLIFTPERCENTAGE"))
            {
                NextTest();
                return;
            }
            err = Test3bIfPaLfThReadsCurrentPositionLiftPercentageOptionalAttributeFromDut_6();
            break;
        case 7:
            ChipLogProgress(chipTool,
                            " ***** Test Step 7 : 3c: If (PA & TL) TH reads CurrentPositionTiltPercent100ths attribute from DUT\n");
            if (ShouldSkip("WNCV_TL && WNCV_PA_TL"))
            {
                NextTest();
                return;
            }
            err = Test3cIfPaTlThReadsCurrentPositionTiltPercent100thsAttributeFromDut_7();
            break;
        case 8:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 8 : 3d: If (PA & TL) TH reads CurrentPositionTiltPercentage optional attribute from DUT\n");
            if (ShouldSkip("WNCV_TL && WNCV_PA_TL && A_CURRENTPOSITIONLIFTPERCENTAGE"))
            {
                NextTest();
                return;
            }
            err = Test3dIfPaTlThReadsCurrentPositionTiltPercentageOptionalAttributeFromDut_8();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 9;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mFastMotionDuration;
    chip::Optional<uint16_t> mFullMotionDuration;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_5(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_3_4Suite *>(context))->OnFailureResponse_5(error);
    }

    static void OnSuccessCallback_5(void * context,
                                    const chip::app::DataModel::Nullable<chip::Percent100ths> & currentPositionLiftPercent100ths)
    {
        (static_cast<Test_TC_WNCV_3_4Suite *>(context))->OnSuccessResponse_5(currentPositionLiftPercent100ths);
    }

    static void OnFailureCallback_6(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_3_4Suite *>(context))->OnFailureResponse_6(error);
    }

    static void OnSuccessCallback_6(void * context,
                                    const chip::app::DataModel::Nullable<chip::Percent> & currentPositionLiftPercentage)
    {
        (static_cast<Test_TC_WNCV_3_4Suite *>(context))->OnSuccessResponse_6(currentPositionLiftPercentage);
    }

    static void OnFailureCallback_7(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_3_4Suite *>(context))->OnFailureResponse_7(error);
    }

    static void OnSuccessCallback_7(void * context,
                                    const chip::app::DataModel::Nullable<chip::Percent100ths> & currentPositionTiltPercent100ths)
    {
        (static_cast<Test_TC_WNCV_3_4Suite *>(context))->OnSuccessResponse_7(currentPositionTiltPercent100ths);
    }

    static void OnFailureCallback_8(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_3_4Suite *>(context))->OnFailureResponse_8(error);
    }

    static void OnSuccessCallback_8(void * context,
                                    const chip::app::DataModel::Nullable<chip::Percent> & currentPositionTiltPercentage)
    {
        (static_cast<Test_TC_WNCV_3_4Suite *>(context))->OnSuccessResponse_8(currentPositionTiltPercentage);
    }

    //
    // Tests methods
    //

    CHIP_ERROR Test0WaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR Test1aThSendsDownOrCloseCommandToPrepositionTheDutInTheOppositeDirection_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::WindowCovering::Commands::DownOrClose::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_WNCV_3_4Suite *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_WNCV_3_4Suite *>(context))->OnFailureResponse_1(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR Test1bThWaitsForFastMotionDurationSecondsMovementsOnTheDevice_2()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForMs(mFastMotionDuration.HasValue() ? mFastMotionDuration.Value() : 3000U);
    }

    CHIP_ERROR Test2aThSendsUpOrOpenCommandToDut_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::WindowCovering::Commands::UpOrOpen::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_WNCV_3_4Suite *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_WNCV_3_4Suite *>(context))->OnFailureResponse_3(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR Test2bThWaitsForFullMotionDurationSecondsMovementsOnTheDevice_4()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForMs(mFullMotionDuration.HasValue() ? mFullMotionDuration.Value() : 6000U);
    }

    CHIP_ERROR Test3aIfPaLfThReadsCurrentPositionLiftPercent100thsAttributeFromDut_5()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::CurrentPositionLiftPercent100ths::TypeInfo>(
                this, OnSuccessCallback_5, OnFailureCallback_5, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_5(const chip::app::DataModel::Nullable<chip::Percent100ths> & currentPositionLiftPercent100ths)
    {
        VerifyOrReturn(CheckValueNonNull("currentPositionLiftPercent100ths", currentPositionLiftPercent100ths));
        VerifyOrReturn(CheckValue("currentPositionLiftPercent100ths.Value()", currentPositionLiftPercent100ths.Value(), 0U));

        NextTest();
    }

    CHIP_ERROR Test3bIfPaLfThReadsCurrentPositionLiftPercentageOptionalAttributeFromDut_6()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::CurrentPositionLiftPercentage::TypeInfo>(
                this, OnSuccessCallback_6, OnFailureCallback_6, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_6(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_6(const chip::app::DataModel::Nullable<chip::Percent> & currentPositionLiftPercentage)
    {
        VerifyOrReturn(CheckValueNonNull("currentPositionLiftPercentage", currentPositionLiftPercentage));
        VerifyOrReturn(CheckValue("currentPositionLiftPercentage.Value()", currentPositionLiftPercentage.Value(), 0));

        NextTest();
    }

    CHIP_ERROR Test3cIfPaTlThReadsCurrentPositionTiltPercent100thsAttributeFromDut_7()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::CurrentPositionTiltPercent100ths::TypeInfo>(
                this, OnSuccessCallback_7, OnFailureCallback_7, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_7(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_7(const chip::app::DataModel::Nullable<chip::Percent100ths> & currentPositionTiltPercent100ths)
    {
        VerifyOrReturn(CheckValueNonNull("currentPositionTiltPercent100ths", currentPositionTiltPercent100ths));
        VerifyOrReturn(CheckValue("currentPositionTiltPercent100ths.Value()", currentPositionTiltPercent100ths.Value(), 0U));

        NextTest();
    }

    CHIP_ERROR Test3dIfPaTlThReadsCurrentPositionTiltPercentageOptionalAttributeFromDut_8()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::CurrentPositionTiltPercentage::TypeInfo>(
                this, OnSuccessCallback_8, OnFailureCallback_8, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_8(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_8(const chip::app::DataModel::Nullable<chip::Percent> & currentPositionTiltPercentage)
    {
        VerifyOrReturn(CheckValueNonNull("currentPositionTiltPercentage", currentPositionTiltPercentage));
        VerifyOrReturn(CheckValue("currentPositionTiltPercentage.Value()", currentPositionTiltPercentage.Value(), 0));

        NextTest();
    }
};

class Test_TC_WNCV_3_5Suite : public TestCommand
{
public:
    Test_TC_WNCV_3_5Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_WNCV_3_5", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("fastMotionDuration", 0, UINT16_MAX, &mFastMotionDuration);
        AddArgument("fullMotionDuration", 0, UINT16_MAX, &mFullMotionDuration);
    }

    ~Test_TC_WNCV_3_5Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_WNCV_3_5\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_WNCV_3_5\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : 0: Wait for the commissioned device to be retrieved\n");
            err = Test0WaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(
                chipTool, " ***** Test Step 1 : 1a: TH sends UpOrOpen command to preposition the DUT in the opposite direction\n");
            err = Test1aThSendsUpOrOpenCommandToPrepositionTheDutInTheOppositeDirection_1();
            break;
        case 2:
            ChipLogProgress(chipTool,
                            " ***** Test Step 2 : 1b: TH Waits for fastMotionDuration seconds movement(s) on the device\n");
            err = Test1bThWaitsForFastMotionDurationSecondsMovementsOnTheDevice_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : 2a: TH sends DownOrClose command to DUT\n");
            err = Test2aThSendsDownOrCloseCommandToDut_3();
            break;
        case 4:
            ChipLogProgress(chipTool,
                            " ***** Test Step 4 : 2b: TH Waits for fullMotionDuration seconds movement(s) on the device\n");
            err = Test2bThWaitsForFullMotionDurationSecondsMovementsOnTheDevice_4();
            break;
        case 5:
            ChipLogProgress(chipTool,
                            " ***** Test Step 5 : 3a: If (PA & LF) TH reads CurrentPositionLiftPercent100ths attribute from DUT\n");
            if (ShouldSkip("WNCV_LF && WNCV_PA_LF"))
            {
                NextTest();
                return;
            }
            err = Test3aIfPaLfThReadsCurrentPositionLiftPercent100thsAttributeFromDut_5();
            break;
        case 6:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 6 : 3b: If (PA & LF) TH reads CurrentPositionLiftPercentage optional attribute from DUT\n");
            if (ShouldSkip("WNCV_LF && WNCV_PA_LF && A_CURRENTPOSITIONLIFTPERCENTAGE"))
            {
                NextTest();
                return;
            }
            err = Test3bIfPaLfThReadsCurrentPositionLiftPercentageOptionalAttributeFromDut_6();
            break;
        case 7:
            ChipLogProgress(chipTool,
                            " ***** Test Step 7 : 3c: If (PA & TL) TH reads CurrentPositionTiltPercent100ths attribute from DUT\n");
            if (ShouldSkip("WNCV_TL && WNCV_PA_TL"))
            {
                NextTest();
                return;
            }
            err = Test3cIfPaTlThReadsCurrentPositionTiltPercent100thsAttributeFromDut_7();
            break;
        case 8:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 8 : 3d: If (PA & TL) TH reads CurrentPositionTiltPercentage optional attribute from DUT\n");
            if (ShouldSkip("WNCV_TL && WNCV_PA_TL && A_CURRENTPOSITIONLIFTPERCENTAGE"))
            {
                NextTest();
                return;
            }
            err = Test3dIfPaTlThReadsCurrentPositionTiltPercentageOptionalAttributeFromDut_8();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 9;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mFastMotionDuration;
    chip::Optional<uint16_t> mFullMotionDuration;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_5(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_3_5Suite *>(context))->OnFailureResponse_5(error);
    }

    static void OnSuccessCallback_5(void * context,
                                    const chip::app::DataModel::Nullable<chip::Percent100ths> & currentPositionLiftPercent100ths)
    {
        (static_cast<Test_TC_WNCV_3_5Suite *>(context))->OnSuccessResponse_5(currentPositionLiftPercent100ths);
    }

    static void OnFailureCallback_6(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_3_5Suite *>(context))->OnFailureResponse_6(error);
    }

    static void OnSuccessCallback_6(void * context,
                                    const chip::app::DataModel::Nullable<chip::Percent> & currentPositionLiftPercentage)
    {
        (static_cast<Test_TC_WNCV_3_5Suite *>(context))->OnSuccessResponse_6(currentPositionLiftPercentage);
    }

    static void OnFailureCallback_7(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_3_5Suite *>(context))->OnFailureResponse_7(error);
    }

    static void OnSuccessCallback_7(void * context,
                                    const chip::app::DataModel::Nullable<chip::Percent100ths> & currentPositionTiltPercent100ths)
    {
        (static_cast<Test_TC_WNCV_3_5Suite *>(context))->OnSuccessResponse_7(currentPositionTiltPercent100ths);
    }

    static void OnFailureCallback_8(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_3_5Suite *>(context))->OnFailureResponse_8(error);
    }

    static void OnSuccessCallback_8(void * context,
                                    const chip::app::DataModel::Nullable<chip::Percent> & currentPositionTiltPercentage)
    {
        (static_cast<Test_TC_WNCV_3_5Suite *>(context))->OnSuccessResponse_8(currentPositionTiltPercentage);
    }

    //
    // Tests methods
    //

    CHIP_ERROR Test0WaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR Test1aThSendsUpOrOpenCommandToPrepositionTheDutInTheOppositeDirection_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::WindowCovering::Commands::UpOrOpen::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_WNCV_3_5Suite *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_WNCV_3_5Suite *>(context))->OnFailureResponse_1(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR Test1bThWaitsForFastMotionDurationSecondsMovementsOnTheDevice_2()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForMs(mFastMotionDuration.HasValue() ? mFastMotionDuration.Value() : 3000U);
    }

    CHIP_ERROR Test2aThSendsDownOrCloseCommandToDut_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::WindowCovering::Commands::DownOrClose::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_WNCV_3_5Suite *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_WNCV_3_5Suite *>(context))->OnFailureResponse_3(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR Test2bThWaitsForFullMotionDurationSecondsMovementsOnTheDevice_4()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForMs(mFullMotionDuration.HasValue() ? mFullMotionDuration.Value() : 6000U);
    }

    CHIP_ERROR Test3aIfPaLfThReadsCurrentPositionLiftPercent100thsAttributeFromDut_5()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::CurrentPositionLiftPercent100ths::TypeInfo>(
                this, OnSuccessCallback_5, OnFailureCallback_5, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_5(const chip::app::DataModel::Nullable<chip::Percent100ths> & currentPositionLiftPercent100ths)
    {
        VerifyOrReturn(CheckValueNonNull("currentPositionLiftPercent100ths", currentPositionLiftPercent100ths));
        VerifyOrReturn(CheckValue("currentPositionLiftPercent100ths.Value()", currentPositionLiftPercent100ths.Value(), 10000U));

        NextTest();
    }

    CHIP_ERROR Test3bIfPaLfThReadsCurrentPositionLiftPercentageOptionalAttributeFromDut_6()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::CurrentPositionLiftPercentage::TypeInfo>(
                this, OnSuccessCallback_6, OnFailureCallback_6, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_6(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_6(const chip::app::DataModel::Nullable<chip::Percent> & currentPositionLiftPercentage)
    {
        VerifyOrReturn(CheckValueNonNull("currentPositionLiftPercentage", currentPositionLiftPercentage));
        VerifyOrReturn(CheckValue("currentPositionLiftPercentage.Value()", currentPositionLiftPercentage.Value(), 100));

        NextTest();
    }

    CHIP_ERROR Test3cIfPaTlThReadsCurrentPositionTiltPercent100thsAttributeFromDut_7()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::CurrentPositionTiltPercent100ths::TypeInfo>(
                this, OnSuccessCallback_7, OnFailureCallback_7, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_7(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_7(const chip::app::DataModel::Nullable<chip::Percent100ths> & currentPositionTiltPercent100ths)
    {
        VerifyOrReturn(CheckValueNonNull("currentPositionTiltPercent100ths", currentPositionTiltPercent100ths));
        VerifyOrReturn(CheckValue("currentPositionTiltPercent100ths.Value()", currentPositionTiltPercent100ths.Value(), 10000U));

        NextTest();
    }

    CHIP_ERROR Test3dIfPaTlThReadsCurrentPositionTiltPercentageOptionalAttributeFromDut_8()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::CurrentPositionTiltPercentage::TypeInfo>(
                this, OnSuccessCallback_8, OnFailureCallback_8, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_8(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_8(const chip::app::DataModel::Nullable<chip::Percent> & currentPositionTiltPercentage)
    {
        VerifyOrReturn(CheckValueNonNull("currentPositionTiltPercentage", currentPositionTiltPercentage));
        VerifyOrReturn(CheckValue("currentPositionTiltPercentage.Value()", currentPositionTiltPercentage.Value(), 100));

        NextTest();
    }
};

class Test_TC_WNCV_4_3Suite : public TestCommand
{
public:
    Test_TC_WNCV_4_3Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_WNCV_4_3", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_WNCV_4_3Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_WNCV_4_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_WNCV_4_3\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : 0: Wait for the commissioned device to be retrieved\n");
            err = Test0WaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool,
                            " ***** Test Step 1 : 1a: If (PA_LF & LF) TH reads CurrentPositionLiftPercent100ths from DUT\n");
            if (ShouldSkip("WNCV_LF && WNCV_PA_LF"))
            {
                NextTest();
                return;
            }
            err = Test1aIfPaLfLfThReadsCurrentPositionLiftPercent100thsFromDut_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : 1b: If (PA_LF & LF) TH reads CurrentPositionLiftPercentage from DUT\n");
            if (ShouldSkip("WNCV_LF && WNCV_PA_LF && A_CURRENTPOSITIONLIFTPERCENTAGE"))
            {
                NextTest();
                return;
            }
            err = Test1bIfPaLfLfThReadsCurrentPositionLiftPercentageFromDut_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : 2b: TH sends GoToLiftPercentage command with BadParam to DUT\n");
            if (ShouldSkip("WNCV_LF && WNCV_PA_LF || WNCV_LF && PICS_CR_GOTOLIFTPERCENTAGE"))
            {
                NextTest();
                return;
            }
            err = Test2bThSendsGoToLiftPercentageCommandWithBadParamToDut_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : 3a: TH sends GoToLiftPercentage command with 10001 to DUT\n");
            if (ShouldSkip("WNCV_LF && WNCV_PA_LF || WNCV_LF && PICS_CR_GOTOLIFTPERCENTAGE"))
            {
                NextTest();
                return;
            }
            err = Test3aThSendsGoToLiftPercentageCommandWith10001ToDut_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : 4a: TH sends GoToLiftPercentage command with 0xFFFF to DUT\n");
            if (ShouldSkip("WNCV_LF && WNCV_PA_LF || WNCV_LF && PICS_CR_GOTOLIFTPERCENTAGE"))
            {
                NextTest();
                return;
            }
            err = Test4aThSendsGoToLiftPercentageCommandWith0xFFFFToDut_5();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 6;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::app::DataModel::Nullable<chip::Percent100ths> attrCurrentPositionLiftPercent100ths;
    chip::app::DataModel::Nullable<chip::Percent> attrCurrentPositionLiftPercentage;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_1(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_4_3Suite *>(context))->OnFailureResponse_1(error);
    }

    static void OnSuccessCallback_1(void * context,
                                    const chip::app::DataModel::Nullable<chip::Percent100ths> & currentPositionLiftPercent100ths)
    {
        (static_cast<Test_TC_WNCV_4_3Suite *>(context))->OnSuccessResponse_1(currentPositionLiftPercent100ths);
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_4_3Suite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context,
                                    const chip::app::DataModel::Nullable<chip::Percent> & currentPositionLiftPercentage)
    {
        (static_cast<Test_TC_WNCV_4_3Suite *>(context))->OnSuccessResponse_2(currentPositionLiftPercentage);
    }

    //
    // Tests methods
    //

    CHIP_ERROR Test0WaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR Test1aIfPaLfLfThReadsCurrentPositionLiftPercent100thsFromDut_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::CurrentPositionLiftPercent100ths::TypeInfo>(
                this, OnSuccessCallback_1, OnFailureCallback_1, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1(const chip::app::DataModel::Nullable<chip::Percent100ths> & currentPositionLiftPercent100ths)
    {
        VerifyOrReturn(
            CheckConstraintMinValue<chip::Percent100ths>("currentPositionLiftPercent100ths", currentPositionLiftPercent100ths, 0U));
        VerifyOrReturn(CheckConstraintMaxValue<chip::Percent100ths>("currentPositionLiftPercent100ths",
                                                                    currentPositionLiftPercent100ths, 10000U));
        attrCurrentPositionLiftPercent100ths = currentPositionLiftPercent100ths;
        NextTest();
    }

    CHIP_ERROR Test1bIfPaLfLfThReadsCurrentPositionLiftPercentageFromDut_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::CurrentPositionLiftPercentage::TypeInfo>(
                this, OnSuccessCallback_2, OnFailureCallback_2, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2(const chip::app::DataModel::Nullable<chip::Percent> & currentPositionLiftPercentage)
    {
        VerifyOrReturn(CheckConstraintMinValue<chip::Percent>("currentPositionLiftPercentage", currentPositionLiftPercentage, 0));
        VerifyOrReturn(CheckConstraintMaxValue<chip::Percent>("currentPositionLiftPercentage", currentPositionLiftPercentage, 100));
        attrCurrentPositionLiftPercentage = currentPositionLiftPercentage;
        NextTest();
    }

    CHIP_ERROR Test2bThSendsGoToLiftPercentageCommandWithBadParamToDut_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::WindowCovering::Commands::GoToLiftPercentage::Type;

        RequestType request;
        request.liftPercentageValue    = 63;
        request.liftPercent100thsValue = 12288U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_WNCV_4_3Suite *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_WNCV_4_3Suite *>(context))->OnFailureResponse_3(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
        NextTest();
    }

    void OnSuccessResponse_3() { ThrowSuccessResponse(); }

    CHIP_ERROR Test3aThSendsGoToLiftPercentageCommandWith10001ToDut_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::WindowCovering::Commands::GoToLiftPercentage::Type;

        RequestType request;
        request.liftPercentageValue    = 100;
        request.liftPercent100thsValue = 10001U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_WNCV_4_3Suite *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_WNCV_4_3Suite *>(context))->OnFailureResponse_4(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
        NextTest();
    }

    void OnSuccessResponse_4() { ThrowSuccessResponse(); }

    CHIP_ERROR Test4aThSendsGoToLiftPercentageCommandWith0xFFFFToDut_5()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::WindowCovering::Commands::GoToLiftPercentage::Type;

        RequestType request;
        request.liftPercentageValue    = 255;
        request.liftPercent100thsValue = 65535U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_WNCV_4_3Suite *>(context))->OnSuccessResponse_5();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_WNCV_4_3Suite *>(context))->OnFailureResponse_5(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
        NextTest();
    }

    void OnSuccessResponse_5() { ThrowSuccessResponse(); }
};

class Test_TC_WNCV_4_4Suite : public TestCommand
{
public:
    Test_TC_WNCV_4_4Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_WNCV_4_4", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_WNCV_4_4Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_WNCV_4_4\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_WNCV_4_4\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : 0: Wait for the commissioned device to be retrieved\n");
            err = Test0WaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool,
                            " ***** Test Step 1 : 1a: If (PA_TL & TL) TH reads CurrentPositionTiltPercent100ths from DUT\n");
            if (ShouldSkip("WNCV_TL && WNCV_PA_TL"))
            {
                NextTest();
                return;
            }
            err = Test1aIfPaTlTlThReadsCurrentPositionTiltPercent100thsFromDut_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : 1b: If (PA_TL & TL) TH reads CurrentPositionTiltPercentage from DUT\n");
            if (ShouldSkip("WNCV_TL && WNCV_PA_TL && A_CURRENTPOSITIONTILTPERCENTAGE"))
            {
                NextTest();
                return;
            }
            err = Test1bIfPaTlTlThReadsCurrentPositionTiltPercentageFromDut_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : 2b: TH sends GoToTiltPercentage command with BadParam to DUT\n");
            if (ShouldSkip("WNCV_TL && WNCV_PA_TL || WNCV_TL && PICS_CR_GOTOTILTPERCENTAGE"))
            {
                NextTest();
                return;
            }
            err = Test2bThSendsGoToTiltPercentageCommandWithBadParamToDut_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : 3a: TH sends GoToTiltPercentage command with 10001 to DUT\n");
            if (ShouldSkip("WNCV_TL && WNCV_PA_TL || WNCV_TL && PICS_CR_GOTOTILTPERCENTAGE"))
            {
                NextTest();
                return;
            }
            err = Test3aThSendsGoToTiltPercentageCommandWith10001ToDut_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : 4a: TH sends GoToTiltPercentage command with 0xFFFF to DUT\n");
            if (ShouldSkip("WNCV_TL && WNCV_PA_TL || WNCV_TL && PICS_CR_GOTOTILTPERCENTAGE"))
            {
                NextTest();
                return;
            }
            err = Test4aThSendsGoToTiltPercentageCommandWith0xFFFFToDut_5();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 6;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::app::DataModel::Nullable<chip::Percent100ths> attrCurrentPositionTiltPercent100ths;
    chip::app::DataModel::Nullable<chip::Percent> attrCurrentPositionTiltPercentage;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_1(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_4_4Suite *>(context))->OnFailureResponse_1(error);
    }

    static void OnSuccessCallback_1(void * context,
                                    const chip::app::DataModel::Nullable<chip::Percent100ths> & currentPositionTiltPercent100ths)
    {
        (static_cast<Test_TC_WNCV_4_4Suite *>(context))->OnSuccessResponse_1(currentPositionTiltPercent100ths);
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_WNCV_4_4Suite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context,
                                    const chip::app::DataModel::Nullable<chip::Percent> & currentPositionTiltPercentage)
    {
        (static_cast<Test_TC_WNCV_4_4Suite *>(context))->OnSuccessResponse_2(currentPositionTiltPercentage);
    }

    //
    // Tests methods
    //

    CHIP_ERROR Test0WaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR Test1aIfPaTlTlThReadsCurrentPositionTiltPercent100thsFromDut_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::CurrentPositionTiltPercent100ths::TypeInfo>(
                this, OnSuccessCallback_1, OnFailureCallback_1, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1(const chip::app::DataModel::Nullable<chip::Percent100ths> & currentPositionTiltPercent100ths)
    {
        VerifyOrReturn(
            CheckConstraintMinValue<chip::Percent100ths>("currentPositionTiltPercent100ths", currentPositionTiltPercent100ths, 0U));
        VerifyOrReturn(CheckConstraintMaxValue<chip::Percent100ths>("currentPositionTiltPercent100ths",
                                                                    currentPositionTiltPercent100ths, 10000U));
        attrCurrentPositionTiltPercent100ths = currentPositionTiltPercent100ths;
        NextTest();
    }

    CHIP_ERROR Test1bIfPaTlTlThReadsCurrentPositionTiltPercentageFromDut_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::CurrentPositionTiltPercentage::TypeInfo>(
                this, OnSuccessCallback_2, OnFailureCallback_2, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2(const chip::app::DataModel::Nullable<chip::Percent> & currentPositionTiltPercentage)
    {
        VerifyOrReturn(CheckConstraintMinValue<chip::Percent>("currentPositionTiltPercentage", currentPositionTiltPercentage, 0));
        VerifyOrReturn(CheckConstraintMaxValue<chip::Percent>("currentPositionTiltPercentage", currentPositionTiltPercentage, 100));
        attrCurrentPositionTiltPercentage = currentPositionTiltPercentage;
        NextTest();
    }

    CHIP_ERROR Test2bThSendsGoToTiltPercentageCommandWithBadParamToDut_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::WindowCovering::Commands::GoToTiltPercentage::Type;

        RequestType request;
        request.tiltPercentageValue    = 63;
        request.tiltPercent100thsValue = 12288U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_WNCV_4_4Suite *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_WNCV_4_4Suite *>(context))->OnFailureResponse_3(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
        NextTest();
    }

    void OnSuccessResponse_3() { ThrowSuccessResponse(); }

    CHIP_ERROR Test3aThSendsGoToTiltPercentageCommandWith10001ToDut_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::WindowCovering::Commands::GoToTiltPercentage::Type;

        RequestType request;
        request.tiltPercentageValue    = 100;
        request.tiltPercent100thsValue = 10001U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_WNCV_4_4Suite *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_WNCV_4_4Suite *>(context))->OnFailureResponse_4(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
        NextTest();
    }

    void OnSuccessResponse_4() { ThrowSuccessResponse(); }

    CHIP_ERROR Test4aThSendsGoToTiltPercentageCommandWith0xFFFFToDut_5()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::WindowCovering::Commands::GoToTiltPercentage::Type;

        RequestType request;
        request.tiltPercentageValue    = 255;
        request.tiltPercent100thsValue = 65535U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_WNCV_4_4Suite *>(context))->OnSuccessResponse_5();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_WNCV_4_4Suite *>(context))->OnFailureResponse_5(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
        NextTest();
    }

    void OnSuccessResponse_5() { ThrowSuccessResponse(); }
};

class TV_TargetNavigatorClusterSuite : public TestCommand
{
public:
    TV_TargetNavigatorClusterSuite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("TV_TargetNavigatorCluster", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~TV_TargetNavigatorClusterSuite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TV_TargetNavigatorCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TV_TargetNavigatorCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read attribute Target Navigator list\n");
            err = TestReadAttributeTargetNavigatorList_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read attribute current navigator target\n");
            err = TestReadAttributeCurrentNavigatorTarget_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Navigate Target Request Command\n");
            err = TestNavigateTargetRequestCommand_3();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 4;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_1(void * context, CHIP_ERROR error)
    {
        (static_cast<TV_TargetNavigatorClusterSuite *>(context))->OnFailureResponse_1(error);
    }

    static void OnSuccessCallback_1(
        void * context,
        const chip::app::DataModel::DecodableList<chip::app::Clusters::TargetNavigator::Structs::TargetInfo::DecodableType> &
            targetList)
    {
        (static_cast<TV_TargetNavigatorClusterSuite *>(context))->OnSuccessResponse_1(targetList);
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<TV_TargetNavigatorClusterSuite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context, uint8_t currentTarget)
    {
        (static_cast<TV_TargetNavigatorClusterSuite *>(context))->OnSuccessResponse_2(currentTarget);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestReadAttributeTargetNavigatorList_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TargetNavigatorClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TargetNavigator::Attributes::TargetList::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1(
        const chip::app::DataModel::DecodableList<chip::app::Clusters::TargetNavigator::Structs::TargetInfo::DecodableType> &
            targetList)
    {
        {
            auto iter_0 = targetList.begin();
            VerifyOrReturn(CheckNextListItemDecodes<decltype(targetList)>("targetList", iter_0, 0));
            VerifyOrReturn(CheckValue("targetList[0].identifier", iter_0.GetValue().identifier, 1));
            VerifyOrReturn(CheckValueAsString("targetList[0].name", iter_0.GetValue().name, chip::CharSpan("exampleName", 11)));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(targetList)>("targetList", iter_0, 1));
            VerifyOrReturn(CheckValue("targetList[1].identifier", iter_0.GetValue().identifier, 2));
            VerifyOrReturn(CheckValueAsString("targetList[1].name", iter_0.GetValue().name, chip::CharSpan("exampleName", 11)));
            VerifyOrReturn(CheckNoMoreListItems<decltype(targetList)>("targetList", iter_0, 2));
        }

        NextTest();
    }

    CHIP_ERROR TestReadAttributeCurrentNavigatorTarget_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TargetNavigatorClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TargetNavigator::Attributes::CurrentTarget::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2(uint8_t currentTarget)
    {
        VerifyOrReturn(CheckValue("currentTarget", currentTarget, 0));

        NextTest();
    }

    CHIP_ERROR TestNavigateTargetRequestCommand_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::TargetNavigator::Commands::NavigateTarget::Type;

        RequestType request;
        request.target = 1;
        request.data.Emplace();
        request.data.Value() = chip::Span<const char>("1garbage: not in length on purpose", 1);

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TV_TargetNavigatorClusterSuite *>(context))->OnSuccessResponse_3(data.status, data.data);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TV_TargetNavigatorClusterSuite *>(context))->OnFailureResponse_3(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3(chip::app::Clusters::TargetNavigator::StatusEnum status, const chip::Optional<chip::CharSpan> & data)
    {
        VerifyOrReturn(CheckValue("status", status, 0));

        VerifyOrReturn(CheckValuePresent("data", data));
        VerifyOrReturn(CheckValueAsString("data.Value()", data.Value(), chip::CharSpan("data response", 13)));

        NextTest();
    }
};

class TV_AudioOutputClusterSuite : public TestCommand
{
public:
    TV_AudioOutputClusterSuite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("TV_AudioOutputCluster", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~TV_AudioOutputClusterSuite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TV_AudioOutputCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TV_AudioOutputCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read attribute Audio Output list\n");
            err = TestReadAttributeAudioOutputList_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read attribute current audio output\n");
            err = TestReadAttributeCurrentAudioOutput_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Select Output Command\n");
            err = TestSelectOutputCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Rename Output Command\n");
            err = TestRenameOutputCommand_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Read attribute Audio Output list\n");
            err = TestReadAttributeAudioOutputList_5();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 6;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_1(void * context, CHIP_ERROR error)
    {
        (static_cast<TV_AudioOutputClusterSuite *>(context))->OnFailureResponse_1(error);
    }

    static void OnSuccessCallback_1(
        void * context,
        const chip::app::DataModel::DecodableList<chip::app::Clusters::AudioOutput::Structs::OutputInfo::DecodableType> &
            outputList)
    {
        (static_cast<TV_AudioOutputClusterSuite *>(context))->OnSuccessResponse_1(outputList);
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<TV_AudioOutputClusterSuite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context, uint8_t currentOutput)
    {
        (static_cast<TV_AudioOutputClusterSuite *>(context))->OnSuccessResponse_2(currentOutput);
    }

    static void OnFailureCallback_5(void * context, CHIP_ERROR error)
    {
        (static_cast<TV_AudioOutputClusterSuite *>(context))->OnFailureResponse_5(error);
    }

    static void OnSuccessCallback_5(
        void * context,
        const chip::app::DataModel::DecodableList<chip::app::Clusters::AudioOutput::Structs::OutputInfo::DecodableType> &
            outputList)
    {
        (static_cast<TV_AudioOutputClusterSuite *>(context))->OnSuccessResponse_5(outputList);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestReadAttributeAudioOutputList_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 2;
        chip::Controller::AudioOutputClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::AudioOutput::Attributes::OutputList::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1(
        const chip::app::DataModel::DecodableList<chip::app::Clusters::AudioOutput::Structs::OutputInfo::DecodableType> &
            outputList)
    {
        {
            auto iter_0 = outputList.begin();
            VerifyOrReturn(CheckNextListItemDecodes<decltype(outputList)>("outputList", iter_0, 0));
            VerifyOrReturn(CheckValue("outputList[0].index", iter_0.GetValue().index, 1));
            VerifyOrReturn(CheckValue("outputList[0].outputType", iter_0.GetValue().outputType, 0));
            VerifyOrReturn(CheckValueAsString("outputList[0].name", iter_0.GetValue().name, chip::CharSpan("HDMI", 4)));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(outputList)>("outputList", iter_0, 1));
            VerifyOrReturn(CheckValue("outputList[1].index", iter_0.GetValue().index, 2));
            VerifyOrReturn(CheckValue("outputList[1].outputType", iter_0.GetValue().outputType, 0));
            VerifyOrReturn(CheckValueAsString("outputList[1].name", iter_0.GetValue().name, chip::CharSpan("HDMI", 4)));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(outputList)>("outputList", iter_0, 2));
            VerifyOrReturn(CheckValue("outputList[2].index", iter_0.GetValue().index, 3));
            VerifyOrReturn(CheckValue("outputList[2].outputType", iter_0.GetValue().outputType, 0));
            VerifyOrReturn(CheckValueAsString("outputList[2].name", iter_0.GetValue().name, chip::CharSpan("HDMI", 4)));
            VerifyOrReturn(CheckNoMoreListItems<decltype(outputList)>("outputList", iter_0, 3));
        }

        NextTest();
    }

    CHIP_ERROR TestReadAttributeCurrentAudioOutput_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 2;
        chip::Controller::AudioOutputClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::AudioOutput::Attributes::CurrentOutput::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2(uint8_t currentOutput)
    {
        VerifyOrReturn(CheckValue("currentOutput", currentOutput, 1));

        NextTest();
    }

    CHIP_ERROR TestSelectOutputCommand_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 2;
        using RequestType               = chip::app::Clusters::AudioOutput::Commands::SelectOutput::Type;

        RequestType request;
        request.index = 1;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TV_AudioOutputClusterSuite *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TV_AudioOutputClusterSuite *>(context))->OnFailureResponse_3(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestRenameOutputCommand_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 2;
        using RequestType               = chip::app::Clusters::AudioOutput::Commands::RenameOutput::Type;

        RequestType request;
        request.index = 1;
        request.name  = chip::Span<const char>("HDMI Testgarbage: not in length on purpose", 9);

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TV_AudioOutputClusterSuite *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TV_AudioOutputClusterSuite *>(context))->OnFailureResponse_4(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestReadAttributeAudioOutputList_5()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 2;
        chip::Controller::AudioOutputClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::AudioOutput::Attributes::OutputList::TypeInfo>(
            this, OnSuccessCallback_5, OnFailureCallback_5, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_5(
        const chip::app::DataModel::DecodableList<chip::app::Clusters::AudioOutput::Structs::OutputInfo::DecodableType> &
            outputList)
    {
        {
            auto iter_0 = outputList.begin();
            VerifyOrReturn(CheckNextListItemDecodes<decltype(outputList)>("outputList", iter_0, 0));
            VerifyOrReturn(CheckValue("outputList[0].index", iter_0.GetValue().index, 1));
            VerifyOrReturn(CheckValue("outputList[0].outputType", iter_0.GetValue().outputType, 0));
            VerifyOrReturn(CheckValueAsString("outputList[0].name", iter_0.GetValue().name, chip::CharSpan("HDMI Test", 9)));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(outputList)>("outputList", iter_0, 1));
            VerifyOrReturn(CheckValue("outputList[1].index", iter_0.GetValue().index, 2));
            VerifyOrReturn(CheckValue("outputList[1].outputType", iter_0.GetValue().outputType, 0));
            VerifyOrReturn(CheckValueAsString("outputList[1].name", iter_0.GetValue().name, chip::CharSpan("HDMI", 4)));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(outputList)>("outputList", iter_0, 2));
            VerifyOrReturn(CheckValue("outputList[2].index", iter_0.GetValue().index, 3));
            VerifyOrReturn(CheckValue("outputList[2].outputType", iter_0.GetValue().outputType, 0));
            VerifyOrReturn(CheckValueAsString("outputList[2].name", iter_0.GetValue().name, chip::CharSpan("HDMI", 4)));
            VerifyOrReturn(CheckNoMoreListItems<decltype(outputList)>("outputList", iter_0, 3));
        }

        NextTest();
    }
};

class TV_ApplicationLauncherClusterSuite : public TestCommand
{
public:
    TV_ApplicationLauncherClusterSuite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("TV_ApplicationLauncherCluster", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~TV_ApplicationLauncherClusterSuite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TV_ApplicationLauncherCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TV_ApplicationLauncherCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read attribute Application Launcher list\n");
            err = TestReadAttributeApplicationLauncherList_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read attribute application launcher app\n");
            err = TestReadAttributeApplicationLauncherApp_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Launch App Command\n");
            err = TestLaunchAppCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Stop App Command\n");
            err = TestStopAppCommand_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Hide App Command\n");
            err = TestHideAppCommand_5();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 6;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_1(void * context, CHIP_ERROR error)
    {
        (static_cast<TV_ApplicationLauncherClusterSuite *>(context))->OnFailureResponse_1(error);
    }

    static void OnSuccessCallback_1(void * context, const chip::app::DataModel::DecodableList<uint16_t> & catalogList)
    {
        (static_cast<TV_ApplicationLauncherClusterSuite *>(context))->OnSuccessResponse_1(catalogList);
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<TV_ApplicationLauncherClusterSuite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(
        void * context,
        const chip::app::DataModel::Nullable<chip::app::Clusters::ApplicationLauncher::Structs::ApplicationEP::DecodableType> &
            currentApp)
    {
        (static_cast<TV_ApplicationLauncherClusterSuite *>(context))->OnSuccessResponse_2(currentApp);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestReadAttributeApplicationLauncherList_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ApplicationLauncherClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ApplicationLauncher::Attributes::CatalogList::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1(const chip::app::DataModel::DecodableList<uint16_t> & catalogList)
    {
        {
            auto iter_0 = catalogList.begin();
            VerifyOrReturn(CheckNextListItemDecodes<decltype(catalogList)>("catalogList", iter_0, 0));
            VerifyOrReturn(CheckValue("catalogList[0]", iter_0.GetValue(), 123U));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(catalogList)>("catalogList", iter_0, 1));
            VerifyOrReturn(CheckValue("catalogList[1]", iter_0.GetValue(), 456U));
            VerifyOrReturn(CheckNoMoreListItems<decltype(catalogList)>("catalogList", iter_0, 2));
        }

        NextTest();
    }

    CHIP_ERROR TestReadAttributeApplicationLauncherApp_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ApplicationLauncherClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ApplicationLauncher::Attributes::CurrentApp::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2(
        const chip::app::DataModel::Nullable<chip::app::Clusters::ApplicationLauncher::Structs::ApplicationEP::DecodableType> &
            currentApp)
    {
        VerifyOrReturn(CheckValueNull("currentApp", currentApp));

        NextTest();
    }

    CHIP_ERROR TestLaunchAppCommand_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::ApplicationLauncher::Commands::LaunchApp::Type;

        RequestType request;

        request.application.catalogVendorId = 123U;
        request.application.applicationId   = chip::Span<const char>("applicationIdgarbage: not in length on purpose", 13);

        request.data.Emplace();
        request.data.Value() = chip::ByteSpan(chip::Uint8::from_const_char("datagarbage: not in length on purpose"), 4);

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TV_ApplicationLauncherClusterSuite *>(context))->OnSuccessResponse_3(data.status, data.data);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TV_ApplicationLauncherClusterSuite *>(context))->OnFailureResponse_3(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3(chip::app::Clusters::ApplicationLauncher::StatusEnum status, chip::ByteSpan data)
    {
        VerifyOrReturn(CheckValue("status", status, 0));

        VerifyOrReturn(CheckValueAsString("data", data, chip::ByteSpan(chip::Uint8::from_const_char("data"), 4)));

        NextTest();
    }

    CHIP_ERROR TestStopAppCommand_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::ApplicationLauncher::Commands::StopApp::Type;

        RequestType request;

        request.application.catalogVendorId = 123U;
        request.application.applicationId   = chip::Span<const char>("applicationIdgarbage: not in length on purpose", 13);

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TV_ApplicationLauncherClusterSuite *>(context))->OnSuccessResponse_4(data.status, data.data);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TV_ApplicationLauncherClusterSuite *>(context))->OnFailureResponse_4(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_4(chip::app::Clusters::ApplicationLauncher::StatusEnum status, chip::ByteSpan data)
    {
        VerifyOrReturn(CheckValue("status", status, 0));

        VerifyOrReturn(CheckValueAsString("data", data, chip::ByteSpan(chip::Uint8::from_const_char("data"), 4)));

        NextTest();
    }

    CHIP_ERROR TestHideAppCommand_5()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::ApplicationLauncher::Commands::HideApp::Type;

        RequestType request;

        request.application.catalogVendorId = 123U;
        request.application.applicationId   = chip::Span<const char>("applicationIdgarbage: not in length on purpose", 13);

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TV_ApplicationLauncherClusterSuite *>(context))->OnSuccessResponse_5(data.status, data.data);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TV_ApplicationLauncherClusterSuite *>(context))->OnFailureResponse_5(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_5(chip::app::Clusters::ApplicationLauncher::StatusEnum status, chip::ByteSpan data)
    {
        VerifyOrReturn(CheckValue("status", status, 0));

        VerifyOrReturn(CheckValueAsString("data", data, chip::ByteSpan(chip::Uint8::from_const_char("data"), 4)));

        NextTest();
    }
};

class TV_KeypadInputClusterSuite : public TestCommand
{
public:
    TV_KeypadInputClusterSuite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("TV_KeypadInputCluster", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~TV_KeypadInputClusterSuite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TV_KeypadInputCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TV_KeypadInputCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Send Key Command\n");
            err = TestSendKeyCommand_1();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 2;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestSendKeyCommand_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::KeypadInput::Commands::SendKey::Type;

        RequestType request;
        request.keyCode = static_cast<chip::app::Clusters::KeypadInput::CecKeyCode>(3);

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TV_KeypadInputClusterSuite *>(context))->OnSuccessResponse_1(data.status);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TV_KeypadInputClusterSuite *>(context))->OnFailureResponse_1(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1(chip::app::Clusters::KeypadInput::StatusEnum status)
    {
        VerifyOrReturn(CheckValue("status", status, 0));

        NextTest();
    }
};

class TV_AccountLoginClusterSuite : public TestCommand
{
public:
    TV_AccountLoginClusterSuite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("TV_AccountLoginCluster", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~TV_AccountLoginClusterSuite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TV_AccountLoginCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TV_AccountLoginCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Get Setup PIN Command\n");
            err = TestGetSetupPinCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Login Command\n");
            err = TestLoginCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Logout Command\n");
            err = TestLogoutCommand_3();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 4;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestGetSetupPinCommand_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 3;
        using RequestType               = chip::app::Clusters::AccountLogin::Commands::GetSetupPIN::Type;

        RequestType request;
        request.tempAccountIdentifier = chip::Span<const char>("asdfgarbage: not in length on purpose", 4);

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TV_AccountLoginClusterSuite *>(context))->OnSuccessResponse_1(data.setupPIN);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TV_AccountLoginClusterSuite *>(context))->OnFailureResponse_1(error);
        };

        ReturnErrorOnFailure(
            chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request, 10000));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1(chip::CharSpan setupPIN)
    {
        VerifyOrReturn(CheckValueAsString("setupPIN", setupPIN, chip::CharSpan("tempPin123", 10)));

        NextTest();
    }

    CHIP_ERROR TestLoginCommand_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 3;
        using RequestType               = chip::app::Clusters::AccountLogin::Commands::Login::Type;

        RequestType request;
        request.tempAccountIdentifier = chip::Span<const char>("asdfgarbage: not in length on purpose", 4);
        request.setupPIN              = chip::Span<const char>("tempPin123garbage: not in length on purpose", 10);

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TV_AccountLoginClusterSuite *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TV_AccountLoginClusterSuite *>(context))->OnFailureResponse_2(error);
        };

        ReturnErrorOnFailure(
            chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request, 10000));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestLogoutCommand_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 3;
        using RequestType               = chip::app::Clusters::AccountLogin::Commands::Logout::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TV_AccountLoginClusterSuite *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TV_AccountLoginClusterSuite *>(context))->OnFailureResponse_3(error);
        };

        ReturnErrorOnFailure(
            chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request, 10000));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3() { NextTest(); }
};

class TV_WakeOnLanClusterSuite : public TestCommand
{
public:
    TV_WakeOnLanClusterSuite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("TV_WakeOnLanCluster", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~TV_WakeOnLanClusterSuite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TV_WakeOnLanCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TV_WakeOnLanCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read mac address\n");
            err = TestReadMacAddress_1();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 2;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_1(void * context, CHIP_ERROR error)
    {
        (static_cast<TV_WakeOnLanClusterSuite *>(context))->OnFailureResponse_1(error);
    }

    static void OnSuccessCallback_1(void * context, chip::CharSpan MACAddress)
    {
        (static_cast<TV_WakeOnLanClusterSuite *>(context))->OnSuccessResponse_1(MACAddress);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestReadMacAddress_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::WakeOnLanClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::WakeOnLan::Attributes::MACAddress::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1(chip::CharSpan MACAddress)
    {
        VerifyOrReturn(CheckValueAsString("MACAddress", MACAddress, chip::CharSpan("00:00:00:00:00", 14)));

        NextTest();
    }
};

class TV_ApplicationBasicClusterSuite : public TestCommand
{
public:
    TV_ApplicationBasicClusterSuite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("TV_ApplicationBasicCluster", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~TV_ApplicationBasicClusterSuite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TV_ApplicationBasicCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TV_ApplicationBasicCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read attribute vendor name\n");
            err = TestReadAttributeVendorName_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read attribute vendor id\n");
            err = TestReadAttributeVendorId_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read attribute application name\n");
            err = TestReadAttributeApplicationName_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Read attribute product id\n");
            err = TestReadAttributeProductId_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Read attribute application status\n");
            err = TestReadAttributeApplicationStatus_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Read attribute application status\n");
            err = TestReadAttributeApplicationStatus_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Read attribute application version\n");
            err = TestReadAttributeApplicationVersion_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Read attribute application allowed vendor list\n");
            err = TestReadAttributeApplicationAllowedVendorList_8();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 9;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_1(void * context, CHIP_ERROR error)
    {
        (static_cast<TV_ApplicationBasicClusterSuite *>(context))->OnFailureResponse_1(error);
    }

    static void OnSuccessCallback_1(void * context, chip::CharSpan vendorName)
    {
        (static_cast<TV_ApplicationBasicClusterSuite *>(context))->OnSuccessResponse_1(vendorName);
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<TV_ApplicationBasicClusterSuite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context, uint16_t vendorID)
    {
        (static_cast<TV_ApplicationBasicClusterSuite *>(context))->OnSuccessResponse_2(vendorID);
    }

    static void OnFailureCallback_3(void * context, CHIP_ERROR error)
    {
        (static_cast<TV_ApplicationBasicClusterSuite *>(context))->OnFailureResponse_3(error);
    }

    static void OnSuccessCallback_3(void * context, chip::CharSpan applicationName)
    {
        (static_cast<TV_ApplicationBasicClusterSuite *>(context))->OnSuccessResponse_3(applicationName);
    }

    static void OnFailureCallback_4(void * context, CHIP_ERROR error)
    {
        (static_cast<TV_ApplicationBasicClusterSuite *>(context))->OnFailureResponse_4(error);
    }

    static void OnSuccessCallback_4(void * context, uint16_t productID)
    {
        (static_cast<TV_ApplicationBasicClusterSuite *>(context))->OnSuccessResponse_4(productID);
    }

    static void OnFailureCallback_5(void * context, CHIP_ERROR error)
    {
        (static_cast<TV_ApplicationBasicClusterSuite *>(context))->OnFailureResponse_5(error);
    }

    static void OnSuccessCallback_5(void * context, chip::app::Clusters::ApplicationBasic::ApplicationStatusEnum status)
    {
        (static_cast<TV_ApplicationBasicClusterSuite *>(context))->OnSuccessResponse_5(status);
    }

    static void OnFailureCallback_6(void * context, CHIP_ERROR error)
    {
        (static_cast<TV_ApplicationBasicClusterSuite *>(context))->OnFailureResponse_6(error);
    }

    static void OnSuccessCallback_6(
        void * context,
        const chip::app::Clusters::ApplicationBasic::Structs::ApplicationBasicApplication::DecodableType & application)
    {
        (static_cast<TV_ApplicationBasicClusterSuite *>(context))->OnSuccessResponse_6(application);
    }

    static void OnFailureCallback_7(void * context, CHIP_ERROR error)
    {
        (static_cast<TV_ApplicationBasicClusterSuite *>(context))->OnFailureResponse_7(error);
    }

    static void OnSuccessCallback_7(void * context, chip::CharSpan applicationVersion)
    {
        (static_cast<TV_ApplicationBasicClusterSuite *>(context))->OnSuccessResponse_7(applicationVersion);
    }

    static void OnFailureCallback_8(void * context, CHIP_ERROR error)
    {
        (static_cast<TV_ApplicationBasicClusterSuite *>(context))->OnFailureResponse_8(error);
    }

    static void OnSuccessCallback_8(void * context, const chip::app::DataModel::DecodableList<chip::VendorId> & allowedVendorList)
    {
        (static_cast<TV_ApplicationBasicClusterSuite *>(context))->OnSuccessResponse_8(allowedVendorList);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestReadAttributeVendorName_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 3;
        chip::Controller::ApplicationBasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ApplicationBasic::Attributes::VendorName::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1(chip::CharSpan vendorName)
    {
        VerifyOrReturn(CheckValueAsString("vendorName", vendorName, chip::CharSpan("exampleVendorName1", 18)));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeVendorId_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 3;
        chip::Controller::ApplicationBasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ApplicationBasic::Attributes::VendorID::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2(uint16_t vendorID)
    {
        VerifyOrReturn(CheckValue("vendorID", vendorID, 1U));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeApplicationName_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 3;
        chip::Controller::ApplicationBasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ApplicationBasic::Attributes::ApplicationName::TypeInfo>(
            this, OnSuccessCallback_3, OnFailureCallback_3, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3(chip::CharSpan applicationName)
    {
        VerifyOrReturn(CheckValueAsString("applicationName", applicationName, chip::CharSpan("exampleName1", 12)));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeProductId_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 3;
        chip::Controller::ApplicationBasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ApplicationBasic::Attributes::ProductID::TypeInfo>(
            this, OnSuccessCallback_4, OnFailureCallback_4, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_4(uint16_t productID)
    {
        VerifyOrReturn(CheckValue("productID", productID, 1U));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeApplicationStatus_5()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 3;
        chip::Controller::ApplicationBasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ApplicationBasic::Attributes::Status::TypeInfo>(
            this, OnSuccessCallback_5, OnFailureCallback_5, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_5(chip::app::Clusters::ApplicationBasic::ApplicationStatusEnum status)
    {
        VerifyOrReturn(CheckValue("status", status, 0));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeApplicationStatus_6()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 3;
        chip::Controller::ApplicationBasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ApplicationBasic::Attributes::Application::TypeInfo>(
            this, OnSuccessCallback_6, OnFailureCallback_6, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_6(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_6(
        const chip::app::Clusters::ApplicationBasic::Structs::ApplicationBasicApplication::DecodableType & application)
    {
        VerifyOrReturn(CheckValue("application.catalogVendorId", application.catalogVendorId, 123U));
        VerifyOrReturn(
            CheckValueAsString("application.applicationId", application.applicationId, chip::CharSpan("applicationId", 13)));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeApplicationVersion_7()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 3;
        chip::Controller::ApplicationBasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ApplicationBasic::Attributes::ApplicationVersion::TypeInfo>(
            this, OnSuccessCallback_7, OnFailureCallback_7, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_7(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_7(chip::CharSpan applicationVersion)
    {
        VerifyOrReturn(CheckValueAsString("applicationVersion", applicationVersion, chip::CharSpan("exampleVersion", 14)));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeApplicationAllowedVendorList_8()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 3;
        chip::Controller::ApplicationBasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ApplicationBasic::Attributes::AllowedVendorList::TypeInfo>(
            this, OnSuccessCallback_8, OnFailureCallback_8, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_8(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_8(const chip::app::DataModel::DecodableList<chip::VendorId> & allowedVendorList)
    {
        {
            auto iter_0 = allowedVendorList.begin();
            VerifyOrReturn(CheckNextListItemDecodes<decltype(allowedVendorList)>("allowedVendorList", iter_0, 0));
            VerifyOrReturn(CheckValue("allowedVendorList[0]", iter_0.GetValue(), 1U));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(allowedVendorList)>("allowedVendorList", iter_0, 1));
            VerifyOrReturn(CheckValue("allowedVendorList[1]", iter_0.GetValue(), 456U));
            VerifyOrReturn(CheckNoMoreListItems<decltype(allowedVendorList)>("allowedVendorList", iter_0, 2));
        }

        NextTest();
    }
};

class TV_MediaPlaybackClusterSuite : public TestCommand
{
public:
    TV_MediaPlaybackClusterSuite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("TV_MediaPlaybackCluster", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~TV_MediaPlaybackClusterSuite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TV_MediaPlaybackCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TV_MediaPlaybackCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read attribute playback state\n");
            err = TestReadAttributePlaybackState_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read attribute start time\n");
            err = TestReadAttributeStartTime_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read attribute duration\n");
            err = TestReadAttributeDuration_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Read attribute position\n");
            err = TestReadAttributePosition_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Read attribute playback speed\n");
            err = TestReadAttributePlaybackSpeed_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Read attribute seek range end\n");
            err = TestReadAttributeSeekRangeEnd_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Read attribute seek range start\n");
            err = TestReadAttributeSeekRangeStart_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Media Playback Play Command\n");
            err = TestMediaPlaybackPlayCommand_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Media Playback Pause Command\n");
            err = TestMediaPlaybackPauseCommand_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Media Playback Stop Command\n");
            err = TestMediaPlaybackStopCommand_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : Media Playback Start Over Command\n");
            err = TestMediaPlaybackStartOverCommand_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : Media Playback Previous Command\n");
            err = TestMediaPlaybackPreviousCommand_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : Media Playback Next Command\n");
            err = TestMediaPlaybackNextCommand_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : Media Playback Rewind Command\n");
            err = TestMediaPlaybackRewindCommand_14();
            break;
        case 15:
            ChipLogProgress(chipTool, " ***** Test Step 15 : Media Playback Fast Forward Command\n");
            err = TestMediaPlaybackFastForwardCommand_15();
            break;
        case 16:
            ChipLogProgress(chipTool, " ***** Test Step 16 : Media Playback Skip Forward Command\n");
            err = TestMediaPlaybackSkipForwardCommand_16();
            break;
        case 17:
            ChipLogProgress(chipTool, " ***** Test Step 17 : Read attribute position after skip forward\n");
            err = TestReadAttributePositionAfterSkipForward_17();
            break;
        case 18:
            ChipLogProgress(chipTool, " ***** Test Step 18 : Media Playback Skip Backward Command\n");
            err = TestMediaPlaybackSkipBackwardCommand_18();
            break;
        case 19:
            ChipLogProgress(chipTool, " ***** Test Step 19 : Read attribute position after skip backward\n");
            err = TestReadAttributePositionAfterSkipBackward_19();
            break;
        case 20:
            ChipLogProgress(chipTool, " ***** Test Step 20 : Media Playback Seek Command\n");
            err = TestMediaPlaybackSeekCommand_20();
            break;
        case 21:
            ChipLogProgress(chipTool, " ***** Test Step 21 : Read attribute position after seek\n");
            err = TestReadAttributePositionAfterSeek_21();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 22;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_1(void * context, CHIP_ERROR error)
    {
        (static_cast<TV_MediaPlaybackClusterSuite *>(context))->OnFailureResponse_1(error);
    }

    static void OnSuccessCallback_1(void * context, chip::app::Clusters::MediaPlayback::PlaybackStateEnum currentState)
    {
        (static_cast<TV_MediaPlaybackClusterSuite *>(context))->OnSuccessResponse_1(currentState);
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<TV_MediaPlaybackClusterSuite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context, const chip::app::DataModel::Nullable<uint64_t> & startTime)
    {
        (static_cast<TV_MediaPlaybackClusterSuite *>(context))->OnSuccessResponse_2(startTime);
    }

    static void OnFailureCallback_3(void * context, CHIP_ERROR error)
    {
        (static_cast<TV_MediaPlaybackClusterSuite *>(context))->OnFailureResponse_3(error);
    }

    static void OnSuccessCallback_3(void * context, const chip::app::DataModel::Nullable<uint64_t> & duration)
    {
        (static_cast<TV_MediaPlaybackClusterSuite *>(context))->OnSuccessResponse_3(duration);
    }

    static void OnFailureCallback_4(void * context, CHIP_ERROR error)
    {
        (static_cast<TV_MediaPlaybackClusterSuite *>(context))->OnFailureResponse_4(error);
    }

    static void OnSuccessCallback_4(
        void * context,
        const chip::app::DataModel::Nullable<chip::app::Clusters::MediaPlayback::Structs::PlaybackPosition::DecodableType> &
            sampledPosition)
    {
        (static_cast<TV_MediaPlaybackClusterSuite *>(context))->OnSuccessResponse_4(sampledPosition);
    }

    static void OnFailureCallback_5(void * context, CHIP_ERROR error)
    {
        (static_cast<TV_MediaPlaybackClusterSuite *>(context))->OnFailureResponse_5(error);
    }

    static void OnSuccessCallback_5(void * context, float playbackSpeed)
    {
        (static_cast<TV_MediaPlaybackClusterSuite *>(context))->OnSuccessResponse_5(playbackSpeed);
    }

    static void OnFailureCallback_6(void * context, CHIP_ERROR error)
    {
        (static_cast<TV_MediaPlaybackClusterSuite *>(context))->OnFailureResponse_6(error);
    }

    static void OnSuccessCallback_6(void * context, const chip::app::DataModel::Nullable<uint64_t> & seekRangeEnd)
    {
        (static_cast<TV_MediaPlaybackClusterSuite *>(context))->OnSuccessResponse_6(seekRangeEnd);
    }

    static void OnFailureCallback_7(void * context, CHIP_ERROR error)
    {
        (static_cast<TV_MediaPlaybackClusterSuite *>(context))->OnFailureResponse_7(error);
    }

    static void OnSuccessCallback_7(void * context, const chip::app::DataModel::Nullable<uint64_t> & seekRangeStart)
    {
        (static_cast<TV_MediaPlaybackClusterSuite *>(context))->OnSuccessResponse_7(seekRangeStart);
    }

    static void OnFailureCallback_17(void * context, CHIP_ERROR error)
    {
        (static_cast<TV_MediaPlaybackClusterSuite *>(context))->OnFailureResponse_17(error);
    }

    static void OnSuccessCallback_17(
        void * context,
        const chip::app::DataModel::Nullable<chip::app::Clusters::MediaPlayback::Structs::PlaybackPosition::DecodableType> &
            sampledPosition)
    {
        (static_cast<TV_MediaPlaybackClusterSuite *>(context))->OnSuccessResponse_17(sampledPosition);
    }

    static void OnFailureCallback_19(void * context, CHIP_ERROR error)
    {
        (static_cast<TV_MediaPlaybackClusterSuite *>(context))->OnFailureResponse_19(error);
    }

    static void OnSuccessCallback_19(
        void * context,
        const chip::app::DataModel::Nullable<chip::app::Clusters::MediaPlayback::Structs::PlaybackPosition::DecodableType> &
            sampledPosition)
    {
        (static_cast<TV_MediaPlaybackClusterSuite *>(context))->OnSuccessResponse_19(sampledPosition);
    }

    static void OnFailureCallback_21(void * context, CHIP_ERROR error)
    {
        (static_cast<TV_MediaPlaybackClusterSuite *>(context))->OnFailureResponse_21(error);
    }

    static void OnSuccessCallback_21(
        void * context,
        const chip::app::DataModel::Nullable<chip::app::Clusters::MediaPlayback::Structs::PlaybackPosition::DecodableType> &
            sampledPosition)
    {
        (static_cast<TV_MediaPlaybackClusterSuite *>(context))->OnSuccessResponse_21(sampledPosition);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestReadAttributePlaybackState_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 3;
        chip::Controller::MediaPlaybackClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::MediaPlayback::Attributes::CurrentState::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1(chip::app::Clusters::MediaPlayback::PlaybackStateEnum currentState)
    {
        VerifyOrReturn(CheckValue("currentState", currentState, 0));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeStartTime_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 3;
        chip::Controller::MediaPlaybackClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::MediaPlayback::Attributes::StartTime::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2(const chip::app::DataModel::Nullable<uint64_t> & startTime)
    {
        VerifyOrReturn(CheckValueNonNull("startTime", startTime));
        VerifyOrReturn(CheckValue("startTime.Value()", startTime.Value(), 0ULL));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeDuration_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 3;
        chip::Controller::MediaPlaybackClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::MediaPlayback::Attributes::Duration::TypeInfo>(
            this, OnSuccessCallback_3, OnFailureCallback_3, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3(const chip::app::DataModel::Nullable<uint64_t> & duration)
    {
        VerifyOrReturn(CheckValueNonNull("duration", duration));
        VerifyOrReturn(CheckValue("duration.Value()", duration.Value(), 80000ULL));

        NextTest();
    }

    CHIP_ERROR TestReadAttributePosition_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 3;
        chip::Controller::MediaPlaybackClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::MediaPlayback::Attributes::SampledPosition::TypeInfo>(
            this, OnSuccessCallback_4, OnFailureCallback_4, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_4(
        const chip::app::DataModel::Nullable<chip::app::Clusters::MediaPlayback::Structs::PlaybackPosition::DecodableType> &
            sampledPosition)
    {
        VerifyOrReturn(CheckValueNonNull("sampledPosition", sampledPosition));
        VerifyOrReturn(CheckValue("sampledPosition.Value().updatedAt", sampledPosition.Value().updatedAt, 0ULL));
        VerifyOrReturn(CheckValueNonNull("sampledPosition.Value().position", sampledPosition.Value().position));
        VerifyOrReturn(CheckValue("sampledPosition.Value().position.Value()", sampledPosition.Value().position.Value(), 0ULL));

        NextTest();
    }

    CHIP_ERROR TestReadAttributePlaybackSpeed_5()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 3;
        chip::Controller::MediaPlaybackClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::MediaPlayback::Attributes::PlaybackSpeed::TypeInfo>(
            this, OnSuccessCallback_5, OnFailureCallback_5, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_5(float playbackSpeed)
    {
        VerifyOrReturn(CheckValue("playbackSpeed", playbackSpeed, 0.0f));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeSeekRangeEnd_6()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 3;
        chip::Controller::MediaPlaybackClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::MediaPlayback::Attributes::SeekRangeEnd::TypeInfo>(
            this, OnSuccessCallback_6, OnFailureCallback_6, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_6(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_6(const chip::app::DataModel::Nullable<uint64_t> & seekRangeEnd)
    {
        VerifyOrReturn(CheckValueNonNull("seekRangeEnd", seekRangeEnd));
        VerifyOrReturn(CheckValue("seekRangeEnd.Value()", seekRangeEnd.Value(), 80000ULL));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeSeekRangeStart_7()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 3;
        chip::Controller::MediaPlaybackClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::MediaPlayback::Attributes::SeekRangeStart::TypeInfo>(
            this, OnSuccessCallback_7, OnFailureCallback_7, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_7(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_7(const chip::app::DataModel::Nullable<uint64_t> & seekRangeStart)
    {
        VerifyOrReturn(CheckValueNonNull("seekRangeStart", seekRangeStart));
        VerifyOrReturn(CheckValue("seekRangeStart.Value()", seekRangeStart.Value(), 0ULL));

        NextTest();
    }

    CHIP_ERROR TestMediaPlaybackPlayCommand_8()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 3;
        using RequestType               = chip::app::Clusters::MediaPlayback::Commands::Play::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TV_MediaPlaybackClusterSuite *>(context))->OnSuccessResponse_8(data.status);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TV_MediaPlaybackClusterSuite *>(context))->OnFailureResponse_8(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_8(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_8(chip::app::Clusters::MediaPlayback::StatusEnum status)
    {
        VerifyOrReturn(CheckValue("status", status, 0));

        NextTest();
    }

    CHIP_ERROR TestMediaPlaybackPauseCommand_9()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 3;
        using RequestType               = chip::app::Clusters::MediaPlayback::Commands::Pause::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TV_MediaPlaybackClusterSuite *>(context))->OnSuccessResponse_9(data.status);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TV_MediaPlaybackClusterSuite *>(context))->OnFailureResponse_9(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_9(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_9(chip::app::Clusters::MediaPlayback::StatusEnum status)
    {
        VerifyOrReturn(CheckValue("status", status, 0));

        NextTest();
    }

    CHIP_ERROR TestMediaPlaybackStopCommand_10()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 3;
        using RequestType               = chip::app::Clusters::MediaPlayback::Commands::StopPlayback::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TV_MediaPlaybackClusterSuite *>(context))->OnSuccessResponse_10(data.status);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TV_MediaPlaybackClusterSuite *>(context))->OnFailureResponse_10(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_10(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_10(chip::app::Clusters::MediaPlayback::StatusEnum status)
    {
        VerifyOrReturn(CheckValue("status", status, 0));

        NextTest();
    }

    CHIP_ERROR TestMediaPlaybackStartOverCommand_11()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 3;
        using RequestType               = chip::app::Clusters::MediaPlayback::Commands::StartOver::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TV_MediaPlaybackClusterSuite *>(context))->OnSuccessResponse_11(data.status);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TV_MediaPlaybackClusterSuite *>(context))->OnFailureResponse_11(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_11(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_11(chip::app::Clusters::MediaPlayback::StatusEnum status)
    {
        VerifyOrReturn(CheckValue("status", status, 0));

        NextTest();
    }

    CHIP_ERROR TestMediaPlaybackPreviousCommand_12()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 3;
        using RequestType               = chip::app::Clusters::MediaPlayback::Commands::Previous::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TV_MediaPlaybackClusterSuite *>(context))->OnSuccessResponse_12(data.status);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TV_MediaPlaybackClusterSuite *>(context))->OnFailureResponse_12(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_12(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_12(chip::app::Clusters::MediaPlayback::StatusEnum status)
    {
        VerifyOrReturn(CheckValue("status", status, 0));

        NextTest();
    }

    CHIP_ERROR TestMediaPlaybackNextCommand_13()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 3;
        using RequestType               = chip::app::Clusters::MediaPlayback::Commands::Next::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TV_MediaPlaybackClusterSuite *>(context))->OnSuccessResponse_13(data.status);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TV_MediaPlaybackClusterSuite *>(context))->OnFailureResponse_13(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_13(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_13(chip::app::Clusters::MediaPlayback::StatusEnum status)
    {
        VerifyOrReturn(CheckValue("status", status, 0));

        NextTest();
    }

    CHIP_ERROR TestMediaPlaybackRewindCommand_14()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 3;
        using RequestType               = chip::app::Clusters::MediaPlayback::Commands::Rewind::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TV_MediaPlaybackClusterSuite *>(context))->OnSuccessResponse_14(data.status);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TV_MediaPlaybackClusterSuite *>(context))->OnFailureResponse_14(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_14(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_14(chip::app::Clusters::MediaPlayback::StatusEnum status)
    {
        VerifyOrReturn(CheckValue("status", status, 0));

        NextTest();
    }

    CHIP_ERROR TestMediaPlaybackFastForwardCommand_15()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 3;
        using RequestType               = chip::app::Clusters::MediaPlayback::Commands::FastForward::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TV_MediaPlaybackClusterSuite *>(context))->OnSuccessResponse_15(data.status);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TV_MediaPlaybackClusterSuite *>(context))->OnFailureResponse_15(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_15(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_15(chip::app::Clusters::MediaPlayback::StatusEnum status)
    {
        VerifyOrReturn(CheckValue("status", status, 0));

        NextTest();
    }

    CHIP_ERROR TestMediaPlaybackSkipForwardCommand_16()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 3;
        using RequestType               = chip::app::Clusters::MediaPlayback::Commands::SkipForward::Type;

        RequestType request;
        request.deltaPositionMilliseconds = 500ULL;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TV_MediaPlaybackClusterSuite *>(context))->OnSuccessResponse_16(data.status);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TV_MediaPlaybackClusterSuite *>(context))->OnFailureResponse_16(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_16(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_16(chip::app::Clusters::MediaPlayback::StatusEnum status)
    {
        VerifyOrReturn(CheckValue("status", status, 0));

        NextTest();
    }

    CHIP_ERROR TestReadAttributePositionAfterSkipForward_17()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 3;
        chip::Controller::MediaPlaybackClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::MediaPlayback::Attributes::SampledPosition::TypeInfo>(
            this, OnSuccessCallback_17, OnFailureCallback_17, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_17(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_17(
        const chip::app::DataModel::Nullable<chip::app::Clusters::MediaPlayback::Structs::PlaybackPosition::DecodableType> &
            sampledPosition)
    {
        VerifyOrReturn(CheckValueNonNull("sampledPosition", sampledPosition));
        VerifyOrReturn(CheckValue("sampledPosition.Value().updatedAt", sampledPosition.Value().updatedAt, 0ULL));
        VerifyOrReturn(CheckValueNonNull("sampledPosition.Value().position", sampledPosition.Value().position));
        VerifyOrReturn(CheckValue("sampledPosition.Value().position.Value()", sampledPosition.Value().position.Value(), 500ULL));

        NextTest();
    }

    CHIP_ERROR TestMediaPlaybackSkipBackwardCommand_18()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 3;
        using RequestType               = chip::app::Clusters::MediaPlayback::Commands::SkipBackward::Type;

        RequestType request;
        request.deltaPositionMilliseconds = 100ULL;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TV_MediaPlaybackClusterSuite *>(context))->OnSuccessResponse_18(data.status);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TV_MediaPlaybackClusterSuite *>(context))->OnFailureResponse_18(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_18(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_18(chip::app::Clusters::MediaPlayback::StatusEnum status)
    {
        VerifyOrReturn(CheckValue("status", status, 0));

        NextTest();
    }

    CHIP_ERROR TestReadAttributePositionAfterSkipBackward_19()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 3;
        chip::Controller::MediaPlaybackClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::MediaPlayback::Attributes::SampledPosition::TypeInfo>(
            this, OnSuccessCallback_19, OnFailureCallback_19, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_19(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_19(
        const chip::app::DataModel::Nullable<chip::app::Clusters::MediaPlayback::Structs::PlaybackPosition::DecodableType> &
            sampledPosition)
    {
        VerifyOrReturn(CheckValueNonNull("sampledPosition", sampledPosition));
        VerifyOrReturn(CheckValue("sampledPosition.Value().updatedAt", sampledPosition.Value().updatedAt, 0ULL));
        VerifyOrReturn(CheckValueNonNull("sampledPosition.Value().position", sampledPosition.Value().position));
        VerifyOrReturn(CheckValue("sampledPosition.Value().position.Value()", sampledPosition.Value().position.Value(), 400ULL));

        NextTest();
    }

    CHIP_ERROR TestMediaPlaybackSeekCommand_20()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 3;
        using RequestType               = chip::app::Clusters::MediaPlayback::Commands::Seek::Type;

        RequestType request;
        request.position = 1000ULL;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TV_MediaPlaybackClusterSuite *>(context))->OnSuccessResponse_20(data.status);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TV_MediaPlaybackClusterSuite *>(context))->OnFailureResponse_20(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_20(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_20(chip::app::Clusters::MediaPlayback::StatusEnum status)
    {
        VerifyOrReturn(CheckValue("status", status, 0));

        NextTest();
    }

    CHIP_ERROR TestReadAttributePositionAfterSeek_21()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 3;
        chip::Controller::MediaPlaybackClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::MediaPlayback::Attributes::SampledPosition::TypeInfo>(
            this, OnSuccessCallback_21, OnFailureCallback_21, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_21(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_21(
        const chip::app::DataModel::Nullable<chip::app::Clusters::MediaPlayback::Structs::PlaybackPosition::DecodableType> &
            sampledPosition)
    {
        VerifyOrReturn(CheckValueNonNull("sampledPosition", sampledPosition));
        VerifyOrReturn(CheckValue("sampledPosition.Value().updatedAt", sampledPosition.Value().updatedAt, 0ULL));
        VerifyOrReturn(CheckValueNonNull("sampledPosition.Value().position", sampledPosition.Value().position));
        VerifyOrReturn(CheckValue("sampledPosition.Value().position.Value()", sampledPosition.Value().position.Value(), 1000ULL));

        NextTest();
    }
};

class TV_ChannelClusterSuite : public TestCommand
{
public:
    TV_ChannelClusterSuite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("TV_ChannelCluster", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~TV_ChannelClusterSuite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TV_ChannelCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TV_ChannelCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read attribute Channel list\n");
            err = TestReadAttributeChannelList_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read attribute channel lineup\n");
            err = TestReadAttributeChannelLineup_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read attribute current channel\n");
            err = TestReadAttributeCurrentChannel_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Change Channel Command\n");
            err = TestChangeChannelCommand_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Change Channel By Number Command\n");
            err = TestChangeChannelByNumberCommand_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Skip Channel Command\n");
            err = TestSkipChannelCommand_6();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 7;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_1(void * context, CHIP_ERROR error)
    {
        (static_cast<TV_ChannelClusterSuite *>(context))->OnFailureResponse_1(error);
    }

    static void OnSuccessCallback_1(
        void * context,
        const chip::app::DataModel::DecodableList<chip::app::Clusters::Channel::Structs::ChannelInfo::DecodableType> & channelList)
    {
        (static_cast<TV_ChannelClusterSuite *>(context))->OnSuccessResponse_1(channelList);
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<TV_ChannelClusterSuite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(
        void * context,
        const chip::app::DataModel::Nullable<chip::app::Clusters::Channel::Structs::LineupInfo::DecodableType> & lineup)
    {
        (static_cast<TV_ChannelClusterSuite *>(context))->OnSuccessResponse_2(lineup);
    }

    static void OnFailureCallback_3(void * context, CHIP_ERROR error)
    {
        (static_cast<TV_ChannelClusterSuite *>(context))->OnFailureResponse_3(error);
    }

    static void OnSuccessCallback_3(
        void * context,
        const chip::app::DataModel::Nullable<chip::app::Clusters::Channel::Structs::ChannelInfo::DecodableType> & currentChannel)
    {
        (static_cast<TV_ChannelClusterSuite *>(context))->OnSuccessResponse_3(currentChannel);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestReadAttributeChannelList_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ChannelClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Channel::Attributes::ChannelList::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1(
        const chip::app::DataModel::DecodableList<chip::app::Clusters::Channel::Structs::ChannelInfo::DecodableType> & channelList)
    {
        {
            auto iter_0 = channelList.begin();
            VerifyOrReturn(CheckNextListItemDecodes<decltype(channelList)>("channelList", iter_0, 0));
            VerifyOrReturn(CheckValue("channelList[0].majorNumber", iter_0.GetValue().majorNumber, 6U));
            VerifyOrReturn(CheckValue("channelList[0].minorNumber", iter_0.GetValue().minorNumber, 0U));
            VerifyOrReturn(CheckValuePresent("channelList[0].name", iter_0.GetValue().name));
            VerifyOrReturn(
                CheckValueAsString("channelList[0].name.Value()", iter_0.GetValue().name.Value(), chip::CharSpan("ABC", 3)));
            VerifyOrReturn(CheckValuePresent("channelList[0].callSign", iter_0.GetValue().callSign));
            VerifyOrReturn(CheckValueAsString("channelList[0].callSign.Value()", iter_0.GetValue().callSign.Value(),
                                              chip::CharSpan("KAAL-TV", 7)));
            VerifyOrReturn(CheckValuePresent("channelList[0].affiliateCallSign", iter_0.GetValue().affiliateCallSign));
            VerifyOrReturn(CheckValueAsString("channelList[0].affiliateCallSign.Value()",
                                              iter_0.GetValue().affiliateCallSign.Value(), chip::CharSpan("KAAL", 4)));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(channelList)>("channelList", iter_0, 1));
            VerifyOrReturn(CheckValue("channelList[1].majorNumber", iter_0.GetValue().majorNumber, 9U));
            VerifyOrReturn(CheckValue("channelList[1].minorNumber", iter_0.GetValue().minorNumber, 1U));
            VerifyOrReturn(CheckValuePresent("channelList[1].name", iter_0.GetValue().name));
            VerifyOrReturn(
                CheckValueAsString("channelList[1].name.Value()", iter_0.GetValue().name.Value(), chip::CharSpan("PBS", 3)));
            VerifyOrReturn(CheckValuePresent("channelList[1].callSign", iter_0.GetValue().callSign));
            VerifyOrReturn(CheckValueAsString("channelList[1].callSign.Value()", iter_0.GetValue().callSign.Value(),
                                              chip::CharSpan("KCTS-TV", 7)));
            VerifyOrReturn(CheckValuePresent("channelList[1].affiliateCallSign", iter_0.GetValue().affiliateCallSign));
            VerifyOrReturn(CheckValueAsString("channelList[1].affiliateCallSign.Value()",
                                              iter_0.GetValue().affiliateCallSign.Value(), chip::CharSpan("KCTS", 4)));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(channelList)>("channelList", iter_0, 2));
            VerifyOrReturn(CheckValue("channelList[2].majorNumber", iter_0.GetValue().majorNumber, 9U));
            VerifyOrReturn(CheckValue("channelList[2].minorNumber", iter_0.GetValue().minorNumber, 2U));
            VerifyOrReturn(CheckValuePresent("channelList[2].name", iter_0.GetValue().name));
            VerifyOrReturn(
                CheckValueAsString("channelList[2].name.Value()", iter_0.GetValue().name.Value(), chip::CharSpan("PBS Kids", 8)));
            VerifyOrReturn(CheckValuePresent("channelList[2].callSign", iter_0.GetValue().callSign));
            VerifyOrReturn(CheckValueAsString("channelList[2].callSign.Value()", iter_0.GetValue().callSign.Value(),
                                              chip::CharSpan("KCTS-TV", 7)));
            VerifyOrReturn(CheckValuePresent("channelList[2].affiliateCallSign", iter_0.GetValue().affiliateCallSign));
            VerifyOrReturn(CheckValueAsString("channelList[2].affiliateCallSign.Value()",
                                              iter_0.GetValue().affiliateCallSign.Value(), chip::CharSpan("KCTS", 4)));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(channelList)>("channelList", iter_0, 3));
            VerifyOrReturn(CheckValue("channelList[3].majorNumber", iter_0.GetValue().majorNumber, 9U));
            VerifyOrReturn(CheckValue("channelList[3].minorNumber", iter_0.GetValue().minorNumber, 3U));
            VerifyOrReturn(CheckValuePresent("channelList[3].name", iter_0.GetValue().name));
            VerifyOrReturn(CheckValueAsString("channelList[3].name.Value()", iter_0.GetValue().name.Value(),
                                              chip::CharSpan("World Channel", 13)));
            VerifyOrReturn(CheckValuePresent("channelList[3].callSign", iter_0.GetValue().callSign));
            VerifyOrReturn(CheckValueAsString("channelList[3].callSign.Value()", iter_0.GetValue().callSign.Value(),
                                              chip::CharSpan("KCTS-TV", 7)));
            VerifyOrReturn(CheckValuePresent("channelList[3].affiliateCallSign", iter_0.GetValue().affiliateCallSign));
            VerifyOrReturn(CheckValueAsString("channelList[3].affiliateCallSign.Value()",
                                              iter_0.GetValue().affiliateCallSign.Value(), chip::CharSpan("KCTS", 4)));
            VerifyOrReturn(CheckNoMoreListItems<decltype(channelList)>("channelList", iter_0, 4));
        }

        NextTest();
    }

    CHIP_ERROR TestReadAttributeChannelLineup_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ChannelClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Channel::Attributes::Lineup::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2(
        const chip::app::DataModel::Nullable<chip::app::Clusters::Channel::Structs::LineupInfo::DecodableType> & lineup)
    {
        VerifyOrReturn(CheckValueNonNull("lineup", lineup));
        VerifyOrReturn(
            CheckValueAsString("lineup.Value().operatorName", lineup.Value().operatorName, chip::CharSpan("Comcast", 7)));
        VerifyOrReturn(CheckValuePresent("lineup.Value().lineupName", lineup.Value().lineupName));
        VerifyOrReturn(CheckValueAsString("lineup.Value().lineupName.Value()", lineup.Value().lineupName.Value(),
                                          chip::CharSpan("Comcast King County", 19)));
        VerifyOrReturn(CheckValuePresent("lineup.Value().postalCode", lineup.Value().postalCode));
        VerifyOrReturn(
            CheckValueAsString("lineup.Value().postalCode.Value()", lineup.Value().postalCode.Value(), chip::CharSpan("98052", 5)));
        VerifyOrReturn(CheckValue("lineup.Value().lineupInfoType", lineup.Value().lineupInfoType, 0));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeCurrentChannel_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ChannelClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Channel::Attributes::CurrentChannel::TypeInfo>(
            this, OnSuccessCallback_3, OnFailureCallback_3, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3(
        const chip::app::DataModel::Nullable<chip::app::Clusters::Channel::Structs::ChannelInfo::DecodableType> & currentChannel)
    {
        VerifyOrReturn(CheckValueNonNull("currentChannel", currentChannel));
        VerifyOrReturn(CheckValue("currentChannel.Value().majorNumber", currentChannel.Value().majorNumber, 6U));
        VerifyOrReturn(CheckValue("currentChannel.Value().minorNumber", currentChannel.Value().minorNumber, 0U));
        VerifyOrReturn(CheckValuePresent("currentChannel.Value().name", currentChannel.Value().name));
        VerifyOrReturn(CheckValueAsString("currentChannel.Value().name.Value()", currentChannel.Value().name.Value(),
                                          chip::CharSpan("ABC", 3)));
        VerifyOrReturn(CheckValuePresent("currentChannel.Value().callSign", currentChannel.Value().callSign));
        VerifyOrReturn(CheckValueAsString("currentChannel.Value().callSign.Value()", currentChannel.Value().callSign.Value(),
                                          chip::CharSpan("KAAL-TV", 7)));
        VerifyOrReturn(CheckValuePresent("currentChannel.Value().affiliateCallSign", currentChannel.Value().affiliateCallSign));
        VerifyOrReturn(CheckValueAsString("currentChannel.Value().affiliateCallSign.Value()",
                                          currentChannel.Value().affiliateCallSign.Value(), chip::CharSpan("KAAL", 4)));

        NextTest();
    }

    CHIP_ERROR TestChangeChannelCommand_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::Channel::Commands::ChangeChannel::Type;

        RequestType request;
        request.match = chip::Span<const char>("PBSgarbage: not in length on purpose", 3);

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TV_ChannelClusterSuite *>(context))->OnSuccessResponse_4(data.channelMatch, data.status);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TV_ChannelClusterSuite *>(context))->OnFailureResponse_4(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_4(const chip::app::Clusters::Channel::Structs::ChannelInfo::DecodableType & channelMatch,
                             chip::app::Clusters::Channel::StatusEnum status)
    {
        VerifyOrReturn(CheckValue("channelMatch.majorNumber", channelMatch.majorNumber, 9U));
        VerifyOrReturn(CheckValue("channelMatch.minorNumber", channelMatch.minorNumber, 1U));
        VerifyOrReturn(CheckValuePresent("channelMatch.name", channelMatch.name));
        VerifyOrReturn(CheckValueAsString("channelMatch.name.Value()", channelMatch.name.Value(), chip::CharSpan("PBS", 3)));
        VerifyOrReturn(CheckValuePresent("channelMatch.callSign", channelMatch.callSign));
        VerifyOrReturn(
            CheckValueAsString("channelMatch.callSign.Value()", channelMatch.callSign.Value(), chip::CharSpan("KCTS-TV", 7)));
        VerifyOrReturn(CheckValuePresent("channelMatch.affiliateCallSign", channelMatch.affiliateCallSign));
        VerifyOrReturn(CheckValueAsString("channelMatch.affiliateCallSign.Value()", channelMatch.affiliateCallSign.Value(),
                                          chip::CharSpan("KCTS", 4)));

        VerifyOrReturn(CheckValue("status", status, 0));

        NextTest();
    }

    CHIP_ERROR TestChangeChannelByNumberCommand_5()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::Channel::Commands::ChangeChannelByNumber::Type;

        RequestType request;
        request.majorNumber = 6U;
        request.minorNumber = 0U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TV_ChannelClusterSuite *>(context))->OnSuccessResponse_5();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TV_ChannelClusterSuite *>(context))->OnFailureResponse_5(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_5() { NextTest(); }

    CHIP_ERROR TestSkipChannelCommand_6()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::Channel::Commands::SkipChannel::Type;

        RequestType request;
        request.count = 1U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TV_ChannelClusterSuite *>(context))->OnSuccessResponse_6();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TV_ChannelClusterSuite *>(context))->OnFailureResponse_6(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_6(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_6() { NextTest(); }
};

class TV_LowPowerClusterSuite : public TestCommand
{
public:
    TV_LowPowerClusterSuite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("TV_LowPowerCluster", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~TV_LowPowerClusterSuite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TV_LowPowerCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TV_LowPowerCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Sleep Input Status Command\n");
            err = TestSleepInputStatusCommand_1();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 2;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestSleepInputStatusCommand_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::LowPower::Commands::Sleep::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TV_LowPowerClusterSuite *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TV_LowPowerClusterSuite *>(context))->OnFailureResponse_1(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1() { NextTest(); }
};

class TV_ContentLauncherClusterSuite : public TestCommand
{
public:
    TV_ContentLauncherClusterSuite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("TV_ContentLauncherCluster", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~TV_ContentLauncherClusterSuite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TV_ContentLauncherCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TV_ContentLauncherCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read attribute accept header list\n");
            err = TestReadAttributeAcceptHeaderList_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read attribute supported streaming protocols\n");
            err = TestReadAttributeSupportedStreamingProtocols_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Launch Content Command\n");
            err = TestLaunchContentCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Launch URL Command\n");
            err = TestLaunchUrlCommand_4();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 5;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_1(void * context, CHIP_ERROR error)
    {
        (static_cast<TV_ContentLauncherClusterSuite *>(context))->OnFailureResponse_1(error);
    }

    static void OnSuccessCallback_1(void * context, const chip::app::DataModel::DecodableList<chip::CharSpan> & acceptHeader)
    {
        (static_cast<TV_ContentLauncherClusterSuite *>(context))->OnSuccessResponse_1(acceptHeader);
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<TV_ContentLauncherClusterSuite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context, uint32_t supportedStreamingProtocols)
    {
        (static_cast<TV_ContentLauncherClusterSuite *>(context))->OnSuccessResponse_2(supportedStreamingProtocols);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestReadAttributeAcceptHeaderList_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ContentLauncherClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ContentLauncher::Attributes::AcceptHeader::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1(const chip::app::DataModel::DecodableList<chip::CharSpan> & acceptHeader)
    {
        {
            auto iter_0 = acceptHeader.begin();
            VerifyOrReturn(CheckNextListItemDecodes<decltype(acceptHeader)>("acceptHeader", iter_0, 0));
            VerifyOrReturn(CheckValueAsString("acceptHeader[0]", iter_0.GetValue(), chip::CharSpan("example", 7)));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(acceptHeader)>("acceptHeader", iter_0, 1));
            VerifyOrReturn(CheckValueAsString("acceptHeader[1]", iter_0.GetValue(), chip::CharSpan("example", 7)));
            VerifyOrReturn(CheckNoMoreListItems<decltype(acceptHeader)>("acceptHeader", iter_0, 2));
        }

        NextTest();
    }

    CHIP_ERROR TestReadAttributeSupportedStreamingProtocols_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ContentLauncherClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::ContentLauncher::Attributes::SupportedStreamingProtocols::TypeInfo>(
                this, OnSuccessCallback_2, OnFailureCallback_2, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2(uint32_t supportedStreamingProtocols)
    {
        VerifyOrReturn(CheckValue("supportedStreamingProtocols", supportedStreamingProtocols, 0UL));

        NextTest();
    }

    CHIP_ERROR TestLaunchContentCommand_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::ContentLauncher::Commands::LaunchContent::Type;

        ListFreer listFreer;
        RequestType request;

        {
            auto * listHolder_1 = new ListHolder<chip::app::Clusters::ContentLauncher::Structs::Parameter::Type>(1);
            listFreer.add(listHolder_1);

            listHolder_1->mList[0].type  = static_cast<chip::app::Clusters::ContentLauncher::ParameterEnum>(1);
            listHolder_1->mList[0].value = chip::Span<const char>("exampleValuegarbage: not in length on purpose", 12);
            listHolder_1->mList[0].externalIDList.Emplace();

            {
                auto * listHolder_4 = new ListHolder<chip::app::Clusters::ContentLauncher::Structs::AdditionalInfo::Type>(1);
                listFreer.add(listHolder_4);

                listHolder_4->mList[0].name  = chip::Span<const char>("namegarbage: not in length on purpose", 4);
                listHolder_4->mList[0].value = chip::Span<const char>("valuegarbage: not in length on purpose", 5);

                listHolder_1->mList[0].externalIDList.Value() =
                    chip::app::DataModel::List<chip::app::Clusters::ContentLauncher::Structs::AdditionalInfo::Type>(
                        listHolder_4->mList, 1);
            }

            request.search.parameterList =
                chip::app::DataModel::List<chip::app::Clusters::ContentLauncher::Structs::Parameter::Type>(listHolder_1->mList, 1);
        }

        request.autoPlay = true;
        request.data.Emplace();
        request.data.Value() = chip::Span<const char>("exampleDatagarbage: not in length on purpose", 11);

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TV_ContentLauncherClusterSuite *>(context))->OnSuccessResponse_3(data.status, data.data);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TV_ContentLauncherClusterSuite *>(context))->OnFailureResponse_3(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3(chip::app::Clusters::ContentLauncher::StatusEnum status, const chip::Optional<chip::CharSpan> & data)
    {
        VerifyOrReturn(CheckValue("status", status, 0));

        VerifyOrReturn(CheckValuePresent("data", data));
        VerifyOrReturn(CheckValueAsString("data.Value()", data.Value(), chip::CharSpan("exampleData", 11)));

        NextTest();
    }

    CHIP_ERROR TestLaunchUrlCommand_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::ContentLauncher::Commands::LaunchURL::Type;

        RequestType request;
        request.contentURL = chip::Span<const char>("exampleUrlgarbage: not in length on purpose", 10);
        request.displayString.Emplace();
        request.displayString.Value() = chip::Span<const char>("exampleDisplayStringgarbage: not in length on purpose", 20);
        request.brandingInformation.Emplace();

        request.brandingInformation.Value().providerName =
            chip::Span<const char>("exampleNamegarbage: not in length on purpose", 11);
        request.brandingInformation.Value().background.Emplace();

        request.brandingInformation.Value().background.Value().imageUrl.Emplace();
        request.brandingInformation.Value().background.Value().imageUrl.Value() =
            chip::Span<const char>("exampleUrlgarbage: not in length on purpose", 10);
        request.brandingInformation.Value().background.Value().color.Emplace();
        request.brandingInformation.Value().background.Value().color.Value() =
            chip::Span<const char>("exampleColorgarbage: not in length on purpose", 12);
        request.brandingInformation.Value().background.Value().size.Emplace();

        request.brandingInformation.Value().background.Value().size.Value().width  = 0;
        request.brandingInformation.Value().background.Value().size.Value().height = 0;
        request.brandingInformation.Value().background.Value().size.Value().metric =
            static_cast<chip::app::Clusters::ContentLauncher::MetricTypeEnum>(0);

        request.brandingInformation.Value().logo.Emplace();

        request.brandingInformation.Value().logo.Value().imageUrl.Emplace();
        request.brandingInformation.Value().logo.Value().imageUrl.Value() =
            chip::Span<const char>("exampleUrlgarbage: not in length on purpose", 10);
        request.brandingInformation.Value().logo.Value().color.Emplace();
        request.brandingInformation.Value().logo.Value().color.Value() =
            chip::Span<const char>("exampleColorgarbage: not in length on purpose", 12);
        request.brandingInformation.Value().logo.Value().size.Emplace();

        request.brandingInformation.Value().logo.Value().size.Value().width  = 0;
        request.brandingInformation.Value().logo.Value().size.Value().height = 0;
        request.brandingInformation.Value().logo.Value().size.Value().metric =
            static_cast<chip::app::Clusters::ContentLauncher::MetricTypeEnum>(0);

        request.brandingInformation.Value().progressBar.Emplace();

        request.brandingInformation.Value().progressBar.Value().imageUrl.Emplace();
        request.brandingInformation.Value().progressBar.Value().imageUrl.Value() =
            chip::Span<const char>("exampleUrlgarbage: not in length on purpose", 10);
        request.brandingInformation.Value().progressBar.Value().color.Emplace();
        request.brandingInformation.Value().progressBar.Value().color.Value() =
            chip::Span<const char>("exampleColorgarbage: not in length on purpose", 12);
        request.brandingInformation.Value().progressBar.Value().size.Emplace();

        request.brandingInformation.Value().progressBar.Value().size.Value().width  = 0;
        request.brandingInformation.Value().progressBar.Value().size.Value().height = 0;
        request.brandingInformation.Value().progressBar.Value().size.Value().metric =
            static_cast<chip::app::Clusters::ContentLauncher::MetricTypeEnum>(0);

        request.brandingInformation.Value().splash.Emplace();

        request.brandingInformation.Value().splash.Value().imageUrl.Emplace();
        request.brandingInformation.Value().splash.Value().imageUrl.Value() =
            chip::Span<const char>("exampleUrlgarbage: not in length on purpose", 10);
        request.brandingInformation.Value().splash.Value().color.Emplace();
        request.brandingInformation.Value().splash.Value().color.Value() =
            chip::Span<const char>("exampleColorgarbage: not in length on purpose", 12);
        request.brandingInformation.Value().splash.Value().size.Emplace();

        request.brandingInformation.Value().splash.Value().size.Value().width  = 0;
        request.brandingInformation.Value().splash.Value().size.Value().height = 0;
        request.brandingInformation.Value().splash.Value().size.Value().metric =
            static_cast<chip::app::Clusters::ContentLauncher::MetricTypeEnum>(0);

        request.brandingInformation.Value().waterMark.Emplace();

        request.brandingInformation.Value().waterMark.Value().imageUrl.Emplace();
        request.brandingInformation.Value().waterMark.Value().imageUrl.Value() =
            chip::Span<const char>("exampleUrlgarbage: not in length on purpose", 10);
        request.brandingInformation.Value().waterMark.Value().color.Emplace();
        request.brandingInformation.Value().waterMark.Value().color.Value() =
            chip::Span<const char>("exampleColorgarbage: not in length on purpose", 12);
        request.brandingInformation.Value().waterMark.Value().size.Emplace();

        request.brandingInformation.Value().waterMark.Value().size.Value().width  = 0;
        request.brandingInformation.Value().waterMark.Value().size.Value().height = 0;
        request.brandingInformation.Value().waterMark.Value().size.Value().metric =
            static_cast<chip::app::Clusters::ContentLauncher::MetricTypeEnum>(0);

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TV_ContentLauncherClusterSuite *>(context))->OnSuccessResponse_4(data.status, data.data);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TV_ContentLauncherClusterSuite *>(context))->OnFailureResponse_4(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_4(chip::app::Clusters::ContentLauncher::StatusEnum status, const chip::Optional<chip::CharSpan> & data)
    {
        VerifyOrReturn(CheckValue("status", status, 0));

        VerifyOrReturn(CheckValuePresent("data", data));
        VerifyOrReturn(CheckValueAsString("data.Value()", data.Value(), chip::CharSpan("exampleData", 11)));

        NextTest();
    }
};

class TV_MediaInputClusterSuite : public TestCommand
{
public:
    TV_MediaInputClusterSuite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("TV_MediaInputCluster", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~TV_MediaInputClusterSuite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TV_MediaInputCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TV_MediaInputCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read attribute media input list\n");
            err = TestReadAttributeMediaInputList_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read current media input\n");
            err = TestReadCurrentMediaInput_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Select Input Command\n");
            err = TestSelectInputCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Hide Input Status Command\n");
            err = TestHideInputStatusCommand_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Show Input Status Command\n");
            err = TestShowInputStatusCommand_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Rename Input Command\n");
            err = TestRenameInputCommand_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Read attribute media input list\n");
            err = TestReadAttributeMediaInputList_7();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 8;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_1(void * context, CHIP_ERROR error)
    {
        (static_cast<TV_MediaInputClusterSuite *>(context))->OnFailureResponse_1(error);
    }

    static void OnSuccessCallback_1(
        void * context,
        const chip::app::DataModel::DecodableList<chip::app::Clusters::MediaInput::Structs::InputInfo::DecodableType> & inputList)
    {
        (static_cast<TV_MediaInputClusterSuite *>(context))->OnSuccessResponse_1(inputList);
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<TV_MediaInputClusterSuite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context, uint8_t currentInput)
    {
        (static_cast<TV_MediaInputClusterSuite *>(context))->OnSuccessResponse_2(currentInput);
    }

    static void OnFailureCallback_7(void * context, CHIP_ERROR error)
    {
        (static_cast<TV_MediaInputClusterSuite *>(context))->OnFailureResponse_7(error);
    }

    static void OnSuccessCallback_7(
        void * context,
        const chip::app::DataModel::DecodableList<chip::app::Clusters::MediaInput::Structs::InputInfo::DecodableType> & inputList)
    {
        (static_cast<TV_MediaInputClusterSuite *>(context))->OnSuccessResponse_7(inputList);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestReadAttributeMediaInputList_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::MediaInputClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::MediaInput::Attributes::InputList::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1(
        const chip::app::DataModel::DecodableList<chip::app::Clusters::MediaInput::Structs::InputInfo::DecodableType> & inputList)
    {
        {
            auto iter_0 = inputList.begin();
            VerifyOrReturn(CheckNextListItemDecodes<decltype(inputList)>("inputList", iter_0, 0));
            VerifyOrReturn(CheckValue("inputList[0].index", iter_0.GetValue().index, 1));
            VerifyOrReturn(CheckValue("inputList[0].inputType", iter_0.GetValue().inputType, 4));
            VerifyOrReturn(CheckValueAsString("inputList[0].name", iter_0.GetValue().name, chip::CharSpan("HDMI", 4)));
            VerifyOrReturn(CheckValueAsString("inputList[0].description", iter_0.GetValue().description,
                                              chip::CharSpan("High-Definition Multimedia Interface", 36)));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(inputList)>("inputList", iter_0, 1));
            VerifyOrReturn(CheckValue("inputList[1].index", iter_0.GetValue().index, 2));
            VerifyOrReturn(CheckValue("inputList[1].inputType", iter_0.GetValue().inputType, 4));
            VerifyOrReturn(CheckValueAsString("inputList[1].name", iter_0.GetValue().name, chip::CharSpan("HDMI", 4)));
            VerifyOrReturn(CheckValueAsString("inputList[1].description", iter_0.GetValue().description,
                                              chip::CharSpan("High-Definition Multimedia Interface", 36)));
            VerifyOrReturn(CheckNoMoreListItems<decltype(inputList)>("inputList", iter_0, 2));
        }

        NextTest();
    }

    CHIP_ERROR TestReadCurrentMediaInput_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::MediaInputClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::MediaInput::Attributes::CurrentInput::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2(uint8_t currentInput)
    {
        VerifyOrReturn(CheckValue("currentInput", currentInput, 1));

        NextTest();
    }

    CHIP_ERROR TestSelectInputCommand_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::MediaInput::Commands::SelectInput::Type;

        RequestType request;
        request.index = 1;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TV_MediaInputClusterSuite *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TV_MediaInputClusterSuite *>(context))->OnFailureResponse_3(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestHideInputStatusCommand_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::MediaInput::Commands::HideInputStatus::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TV_MediaInputClusterSuite *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TV_MediaInputClusterSuite *>(context))->OnFailureResponse_4(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestShowInputStatusCommand_5()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::MediaInput::Commands::ShowInputStatus::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TV_MediaInputClusterSuite *>(context))->OnSuccessResponse_5();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TV_MediaInputClusterSuite *>(context))->OnFailureResponse_5(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_5() { NextTest(); }

    CHIP_ERROR TestRenameInputCommand_6()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::MediaInput::Commands::RenameInput::Type;

        RequestType request;
        request.index = 1;
        request.name  = chip::Span<const char>("HDMI Testgarbage: not in length on purpose", 9);

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TV_MediaInputClusterSuite *>(context))->OnSuccessResponse_6();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TV_MediaInputClusterSuite *>(context))->OnFailureResponse_6(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_6(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_6() { NextTest(); }

    CHIP_ERROR TestReadAttributeMediaInputList_7()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::MediaInputClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::MediaInput::Attributes::InputList::TypeInfo>(
            this, OnSuccessCallback_7, OnFailureCallback_7, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_7(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_7(
        const chip::app::DataModel::DecodableList<chip::app::Clusters::MediaInput::Structs::InputInfo::DecodableType> & inputList)
    {
        {
            auto iter_0 = inputList.begin();
            VerifyOrReturn(CheckNextListItemDecodes<decltype(inputList)>("inputList", iter_0, 0));
            VerifyOrReturn(CheckValue("inputList[0].index", iter_0.GetValue().index, 1));
            VerifyOrReturn(CheckValue("inputList[0].inputType", iter_0.GetValue().inputType, 4));
            VerifyOrReturn(CheckValueAsString("inputList[0].name", iter_0.GetValue().name, chip::CharSpan("HDMI Test", 9)));
            VerifyOrReturn(CheckValueAsString("inputList[0].description", iter_0.GetValue().description,
                                              chip::CharSpan("High-Definition Multimedia Interface", 36)));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(inputList)>("inputList", iter_0, 1));
            VerifyOrReturn(CheckValue("inputList[1].index", iter_0.GetValue().index, 2));
            VerifyOrReturn(CheckValue("inputList[1].inputType", iter_0.GetValue().inputType, 4));
            VerifyOrReturn(CheckValueAsString("inputList[1].name", iter_0.GetValue().name, chip::CharSpan("HDMI", 4)));
            VerifyOrReturn(CheckValueAsString("inputList[1].description", iter_0.GetValue().description,
                                              chip::CharSpan("High-Definition Multimedia Interface", 36)));
            VerifyOrReturn(CheckNoMoreListItems<decltype(inputList)>("inputList", iter_0, 2));
        }

        NextTest();
    }
};

class TestClusterSuite : public TestCommand
{
public:
    TestClusterSuite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("TestCluster", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~TestClusterSuite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Send Test Command\n");
            err = TestSendTestCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Send Test Not Handled Command\n");
            err = TestSendTestNotHandledCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Send Test Specific Command\n");
            err = TestSendTestSpecificCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Send Test Add Arguments Command\n");
            err = TestSendTestAddArgumentsCommand_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Send failing Test Add Arguments Command\n");
            err = TestSendFailingTestAddArgumentsCommand_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Read attribute BOOLEAN Default Value\n");
            err = TestReadAttributeBooleanDefaultValue_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Write attribute BOOLEAN True\n");
            err = TestWriteAttributeBooleanTrue_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Read attribute BOOLEAN True\n");
            err = TestReadAttributeBooleanTrue_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Write attribute BOOLEAN False\n");
            err = TestWriteAttributeBooleanFalse_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Read attribute BOOLEAN False\n");
            err = TestReadAttributeBooleanFalse_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : Read attribute BITMAP8 Default Value\n");
            err = TestReadAttributeBitmap8DefaultValue_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : Write attribute BITMAP8 Max Value\n");
            err = TestWriteAttributeBitmap8MaxValue_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : Read attribute BITMAP8 Max Value\n");
            err = TestReadAttributeBitmap8MaxValue_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : Write attribute BITMAP8 Min Value\n");
            err = TestWriteAttributeBitmap8MinValue_14();
            break;
        case 15:
            ChipLogProgress(chipTool, " ***** Test Step 15 : Read attribute BITMAP8 Min Value\n");
            err = TestReadAttributeBitmap8MinValue_15();
            break;
        case 16:
            ChipLogProgress(chipTool, " ***** Test Step 16 : Read attribute BITMAP16 Default Value\n");
            err = TestReadAttributeBitmap16DefaultValue_16();
            break;
        case 17:
            ChipLogProgress(chipTool, " ***** Test Step 17 : Write attribute BITMAP16 Max Value\n");
            err = TestWriteAttributeBitmap16MaxValue_17();
            break;
        case 18:
            ChipLogProgress(chipTool, " ***** Test Step 18 : Read attribute BITMAP16 Max Value\n");
            err = TestReadAttributeBitmap16MaxValue_18();
            break;
        case 19:
            ChipLogProgress(chipTool, " ***** Test Step 19 : Write attribute BITMAP16 Min Value\n");
            err = TestWriteAttributeBitmap16MinValue_19();
            break;
        case 20:
            ChipLogProgress(chipTool, " ***** Test Step 20 : Read attribute BITMAP16 Min Value\n");
            err = TestReadAttributeBitmap16MinValue_20();
            break;
        case 21:
            ChipLogProgress(chipTool, " ***** Test Step 21 : Read attribute BITMAP32 Default Value\n");
            err = TestReadAttributeBitmap32DefaultValue_21();
            break;
        case 22:
            ChipLogProgress(chipTool, " ***** Test Step 22 : Write attribute BITMAP32 Max Value\n");
            err = TestWriteAttributeBitmap32MaxValue_22();
            break;
        case 23:
            ChipLogProgress(chipTool, " ***** Test Step 23 : Read attribute BITMAP32 Max Value\n");
            err = TestReadAttributeBitmap32MaxValue_23();
            break;
        case 24:
            ChipLogProgress(chipTool, " ***** Test Step 24 : Write attribute BITMAP32 Min Value\n");
            err = TestWriteAttributeBitmap32MinValue_24();
            break;
        case 25:
            ChipLogProgress(chipTool, " ***** Test Step 25 : Read attribute BITMAP32 Min Value\n");
            err = TestReadAttributeBitmap32MinValue_25();
            break;
        case 26:
            ChipLogProgress(chipTool, " ***** Test Step 26 : Read attribute BITMAP64 Default Value\n");
            err = TestReadAttributeBitmap64DefaultValue_26();
            break;
        case 27:
            ChipLogProgress(chipTool, " ***** Test Step 27 : Write attribute BITMAP64 Max Value\n");
            err = TestWriteAttributeBitmap64MaxValue_27();
            break;
        case 28:
            ChipLogProgress(chipTool, " ***** Test Step 28 : Read attribute BITMAP64 Max Value\n");
            err = TestReadAttributeBitmap64MaxValue_28();
            break;
        case 29:
            ChipLogProgress(chipTool, " ***** Test Step 29 : Write attribute BITMAP64 Min Value\n");
            err = TestWriteAttributeBitmap64MinValue_29();
            break;
        case 30:
            ChipLogProgress(chipTool, " ***** Test Step 30 : Read attribute BITMAP64 Min Value\n");
            err = TestReadAttributeBitmap64MinValue_30();
            break;
        case 31:
            ChipLogProgress(chipTool, " ***** Test Step 31 : Read attribute INT8U Default Value\n");
            err = TestReadAttributeInt8uDefaultValue_31();
            break;
        case 32:
            ChipLogProgress(chipTool, " ***** Test Step 32 : Write attribute INT8U Max Value\n");
            err = TestWriteAttributeInt8uMaxValue_32();
            break;
        case 33:
            ChipLogProgress(chipTool, " ***** Test Step 33 : Read attribute INT8U Max Value\n");
            err = TestReadAttributeInt8uMaxValue_33();
            break;
        case 34:
            ChipLogProgress(chipTool, " ***** Test Step 34 : Write attribute INT8U Min Value\n");
            err = TestWriteAttributeInt8uMinValue_34();
            break;
        case 35:
            ChipLogProgress(chipTool, " ***** Test Step 35 : Read attribute INT8U Min Value\n");
            err = TestReadAttributeInt8uMinValue_35();
            break;
        case 36:
            ChipLogProgress(chipTool, " ***** Test Step 36 : Read attribute INT16U Default Value\n");
            err = TestReadAttributeInt16uDefaultValue_36();
            break;
        case 37:
            ChipLogProgress(chipTool, " ***** Test Step 37 : Write attribute INT16U Max Value\n");
            err = TestWriteAttributeInt16uMaxValue_37();
            break;
        case 38:
            ChipLogProgress(chipTool, " ***** Test Step 38 : Read attribute INT16U Max Value\n");
            err = TestReadAttributeInt16uMaxValue_38();
            break;
        case 39:
            ChipLogProgress(chipTool, " ***** Test Step 39 : Write attribute INT16U Min Value\n");
            err = TestWriteAttributeInt16uMinValue_39();
            break;
        case 40:
            ChipLogProgress(chipTool, " ***** Test Step 40 : Read attribute INT16U Min Value\n");
            err = TestReadAttributeInt16uMinValue_40();
            break;
        case 41:
            ChipLogProgress(chipTool, " ***** Test Step 41 : Read attribute INT32U Default Value\n");
            err = TestReadAttributeInt32uDefaultValue_41();
            break;
        case 42:
            ChipLogProgress(chipTool, " ***** Test Step 42 : Write attribute INT32U Max Value\n");
            err = TestWriteAttributeInt32uMaxValue_42();
            break;
        case 43:
            ChipLogProgress(chipTool, " ***** Test Step 43 : Read attribute INT32U Max Value\n");
            err = TestReadAttributeInt32uMaxValue_43();
            break;
        case 44:
            ChipLogProgress(chipTool, " ***** Test Step 44 : Write attribute INT32U Min Value\n");
            err = TestWriteAttributeInt32uMinValue_44();
            break;
        case 45:
            ChipLogProgress(chipTool, " ***** Test Step 45 : Read attribute INT32U Min Value\n");
            err = TestReadAttributeInt32uMinValue_45();
            break;
        case 46:
            ChipLogProgress(chipTool, " ***** Test Step 46 : Read attribute INT64U Default Value\n");
            err = TestReadAttributeInt64uDefaultValue_46();
            break;
        case 47:
            ChipLogProgress(chipTool, " ***** Test Step 47 : Write attribute INT64U Max Value\n");
            err = TestWriteAttributeInt64uMaxValue_47();
            break;
        case 48:
            ChipLogProgress(chipTool, " ***** Test Step 48 : Read attribute INT64U Max Value\n");
            err = TestReadAttributeInt64uMaxValue_48();
            break;
        case 49:
            ChipLogProgress(chipTool, " ***** Test Step 49 : Write attribute INT64U Min Value\n");
            err = TestWriteAttributeInt64uMinValue_49();
            break;
        case 50:
            ChipLogProgress(chipTool, " ***** Test Step 50 : Read attribute INT64U Min Value\n");
            err = TestReadAttributeInt64uMinValue_50();
            break;
        case 51:
            ChipLogProgress(chipTool, " ***** Test Step 51 : Read attribute INT8S Default Value\n");
            err = TestReadAttributeInt8sDefaultValue_51();
            break;
        case 52:
            ChipLogProgress(chipTool, " ***** Test Step 52 : Write attribute INT8S Max Value\n");
            err = TestWriteAttributeInt8sMaxValue_52();
            break;
        case 53:
            ChipLogProgress(chipTool, " ***** Test Step 53 : Read attribute INT8S Max Value\n");
            err = TestReadAttributeInt8sMaxValue_53();
            break;
        case 54:
            ChipLogProgress(chipTool, " ***** Test Step 54 : Write attribute INT8S Min Value\n");
            err = TestWriteAttributeInt8sMinValue_54();
            break;
        case 55:
            ChipLogProgress(chipTool, " ***** Test Step 55 : Read attribute INT8S Min Value\n");
            err = TestReadAttributeInt8sMinValue_55();
            break;
        case 56:
            ChipLogProgress(chipTool, " ***** Test Step 56 : Write attribute INT8S Default Value\n");
            err = TestWriteAttributeInt8sDefaultValue_56();
            break;
        case 57:
            ChipLogProgress(chipTool, " ***** Test Step 57 : Read attribute INT8S Default Value\n");
            err = TestReadAttributeInt8sDefaultValue_57();
            break;
        case 58:
            ChipLogProgress(chipTool, " ***** Test Step 58 : Read attribute INT16S Default Value\n");
            err = TestReadAttributeInt16sDefaultValue_58();
            break;
        case 59:
            ChipLogProgress(chipTool, " ***** Test Step 59 : Write attribute INT16S Max Value\n");
            err = TestWriteAttributeInt16sMaxValue_59();
            break;
        case 60:
            ChipLogProgress(chipTool, " ***** Test Step 60 : Read attribute INT16S Max Value\n");
            err = TestReadAttributeInt16sMaxValue_60();
            break;
        case 61:
            ChipLogProgress(chipTool, " ***** Test Step 61 : Write attribute INT16S Min Value\n");
            err = TestWriteAttributeInt16sMinValue_61();
            break;
        case 62:
            ChipLogProgress(chipTool, " ***** Test Step 62 : Read attribute INT16S Min Value\n");
            err = TestReadAttributeInt16sMinValue_62();
            break;
        case 63:
            ChipLogProgress(chipTool, " ***** Test Step 63 : Write attribute INT16S Default Value\n");
            err = TestWriteAttributeInt16sDefaultValue_63();
            break;
        case 64:
            ChipLogProgress(chipTool, " ***** Test Step 64 : Read attribute INT16S Default Value\n");
            err = TestReadAttributeInt16sDefaultValue_64();
            break;
        case 65:
            ChipLogProgress(chipTool, " ***** Test Step 65 : Read attribute INT32S Default Value\n");
            err = TestReadAttributeInt32sDefaultValue_65();
            break;
        case 66:
            ChipLogProgress(chipTool, " ***** Test Step 66 : Write attribute INT32S Max Value\n");
            err = TestWriteAttributeInt32sMaxValue_66();
            break;
        case 67:
            ChipLogProgress(chipTool, " ***** Test Step 67 : Read attribute INT32S Max Value\n");
            err = TestReadAttributeInt32sMaxValue_67();
            break;
        case 68:
            ChipLogProgress(chipTool, " ***** Test Step 68 : Write attribute INT32S Min Value\n");
            err = TestWriteAttributeInt32sMinValue_68();
            break;
        case 69:
            ChipLogProgress(chipTool, " ***** Test Step 69 : Read attribute INT32S Min Value\n");
            err = TestReadAttributeInt32sMinValue_69();
            break;
        case 70:
            ChipLogProgress(chipTool, " ***** Test Step 70 : Write attribute INT32S Default Value\n");
            err = TestWriteAttributeInt32sDefaultValue_70();
            break;
        case 71:
            ChipLogProgress(chipTool, " ***** Test Step 71 : Read attribute INT32S Default Value\n");
            err = TestReadAttributeInt32sDefaultValue_71();
            break;
        case 72:
            ChipLogProgress(chipTool, " ***** Test Step 72 : Read attribute INT64S Default Value\n");
            err = TestReadAttributeInt64sDefaultValue_72();
            break;
        case 73:
            ChipLogProgress(chipTool, " ***** Test Step 73 : Write attribute INT64S Max Value\n");
            err = TestWriteAttributeInt64sMaxValue_73();
            break;
        case 74:
            ChipLogProgress(chipTool, " ***** Test Step 74 : Read attribute INT64S Max Value\n");
            err = TestReadAttributeInt64sMaxValue_74();
            break;
        case 75:
            ChipLogProgress(chipTool, " ***** Test Step 75 : Write attribute INT64S Min Value\n");
            err = TestWriteAttributeInt64sMinValue_75();
            break;
        case 76:
            ChipLogProgress(chipTool, " ***** Test Step 76 : Read attribute INT64S Min Value\n");
            err = TestReadAttributeInt64sMinValue_76();
            break;
        case 77:
            ChipLogProgress(chipTool, " ***** Test Step 77 : Write attribute INT64S Default Value\n");
            err = TestWriteAttributeInt64sDefaultValue_77();
            break;
        case 78:
            ChipLogProgress(chipTool, " ***** Test Step 78 : Read attribute INT64S Default Value\n");
            err = TestReadAttributeInt64sDefaultValue_78();
            break;
        case 79:
            ChipLogProgress(chipTool, " ***** Test Step 79 : Read attribute SINGLE Default Value\n");
            err = TestReadAttributeSingleDefaultValue_79();
            break;
        case 80:
            ChipLogProgress(chipTool, " ***** Test Step 80 : Write attribute SINGLE medium Value\n");
            err = TestWriteAttributeSingleMediumValue_80();
            break;
        case 81:
            ChipLogProgress(chipTool, " ***** Test Step 81 : Read attribute SINGLE medium Value\n");
            err = TestReadAttributeSingleMediumValue_81();
            break;
        case 82:
            ChipLogProgress(chipTool, " ***** Test Step 82 : Write attribute SINGLE large Value\n");
            err = TestWriteAttributeSingleLargeValue_82();
            break;
        case 83:
            ChipLogProgress(chipTool, " ***** Test Step 83 : Read attribute SINGLE large Value\n");
            err = TestReadAttributeSingleLargeValue_83();
            break;
        case 84:
            ChipLogProgress(chipTool, " ***** Test Step 84 : Write attribute SINGLE small Value\n");
            err = TestWriteAttributeSingleSmallValue_84();
            break;
        case 85:
            ChipLogProgress(chipTool, " ***** Test Step 85 : Read attribute SINGLE small Value\n");
            err = TestReadAttributeSingleSmallValue_85();
            break;
        case 86:
            ChipLogProgress(chipTool, " ***** Test Step 86 : Write attribute SINGLE Default Value\n");
            err = TestWriteAttributeSingleDefaultValue_86();
            break;
        case 87:
            ChipLogProgress(chipTool, " ***** Test Step 87 : Read attribute SINGLE Default Value\n");
            err = TestReadAttributeSingleDefaultValue_87();
            break;
        case 88:
            ChipLogProgress(chipTool, " ***** Test Step 88 : Read attribute DOUBLE Default Value\n");
            err = TestReadAttributeDoubleDefaultValue_88();
            break;
        case 89:
            ChipLogProgress(chipTool, " ***** Test Step 89 : Write attribute DOUBLE medium Value\n");
            err = TestWriteAttributeDoubleMediumValue_89();
            break;
        case 90:
            ChipLogProgress(chipTool, " ***** Test Step 90 : Read attribute DOUBLE medium Value\n");
            err = TestReadAttributeDoubleMediumValue_90();
            break;
        case 91:
            ChipLogProgress(chipTool, " ***** Test Step 91 : Write attribute DOUBLE large Value\n");
            err = TestWriteAttributeDoubleLargeValue_91();
            break;
        case 92:
            ChipLogProgress(chipTool, " ***** Test Step 92 : Read attribute DOUBLE large Value\n");
            err = TestReadAttributeDoubleLargeValue_92();
            break;
        case 93:
            ChipLogProgress(chipTool, " ***** Test Step 93 : Write attribute DOUBLE small Value\n");
            err = TestWriteAttributeDoubleSmallValue_93();
            break;
        case 94:
            ChipLogProgress(chipTool, " ***** Test Step 94 : Read attribute DOUBLE small Value\n");
            err = TestReadAttributeDoubleSmallValue_94();
            break;
        case 95:
            ChipLogProgress(chipTool, " ***** Test Step 95 : Write attribute DOUBLE Default Value\n");
            err = TestWriteAttributeDoubleDefaultValue_95();
            break;
        case 96:
            ChipLogProgress(chipTool, " ***** Test Step 96 : Read attribute DOUBLE Default Value\n");
            err = TestReadAttributeDoubleDefaultValue_96();
            break;
        case 97:
            ChipLogProgress(chipTool, " ***** Test Step 97 : Read attribute ENUM8 Default Value\n");
            err = TestReadAttributeEnum8DefaultValue_97();
            break;
        case 98:
            ChipLogProgress(chipTool, " ***** Test Step 98 : Write attribute ENUM8 Max Value\n");
            err = TestWriteAttributeEnum8MaxValue_98();
            break;
        case 99:
            ChipLogProgress(chipTool, " ***** Test Step 99 : Read attribute ENUM8 Max Value\n");
            err = TestReadAttributeEnum8MaxValue_99();
            break;
        case 100:
            ChipLogProgress(chipTool, " ***** Test Step 100 : Write attribute ENUM8 Min Value\n");
            err = TestWriteAttributeEnum8MinValue_100();
            break;
        case 101:
            ChipLogProgress(chipTool, " ***** Test Step 101 : Read attribute ENUM8 Min Value\n");
            err = TestReadAttributeEnum8MinValue_101();
            break;
        case 102:
            ChipLogProgress(chipTool, " ***** Test Step 102 : Read attribute ENUM16 Default Value\n");
            err = TestReadAttributeEnum16DefaultValue_102();
            break;
        case 103:
            ChipLogProgress(chipTool, " ***** Test Step 103 : Write attribute ENUM16 Max Value\n");
            err = TestWriteAttributeEnum16MaxValue_103();
            break;
        case 104:
            ChipLogProgress(chipTool, " ***** Test Step 104 : Read attribute ENUM16 Max Value\n");
            err = TestReadAttributeEnum16MaxValue_104();
            break;
        case 105:
            ChipLogProgress(chipTool, " ***** Test Step 105 : Write attribute ENUM16 Min Value\n");
            err = TestWriteAttributeEnum16MinValue_105();
            break;
        case 106:
            ChipLogProgress(chipTool, " ***** Test Step 106 : Read attribute ENUM16 Min Value\n");
            err = TestReadAttributeEnum16MinValue_106();
            break;
        case 107:
            ChipLogProgress(chipTool, " ***** Test Step 107 : Read attribute OCTET_STRING Default Value\n");
            err = TestReadAttributeOctetStringDefaultValue_107();
            break;
        case 108:
            ChipLogProgress(chipTool, " ***** Test Step 108 : Write attribute OCTET_STRING with embedded null\n");
            err = TestWriteAttributeOctetStringWithEmbeddedNull_108();
            break;
        case 109:
            ChipLogProgress(chipTool, " ***** Test Step 109 : Read attribute OCTET_STRING with embedded null\n");
            err = TestReadAttributeOctetStringWithEmbeddedNull_109();
            break;
        case 110:
            ChipLogProgress(chipTool, " ***** Test Step 110 : Write attribute OCTET_STRING with weird chars\n");
            err = TestWriteAttributeOctetStringWithWeirdChars_110();
            break;
        case 111:
            ChipLogProgress(chipTool, " ***** Test Step 111 : Read attribute OCTET_STRING with weird chars\n");
            err = TestReadAttributeOctetStringWithWeirdChars_111();
            break;
        case 112:
            ChipLogProgress(chipTool, " ***** Test Step 112 : Write attribute OCTET_STRING\n");
            err = TestWriteAttributeOctetString_112();
            break;
        case 113:
            ChipLogProgress(chipTool, " ***** Test Step 113 : Read attribute OCTET_STRING\n");
            err = TestReadAttributeOctetString_113();
            break;
        case 114:
            ChipLogProgress(chipTool, " ***** Test Step 114 : Write attribute OCTET_STRING\n");
            err = TestWriteAttributeOctetString_114();
            break;
        case 115:
            ChipLogProgress(chipTool, " ***** Test Step 115 : Read attribute OCTET_STRING\n");
            err = TestReadAttributeOctetString_115();
            break;
        case 116:
            ChipLogProgress(chipTool, " ***** Test Step 116 : Write attribute OCTET_STRING\n");
            err = TestWriteAttributeOctetString_116();
            break;
        case 117:
            ChipLogProgress(chipTool, " ***** Test Step 117 : Read attribute LONG_OCTET_STRING Default Value\n");
            err = TestReadAttributeLongOctetStringDefaultValue_117();
            break;
        case 118:
            ChipLogProgress(chipTool, " ***** Test Step 118 : Write attribute LONG_OCTET_STRING\n");
            err = TestWriteAttributeLongOctetString_118();
            break;
        case 119:
            ChipLogProgress(chipTool, " ***** Test Step 119 : Read attribute LONG_OCTET_STRING\n");
            err = TestReadAttributeLongOctetString_119();
            break;
        case 120:
            ChipLogProgress(chipTool, " ***** Test Step 120 : Write attribute LONG_OCTET_STRING\n");
            err = TestWriteAttributeLongOctetString_120();
            break;
        case 121:
            ChipLogProgress(chipTool, " ***** Test Step 121 : Read attribute CHAR_STRING Default Value\n");
            err = TestReadAttributeCharStringDefaultValue_121();
            break;
        case 122:
            ChipLogProgress(chipTool, " ***** Test Step 122 : Write attribute CHAR_STRING\n");
            err = TestWriteAttributeCharString_122();
            break;
        case 123:
            ChipLogProgress(chipTool, " ***** Test Step 123 : Read attribute CHAR_STRING\n");
            err = TestReadAttributeCharString_123();
            break;
        case 124:
            ChipLogProgress(chipTool, " ***** Test Step 124 : Write attribute CHAR_STRING - Value too long\n");
            err = TestWriteAttributeCharStringValueTooLong_124();
            break;
        case 125:
            ChipLogProgress(chipTool, " ***** Test Step 125 : Read attribute CHAR_STRING\n");
            err = TestReadAttributeCharString_125();
            break;
        case 126:
            ChipLogProgress(chipTool, " ***** Test Step 126 : Write attribute CHAR_STRING - Empty\n");
            err = TestWriteAttributeCharStringEmpty_126();
            break;
        case 127:
            ChipLogProgress(chipTool, " ***** Test Step 127 : Read attribute LONG_CHAR_STRING Default Value\n");
            err = TestReadAttributeLongCharStringDefaultValue_127();
            break;
        case 128:
            ChipLogProgress(chipTool, " ***** Test Step 128 : Write attribute LONG_CHAR_STRING\n");
            err = TestWriteAttributeLongCharString_128();
            break;
        case 129:
            ChipLogProgress(chipTool, " ***** Test Step 129 : Read attribute LONG_CHAR_STRING\n");
            err = TestReadAttributeLongCharString_129();
            break;
        case 130:
            ChipLogProgress(chipTool, " ***** Test Step 130 : Write attribute LONG_CHAR_STRING\n");
            err = TestWriteAttributeLongCharString_130();
            break;
        case 131:
            ChipLogProgress(chipTool, " ***** Test Step 131 : Read attribute LIST_LONG_OCTET_STRING (for chunked read)\n");
            err = TestReadAttributeListLongOctetStringForChunkedRead_131();
            break;
        case 132:
            ChipLogProgress(chipTool, " ***** Test Step 132 : Write attribute LIST_LONG_OCTET_STRING (for chunked write)\n");
            err = TestWriteAttributeListLongOctetStringForChunkedWrite_132();
            break;
        case 133:
            ChipLogProgress(chipTool, " ***** Test Step 133 : Read attribute LIST_LONG_OCTET_STRING (for chunked read)\n");
            err = TestReadAttributeListLongOctetStringForChunkedRead_133();
            break;
        case 134:
            ChipLogProgress(chipTool, " ***** Test Step 134 : Read attribute EPOCH_US Default Value\n");
            err = TestReadAttributeEpochUsDefaultValue_134();
            break;
        case 135:
            ChipLogProgress(chipTool, " ***** Test Step 135 : Write attribute EPOCH_US Max Value\n");
            err = TestWriteAttributeEpochUsMaxValue_135();
            break;
        case 136:
            ChipLogProgress(chipTool, " ***** Test Step 136 : Read attribute EPOCH_US Max Value\n");
            err = TestReadAttributeEpochUsMaxValue_136();
            break;
        case 137:
            ChipLogProgress(chipTool, " ***** Test Step 137 : Write attribute EPOCH_US Min Value\n");
            err = TestWriteAttributeEpochUsMinValue_137();
            break;
        case 138:
            ChipLogProgress(chipTool, " ***** Test Step 138 : Read attribute EPOCH_US Min Value\n");
            err = TestReadAttributeEpochUsMinValue_138();
            break;
        case 139:
            ChipLogProgress(chipTool, " ***** Test Step 139 : Read attribute EPOCH_S Default Value\n");
            err = TestReadAttributeEpochSDefaultValue_139();
            break;
        case 140:
            ChipLogProgress(chipTool, " ***** Test Step 140 : Write attribute EPOCH_S Max Value\n");
            err = TestWriteAttributeEpochSMaxValue_140();
            break;
        case 141:
            ChipLogProgress(chipTool, " ***** Test Step 141 : Read attribute EPOCH_S Max Value\n");
            err = TestReadAttributeEpochSMaxValue_141();
            break;
        case 142:
            ChipLogProgress(chipTool, " ***** Test Step 142 : Write attribute EPOCH_S Min Value\n");
            err = TestWriteAttributeEpochSMinValue_142();
            break;
        case 143:
            ChipLogProgress(chipTool, " ***** Test Step 143 : Read attribute EPOCH_S Min Value\n");
            err = TestReadAttributeEpochSMinValue_143();
            break;
        case 144:
            ChipLogProgress(chipTool, " ***** Test Step 144 : Read attribute UNSUPPORTED\n");
            err = TestReadAttributeUnsupported_144();
            break;
        case 145:
            ChipLogProgress(chipTool, " ***** Test Step 145 : Writeattribute UNSUPPORTED\n");
            err = TestWriteattributeUnsupported_145();
            break;
        case 146:
            ChipLogProgress(chipTool, " ***** Test Step 146 : Send Test Command to unsupported endpoint\n");
            err = TestSendTestCommandToUnsupportedEndpoint_146();
            break;
        case 147:
            ChipLogProgress(chipTool, " ***** Test Step 147 : Send Test Command to unsupported cluster\n");
            err = TestSendTestCommandToUnsupportedCluster_147();
            break;
        case 148:
            ChipLogProgress(chipTool, " ***** Test Step 148 : Read attribute vendor_id Default Value\n");
            err = TestReadAttributeVendorIdDefaultValue_148();
            break;
        case 149:
            ChipLogProgress(chipTool, " ***** Test Step 149 : Write attribute vendor_id\n");
            err = TestWriteAttributeVendorId_149();
            break;
        case 150:
            ChipLogProgress(chipTool, " ***** Test Step 150 : Read attribute vendor_id\n");
            err = TestReadAttributeVendorId_150();
            break;
        case 151:
            ChipLogProgress(chipTool, " ***** Test Step 151 : Restore attribute vendor_id\n");
            err = TestRestoreAttributeVendorId_151();
            break;
        case 152:
            ChipLogProgress(chipTool, " ***** Test Step 152 : Send a command with a vendor_id and enum\n");
            err = TestSendACommandWithAVendorIdAndEnum_152();
            break;
        case 153:
            ChipLogProgress(chipTool, " ***** Test Step 153 : Send Test Command With Struct Argument and arg1.b is true\n");
            err = TestSendTestCommandWithStructArgumentAndArg1bIsTrue_153();
            break;
        case 154:
            ChipLogProgress(chipTool, " ***** Test Step 154 : Send Test Command With Struct Argument and arg1.b is false\n");
            err = TestSendTestCommandWithStructArgumentAndArg1bIsFalse_154();
            break;
        case 155:
            ChipLogProgress(chipTool,
                            " ***** Test Step 155 : Send Test Command With Nested Struct Argument and arg1.c.b is true\n");
            err = TestSendTestCommandWithNestedStructArgumentAndArg1cbIsTrue_155();
            break;
        case 156:
            ChipLogProgress(chipTool, " ***** Test Step 156 : Send Test Command With Nested Struct Argument arg1.c.b is false\n");
            err = TestSendTestCommandWithNestedStructArgumentArg1cbIsFalse_156();
            break;
        case 157:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 157 : Send Test Command With Nested Struct List Argument and all fields b of arg1.d are true\n");
            err = TestSendTestCommandWithNestedStructListArgumentAndAllFieldsBOfArg1dAreTrue_157();
            break;
        case 158:
            ChipLogProgress(chipTool,
                            " ***** Test Step 158 : Send Test Command With Nested Struct List Argument and some fields b of arg1.d "
                            "are false\n");
            err = TestSendTestCommandWithNestedStructListArgumentAndSomeFieldsBOfArg1dAreFalse_158();
            break;
        case 159:
            ChipLogProgress(chipTool, " ***** Test Step 159 : Send Test Command With Struct Argument and see what we get back\n");
            err = TestSendTestCommandWithStructArgumentAndSeeWhatWeGetBack_159();
            break;
        case 160:
            ChipLogProgress(chipTool, " ***** Test Step 160 : Send Test Command With List of INT8U and none of them is set to 0\n");
            err = TestSendTestCommandWithListOfInt8uAndNoneOfThemIsSetTo0_160();
            break;
        case 161:
            ChipLogProgress(chipTool, " ***** Test Step 161 : Send Test Command With List of INT8U and one of them is set to 0\n");
            err = TestSendTestCommandWithListOfInt8uAndOneOfThemIsSetTo0_161();
            break;
        case 162:
            ChipLogProgress(chipTool, " ***** Test Step 162 : Send Test Command With List of INT8U and get it reversed\n");
            err = TestSendTestCommandWithListOfInt8uAndGetItReversed_162();
            break;
        case 163:
            ChipLogProgress(chipTool,
                            " ***** Test Step 163 : Send Test Command With empty List of INT8U and get an empty list back\n");
            err = TestSendTestCommandWithEmptyListOfInt8uAndGetAnEmptyListBack_163();
            break;
        case 164:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 164 : Send Test Command With List of Struct Argument and arg1.b of first item is true\n");
            err = TestSendTestCommandWithListOfStructArgumentAndArg1bOfFirstItemIsTrue_164();
            break;
        case 165:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 165 : Send Test Command With List of Struct Argument and arg1.b of first item is false\n");
            err = TestSendTestCommandWithListOfStructArgumentAndArg1bOfFirstItemIsFalse_165();
            break;
        case 166:
            ChipLogProgress(chipTool,
                            " ***** Test Step 166 : Send Test Command With List of Nested Struct List Argument and all fields b of "
                            "elements of arg1.d are true\n");
            err = TestSendTestCommandWithListOfNestedStructListArgumentAndAllFieldsBOfElementsOfArg1dAreTrue_166();
            break;
        case 167:
            ChipLogProgress(chipTool,
                            " ***** Test Step 167 : Send Test Command With Nested Struct List Argument and some fields b of "
                            "elements of arg1.d are false\n");
            err = TestSendTestCommandWithNestedStructListArgumentAndSomeFieldsBOfElementsOfArg1dAreFalse_167();
            break;
        case 168:
            ChipLogProgress(chipTool,
                            " ***** Test Step 168 : Write attribute LIST With List of INT8U and none of them is set to 0\n");
            err = TestWriteAttributeListWithListOfInt8uAndNoneOfThemIsSetTo0_168();
            break;
        case 169:
            ChipLogProgress(chipTool, " ***** Test Step 169 : Read attribute LIST With List of INT8U\n");
            err = TestReadAttributeListWithListOfInt8u_169();
            break;
        case 170:
            ChipLogProgress(chipTool, " ***** Test Step 170 : Write attribute LIST With List of OCTET_STRING\n");
            err = TestWriteAttributeListWithListOfOctetString_170();
            break;
        case 171:
            ChipLogProgress(chipTool, " ***** Test Step 171 : Read attribute LIST With List of OCTET_STRING\n");
            err = TestReadAttributeListWithListOfOctetString_171();
            break;
        case 172:
            ChipLogProgress(chipTool, " ***** Test Step 172 : Write attribute LIST With List of LIST_STRUCT_OCTET_STRING\n");
            err = TestWriteAttributeListWithListOfListStructOctetString_172();
            break;
        case 173:
            ChipLogProgress(chipTool, " ***** Test Step 173 : Read attribute LIST With List of LIST_STRUCT_OCTET_STRING\n");
            err = TestReadAttributeListWithListOfListStructOctetString_173();
            break;
        case 174:
            ChipLogProgress(chipTool, " ***** Test Step 174 : Send Test Command with optional arg set.\n");
            err = TestSendTestCommandWithOptionalArgSet_174();
            break;
        case 175:
            ChipLogProgress(chipTool, " ***** Test Step 175 : Send Test Command without its optional arg.\n");
            err = TestSendTestCommandWithoutItsOptionalArg_175();
            break;
        case 176:
            ChipLogProgress(chipTool, " ***** Test Step 176 : Read list of structs containing nullables and optionals\n");
            err = TestReadListOfStructsContainingNullablesAndOptionals_176();
            break;
        case 177:
            ChipLogProgress(chipTool, " ***** Test Step 177 : Write list of structs containing nullables and optionals\n");
            err = TestWriteListOfStructsContainingNullablesAndOptionals_177();
            break;
        case 178:
            ChipLogProgress(chipTool,
                            " ***** Test Step 178 : Read list of structs containing nullables and optionals after writing\n");
            err = TestReadListOfStructsContainingNullablesAndOptionalsAfterWriting_178();
            break;
        case 179:
            ChipLogProgress(chipTool, " ***** Test Step 179 : Write attribute NULLABLE_BOOLEAN null\n");
            err = TestWriteAttributeNullableBooleanNull_179();
            break;
        case 180:
            ChipLogProgress(chipTool, " ***** Test Step 180 : Read attribute NULLABLE_BOOLEAN null\n");
            err = TestReadAttributeNullableBooleanNull_180();
            break;
        case 181:
            ChipLogProgress(chipTool, " ***** Test Step 181 : Write attribute NULLABLE_BOOLEAN True\n");
            err = TestWriteAttributeNullableBooleanTrue_181();
            break;
        case 182:
            ChipLogProgress(chipTool, " ***** Test Step 182 : Read attribute NULLABLE_BOOLEAN True\n");
            err = TestReadAttributeNullableBooleanTrue_182();
            break;
        case 183:
            ChipLogProgress(chipTool, " ***** Test Step 183 : Write attribute NULLABLE_BITMAP8 Max Value\n");
            err = TestWriteAttributeNullableBitmap8MaxValue_183();
            break;
        case 184:
            ChipLogProgress(chipTool, " ***** Test Step 184 : Read attribute NULLABLE_BITMAP8 Max Value\n");
            err = TestReadAttributeNullableBitmap8MaxValue_184();
            break;
        case 185:
            ChipLogProgress(chipTool, " ***** Test Step 185 : Write attribute NULLABLE_BITMAP8 Invalid Value\n");
            err = TestWriteAttributeNullableBitmap8InvalidValue_185();
            break;
        case 186:
            ChipLogProgress(chipTool, " ***** Test Step 186 : Read attribute NULLABLE_BITMAP8 unchanged Value\n");
            err = TestReadAttributeNullableBitmap8UnchangedValue_186();
            break;
        case 187:
            ChipLogProgress(chipTool, " ***** Test Step 187 : Write attribute NULLABLE_BITMAP8 null Value\n");
            err = TestWriteAttributeNullableBitmap8NullValue_187();
            break;
        case 188:
            ChipLogProgress(chipTool, " ***** Test Step 188 : Read attribute NULLABLE_BITMAP8 null Value\n");
            err = TestReadAttributeNullableBitmap8NullValue_188();
            break;
        case 189:
            ChipLogProgress(chipTool, " ***** Test Step 189 : Write attribute NULLABLE_BITMAP16 Max Value\n");
            err = TestWriteAttributeNullableBitmap16MaxValue_189();
            break;
        case 190:
            ChipLogProgress(chipTool, " ***** Test Step 190 : Read attribute NULLABLE_BITMAP16 Max Value\n");
            err = TestReadAttributeNullableBitmap16MaxValue_190();
            break;
        case 191:
            ChipLogProgress(chipTool, " ***** Test Step 191 : Write attribute NULLABLE_BITMAP16 Invalid Value\n");
            err = TestWriteAttributeNullableBitmap16InvalidValue_191();
            break;
        case 192:
            ChipLogProgress(chipTool, " ***** Test Step 192 : Read attribute NULLABLE_BITMAP16 unchanged Value\n");
            err = TestReadAttributeNullableBitmap16UnchangedValue_192();
            break;
        case 193:
            ChipLogProgress(chipTool, " ***** Test Step 193 : Write attribute NULLABLE_BITMAP16 null Value\n");
            err = TestWriteAttributeNullableBitmap16NullValue_193();
            break;
        case 194:
            ChipLogProgress(chipTool, " ***** Test Step 194 : Read attribute NULLABLE_BITMAP16 null Value\n");
            err = TestReadAttributeNullableBitmap16NullValue_194();
            break;
        case 195:
            ChipLogProgress(chipTool, " ***** Test Step 195 : Write attribute NULLABLE_BITMAP32 Max Value\n");
            err = TestWriteAttributeNullableBitmap32MaxValue_195();
            break;
        case 196:
            ChipLogProgress(chipTool, " ***** Test Step 196 : Read attribute NULLABLE_BITMAP32 Max Value\n");
            err = TestReadAttributeNullableBitmap32MaxValue_196();
            break;
        case 197:
            ChipLogProgress(chipTool, " ***** Test Step 197 : Write attribute NULLABLE_BITMAP32 Invalid Value\n");
            err = TestWriteAttributeNullableBitmap32InvalidValue_197();
            break;
        case 198:
            ChipLogProgress(chipTool, " ***** Test Step 198 : Read attribute NULLABLE_BITMAP32 unchanged Value\n");
            err = TestReadAttributeNullableBitmap32UnchangedValue_198();
            break;
        case 199:
            ChipLogProgress(chipTool, " ***** Test Step 199 : Write attribute NULLABLE_BITMAP32 null Value\n");
            err = TestWriteAttributeNullableBitmap32NullValue_199();
            break;
        case 200:
            ChipLogProgress(chipTool, " ***** Test Step 200 : Read attribute NULLABLE_BITMAP32 null Value\n");
            err = TestReadAttributeNullableBitmap32NullValue_200();
            break;
        case 201:
            ChipLogProgress(chipTool, " ***** Test Step 201 : Write attribute NULLABLE_BITMAP64 Max Value\n");
            err = TestWriteAttributeNullableBitmap64MaxValue_201();
            break;
        case 202:
            ChipLogProgress(chipTool, " ***** Test Step 202 : Read attribute NULLABLE_BITMAP64 Max Value\n");
            err = TestReadAttributeNullableBitmap64MaxValue_202();
            break;
        case 203:
            ChipLogProgress(chipTool, " ***** Test Step 203 : Write attribute NULLABLE_BITMAP64 Invalid Value\n");
            err = TestWriteAttributeNullableBitmap64InvalidValue_203();
            break;
        case 204:
            ChipLogProgress(chipTool, " ***** Test Step 204 : Read attribute NULLABLE_BITMAP64 unchanged Value\n");
            err = TestReadAttributeNullableBitmap64UnchangedValue_204();
            break;
        case 205:
            ChipLogProgress(chipTool, " ***** Test Step 205 : Write attribute NULLABLE_BITMAP64 null Value\n");
            err = TestWriteAttributeNullableBitmap64NullValue_205();
            break;
        case 206:
            ChipLogProgress(chipTool, " ***** Test Step 206 : Read attribute NULLABLE_BITMAP64 null Value\n");
            err = TestReadAttributeNullableBitmap64NullValue_206();
            break;
        case 207:
            ChipLogProgress(chipTool, " ***** Test Step 207 : Write attribute NULLABLE_INT8U Min Value\n");
            err = TestWriteAttributeNullableInt8uMinValue_207();
            break;
        case 208:
            ChipLogProgress(chipTool, " ***** Test Step 208 : Read attribute NULLABLE_INT8U Min Value\n");
            err = TestReadAttributeNullableInt8uMinValue_208();
            break;
        case 209:
            ChipLogProgress(chipTool, " ***** Test Step 209 : Write attribute NULLABLE_INT8U Max Value\n");
            err = TestWriteAttributeNullableInt8uMaxValue_209();
            break;
        case 210:
            ChipLogProgress(chipTool, " ***** Test Step 210 : Read attribute NULLABLE_INT8U Max Value\n");
            err = TestReadAttributeNullableInt8uMaxValue_210();
            break;
        case 211:
            ChipLogProgress(chipTool, " ***** Test Step 211 : Write attribute NULLABLE_INT8U Invalid Value\n");
            err = TestWriteAttributeNullableInt8uInvalidValue_211();
            break;
        case 212:
            ChipLogProgress(chipTool, " ***** Test Step 212 : Read attribute NULLABLE_INT8U unchanged Value\n");
            err = TestReadAttributeNullableInt8uUnchangedValue_212();
            break;
        case 213:
            ChipLogProgress(chipTool, " ***** Test Step 213 : Read attribute NULLABLE_INT8U unchanged Value with constraint\n");
            err = TestReadAttributeNullableInt8uUnchangedValueWithConstraint_213();
            break;
        case 214:
            ChipLogProgress(chipTool, " ***** Test Step 214 : Write attribute NULLABLE_INT8U null Value\n");
            err = TestWriteAttributeNullableInt8uNullValue_214();
            break;
        case 215:
            ChipLogProgress(chipTool, " ***** Test Step 215 : Read attribute NULLABLE_INT8U null Value\n");
            err = TestReadAttributeNullableInt8uNullValue_215();
            break;
        case 216:
            ChipLogProgress(chipTool, " ***** Test Step 216 : Read attribute NULLABLE_INT8U null Value & range\n");
            err = TestReadAttributeNullableInt8uNullValueRange_216();
            break;
        case 217:
            ChipLogProgress(chipTool, " ***** Test Step 217 : Read attribute NULLABLE_INT8U null Value & not\n");
            err = TestReadAttributeNullableInt8uNullValueNot_217();
            break;
        case 218:
            ChipLogProgress(chipTool, " ***** Test Step 218 : Write attribute NULLABLE_INT8U Value\n");
            err = TestWriteAttributeNullableInt8uValue_218();
            break;
        case 219:
            ChipLogProgress(chipTool, " ***** Test Step 219 : Read attribute NULLABLE_INT8U Value in range\n");
            err = TestReadAttributeNullableInt8uValueInRange_219();
            break;
        case 220:
            ChipLogProgress(chipTool, " ***** Test Step 220 : Read attribute NULLABLE_INT8U notValue OK\n");
            err = TestReadAttributeNullableInt8uNotValueOk_220();
            break;
        case 221:
            ChipLogProgress(chipTool, " ***** Test Step 221 : Write attribute NULLABLE_INT16U Min Value\n");
            err = TestWriteAttributeNullableInt16uMinValue_221();
            break;
        case 222:
            ChipLogProgress(chipTool, " ***** Test Step 222 : Read attribute NULLABLE_INT16U Min Value\n");
            err = TestReadAttributeNullableInt16uMinValue_222();
            break;
        case 223:
            ChipLogProgress(chipTool, " ***** Test Step 223 : Write attribute NULLABLE_INT16U Max Value\n");
            err = TestWriteAttributeNullableInt16uMaxValue_223();
            break;
        case 224:
            ChipLogProgress(chipTool, " ***** Test Step 224 : Read attribute NULLABLE_INT16U Max Value\n");
            err = TestReadAttributeNullableInt16uMaxValue_224();
            break;
        case 225:
            ChipLogProgress(chipTool, " ***** Test Step 225 : Write attribute NULLABLE_INT16U Invalid Value\n");
            err = TestWriteAttributeNullableInt16uInvalidValue_225();
            break;
        case 226:
            ChipLogProgress(chipTool, " ***** Test Step 226 : Read attribute NULLABLE_INT16U unchanged Value\n");
            err = TestReadAttributeNullableInt16uUnchangedValue_226();
            break;
        case 227:
            ChipLogProgress(chipTool, " ***** Test Step 227 : Write attribute NULLABLE_INT16U null Value\n");
            err = TestWriteAttributeNullableInt16uNullValue_227();
            break;
        case 228:
            ChipLogProgress(chipTool, " ***** Test Step 228 : Read attribute NULLABLE_INT16U null Value\n");
            err = TestReadAttributeNullableInt16uNullValue_228();
            break;
        case 229:
            ChipLogProgress(chipTool, " ***** Test Step 229 : Read attribute NULLABLE_INT16U null Value & range\n");
            err = TestReadAttributeNullableInt16uNullValueRange_229();
            break;
        case 230:
            ChipLogProgress(chipTool, " ***** Test Step 230 : Read attribute NULLABLE_INT16U null Value & not\n");
            err = TestReadAttributeNullableInt16uNullValueNot_230();
            break;
        case 231:
            ChipLogProgress(chipTool, " ***** Test Step 231 : Write attribute NULLABLE_INT16U Value\n");
            err = TestWriteAttributeNullableInt16uValue_231();
            break;
        case 232:
            ChipLogProgress(chipTool, " ***** Test Step 232 : Read attribute NULLABLE_INT16U Value in range\n");
            err = TestReadAttributeNullableInt16uValueInRange_232();
            break;
        case 233:
            ChipLogProgress(chipTool, " ***** Test Step 233 : Read attribute NULLABLE_INT16U notValue OK\n");
            err = TestReadAttributeNullableInt16uNotValueOk_233();
            break;
        case 234:
            ChipLogProgress(chipTool, " ***** Test Step 234 : Write attribute NULLABLE_INT32U Min Value\n");
            err = TestWriteAttributeNullableInt32uMinValue_234();
            break;
        case 235:
            ChipLogProgress(chipTool, " ***** Test Step 235 : Read attribute NULLABLE_INT32U Min Value\n");
            err = TestReadAttributeNullableInt32uMinValue_235();
            break;
        case 236:
            ChipLogProgress(chipTool, " ***** Test Step 236 : Write attribute NULLABLE_INT32U Max Value\n");
            err = TestWriteAttributeNullableInt32uMaxValue_236();
            break;
        case 237:
            ChipLogProgress(chipTool, " ***** Test Step 237 : Read attribute NULLABLE_INT32U Max Value\n");
            err = TestReadAttributeNullableInt32uMaxValue_237();
            break;
        case 238:
            ChipLogProgress(chipTool, " ***** Test Step 238 : Write attribute NULLABLE_INT32U Invalid Value\n");
            err = TestWriteAttributeNullableInt32uInvalidValue_238();
            break;
        case 239:
            ChipLogProgress(chipTool, " ***** Test Step 239 : Read attribute NULLABLE_INT32U unchanged Value\n");
            err = TestReadAttributeNullableInt32uUnchangedValue_239();
            break;
        case 240:
            ChipLogProgress(chipTool, " ***** Test Step 240 : Write attribute NULLABLE_INT32U null Value\n");
            err = TestWriteAttributeNullableInt32uNullValue_240();
            break;
        case 241:
            ChipLogProgress(chipTool, " ***** Test Step 241 : Read attribute NULLABLE_INT32U null Value\n");
            err = TestReadAttributeNullableInt32uNullValue_241();
            break;
        case 242:
            ChipLogProgress(chipTool, " ***** Test Step 242 : Read attribute NULLABLE_INT32U null Value & range\n");
            err = TestReadAttributeNullableInt32uNullValueRange_242();
            break;
        case 243:
            ChipLogProgress(chipTool, " ***** Test Step 243 : Read attribute NULLABLE_INT32U null Value & not\n");
            err = TestReadAttributeNullableInt32uNullValueNot_243();
            break;
        case 244:
            ChipLogProgress(chipTool, " ***** Test Step 244 : Write attribute NULLABLE_INT32U Value\n");
            err = TestWriteAttributeNullableInt32uValue_244();
            break;
        case 245:
            ChipLogProgress(chipTool, " ***** Test Step 245 : Read attribute NULLABLE_INT32U Value in range\n");
            err = TestReadAttributeNullableInt32uValueInRange_245();
            break;
        case 246:
            ChipLogProgress(chipTool, " ***** Test Step 246 : Read attribute NULLABLE_INT32U notValue OK\n");
            err = TestReadAttributeNullableInt32uNotValueOk_246();
            break;
        case 247:
            ChipLogProgress(chipTool, " ***** Test Step 247 : Write attribute NULLABLE_INT64U Min Value\n");
            err = TestWriteAttributeNullableInt64uMinValue_247();
            break;
        case 248:
            ChipLogProgress(chipTool, " ***** Test Step 248 : Read attribute NULLABLE_INT64U Min Value\n");
            err = TestReadAttributeNullableInt64uMinValue_248();
            break;
        case 249:
            ChipLogProgress(chipTool, " ***** Test Step 249 : Write attribute NULLABLE_INT64U Max Value\n");
            err = TestWriteAttributeNullableInt64uMaxValue_249();
            break;
        case 250:
            ChipLogProgress(chipTool, " ***** Test Step 250 : Read attribute NULLABLE_INT64U Max Value\n");
            err = TestReadAttributeNullableInt64uMaxValue_250();
            break;
        case 251:
            ChipLogProgress(chipTool, " ***** Test Step 251 : Write attribute NULLABLE_INT64U Invalid Value\n");
            err = TestWriteAttributeNullableInt64uInvalidValue_251();
            break;
        case 252:
            ChipLogProgress(chipTool, " ***** Test Step 252 : Read attribute NULLABLE_INT64U unchanged Value\n");
            err = TestReadAttributeNullableInt64uUnchangedValue_252();
            break;
        case 253:
            ChipLogProgress(chipTool, " ***** Test Step 253 : Write attribute NULLABLE_INT64U null Value\n");
            err = TestWriteAttributeNullableInt64uNullValue_253();
            break;
        case 254:
            ChipLogProgress(chipTool, " ***** Test Step 254 : Read attribute NULLABLE_INT64U null Value\n");
            err = TestReadAttributeNullableInt64uNullValue_254();
            break;
        case 255:
            ChipLogProgress(chipTool, " ***** Test Step 255 : Read attribute NULLABLE_INT64U null Value & range\n");
            err = TestReadAttributeNullableInt64uNullValueRange_255();
            break;
        case 256:
            ChipLogProgress(chipTool, " ***** Test Step 256 : Read attribute NULLABLE_INT64U null Value & not\n");
            err = TestReadAttributeNullableInt64uNullValueNot_256();
            break;
        case 257:
            ChipLogProgress(chipTool, " ***** Test Step 257 : Write attribute NULLABLE_INT64U Value\n");
            err = TestWriteAttributeNullableInt64uValue_257();
            break;
        case 258:
            ChipLogProgress(chipTool, " ***** Test Step 258 : Read attribute NULLABLE_INT64U Value in range\n");
            err = TestReadAttributeNullableInt64uValueInRange_258();
            break;
        case 259:
            ChipLogProgress(chipTool, " ***** Test Step 259 : Read attribute NULLABLE_INT64U notValue OK\n");
            err = TestReadAttributeNullableInt64uNotValueOk_259();
            break;
        case 260:
            ChipLogProgress(chipTool, " ***** Test Step 260 : Write attribute NULLABLE_INT8S Min Value\n");
            err = TestWriteAttributeNullableInt8sMinValue_260();
            break;
        case 261:
            ChipLogProgress(chipTool, " ***** Test Step 261 : Read attribute NULLABLE_INT8S Min Value\n");
            err = TestReadAttributeNullableInt8sMinValue_261();
            break;
        case 262:
            ChipLogProgress(chipTool, " ***** Test Step 262 : Write attribute NULLABLE_INT8S Invalid Value\n");
            err = TestWriteAttributeNullableInt8sInvalidValue_262();
            break;
        case 263:
            ChipLogProgress(chipTool, " ***** Test Step 263 : Read attribute NULLABLE_INT8S unchanged Value\n");
            err = TestReadAttributeNullableInt8sUnchangedValue_263();
            break;
        case 264:
            ChipLogProgress(chipTool, " ***** Test Step 264 : Write attribute NULLABLE_INT8S null Value\n");
            err = TestWriteAttributeNullableInt8sNullValue_264();
            break;
        case 265:
            ChipLogProgress(chipTool, " ***** Test Step 265 : Read attribute NULLABLE_INT8S null Value\n");
            err = TestReadAttributeNullableInt8sNullValue_265();
            break;
        case 266:
            ChipLogProgress(chipTool, " ***** Test Step 266 : Read attribute NULLABLE_INT8S null Value & range\n");
            err = TestReadAttributeNullableInt8sNullValueRange_266();
            break;
        case 267:
            ChipLogProgress(chipTool, " ***** Test Step 267 : Read attribute NULLABLE_INT8S null Value & not\n");
            err = TestReadAttributeNullableInt8sNullValueNot_267();
            break;
        case 268:
            ChipLogProgress(chipTool, " ***** Test Step 268 : Write attribute NULLABLE_INT8S Value\n");
            err = TestWriteAttributeNullableInt8sValue_268();
            break;
        case 269:
            ChipLogProgress(chipTool, " ***** Test Step 269 : Read attribute NULLABLE_INT8S Value in range\n");
            err = TestReadAttributeNullableInt8sValueInRange_269();
            break;
        case 270:
            ChipLogProgress(chipTool, " ***** Test Step 270 : Read attribute NULLABLE_INT8S notValue OK\n");
            err = TestReadAttributeNullableInt8sNotValueOk_270();
            break;
        case 271:
            ChipLogProgress(chipTool, " ***** Test Step 271 : Write attribute NULLABLE_INT16S Min Value\n");
            err = TestWriteAttributeNullableInt16sMinValue_271();
            break;
        case 272:
            ChipLogProgress(chipTool, " ***** Test Step 272 : Read attribute NULLABLE_INT16S Min Value\n");
            err = TestReadAttributeNullableInt16sMinValue_272();
            break;
        case 273:
            ChipLogProgress(chipTool, " ***** Test Step 273 : Write attribute NULLABLE_INT16S Invalid Value\n");
            err = TestWriteAttributeNullableInt16sInvalidValue_273();
            break;
        case 274:
            ChipLogProgress(chipTool, " ***** Test Step 274 : Read attribute NULLABLE_INT16S unchanged Value\n");
            err = TestReadAttributeNullableInt16sUnchangedValue_274();
            break;
        case 275:
            ChipLogProgress(chipTool, " ***** Test Step 275 : Write attribute NULLABLE_INT16S null Value\n");
            err = TestWriteAttributeNullableInt16sNullValue_275();
            break;
        case 276:
            ChipLogProgress(chipTool, " ***** Test Step 276 : Read attribute NULLABLE_INT16S null Value\n");
            err = TestReadAttributeNullableInt16sNullValue_276();
            break;
        case 277:
            ChipLogProgress(chipTool, " ***** Test Step 277 : Read attribute NULLABLE_INT16S null Value & range\n");
            err = TestReadAttributeNullableInt16sNullValueRange_277();
            break;
        case 278:
            ChipLogProgress(chipTool, " ***** Test Step 278 : Read attribute NULLABLE_INT16S null Value & not\n");
            err = TestReadAttributeNullableInt16sNullValueNot_278();
            break;
        case 279:
            ChipLogProgress(chipTool, " ***** Test Step 279 : Write attribute NULLABLE_INT16S Value\n");
            err = TestWriteAttributeNullableInt16sValue_279();
            break;
        case 280:
            ChipLogProgress(chipTool, " ***** Test Step 280 : Read attribute NULLABLE_INT16S Value in range\n");
            err = TestReadAttributeNullableInt16sValueInRange_280();
            break;
        case 281:
            ChipLogProgress(chipTool, " ***** Test Step 281 : Read attribute NULLABLE_INT16S notValue OK\n");
            err = TestReadAttributeNullableInt16sNotValueOk_281();
            break;
        case 282:
            ChipLogProgress(chipTool, " ***** Test Step 282 : Write attribute NULLABLE_INT32S Min Value\n");
            err = TestWriteAttributeNullableInt32sMinValue_282();
            break;
        case 283:
            ChipLogProgress(chipTool, " ***** Test Step 283 : Read attribute NULLABLE_INT32S Min Value\n");
            err = TestReadAttributeNullableInt32sMinValue_283();
            break;
        case 284:
            ChipLogProgress(chipTool, " ***** Test Step 284 : Write attribute NULLABLE_INT32S Invalid Value\n");
            err = TestWriteAttributeNullableInt32sInvalidValue_284();
            break;
        case 285:
            ChipLogProgress(chipTool, " ***** Test Step 285 : Read attribute NULLABLE_INT32S unchanged Value\n");
            err = TestReadAttributeNullableInt32sUnchangedValue_285();
            break;
        case 286:
            ChipLogProgress(chipTool, " ***** Test Step 286 : Write attribute NULLABLE_INT32S null Value\n");
            err = TestWriteAttributeNullableInt32sNullValue_286();
            break;
        case 287:
            ChipLogProgress(chipTool, " ***** Test Step 287 : Read attribute NULLABLE_INT32S null Value\n");
            err = TestReadAttributeNullableInt32sNullValue_287();
            break;
        case 288:
            ChipLogProgress(chipTool, " ***** Test Step 288 : Read attribute NULLABLE_INT32S null Value & range\n");
            err = TestReadAttributeNullableInt32sNullValueRange_288();
            break;
        case 289:
            ChipLogProgress(chipTool, " ***** Test Step 289 : Read attribute NULLABLE_INT32S null Value & not\n");
            err = TestReadAttributeNullableInt32sNullValueNot_289();
            break;
        case 290:
            ChipLogProgress(chipTool, " ***** Test Step 290 : Write attribute NULLABLE_INT32S Value\n");
            err = TestWriteAttributeNullableInt32sValue_290();
            break;
        case 291:
            ChipLogProgress(chipTool, " ***** Test Step 291 : Read attribute NULLABLE_INT32S Value in range\n");
            err = TestReadAttributeNullableInt32sValueInRange_291();
            break;
        case 292:
            ChipLogProgress(chipTool, " ***** Test Step 292 : Read attribute NULLABLE_INT32S notValue OK\n");
            err = TestReadAttributeNullableInt32sNotValueOk_292();
            break;
        case 293:
            ChipLogProgress(chipTool, " ***** Test Step 293 : Write attribute NULLABLE_INT64S Min Value\n");
            err = TestWriteAttributeNullableInt64sMinValue_293();
            break;
        case 294:
            ChipLogProgress(chipTool, " ***** Test Step 294 : Read attribute NULLABLE_INT64S Min Value\n");
            err = TestReadAttributeNullableInt64sMinValue_294();
            break;
        case 295:
            ChipLogProgress(chipTool, " ***** Test Step 295 : Write attribute NULLABLE_INT64S Invalid Value\n");
            err = TestWriteAttributeNullableInt64sInvalidValue_295();
            break;
        case 296:
            ChipLogProgress(chipTool, " ***** Test Step 296 : Read attribute NULLABLE_INT64S unchanged Value\n");
            err = TestReadAttributeNullableInt64sUnchangedValue_296();
            break;
        case 297:
            ChipLogProgress(chipTool, " ***** Test Step 297 : Write attribute NULLABLE_INT64S null Value\n");
            err = TestWriteAttributeNullableInt64sNullValue_297();
            break;
        case 298:
            ChipLogProgress(chipTool, " ***** Test Step 298 : Read attribute NULLABLE_INT64S null Value\n");
            err = TestReadAttributeNullableInt64sNullValue_298();
            break;
        case 299:
            ChipLogProgress(chipTool, " ***** Test Step 299 : Read attribute NULLABLE_INT64S null Value & range\n");
            err = TestReadAttributeNullableInt64sNullValueRange_299();
            break;
        case 300:
            ChipLogProgress(chipTool, " ***** Test Step 300 : Read attribute NULLABLE_INT64S null Value & not\n");
            err = TestReadAttributeNullableInt64sNullValueNot_300();
            break;
        case 301:
            ChipLogProgress(chipTool, " ***** Test Step 301 : Write attribute NULLABLE_INT64S Value\n");
            err = TestWriteAttributeNullableInt64sValue_301();
            break;
        case 302:
            ChipLogProgress(chipTool, " ***** Test Step 302 : Read attribute NULLABLE_INT64S Value in range\n");
            err = TestReadAttributeNullableInt64sValueInRange_302();
            break;
        case 303:
            ChipLogProgress(chipTool, " ***** Test Step 303 : Read attribute NULLABLE_INT64S notValue OK\n");
            err = TestReadAttributeNullableInt64sNotValueOk_303();
            break;
        case 304:
            ChipLogProgress(chipTool, " ***** Test Step 304 : Write attribute NULLABLE_SINGLE medium Value\n");
            err = TestWriteAttributeNullableSingleMediumValue_304();
            break;
        case 305:
            ChipLogProgress(chipTool, " ***** Test Step 305 : Read attribute NULLABLE_SINGLE medium Value\n");
            err = TestReadAttributeNullableSingleMediumValue_305();
            break;
        case 306:
            ChipLogProgress(chipTool, " ***** Test Step 306 : Write attribute NULLABLE_SINGLE largest Value\n");
            err = TestWriteAttributeNullableSingleLargestValue_306();
            break;
        case 307:
            ChipLogProgress(chipTool, " ***** Test Step 307 : Read attribute NULLABLE_SINGLE largest Value\n");
            err = TestReadAttributeNullableSingleLargestValue_307();
            break;
        case 308:
            ChipLogProgress(chipTool, " ***** Test Step 308 : Write attribute NULLABLE_SINGLE smallest Value\n");
            err = TestWriteAttributeNullableSingleSmallestValue_308();
            break;
        case 309:
            ChipLogProgress(chipTool, " ***** Test Step 309 : Read attribute NULLABLE_SINGLE smallest Value\n");
            err = TestReadAttributeNullableSingleSmallestValue_309();
            break;
        case 310:
            ChipLogProgress(chipTool, " ***** Test Step 310 : Write attribute NULLABLE_SINGLE null Value\n");
            err = TestWriteAttributeNullableSingleNullValue_310();
            break;
        case 311:
            ChipLogProgress(chipTool, " ***** Test Step 311 : Read attribute NULLABLE_SINGLE null Value\n");
            err = TestReadAttributeNullableSingleNullValue_311();
            break;
        case 312:
            ChipLogProgress(chipTool, " ***** Test Step 312 : Write attribute NULLABLE_SINGLE 0 Value\n");
            err = TestWriteAttributeNullableSingle0Value_312();
            break;
        case 313:
            ChipLogProgress(chipTool, " ***** Test Step 313 : Read attribute NULLABLE_SINGLE 0 Value\n");
            err = TestReadAttributeNullableSingle0Value_313();
            break;
        case 314:
            ChipLogProgress(chipTool, " ***** Test Step 314 : Write attribute NULLABLE_DOUBLE medium Value\n");
            err = TestWriteAttributeNullableDoubleMediumValue_314();
            break;
        case 315:
            ChipLogProgress(chipTool, " ***** Test Step 315 : Read attribute NULLABLE_DOUBLE medium Value\n");
            err = TestReadAttributeNullableDoubleMediumValue_315();
            break;
        case 316:
            ChipLogProgress(chipTool, " ***** Test Step 316 : Write attribute NULLABLE_DOUBLE largest Value\n");
            err = TestWriteAttributeNullableDoubleLargestValue_316();
            break;
        case 317:
            ChipLogProgress(chipTool, " ***** Test Step 317 : Read attribute NULLABLE_DOUBLE largest Value\n");
            err = TestReadAttributeNullableDoubleLargestValue_317();
            break;
        case 318:
            ChipLogProgress(chipTool, " ***** Test Step 318 : Write attribute NULLABLE_DOUBLE smallest Value\n");
            err = TestWriteAttributeNullableDoubleSmallestValue_318();
            break;
        case 319:
            ChipLogProgress(chipTool, " ***** Test Step 319 : Read attribute NULLABLE_DOUBLE smallest Value\n");
            err = TestReadAttributeNullableDoubleSmallestValue_319();
            break;
        case 320:
            ChipLogProgress(chipTool, " ***** Test Step 320 : Write attribute NULLABLE_DOUBLE null Value\n");
            err = TestWriteAttributeNullableDoubleNullValue_320();
            break;
        case 321:
            ChipLogProgress(chipTool, " ***** Test Step 321 : Read attribute NULLABLE_DOUBLE null Value\n");
            err = TestReadAttributeNullableDoubleNullValue_321();
            break;
        case 322:
            ChipLogProgress(chipTool, " ***** Test Step 322 : Write attribute NULLABLE_DOUBLE 0 Value\n");
            err = TestWriteAttributeNullableDouble0Value_322();
            break;
        case 323:
            ChipLogProgress(chipTool, " ***** Test Step 323 : Read attribute NULLABLE_DOUBLE 0 Value\n");
            err = TestReadAttributeNullableDouble0Value_323();
            break;
        case 324:
            ChipLogProgress(chipTool, " ***** Test Step 324 : Write attribute NULLABLE_ENUM8 Min Value\n");
            err = TestWriteAttributeNullableEnum8MinValue_324();
            break;
        case 325:
            ChipLogProgress(chipTool, " ***** Test Step 325 : Read attribute NULLABLE_ENUM8 Min Value\n");
            err = TestReadAttributeNullableEnum8MinValue_325();
            break;
        case 326:
            ChipLogProgress(chipTool, " ***** Test Step 326 : Write attribute NULLABLE_ENUM8 Max Value\n");
            err = TestWriteAttributeNullableEnum8MaxValue_326();
            break;
        case 327:
            ChipLogProgress(chipTool, " ***** Test Step 327 : Read attribute NULLABLE_ENUM8 Max Value\n");
            err = TestReadAttributeNullableEnum8MaxValue_327();
            break;
        case 328:
            ChipLogProgress(chipTool, " ***** Test Step 328 : Write attribute NULLABLE_ENUM8 Invalid Value\n");
            err = TestWriteAttributeNullableEnum8InvalidValue_328();
            break;
        case 329:
            ChipLogProgress(chipTool, " ***** Test Step 329 : Read attribute NULLABLE_ENUM8 unchanged Value\n");
            err = TestReadAttributeNullableEnum8UnchangedValue_329();
            break;
        case 330:
            ChipLogProgress(chipTool, " ***** Test Step 330 : Write attribute NULLABLE_ENUM8 null Value\n");
            err = TestWriteAttributeNullableEnum8NullValue_330();
            break;
        case 331:
            ChipLogProgress(chipTool, " ***** Test Step 331 : Read attribute NULLABLE_ENUM8 null Value\n");
            err = TestReadAttributeNullableEnum8NullValue_331();
            break;
        case 332:
            ChipLogProgress(chipTool, " ***** Test Step 332 : Write attribute NULLABLE_ENUM16 Min Value\n");
            err = TestWriteAttributeNullableEnum16MinValue_332();
            break;
        case 333:
            ChipLogProgress(chipTool, " ***** Test Step 333 : Read attribute NULLABLE_ENUM16 Min Value\n");
            err = TestReadAttributeNullableEnum16MinValue_333();
            break;
        case 334:
            ChipLogProgress(chipTool, " ***** Test Step 334 : Write attribute NULLABLE_ENUM16 Max Value\n");
            err = TestWriteAttributeNullableEnum16MaxValue_334();
            break;
        case 335:
            ChipLogProgress(chipTool, " ***** Test Step 335 : Read attribute NULLABLE_ENUM16 Max Value\n");
            err = TestReadAttributeNullableEnum16MaxValue_335();
            break;
        case 336:
            ChipLogProgress(chipTool, " ***** Test Step 336 : Write attribute NULLABLE_ENUM16 Invalid Value\n");
            err = TestWriteAttributeNullableEnum16InvalidValue_336();
            break;
        case 337:
            ChipLogProgress(chipTool, " ***** Test Step 337 : Read attribute NULLABLE_ENUM16 unchanged Value\n");
            err = TestReadAttributeNullableEnum16UnchangedValue_337();
            break;
        case 338:
            ChipLogProgress(chipTool, " ***** Test Step 338 : Write attribute NULLABLE_ENUM16 null Value\n");
            err = TestWriteAttributeNullableEnum16NullValue_338();
            break;
        case 339:
            ChipLogProgress(chipTool, " ***** Test Step 339 : Read attribute NULLABLE_ENUM16 null Value\n");
            err = TestReadAttributeNullableEnum16NullValue_339();
            break;
        case 340:
            ChipLogProgress(chipTool, " ***** Test Step 340 : Write attribute NULLABLE_SIMPLE_ENUM Min Value\n");
            err = TestWriteAttributeNullableSimpleEnumMinValue_340();
            break;
        case 341:
            ChipLogProgress(chipTool, " ***** Test Step 341 : Read attribute NULLABLE_SIMPLE_ENUM Min Value\n");
            err = TestReadAttributeNullableSimpleEnumMinValue_341();
            break;
        case 342:
            ChipLogProgress(chipTool, " ***** Test Step 342 : Write attribute NULLABLE_SIMPLE_ENUM Max Value\n");
            err = TestWriteAttributeNullableSimpleEnumMaxValue_342();
            break;
        case 343:
            ChipLogProgress(chipTool, " ***** Test Step 343 : Read attribute NULLABLE_SIMPLE_ENUM Max Value\n");
            err = TestReadAttributeNullableSimpleEnumMaxValue_343();
            break;
        case 344:
            ChipLogProgress(chipTool, " ***** Test Step 344 : Write attribute NULLABLE_SIMPLE_ENUM Invalid Value\n");
            err = TestWriteAttributeNullableSimpleEnumInvalidValue_344();
            break;
        case 345:
            ChipLogProgress(chipTool, " ***** Test Step 345 : Read attribute NULLABLE_SIMPLE_ENUM unchanged Value\n");
            err = TestReadAttributeNullableSimpleEnumUnchangedValue_345();
            break;
        case 346:
            ChipLogProgress(chipTool, " ***** Test Step 346 : Write attribute NULLABLE_SIMPLE_ENUM null Value\n");
            err = TestWriteAttributeNullableSimpleEnumNullValue_346();
            break;
        case 347:
            ChipLogProgress(chipTool, " ***** Test Step 347 : Read attribute NULLABLE_SIMPLE_ENUM null Value\n");
            err = TestReadAttributeNullableSimpleEnumNullValue_347();
            break;
        case 348:
            ChipLogProgress(chipTool, " ***** Test Step 348 : Read attribute NULLABLE_OCTET_STRING Default Value\n");
            err = TestReadAttributeNullableOctetStringDefaultValue_348();
            break;
        case 349:
            ChipLogProgress(chipTool, " ***** Test Step 349 : Write attribute NULLABLE_OCTET_STRING\n");
            err = TestWriteAttributeNullableOctetString_349();
            break;
        case 350:
            ChipLogProgress(chipTool, " ***** Test Step 350 : Read attribute NULLABLE_OCTET_STRING\n");
            err = TestReadAttributeNullableOctetString_350();
            break;
        case 351:
            ChipLogProgress(chipTool, " ***** Test Step 351 : Write attribute NULLABLE_OCTET_STRING\n");
            err = TestWriteAttributeNullableOctetString_351();
            break;
        case 352:
            ChipLogProgress(chipTool, " ***** Test Step 352 : Read attribute NULLABLE_OCTET_STRING\n");
            err = TestReadAttributeNullableOctetString_352();
            break;
        case 353:
            ChipLogProgress(chipTool, " ***** Test Step 353 : Write attribute NULLABLE_OCTET_STRING\n");
            err = TestWriteAttributeNullableOctetString_353();
            break;
        case 354:
            ChipLogProgress(chipTool, " ***** Test Step 354 : Read attribute NULLABLE_OCTET_STRING\n");
            err = TestReadAttributeNullableOctetString_354();
            break;
        case 355:
            ChipLogProgress(chipTool, " ***** Test Step 355 : Read attribute NULLABLE_CHAR_STRING Default Value\n");
            err = TestReadAttributeNullableCharStringDefaultValue_355();
            break;
        case 356:
            ChipLogProgress(chipTool, " ***** Test Step 356 : Write attribute NULLABLE_CHAR_STRING\n");
            err = TestWriteAttributeNullableCharString_356();
            break;
        case 357:
            ChipLogProgress(chipTool, " ***** Test Step 357 : Read attribute NULLABLE_CHAR_STRING\n");
            err = TestReadAttributeNullableCharString_357();
            break;
        case 358:
            ChipLogProgress(chipTool, " ***** Test Step 358 : Write attribute NULLABLE_CHAR_STRING - Value too long\n");
            err = TestWriteAttributeNullableCharStringValueTooLong_358();
            break;
        case 359:
            ChipLogProgress(chipTool, " ***** Test Step 359 : Read attribute NULLABLE_CHAR_STRING\n");
            err = TestReadAttributeNullableCharString_359();
            break;
        case 360:
            ChipLogProgress(chipTool, " ***** Test Step 360 : Write attribute NULLABLE_CHAR_STRING - Empty\n");
            err = TestWriteAttributeNullableCharStringEmpty_360();
            break;
        case 361:
            ChipLogProgress(chipTool, " ***** Test Step 361 : Read attribute NULLABLE_CHAR_STRING\n");
            err = TestReadAttributeNullableCharString_361();
            break;
        case 362:
            ChipLogProgress(chipTool, " ***** Test Step 362 : Read attribute from nonexistent endpoint.\n");
            err = TestReadAttributeFromNonexistentEndpoint_362();
            break;
        case 363:
            ChipLogProgress(chipTool, " ***** Test Step 363 : Read attribute from nonexistent cluster.\n");
            err = TestReadAttributeFromNonexistentCluster_363();
            break;
        case 364:
            ChipLogProgress(chipTool,
                            " ***** Test Step 364 : Send a command that takes an optional parameter but do not set it.\n");
            err = TestSendACommandThatTakesAnOptionalParameterButDoNotSetIt_364();
            break;
        case 365:
            ChipLogProgress(chipTool,
                            " ***** Test Step 365 : Send a command that takes an optional parameter but do not set it.\n");
            err = TestSendACommandThatTakesAnOptionalParameterButDoNotSetIt_365();
            break;
        case 366:
            ChipLogProgress(chipTool, " ***** Test Step 366 : Report: Subscribe to list attribute\n");
            err = TestReportSubscribeToListAttribute_366();
            break;
        case 367:
            ChipLogProgress(chipTool, " ***** Test Step 367 : Subscribe to list attribute\n");
            err = TestSubscribeToListAttribute_367();
            break;
        case 368:
            ChipLogProgress(chipTool, " ***** Test Step 368 : Write subscribed-to list attribute\n");
            err = TestWriteSubscribedToListAttribute_368();
            break;
        case 369:
            ChipLogProgress(chipTool, " ***** Test Step 369 : Check for list attribute report\n");
            err = TestCheckForListAttributeReport_369();
            break;
        case 370:
            ChipLogProgress(chipTool, " ***** Test Step 370 : Read range-restricted unsigned 8-bit integer\n");
            err = TestReadRangeRestrictedUnsigned8BitInteger_370();
            break;
        case 371:
            ChipLogProgress(chipTool, " ***** Test Step 371 : Write min value to a range-restricted unsigned 8-bit integer\n");
            err = TestWriteMinValueToARangeRestrictedUnsigned8BitInteger_371();
            break;
        case 372:
            ChipLogProgress(chipTool,
                            " ***** Test Step 372 : Write just-below-range value to a range-restricted unsigned 8-bit integer\n");
            err = TestWriteJustBelowRangeValueToARangeRestrictedUnsigned8BitInteger_372();
            break;
        case 373:
            ChipLogProgress(chipTool,
                            " ***** Test Step 373 : Write just-above-range value to a range-restricted unsigned 8-bit integer\n");
            err = TestWriteJustAboveRangeValueToARangeRestrictedUnsigned8BitInteger_373();
            break;
        case 374:
            ChipLogProgress(chipTool, " ***** Test Step 374 : Write max value to a range-restricted unsigned 8-bit integer\n");
            err = TestWriteMaxValueToARangeRestrictedUnsigned8BitInteger_374();
            break;
        case 375:
            ChipLogProgress(chipTool,
                            " ***** Test Step 375 : Verify range-restricted unsigned 8-bit integer value has not changed\n");
            err = TestVerifyRangeRestrictedUnsigned8BitIntegerValueHasNotChanged_375();
            break;
        case 376:
            ChipLogProgress(chipTool,
                            " ***** Test Step 376 : Write min valid value to a range-restricted unsigned 8-bit integer\n");
            err = TestWriteMinValidValueToARangeRestrictedUnsigned8BitInteger_376();
            break;
        case 377:
            ChipLogProgress(chipTool,
                            " ***** Test Step 377 : Verify range-restricted unsigned 8-bit integer value is at min valid\n");
            err = TestVerifyRangeRestrictedUnsigned8BitIntegerValueIsAtMinValid_377();
            break;
        case 378:
            ChipLogProgress(chipTool,
                            " ***** Test Step 378 : Write max valid value to a range-restricted unsigned 8-bit integer\n");
            err = TestWriteMaxValidValueToARangeRestrictedUnsigned8BitInteger_378();
            break;
        case 379:
            ChipLogProgress(chipTool,
                            " ***** Test Step 379 : Verify range-restricted unsigned 8-bit integer value is at max valid\n");
            err = TestVerifyRangeRestrictedUnsigned8BitIntegerValueIsAtMaxValid_379();
            break;
        case 380:
            ChipLogProgress(chipTool,
                            " ***** Test Step 380 : Write middle valid value to a range-restricted unsigned 8-bit integer\n");
            err = TestWriteMiddleValidValueToARangeRestrictedUnsigned8BitInteger_380();
            break;
        case 381:
            ChipLogProgress(chipTool,
                            " ***** Test Step 381 : Verify range-restricted unsigned 8-bit integer value is at mid valid\n");
            err = TestVerifyRangeRestrictedUnsigned8BitIntegerValueIsAtMidValid_381();
            break;
        case 382:
            ChipLogProgress(chipTool, " ***** Test Step 382 : Read range-restricted unsigned 16-bit integer\n");
            err = TestReadRangeRestrictedUnsigned16BitInteger_382();
            break;
        case 383:
            ChipLogProgress(chipTool, " ***** Test Step 383 : Write min value to a range-restricted unsigned 16-bit integer\n");
            err = TestWriteMinValueToARangeRestrictedUnsigned16BitInteger_383();
            break;
        case 384:
            ChipLogProgress(chipTool,
                            " ***** Test Step 384 : Write just-below-range value to a range-restricted unsigned 16-bit integer\n");
            err = TestWriteJustBelowRangeValueToARangeRestrictedUnsigned16BitInteger_384();
            break;
        case 385:
            ChipLogProgress(chipTool,
                            " ***** Test Step 385 : Write just-above-range value to a range-restricted unsigned 16-bit integer\n");
            err = TestWriteJustAboveRangeValueToARangeRestrictedUnsigned16BitInteger_385();
            break;
        case 386:
            ChipLogProgress(chipTool, " ***** Test Step 386 : Write max value to a range-restricted unsigned 16-bit integer\n");
            err = TestWriteMaxValueToARangeRestrictedUnsigned16BitInteger_386();
            break;
        case 387:
            ChipLogProgress(chipTool,
                            " ***** Test Step 387 : Verify range-restricted unsigned 16-bit integer value has not changed\n");
            err = TestVerifyRangeRestrictedUnsigned16BitIntegerValueHasNotChanged_387();
            break;
        case 388:
            ChipLogProgress(chipTool,
                            " ***** Test Step 388 : Write min valid value to a range-restricted unsigned 16-bit integer\n");
            err = TestWriteMinValidValueToARangeRestrictedUnsigned16BitInteger_388();
            break;
        case 389:
            ChipLogProgress(chipTool,
                            " ***** Test Step 389 : Verify range-restricted unsigned 16-bit integer value is at min valid\n");
            err = TestVerifyRangeRestrictedUnsigned16BitIntegerValueIsAtMinValid_389();
            break;
        case 390:
            ChipLogProgress(chipTool,
                            " ***** Test Step 390 : Write max valid value to a range-restricted unsigned 16-bit integer\n");
            err = TestWriteMaxValidValueToARangeRestrictedUnsigned16BitInteger_390();
            break;
        case 391:
            ChipLogProgress(chipTool,
                            " ***** Test Step 391 : Verify range-restricted unsigned 16-bit integer value is at max valid\n");
            err = TestVerifyRangeRestrictedUnsigned16BitIntegerValueIsAtMaxValid_391();
            break;
        case 392:
            ChipLogProgress(chipTool,
                            " ***** Test Step 392 : Write middle valid value to a range-restricted unsigned 16-bit integer\n");
            err = TestWriteMiddleValidValueToARangeRestrictedUnsigned16BitInteger_392();
            break;
        case 393:
            ChipLogProgress(chipTool,
                            " ***** Test Step 393 : Verify range-restricted unsigned 16-bit integer value is at mid valid\n");
            err = TestVerifyRangeRestrictedUnsigned16BitIntegerValueIsAtMidValid_393();
            break;
        case 394:
            ChipLogProgress(chipTool, " ***** Test Step 394 : Read range-restricted signed 8-bit integer\n");
            err = TestReadRangeRestrictedSigned8BitInteger_394();
            break;
        case 395:
            ChipLogProgress(chipTool, " ***** Test Step 395 : Write min value to a range-restricted signed 8-bit integer\n");
            err = TestWriteMinValueToARangeRestrictedSigned8BitInteger_395();
            break;
        case 396:
            ChipLogProgress(chipTool,
                            " ***** Test Step 396 : Write just-below-range value to a range-restricted signed 8-bit integer\n");
            err = TestWriteJustBelowRangeValueToARangeRestrictedSigned8BitInteger_396();
            break;
        case 397:
            ChipLogProgress(chipTool,
                            " ***** Test Step 397 : Write just-above-range value to a range-restricted signed 8-bit integer\n");
            err = TestWriteJustAboveRangeValueToARangeRestrictedSigned8BitInteger_397();
            break;
        case 398:
            ChipLogProgress(chipTool, " ***** Test Step 398 : Write max value to a range-restricted signed 8-bit integer\n");
            err = TestWriteMaxValueToARangeRestrictedSigned8BitInteger_398();
            break;
        case 399:
            ChipLogProgress(chipTool,
                            " ***** Test Step 399 : Verify range-restricted signed 8-bit integer value has not changed\n");
            err = TestVerifyRangeRestrictedSigned8BitIntegerValueHasNotChanged_399();
            break;
        case 400:
            ChipLogProgress(chipTool, " ***** Test Step 400 : Write min valid value to a range-restricted signed 8-bit integer\n");
            err = TestWriteMinValidValueToARangeRestrictedSigned8BitInteger_400();
            break;
        case 401:
            ChipLogProgress(chipTool,
                            " ***** Test Step 401 : Verify range-restricted signed 8-bit integer value is at min valid\n");
            err = TestVerifyRangeRestrictedSigned8BitIntegerValueIsAtMinValid_401();
            break;
        case 402:
            ChipLogProgress(chipTool, " ***** Test Step 402 : Write max valid value to a range-restricted signed 8-bit integer\n");
            err = TestWriteMaxValidValueToARangeRestrictedSigned8BitInteger_402();
            break;
        case 403:
            ChipLogProgress(chipTool,
                            " ***** Test Step 403 : Verify range-restricted signed 8-bit integer value is at max valid\n");
            err = TestVerifyRangeRestrictedSigned8BitIntegerValueIsAtMaxValid_403();
            break;
        case 404:
            ChipLogProgress(chipTool,
                            " ***** Test Step 404 : Write middle valid value to a range-restricted signed 8-bit integer\n");
            err = TestWriteMiddleValidValueToARangeRestrictedSigned8BitInteger_404();
            break;
        case 405:
            ChipLogProgress(chipTool,
                            " ***** Test Step 405 : Verify range-restricted signed 8-bit integer value is at mid valid\n");
            err = TestVerifyRangeRestrictedSigned8BitIntegerValueIsAtMidValid_405();
            break;
        case 406:
            ChipLogProgress(chipTool, " ***** Test Step 406 : Read range-restricted signed 16-bit integer\n");
            err = TestReadRangeRestrictedSigned16BitInteger_406();
            break;
        case 407:
            ChipLogProgress(chipTool, " ***** Test Step 407 : Write min value to a range-restricted signed 16-bit integer\n");
            err = TestWriteMinValueToARangeRestrictedSigned16BitInteger_407();
            break;
        case 408:
            ChipLogProgress(chipTool,
                            " ***** Test Step 408 : Write just-below-range value to a range-restricted signed 16-bit integer\n");
            err = TestWriteJustBelowRangeValueToARangeRestrictedSigned16BitInteger_408();
            break;
        case 409:
            ChipLogProgress(chipTool,
                            " ***** Test Step 409 : Write just-above-range value to a range-restricted signed 16-bit integer\n");
            err = TestWriteJustAboveRangeValueToARangeRestrictedSigned16BitInteger_409();
            break;
        case 410:
            ChipLogProgress(chipTool, " ***** Test Step 410 : Write max value to a range-restricted signed 16-bit integer\n");
            err = TestWriteMaxValueToARangeRestrictedSigned16BitInteger_410();
            break;
        case 411:
            ChipLogProgress(chipTool,
                            " ***** Test Step 411 : Verify range-restricted signed 16-bit integer value has not changed\n");
            err = TestVerifyRangeRestrictedSigned16BitIntegerValueHasNotChanged_411();
            break;
        case 412:
            ChipLogProgress(chipTool, " ***** Test Step 412 : Write min valid value to a range-restricted signed 16-bit integer\n");
            err = TestWriteMinValidValueToARangeRestrictedSigned16BitInteger_412();
            break;
        case 413:
            ChipLogProgress(chipTool,
                            " ***** Test Step 413 : Verify range-restricted signed 16-bit integer value is at min valid\n");
            err = TestVerifyRangeRestrictedSigned16BitIntegerValueIsAtMinValid_413();
            break;
        case 414:
            ChipLogProgress(chipTool, " ***** Test Step 414 : Write max valid value to a range-restricted signed 16-bit integer\n");
            err = TestWriteMaxValidValueToARangeRestrictedSigned16BitInteger_414();
            break;
        case 415:
            ChipLogProgress(chipTool,
                            " ***** Test Step 415 : Verify range-restricted signed 16-bit integer value is at max valid\n");
            err = TestVerifyRangeRestrictedSigned16BitIntegerValueIsAtMaxValid_415();
            break;
        case 416:
            ChipLogProgress(chipTool,
                            " ***** Test Step 416 : Write middle valid value to a range-restricted signed 16-bit integer\n");
            err = TestWriteMiddleValidValueToARangeRestrictedSigned16BitInteger_416();
            break;
        case 417:
            ChipLogProgress(chipTool,
                            " ***** Test Step 417 : Verify range-restricted signed 16-bit integer value is at mid valid\n");
            err = TestVerifyRangeRestrictedSigned16BitIntegerValueIsAtMidValid_417();
            break;
        case 418:
            ChipLogProgress(chipTool, " ***** Test Step 418 : Read nullable range-restricted unsigned 8-bit integer\n");
            err = TestReadNullableRangeRestrictedUnsigned8BitInteger_418();
            break;
        case 419:
            ChipLogProgress(chipTool,
                            " ***** Test Step 419 : Write min value to a nullable range-restricted unsigned 8-bit integer\n");
            err = TestWriteMinValueToANullableRangeRestrictedUnsigned8BitInteger_419();
            break;
        case 420:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 420 : Write just-below-range value to a nullable range-restricted unsigned 8-bit integer\n");
            err = TestWriteJustBelowRangeValueToANullableRangeRestrictedUnsigned8BitInteger_420();
            break;
        case 421:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 421 : Write just-above-range value to a nullable range-restricted unsigned 8-bit integer\n");
            err = TestWriteJustAboveRangeValueToANullableRangeRestrictedUnsigned8BitInteger_421();
            break;
        case 422:
            ChipLogProgress(chipTool,
                            " ***** Test Step 422 : Write max value to a nullable range-restricted unsigned 8-bit integer\n");
            err = TestWriteMaxValueToANullableRangeRestrictedUnsigned8BitInteger_422();
            break;
        case 423:
            ChipLogProgress(
                chipTool, " ***** Test Step 423 : Verify nullable range-restricted unsigned 8-bit integer value has not changed\n");
            err = TestVerifyNullableRangeRestrictedUnsigned8BitIntegerValueHasNotChanged_423();
            break;
        case 424:
            ChipLogProgress(chipTool,
                            " ***** Test Step 424 : Write min valid value to a nullable range-restricted unsigned 8-bit integer\n");
            err = TestWriteMinValidValueToANullableRangeRestrictedUnsigned8BitInteger_424();
            break;
        case 425:
            ChipLogProgress(
                chipTool, " ***** Test Step 425 : Verify nullable range-restricted unsigned 8-bit integer value is at min valid\n");
            err = TestVerifyNullableRangeRestrictedUnsigned8BitIntegerValueIsAtMinValid_425();
            break;
        case 426:
            ChipLogProgress(chipTool,
                            " ***** Test Step 426 : Write max valid value to a nullable range-restricted unsigned 8-bit integer\n");
            err = TestWriteMaxValidValueToANullableRangeRestrictedUnsigned8BitInteger_426();
            break;
        case 427:
            ChipLogProgress(
                chipTool, " ***** Test Step 427 : Verify nullable range-restricted unsigned 8-bit integer value is at max valid\n");
            err = TestVerifyNullableRangeRestrictedUnsigned8BitIntegerValueIsAtMaxValid_427();
            break;
        case 428:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 428 : Write middle valid value to a nullable range-restricted unsigned 8-bit integer\n");
            err = TestWriteMiddleValidValueToANullableRangeRestrictedUnsigned8BitInteger_428();
            break;
        case 429:
            ChipLogProgress(
                chipTool, " ***** Test Step 429 : Verify nullable range-restricted unsigned 8-bit integer value is at mid valid\n");
            err = TestVerifyNullableRangeRestrictedUnsigned8BitIntegerValueIsAtMidValid_429();
            break;
        case 430:
            ChipLogProgress(chipTool,
                            " ***** Test Step 430 : Write null value to a nullable range-restricted unsigned 8-bit integer\n");
            err = TestWriteNullValueToANullableRangeRestrictedUnsigned8BitInteger_430();
            break;
        case 431:
            ChipLogProgress(chipTool,
                            " ***** Test Step 431 : Verify nullable range-restricted unsigned 8-bit integer value is null\n");
            err = TestVerifyNullableRangeRestrictedUnsigned8BitIntegerValueIsNull_431();
            break;
        case 432:
            ChipLogProgress(chipTool, " ***** Test Step 432 : Read nullable range-restricted unsigned 16-bit integer\n");
            err = TestReadNullableRangeRestrictedUnsigned16BitInteger_432();
            break;
        case 433:
            ChipLogProgress(chipTool,
                            " ***** Test Step 433 : Write min value to a nullable range-restricted unsigned 16-bit integer\n");
            err = TestWriteMinValueToANullableRangeRestrictedUnsigned16BitInteger_433();
            break;
        case 434:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 434 : Write just-below-range value to a nullable range-restricted unsigned 16-bit integer\n");
            err = TestWriteJustBelowRangeValueToANullableRangeRestrictedUnsigned16BitInteger_434();
            break;
        case 435:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 435 : Write just-above-range value to a nullable range-restricted unsigned 16-bit integer\n");
            err = TestWriteJustAboveRangeValueToANullableRangeRestrictedUnsigned16BitInteger_435();
            break;
        case 436:
            ChipLogProgress(chipTool,
                            " ***** Test Step 436 : Write max value to a nullable range-restricted unsigned 16-bit integer\n");
            err = TestWriteMaxValueToANullableRangeRestrictedUnsigned16BitInteger_436();
            break;
        case 437:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 437 : Verify nullable range-restricted unsigned 16-bit integer value has not changed\n");
            err = TestVerifyNullableRangeRestrictedUnsigned16BitIntegerValueHasNotChanged_437();
            break;
        case 438:
            ChipLogProgress(
                chipTool, " ***** Test Step 438 : Write min valid value to a nullable range-restricted unsigned 16-bit integer\n");
            err = TestWriteMinValidValueToANullableRangeRestrictedUnsigned16BitInteger_438();
            break;
        case 439:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 439 : Verify nullable range-restricted unsigned 16-bit integer value is at min valid\n");
            err = TestVerifyNullableRangeRestrictedUnsigned16BitIntegerValueIsAtMinValid_439();
            break;
        case 440:
            ChipLogProgress(
                chipTool, " ***** Test Step 440 : Write max valid value to a nullable range-restricted unsigned 16-bit integer\n");
            err = TestWriteMaxValidValueToANullableRangeRestrictedUnsigned16BitInteger_440();
            break;
        case 441:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 441 : Verify nullable range-restricted unsigned 16-bit integer value is at max valid\n");
            err = TestVerifyNullableRangeRestrictedUnsigned16BitIntegerValueIsAtMaxValid_441();
            break;
        case 442:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 442 : Write middle valid value to a nullable range-restricted unsigned 16-bit integer\n");
            err = TestWriteMiddleValidValueToANullableRangeRestrictedUnsigned16BitInteger_442();
            break;
        case 443:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 443 : Verify nullable range-restricted unsigned 16-bit integer value is at mid valid\n");
            err = TestVerifyNullableRangeRestrictedUnsigned16BitIntegerValueIsAtMidValid_443();
            break;
        case 444:
            ChipLogProgress(chipTool,
                            " ***** Test Step 444 : Write null value to a nullable range-restricted unsigned 16-bit integer\n");
            err = TestWriteNullValueToANullableRangeRestrictedUnsigned16BitInteger_444();
            break;
        case 445:
            ChipLogProgress(chipTool,
                            " ***** Test Step 445 : Verify nullable range-restricted unsigned 16-bit integer value is null\n");
            err = TestVerifyNullableRangeRestrictedUnsigned16BitIntegerValueIsNull_445();
            break;
        case 446:
            ChipLogProgress(chipTool, " ***** Test Step 446 : Read nullable range-restricted signed 8-bit integer\n");
            err = TestReadNullableRangeRestrictedSigned8BitInteger_446();
            break;
        case 447:
            ChipLogProgress(chipTool,
                            " ***** Test Step 447 : Write min value to a nullable range-restricted signed 8-bit integer\n");
            err = TestWriteMinValueToANullableRangeRestrictedSigned8BitInteger_447();
            break;
        case 448:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 448 : Write just-below-range value to a nullable range-restricted signed 8-bit integer\n");
            err = TestWriteJustBelowRangeValueToANullableRangeRestrictedSigned8BitInteger_448();
            break;
        case 449:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 449 : Write just-above-range value to a nullable range-restricted signed 8-bit integer\n");
            err = TestWriteJustAboveRangeValueToANullableRangeRestrictedSigned8BitInteger_449();
            break;
        case 450:
            ChipLogProgress(chipTool,
                            " ***** Test Step 450 : Write max value to a nullable range-restricted signed 8-bit integer\n");
            err = TestWriteMaxValueToANullableRangeRestrictedSigned8BitInteger_450();
            break;
        case 451:
            ChipLogProgress(chipTool,
                            " ***** Test Step 451 : Verify nullable range-restricted signed 8-bit integer value has not changed\n");
            err = TestVerifyNullableRangeRestrictedSigned8BitIntegerValueHasNotChanged_451();
            break;
        case 452:
            ChipLogProgress(chipTool,
                            " ***** Test Step 452 : Write min valid value to a nullable range-restricted signed 8-bit integer\n");
            err = TestWriteMinValidValueToANullableRangeRestrictedSigned8BitInteger_452();
            break;
        case 453:
            ChipLogProgress(chipTool,
                            " ***** Test Step 453 : Verify nullable range-restricted signed 8-bit integer value is at min valid\n");
            err = TestVerifyNullableRangeRestrictedSigned8BitIntegerValueIsAtMinValid_453();
            break;
        case 454:
            ChipLogProgress(chipTool,
                            " ***** Test Step 454 : Write max valid value to a nullable range-restricted signed 8-bit integer\n");
            err = TestWriteMaxValidValueToANullableRangeRestrictedSigned8BitInteger_454();
            break;
        case 455:
            ChipLogProgress(chipTool,
                            " ***** Test Step 455 : Verify nullable range-restricted signed 8-bit integer value is at max valid\n");
            err = TestVerifyNullableRangeRestrictedSigned8BitIntegerValueIsAtMaxValid_455();
            break;
        case 456:
            ChipLogProgress(
                chipTool, " ***** Test Step 456 : Write middle valid value to a nullable range-restricted signed 8-bit integer\n");
            err = TestWriteMiddleValidValueToANullableRangeRestrictedSigned8BitInteger_456();
            break;
        case 457:
            ChipLogProgress(chipTool,
                            " ***** Test Step 457 : Verify nullable range-restricted signed 8-bit integer value is at mid valid\n");
            err = TestVerifyNullableRangeRestrictedSigned8BitIntegerValueIsAtMidValid_457();
            break;
        case 458:
            ChipLogProgress(chipTool,
                            " ***** Test Step 458 : Write null value to a nullable range-restricted signed 8-bit integer\n");
            err = TestWriteNullValueToANullableRangeRestrictedSigned8BitInteger_458();
            break;
        case 459:
            ChipLogProgress(chipTool,
                            " ***** Test Step 459 : Verify nullable range-restricted signed 8-bit integer value is at null\n");
            err = TestVerifyNullableRangeRestrictedSigned8BitIntegerValueIsAtNull_459();
            break;
        case 460:
            ChipLogProgress(chipTool, " ***** Test Step 460 : Read nullable range-restricted signed 16-bit integer\n");
            err = TestReadNullableRangeRestrictedSigned16BitInteger_460();
            break;
        case 461:
            ChipLogProgress(chipTool,
                            " ***** Test Step 461 : Write min value to a nullable range-restricted signed 16-bit integer\n");
            err = TestWriteMinValueToANullableRangeRestrictedSigned16BitInteger_461();
            break;
        case 462:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 462 : Write just-below-range value to a nullable range-restricted signed 16-bit integer\n");
            err = TestWriteJustBelowRangeValueToANullableRangeRestrictedSigned16BitInteger_462();
            break;
        case 463:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 463 : Write just-above-range value to a nullable range-restricted signed 16-bit integer\n");
            err = TestWriteJustAboveRangeValueToANullableRangeRestrictedSigned16BitInteger_463();
            break;
        case 464:
            ChipLogProgress(chipTool,
                            " ***** Test Step 464 : Write max value to a nullable range-restricted signed 16-bit integer\n");
            err = TestWriteMaxValueToANullableRangeRestrictedSigned16BitInteger_464();
            break;
        case 465:
            ChipLogProgress(
                chipTool, " ***** Test Step 465 : Verify nullable range-restricted signed 16-bit integer value has not changed\n");
            err = TestVerifyNullableRangeRestrictedSigned16BitIntegerValueHasNotChanged_465();
            break;
        case 466:
            ChipLogProgress(chipTool,
                            " ***** Test Step 466 : Write min valid value to a nullable range-restricted signed 16-bit integer\n");
            err = TestWriteMinValidValueToANullableRangeRestrictedSigned16BitInteger_466();
            break;
        case 467:
            ChipLogProgress(
                chipTool, " ***** Test Step 467 : Verify nullable range-restricted signed 16-bit integer value is at min valid\n");
            err = TestVerifyNullableRangeRestrictedSigned16BitIntegerValueIsAtMinValid_467();
            break;
        case 468:
            ChipLogProgress(chipTool,
                            " ***** Test Step 468 : Write max valid value to a nullable range-restricted signed 16-bit integer\n");
            err = TestWriteMaxValidValueToANullableRangeRestrictedSigned16BitInteger_468();
            break;
        case 469:
            ChipLogProgress(
                chipTool, " ***** Test Step 469 : Verify nullable range-restricted signed 16-bit integer value is at max valid\n");
            err = TestVerifyNullableRangeRestrictedSigned16BitIntegerValueIsAtMaxValid_469();
            break;
        case 470:
            ChipLogProgress(
                chipTool, " ***** Test Step 470 : Write middle valid value to a nullable range-restricted signed 16-bit integer\n");
            err = TestWriteMiddleValidValueToANullableRangeRestrictedSigned16BitInteger_470();
            break;
        case 471:
            ChipLogProgress(
                chipTool, " ***** Test Step 471 : Verify nullable range-restricted signed 16-bit integer value is at mid valid\n");
            err = TestVerifyNullableRangeRestrictedSigned16BitIntegerValueIsAtMidValid_471();
            break;
        case 472:
            ChipLogProgress(chipTool,
                            " ***** Test Step 472 : Write null value to a nullable range-restricted signed 16-bit integer\n");
            err = TestWriteNullValueToANullableRangeRestrictedSigned16BitInteger_472();
            break;
        case 473:
            ChipLogProgress(chipTool,
                            " ***** Test Step 473 : Verify nullable range-restricted signed 16-bit integer value is null\n");
            err = TestVerifyNullableRangeRestrictedSigned16BitIntegerValueIsNull_473();
            break;
        case 474:
            ChipLogProgress(chipTool, " ***** Test Step 474 : Write attribute that returns general status on write\n");
            err = TestWriteAttributeThatReturnsGeneralStatusOnWrite_474();
            break;
        case 475:
            ChipLogProgress(chipTool, " ***** Test Step 475 : Write attribute that returns cluster-specific status on write\n");
            err = TestWriteAttributeThatReturnsClusterSpecificStatusOnWrite_475();
            break;
        case 476:
            ChipLogProgress(chipTool, " ***** Test Step 476 : Read attribute that returns general status on read\n");
            err = TestReadAttributeThatReturnsGeneralStatusOnRead_476();
            break;
        case 477:
            ChipLogProgress(chipTool, " ***** Test Step 477 : read attribute that returns cluster-specific status on read\n");
            err = TestReadAttributeThatReturnsClusterSpecificStatusOnRead_477();
            break;
        case 478:
            ChipLogProgress(chipTool, " ***** Test Step 478 : read ClientGeneratedCommandList attribute\n");
            err = TestReadClientGeneratedCommandListAttribute_478();
            break;
        case 479:
            ChipLogProgress(chipTool, " ***** Test Step 479 : read ServerGeneratedCommandList attribute\n");
            err = TestReadServerGeneratedCommandListAttribute_479();
            break;
        case 480:
            ChipLogProgress(chipTool, " ***** Test Step 480 : Write struct-typed attribute\n");
            err = TestWriteStructTypedAttribute_480();
            break;
        case 481:
            ChipLogProgress(chipTool, " ***** Test Step 481 : Read struct-typed attribute\n");
            err = TestReadStructTypedAttribute_481();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 482;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    typedef void (*Test_TestCluster_list_int8u_ReportCallback)(void * context,
                                                               const chip::app::DataModel::DecodableList<uint8_t> & value);
    Test_TestCluster_list_int8u_ReportCallback mTest_TestCluster_list_int8u_Reported = nullptr;

    static void OnFailureCallback_6(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_6(error);
    }

    static void OnSuccessCallback_6(void * context, bool boolean)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_6(boolean);
    }

    static void OnFailureCallback_7(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_7(error);
    }

    static void OnSuccessCallback_7(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_7(); }

    static void OnFailureCallback_8(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_8(error);
    }

    static void OnSuccessCallback_8(void * context, bool boolean)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_8(boolean);
    }

    static void OnFailureCallback_9(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_9(error);
    }

    static void OnSuccessCallback_9(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_9(); }

    static void OnFailureCallback_10(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_10(error);
    }

    static void OnSuccessCallback_10(void * context, bool boolean)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_10(boolean);
    }

    static void OnFailureCallback_11(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_11(error);
    }

    static void OnSuccessCallback_11(void * context, uint8_t bitmap8)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_11(bitmap8);
    }

    static void OnFailureCallback_12(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_12(error);
    }

    static void OnSuccessCallback_12(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_12(); }

    static void OnFailureCallback_13(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_13(error);
    }

    static void OnSuccessCallback_13(void * context, uint8_t bitmap8)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_13(bitmap8);
    }

    static void OnFailureCallback_14(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_14(error);
    }

    static void OnSuccessCallback_14(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_14(); }

    static void OnFailureCallback_15(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_15(error);
    }

    static void OnSuccessCallback_15(void * context, uint8_t bitmap8)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_15(bitmap8);
    }

    static void OnFailureCallback_16(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_16(error);
    }

    static void OnSuccessCallback_16(void * context, uint16_t bitmap16)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_16(bitmap16);
    }

    static void OnFailureCallback_17(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_17(error);
    }

    static void OnSuccessCallback_17(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_17(); }

    static void OnFailureCallback_18(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_18(error);
    }

    static void OnSuccessCallback_18(void * context, uint16_t bitmap16)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_18(bitmap16);
    }

    static void OnFailureCallback_19(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_19(error);
    }

    static void OnSuccessCallback_19(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_19(); }

    static void OnFailureCallback_20(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_20(error);
    }

    static void OnSuccessCallback_20(void * context, uint16_t bitmap16)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_20(bitmap16);
    }

    static void OnFailureCallback_21(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_21(error);
    }

    static void OnSuccessCallback_21(void * context, uint32_t bitmap32)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_21(bitmap32);
    }

    static void OnFailureCallback_22(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_22(error);
    }

    static void OnSuccessCallback_22(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_22(); }

    static void OnFailureCallback_23(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_23(error);
    }

    static void OnSuccessCallback_23(void * context, uint32_t bitmap32)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_23(bitmap32);
    }

    static void OnFailureCallback_24(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_24(error);
    }

    static void OnSuccessCallback_24(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_24(); }

    static void OnFailureCallback_25(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_25(error);
    }

    static void OnSuccessCallback_25(void * context, uint32_t bitmap32)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_25(bitmap32);
    }

    static void OnFailureCallback_26(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_26(error);
    }

    static void OnSuccessCallback_26(void * context, uint64_t bitmap64)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_26(bitmap64);
    }

    static void OnFailureCallback_27(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_27(error);
    }

    static void OnSuccessCallback_27(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_27(); }

    static void OnFailureCallback_28(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_28(error);
    }

    static void OnSuccessCallback_28(void * context, uint64_t bitmap64)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_28(bitmap64);
    }

    static void OnFailureCallback_29(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_29(error);
    }

    static void OnSuccessCallback_29(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_29(); }

    static void OnFailureCallback_30(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_30(error);
    }

    static void OnSuccessCallback_30(void * context, uint64_t bitmap64)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_30(bitmap64);
    }

    static void OnFailureCallback_31(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_31(error);
    }

    static void OnSuccessCallback_31(void * context, uint8_t int8u)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_31(int8u);
    }

    static void OnFailureCallback_32(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_32(error);
    }

    static void OnSuccessCallback_32(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_32(); }

    static void OnFailureCallback_33(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_33(error);
    }

    static void OnSuccessCallback_33(void * context, uint8_t int8u)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_33(int8u);
    }

    static void OnFailureCallback_34(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_34(error);
    }

    static void OnSuccessCallback_34(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_34(); }

    static void OnFailureCallback_35(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_35(error);
    }

    static void OnSuccessCallback_35(void * context, uint8_t int8u)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_35(int8u);
    }

    static void OnFailureCallback_36(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_36(error);
    }

    static void OnSuccessCallback_36(void * context, uint16_t int16u)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_36(int16u);
    }

    static void OnFailureCallback_37(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_37(error);
    }

    static void OnSuccessCallback_37(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_37(); }

    static void OnFailureCallback_38(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_38(error);
    }

    static void OnSuccessCallback_38(void * context, uint16_t int16u)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_38(int16u);
    }

    static void OnFailureCallback_39(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_39(error);
    }

    static void OnSuccessCallback_39(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_39(); }

    static void OnFailureCallback_40(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_40(error);
    }

    static void OnSuccessCallback_40(void * context, uint16_t int16u)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_40(int16u);
    }

    static void OnFailureCallback_41(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_41(error);
    }

    static void OnSuccessCallback_41(void * context, uint32_t int32u)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_41(int32u);
    }

    static void OnFailureCallback_42(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_42(error);
    }

    static void OnSuccessCallback_42(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_42(); }

    static void OnFailureCallback_43(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_43(error);
    }

    static void OnSuccessCallback_43(void * context, uint32_t int32u)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_43(int32u);
    }

    static void OnFailureCallback_44(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_44(error);
    }

    static void OnSuccessCallback_44(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_44(); }

    static void OnFailureCallback_45(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_45(error);
    }

    static void OnSuccessCallback_45(void * context, uint32_t int32u)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_45(int32u);
    }

    static void OnFailureCallback_46(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_46(error);
    }

    static void OnSuccessCallback_46(void * context, uint64_t int64u)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_46(int64u);
    }

    static void OnFailureCallback_47(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_47(error);
    }

    static void OnSuccessCallback_47(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_47(); }

    static void OnFailureCallback_48(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_48(error);
    }

    static void OnSuccessCallback_48(void * context, uint64_t int64u)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_48(int64u);
    }

    static void OnFailureCallback_49(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_49(error);
    }

    static void OnSuccessCallback_49(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_49(); }

    static void OnFailureCallback_50(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_50(error);
    }

    static void OnSuccessCallback_50(void * context, uint64_t int64u)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_50(int64u);
    }

    static void OnFailureCallback_51(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_51(error);
    }

    static void OnSuccessCallback_51(void * context, int8_t int8s)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_51(int8s);
    }

    static void OnFailureCallback_52(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_52(error);
    }

    static void OnSuccessCallback_52(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_52(); }

    static void OnFailureCallback_53(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_53(error);
    }

    static void OnSuccessCallback_53(void * context, int8_t int8s)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_53(int8s);
    }

    static void OnFailureCallback_54(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_54(error);
    }

    static void OnSuccessCallback_54(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_54(); }

    static void OnFailureCallback_55(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_55(error);
    }

    static void OnSuccessCallback_55(void * context, int8_t int8s)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_55(int8s);
    }

    static void OnFailureCallback_56(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_56(error);
    }

    static void OnSuccessCallback_56(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_56(); }

    static void OnFailureCallback_57(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_57(error);
    }

    static void OnSuccessCallback_57(void * context, int8_t int8s)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_57(int8s);
    }

    static void OnFailureCallback_58(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_58(error);
    }

    static void OnSuccessCallback_58(void * context, int16_t int16s)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_58(int16s);
    }

    static void OnFailureCallback_59(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_59(error);
    }

    static void OnSuccessCallback_59(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_59(); }

    static void OnFailureCallback_60(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_60(error);
    }

    static void OnSuccessCallback_60(void * context, int16_t int16s)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_60(int16s);
    }

    static void OnFailureCallback_61(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_61(error);
    }

    static void OnSuccessCallback_61(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_61(); }

    static void OnFailureCallback_62(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_62(error);
    }

    static void OnSuccessCallback_62(void * context, int16_t int16s)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_62(int16s);
    }

    static void OnFailureCallback_63(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_63(error);
    }

    static void OnSuccessCallback_63(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_63(); }

    static void OnFailureCallback_64(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_64(error);
    }

    static void OnSuccessCallback_64(void * context, int16_t int16s)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_64(int16s);
    }

    static void OnFailureCallback_65(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_65(error);
    }

    static void OnSuccessCallback_65(void * context, int32_t int32s)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_65(int32s);
    }

    static void OnFailureCallback_66(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_66(error);
    }

    static void OnSuccessCallback_66(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_66(); }

    static void OnFailureCallback_67(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_67(error);
    }

    static void OnSuccessCallback_67(void * context, int32_t int32s)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_67(int32s);
    }

    static void OnFailureCallback_68(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_68(error);
    }

    static void OnSuccessCallback_68(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_68(); }

    static void OnFailureCallback_69(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_69(error);
    }

    static void OnSuccessCallback_69(void * context, int32_t int32s)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_69(int32s);
    }

    static void OnFailureCallback_70(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_70(error);
    }

    static void OnSuccessCallback_70(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_70(); }

    static void OnFailureCallback_71(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_71(error);
    }

    static void OnSuccessCallback_71(void * context, int32_t int32s)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_71(int32s);
    }

    static void OnFailureCallback_72(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_72(error);
    }

    static void OnSuccessCallback_72(void * context, int64_t int64s)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_72(int64s);
    }

    static void OnFailureCallback_73(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_73(error);
    }

    static void OnSuccessCallback_73(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_73(); }

    static void OnFailureCallback_74(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_74(error);
    }

    static void OnSuccessCallback_74(void * context, int64_t int64s)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_74(int64s);
    }

    static void OnFailureCallback_75(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_75(error);
    }

    static void OnSuccessCallback_75(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_75(); }

    static void OnFailureCallback_76(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_76(error);
    }

    static void OnSuccessCallback_76(void * context, int64_t int64s)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_76(int64s);
    }

    static void OnFailureCallback_77(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_77(error);
    }

    static void OnSuccessCallback_77(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_77(); }

    static void OnFailureCallback_78(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_78(error);
    }

    static void OnSuccessCallback_78(void * context, int64_t int64s)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_78(int64s);
    }

    static void OnFailureCallback_79(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_79(error);
    }

    static void OnSuccessCallback_79(void * context, float floatSingle)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_79(floatSingle);
    }

    static void OnFailureCallback_80(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_80(error);
    }

    static void OnSuccessCallback_80(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_80(); }

    static void OnFailureCallback_81(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_81(error);
    }

    static void OnSuccessCallback_81(void * context, float floatSingle)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_81(floatSingle);
    }

    static void OnFailureCallback_82(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_82(error);
    }

    static void OnSuccessCallback_82(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_82(); }

    static void OnFailureCallback_83(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_83(error);
    }

    static void OnSuccessCallback_83(void * context, float floatSingle)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_83(floatSingle);
    }

    static void OnFailureCallback_84(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_84(error);
    }

    static void OnSuccessCallback_84(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_84(); }

    static void OnFailureCallback_85(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_85(error);
    }

    static void OnSuccessCallback_85(void * context, float floatSingle)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_85(floatSingle);
    }

    static void OnFailureCallback_86(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_86(error);
    }

    static void OnSuccessCallback_86(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_86(); }

    static void OnFailureCallback_87(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_87(error);
    }

    static void OnSuccessCallback_87(void * context, float floatSingle)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_87(floatSingle);
    }

    static void OnFailureCallback_88(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_88(error);
    }

    static void OnSuccessCallback_88(void * context, double floatDouble)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_88(floatDouble);
    }

    static void OnFailureCallback_89(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_89(error);
    }

    static void OnSuccessCallback_89(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_89(); }

    static void OnFailureCallback_90(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_90(error);
    }

    static void OnSuccessCallback_90(void * context, double floatDouble)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_90(floatDouble);
    }

    static void OnFailureCallback_91(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_91(error);
    }

    static void OnSuccessCallback_91(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_91(); }

    static void OnFailureCallback_92(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_92(error);
    }

    static void OnSuccessCallback_92(void * context, double floatDouble)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_92(floatDouble);
    }

    static void OnFailureCallback_93(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_93(error);
    }

    static void OnSuccessCallback_93(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_93(); }

    static void OnFailureCallback_94(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_94(error);
    }

    static void OnSuccessCallback_94(void * context, double floatDouble)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_94(floatDouble);
    }

    static void OnFailureCallback_95(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_95(error);
    }

    static void OnSuccessCallback_95(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_95(); }

    static void OnFailureCallback_96(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_96(error);
    }

    static void OnSuccessCallback_96(void * context, double floatDouble)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_96(floatDouble);
    }

    static void OnFailureCallback_97(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_97(error);
    }

    static void OnSuccessCallback_97(void * context, uint8_t enum8)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_97(enum8);
    }

    static void OnFailureCallback_98(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_98(error);
    }

    static void OnSuccessCallback_98(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_98(); }

    static void OnFailureCallback_99(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_99(error);
    }

    static void OnSuccessCallback_99(void * context, uint8_t enum8)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_99(enum8);
    }

    static void OnFailureCallback_100(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_100(error);
    }

    static void OnSuccessCallback_100(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_100(); }

    static void OnFailureCallback_101(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_101(error);
    }

    static void OnSuccessCallback_101(void * context, uint8_t enum8)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_101(enum8);
    }

    static void OnFailureCallback_102(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_102(error);
    }

    static void OnSuccessCallback_102(void * context, uint16_t enum16)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_102(enum16);
    }

    static void OnFailureCallback_103(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_103(error);
    }

    static void OnSuccessCallback_103(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_103(); }

    static void OnFailureCallback_104(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_104(error);
    }

    static void OnSuccessCallback_104(void * context, uint16_t enum16)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_104(enum16);
    }

    static void OnFailureCallback_105(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_105(error);
    }

    static void OnSuccessCallback_105(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_105(); }

    static void OnFailureCallback_106(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_106(error);
    }

    static void OnSuccessCallback_106(void * context, uint16_t enum16)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_106(enum16);
    }

    static void OnFailureCallback_107(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_107(error);
    }

    static void OnSuccessCallback_107(void * context, chip::ByteSpan octetString)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_107(octetString);
    }

    static void OnFailureCallback_108(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_108(error);
    }

    static void OnSuccessCallback_108(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_108(); }

    static void OnFailureCallback_109(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_109(error);
    }

    static void OnSuccessCallback_109(void * context, chip::ByteSpan octetString)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_109(octetString);
    }

    static void OnFailureCallback_110(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_110(error);
    }

    static void OnSuccessCallback_110(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_110(); }

    static void OnFailureCallback_111(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_111(error);
    }

    static void OnSuccessCallback_111(void * context, chip::ByteSpan octetString)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_111(octetString);
    }

    static void OnFailureCallback_112(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_112(error);
    }

    static void OnSuccessCallback_112(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_112(); }

    static void OnFailureCallback_113(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_113(error);
    }

    static void OnSuccessCallback_113(void * context, chip::ByteSpan octetString)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_113(octetString);
    }

    static void OnFailureCallback_114(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_114(error);
    }

    static void OnSuccessCallback_114(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_114(); }

    static void OnFailureCallback_115(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_115(error);
    }

    static void OnSuccessCallback_115(void * context, chip::ByteSpan octetString)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_115(octetString);
    }

    static void OnFailureCallback_116(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_116(error);
    }

    static void OnSuccessCallback_116(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_116(); }

    static void OnFailureCallback_117(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_117(error);
    }

    static void OnSuccessCallback_117(void * context, chip::ByteSpan longOctetString)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_117(longOctetString);
    }

    static void OnFailureCallback_118(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_118(error);
    }

    static void OnSuccessCallback_118(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_118(); }

    static void OnFailureCallback_119(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_119(error);
    }

    static void OnSuccessCallback_119(void * context, chip::ByteSpan longOctetString)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_119(longOctetString);
    }

    static void OnFailureCallback_120(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_120(error);
    }

    static void OnSuccessCallback_120(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_120(); }

    static void OnFailureCallback_121(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_121(error);
    }

    static void OnSuccessCallback_121(void * context, chip::CharSpan charString)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_121(charString);
    }

    static void OnFailureCallback_122(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_122(error);
    }

    static void OnSuccessCallback_122(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_122(); }

    static void OnFailureCallback_123(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_123(error);
    }

    static void OnSuccessCallback_123(void * context, chip::CharSpan charString)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_123(charString);
    }

    static void OnFailureCallback_124(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_124(error);
    }

    static void OnSuccessCallback_124(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_124(); }

    static void OnFailureCallback_125(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_125(error);
    }

    static void OnSuccessCallback_125(void * context, chip::CharSpan charString)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_125(charString);
    }

    static void OnFailureCallback_126(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_126(error);
    }

    static void OnSuccessCallback_126(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_126(); }

    static void OnFailureCallback_127(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_127(error);
    }

    static void OnSuccessCallback_127(void * context, chip::CharSpan longCharString)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_127(longCharString);
    }

    static void OnFailureCallback_128(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_128(error);
    }

    static void OnSuccessCallback_128(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_128(); }

    static void OnFailureCallback_129(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_129(error);
    }

    static void OnSuccessCallback_129(void * context, chip::CharSpan longCharString)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_129(longCharString);
    }

    static void OnFailureCallback_130(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_130(error);
    }

    static void OnSuccessCallback_130(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_130(); }

    static void OnFailureCallback_131(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_131(error);
    }

    static void OnSuccessCallback_131(void * context,
                                      const chip::app::DataModel::DecodableList<chip::ByteSpan> & listLongOctetString)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_131(listLongOctetString);
    }

    static void OnFailureCallback_132(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_132(error);
    }

    static void OnSuccessCallback_132(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_132(); }

    static void OnFailureCallback_133(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_133(error);
    }

    static void OnSuccessCallback_133(void * context,
                                      const chip::app::DataModel::DecodableList<chip::ByteSpan> & listLongOctetString)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_133(listLongOctetString);
    }

    static void OnFailureCallback_134(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_134(error);
    }

    static void OnSuccessCallback_134(void * context, uint64_t epochUs)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_134(epochUs);
    }

    static void OnFailureCallback_135(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_135(error);
    }

    static void OnSuccessCallback_135(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_135(); }

    static void OnFailureCallback_136(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_136(error);
    }

    static void OnSuccessCallback_136(void * context, uint64_t epochUs)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_136(epochUs);
    }

    static void OnFailureCallback_137(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_137(error);
    }

    static void OnSuccessCallback_137(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_137(); }

    static void OnFailureCallback_138(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_138(error);
    }

    static void OnSuccessCallback_138(void * context, uint64_t epochUs)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_138(epochUs);
    }

    static void OnFailureCallback_139(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_139(error);
    }

    static void OnSuccessCallback_139(void * context, uint32_t epochS)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_139(epochS);
    }

    static void OnFailureCallback_140(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_140(error);
    }

    static void OnSuccessCallback_140(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_140(); }

    static void OnFailureCallback_141(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_141(error);
    }

    static void OnSuccessCallback_141(void * context, uint32_t epochS)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_141(epochS);
    }

    static void OnFailureCallback_142(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_142(error);
    }

    static void OnSuccessCallback_142(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_142(); }

    static void OnFailureCallback_143(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_143(error);
    }

    static void OnSuccessCallback_143(void * context, uint32_t epochS)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_143(epochS);
    }

    static void OnFailureCallback_144(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_144(error);
    }

    static void OnSuccessCallback_144(void * context, bool unsupported)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_144(unsupported);
    }

    static void OnFailureCallback_145(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_145(error);
    }

    static void OnSuccessCallback_145(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_145(); }

    static void OnFailureCallback_148(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_148(error);
    }

    static void OnSuccessCallback_148(void * context, chip::VendorId vendorId)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_148(vendorId);
    }

    static void OnFailureCallback_149(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_149(error);
    }

    static void OnSuccessCallback_149(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_149(); }

    static void OnFailureCallback_150(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_150(error);
    }

    static void OnSuccessCallback_150(void * context, chip::VendorId vendorId)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_150(vendorId);
    }

    static void OnFailureCallback_151(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_151(error);
    }

    static void OnSuccessCallback_151(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_151(); }

    static void OnFailureCallback_168(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_168(error);
    }

    static void OnSuccessCallback_168(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_168(); }

    static void OnFailureCallback_169(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_169(error);
    }

    static void OnSuccessCallback_169(void * context, const chip::app::DataModel::DecodableList<uint8_t> & listInt8u)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_169(listInt8u);
    }

    static void OnFailureCallback_170(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_170(error);
    }

    static void OnSuccessCallback_170(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_170(); }

    static void OnFailureCallback_171(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_171(error);
    }

    static void OnSuccessCallback_171(void * context, const chip::app::DataModel::DecodableList<chip::ByteSpan> & listOctetString)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_171(listOctetString);
    }

    static void OnFailureCallback_172(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_172(error);
    }

    static void OnSuccessCallback_172(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_172(); }

    static void OnFailureCallback_173(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_173(error);
    }

    static void OnSuccessCallback_173(
        void * context,
        const chip::app::DataModel::DecodableList<chip::app::Clusters::TestCluster::Structs::TestListStructOctet::DecodableType> &
            listStructOctetString)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_173(listStructOctetString);
    }

    static void OnFailureCallback_176(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_176(error);
    }

    static void OnSuccessCallback_176(void * context,
                                      const chip::app::DataModel::DecodableList<
                                          chip::app::Clusters::TestCluster::Structs::NullablesAndOptionalsStruct::DecodableType> &
                                          listNullablesAndOptionalsStruct)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_176(listNullablesAndOptionalsStruct);
    }

    static void OnFailureCallback_177(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_177(error);
    }

    static void OnSuccessCallback_177(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_177(); }

    static void OnFailureCallback_178(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_178(error);
    }

    static void OnSuccessCallback_178(void * context,
                                      const chip::app::DataModel::DecodableList<
                                          chip::app::Clusters::TestCluster::Structs::NullablesAndOptionalsStruct::DecodableType> &
                                          listNullablesAndOptionalsStruct)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_178(listNullablesAndOptionalsStruct);
    }

    static void OnFailureCallback_179(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_179(error);
    }

    static void OnSuccessCallback_179(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_179(); }

    static void OnFailureCallback_180(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_180(error);
    }

    static void OnSuccessCallback_180(void * context, const chip::app::DataModel::Nullable<bool> & nullableBoolean)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_180(nullableBoolean);
    }

    static void OnFailureCallback_181(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_181(error);
    }

    static void OnSuccessCallback_181(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_181(); }

    static void OnFailureCallback_182(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_182(error);
    }

    static void OnSuccessCallback_182(void * context, const chip::app::DataModel::Nullable<bool> & nullableBoolean)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_182(nullableBoolean);
    }

    static void OnFailureCallback_183(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_183(error);
    }

    static void OnSuccessCallback_183(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_183(); }

    static void OnFailureCallback_184(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_184(error);
    }

    static void OnSuccessCallback_184(void * context, const chip::app::DataModel::Nullable<uint8_t> & nullableBitmap8)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_184(nullableBitmap8);
    }

    static void OnFailureCallback_185(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_185(error);
    }

    static void OnSuccessCallback_185(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_185(); }

    static void OnFailureCallback_186(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_186(error);
    }

    static void OnSuccessCallback_186(void * context, const chip::app::DataModel::Nullable<uint8_t> & nullableBitmap8)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_186(nullableBitmap8);
    }

    static void OnFailureCallback_187(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_187(error);
    }

    static void OnSuccessCallback_187(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_187(); }

    static void OnFailureCallback_188(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_188(error);
    }

    static void OnSuccessCallback_188(void * context, const chip::app::DataModel::Nullable<uint8_t> & nullableBitmap8)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_188(nullableBitmap8);
    }

    static void OnFailureCallback_189(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_189(error);
    }

    static void OnSuccessCallback_189(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_189(); }

    static void OnFailureCallback_190(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_190(error);
    }

    static void OnSuccessCallback_190(void * context, const chip::app::DataModel::Nullable<uint16_t> & nullableBitmap16)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_190(nullableBitmap16);
    }

    static void OnFailureCallback_191(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_191(error);
    }

    static void OnSuccessCallback_191(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_191(); }

    static void OnFailureCallback_192(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_192(error);
    }

    static void OnSuccessCallback_192(void * context, const chip::app::DataModel::Nullable<uint16_t> & nullableBitmap16)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_192(nullableBitmap16);
    }

    static void OnFailureCallback_193(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_193(error);
    }

    static void OnSuccessCallback_193(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_193(); }

    static void OnFailureCallback_194(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_194(error);
    }

    static void OnSuccessCallback_194(void * context, const chip::app::DataModel::Nullable<uint16_t> & nullableBitmap16)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_194(nullableBitmap16);
    }

    static void OnFailureCallback_195(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_195(error);
    }

    static void OnSuccessCallback_195(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_195(); }

    static void OnFailureCallback_196(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_196(error);
    }

    static void OnSuccessCallback_196(void * context, const chip::app::DataModel::Nullable<uint32_t> & nullableBitmap32)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_196(nullableBitmap32);
    }

    static void OnFailureCallback_197(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_197(error);
    }

    static void OnSuccessCallback_197(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_197(); }

    static void OnFailureCallback_198(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_198(error);
    }

    static void OnSuccessCallback_198(void * context, const chip::app::DataModel::Nullable<uint32_t> & nullableBitmap32)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_198(nullableBitmap32);
    }

    static void OnFailureCallback_199(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_199(error);
    }

    static void OnSuccessCallback_199(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_199(); }

    static void OnFailureCallback_200(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_200(error);
    }

    static void OnSuccessCallback_200(void * context, const chip::app::DataModel::Nullable<uint32_t> & nullableBitmap32)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_200(nullableBitmap32);
    }

    static void OnFailureCallback_201(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_201(error);
    }

    static void OnSuccessCallback_201(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_201(); }

    static void OnFailureCallback_202(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_202(error);
    }

    static void OnSuccessCallback_202(void * context, const chip::app::DataModel::Nullable<uint64_t> & nullableBitmap64)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_202(nullableBitmap64);
    }

    static void OnFailureCallback_203(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_203(error);
    }

    static void OnSuccessCallback_203(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_203(); }

    static void OnFailureCallback_204(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_204(error);
    }

    static void OnSuccessCallback_204(void * context, const chip::app::DataModel::Nullable<uint64_t> & nullableBitmap64)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_204(nullableBitmap64);
    }

    static void OnFailureCallback_205(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_205(error);
    }

    static void OnSuccessCallback_205(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_205(); }

    static void OnFailureCallback_206(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_206(error);
    }

    static void OnSuccessCallback_206(void * context, const chip::app::DataModel::Nullable<uint64_t> & nullableBitmap64)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_206(nullableBitmap64);
    }

    static void OnFailureCallback_207(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_207(error);
    }

    static void OnSuccessCallback_207(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_207(); }

    static void OnFailureCallback_208(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_208(error);
    }

    static void OnSuccessCallback_208(void * context, const chip::app::DataModel::Nullable<uint8_t> & nullableInt8u)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_208(nullableInt8u);
    }

    static void OnFailureCallback_209(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_209(error);
    }

    static void OnSuccessCallback_209(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_209(); }

    static void OnFailureCallback_210(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_210(error);
    }

    static void OnSuccessCallback_210(void * context, const chip::app::DataModel::Nullable<uint8_t> & nullableInt8u)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_210(nullableInt8u);
    }

    static void OnFailureCallback_211(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_211(error);
    }

    static void OnSuccessCallback_211(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_211(); }

    static void OnFailureCallback_212(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_212(error);
    }

    static void OnSuccessCallback_212(void * context, const chip::app::DataModel::Nullable<uint8_t> & nullableInt8u)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_212(nullableInt8u);
    }

    static void OnFailureCallback_213(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_213(error);
    }

    static void OnSuccessCallback_213(void * context, const chip::app::DataModel::Nullable<uint8_t> & nullableInt8u)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_213(nullableInt8u);
    }

    static void OnFailureCallback_214(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_214(error);
    }

    static void OnSuccessCallback_214(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_214(); }

    static void OnFailureCallback_215(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_215(error);
    }

    static void OnSuccessCallback_215(void * context, const chip::app::DataModel::Nullable<uint8_t> & nullableInt8u)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_215(nullableInt8u);
    }

    static void OnFailureCallback_216(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_216(error);
    }

    static void OnSuccessCallback_216(void * context, const chip::app::DataModel::Nullable<uint8_t> & nullableInt8u)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_216(nullableInt8u);
    }

    static void OnFailureCallback_217(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_217(error);
    }

    static void OnSuccessCallback_217(void * context, const chip::app::DataModel::Nullable<uint8_t> & nullableInt8u)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_217(nullableInt8u);
    }

    static void OnFailureCallback_218(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_218(error);
    }

    static void OnSuccessCallback_218(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_218(); }

    static void OnFailureCallback_219(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_219(error);
    }

    static void OnSuccessCallback_219(void * context, const chip::app::DataModel::Nullable<uint8_t> & nullableInt8u)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_219(nullableInt8u);
    }

    static void OnFailureCallback_220(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_220(error);
    }

    static void OnSuccessCallback_220(void * context, const chip::app::DataModel::Nullable<uint8_t> & nullableInt8u)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_220(nullableInt8u);
    }

    static void OnFailureCallback_221(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_221(error);
    }

    static void OnSuccessCallback_221(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_221(); }

    static void OnFailureCallback_222(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_222(error);
    }

    static void OnSuccessCallback_222(void * context, const chip::app::DataModel::Nullable<uint16_t> & nullableInt16u)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_222(nullableInt16u);
    }

    static void OnFailureCallback_223(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_223(error);
    }

    static void OnSuccessCallback_223(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_223(); }

    static void OnFailureCallback_224(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_224(error);
    }

    static void OnSuccessCallback_224(void * context, const chip::app::DataModel::Nullable<uint16_t> & nullableInt16u)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_224(nullableInt16u);
    }

    static void OnFailureCallback_225(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_225(error);
    }

    static void OnSuccessCallback_225(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_225(); }

    static void OnFailureCallback_226(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_226(error);
    }

    static void OnSuccessCallback_226(void * context, const chip::app::DataModel::Nullable<uint16_t> & nullableInt16u)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_226(nullableInt16u);
    }

    static void OnFailureCallback_227(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_227(error);
    }

    static void OnSuccessCallback_227(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_227(); }

    static void OnFailureCallback_228(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_228(error);
    }

    static void OnSuccessCallback_228(void * context, const chip::app::DataModel::Nullable<uint16_t> & nullableInt16u)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_228(nullableInt16u);
    }

    static void OnFailureCallback_229(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_229(error);
    }

    static void OnSuccessCallback_229(void * context, const chip::app::DataModel::Nullable<uint16_t> & nullableInt16u)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_229(nullableInt16u);
    }

    static void OnFailureCallback_230(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_230(error);
    }

    static void OnSuccessCallback_230(void * context, const chip::app::DataModel::Nullable<uint16_t> & nullableInt16u)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_230(nullableInt16u);
    }

    static void OnFailureCallback_231(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_231(error);
    }

    static void OnSuccessCallback_231(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_231(); }

    static void OnFailureCallback_232(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_232(error);
    }

    static void OnSuccessCallback_232(void * context, const chip::app::DataModel::Nullable<uint16_t> & nullableInt16u)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_232(nullableInt16u);
    }

    static void OnFailureCallback_233(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_233(error);
    }

    static void OnSuccessCallback_233(void * context, const chip::app::DataModel::Nullable<uint16_t> & nullableInt16u)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_233(nullableInt16u);
    }

    static void OnFailureCallback_234(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_234(error);
    }

    static void OnSuccessCallback_234(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_234(); }

    static void OnFailureCallback_235(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_235(error);
    }

    static void OnSuccessCallback_235(void * context, const chip::app::DataModel::Nullable<uint32_t> & nullableInt32u)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_235(nullableInt32u);
    }

    static void OnFailureCallback_236(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_236(error);
    }

    static void OnSuccessCallback_236(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_236(); }

    static void OnFailureCallback_237(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_237(error);
    }

    static void OnSuccessCallback_237(void * context, const chip::app::DataModel::Nullable<uint32_t> & nullableInt32u)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_237(nullableInt32u);
    }

    static void OnFailureCallback_238(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_238(error);
    }

    static void OnSuccessCallback_238(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_238(); }

    static void OnFailureCallback_239(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_239(error);
    }

    static void OnSuccessCallback_239(void * context, const chip::app::DataModel::Nullable<uint32_t> & nullableInt32u)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_239(nullableInt32u);
    }

    static void OnFailureCallback_240(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_240(error);
    }

    static void OnSuccessCallback_240(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_240(); }

    static void OnFailureCallback_241(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_241(error);
    }

    static void OnSuccessCallback_241(void * context, const chip::app::DataModel::Nullable<uint32_t> & nullableInt32u)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_241(nullableInt32u);
    }

    static void OnFailureCallback_242(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_242(error);
    }

    static void OnSuccessCallback_242(void * context, const chip::app::DataModel::Nullable<uint32_t> & nullableInt32u)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_242(nullableInt32u);
    }

    static void OnFailureCallback_243(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_243(error);
    }

    static void OnSuccessCallback_243(void * context, const chip::app::DataModel::Nullable<uint32_t> & nullableInt32u)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_243(nullableInt32u);
    }

    static void OnFailureCallback_244(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_244(error);
    }

    static void OnSuccessCallback_244(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_244(); }

    static void OnFailureCallback_245(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_245(error);
    }

    static void OnSuccessCallback_245(void * context, const chip::app::DataModel::Nullable<uint32_t> & nullableInt32u)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_245(nullableInt32u);
    }

    static void OnFailureCallback_246(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_246(error);
    }

    static void OnSuccessCallback_246(void * context, const chip::app::DataModel::Nullable<uint32_t> & nullableInt32u)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_246(nullableInt32u);
    }

    static void OnFailureCallback_247(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_247(error);
    }

    static void OnSuccessCallback_247(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_247(); }

    static void OnFailureCallback_248(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_248(error);
    }

    static void OnSuccessCallback_248(void * context, const chip::app::DataModel::Nullable<uint64_t> & nullableInt64u)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_248(nullableInt64u);
    }

    static void OnFailureCallback_249(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_249(error);
    }

    static void OnSuccessCallback_249(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_249(); }

    static void OnFailureCallback_250(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_250(error);
    }

    static void OnSuccessCallback_250(void * context, const chip::app::DataModel::Nullable<uint64_t> & nullableInt64u)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_250(nullableInt64u);
    }

    static void OnFailureCallback_251(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_251(error);
    }

    static void OnSuccessCallback_251(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_251(); }

    static void OnFailureCallback_252(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_252(error);
    }

    static void OnSuccessCallback_252(void * context, const chip::app::DataModel::Nullable<uint64_t> & nullableInt64u)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_252(nullableInt64u);
    }

    static void OnFailureCallback_253(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_253(error);
    }

    static void OnSuccessCallback_253(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_253(); }

    static void OnFailureCallback_254(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_254(error);
    }

    static void OnSuccessCallback_254(void * context, const chip::app::DataModel::Nullable<uint64_t> & nullableInt64u)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_254(nullableInt64u);
    }

    static void OnFailureCallback_255(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_255(error);
    }

    static void OnSuccessCallback_255(void * context, const chip::app::DataModel::Nullable<uint64_t> & nullableInt64u)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_255(nullableInt64u);
    }

    static void OnFailureCallback_256(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_256(error);
    }

    static void OnSuccessCallback_256(void * context, const chip::app::DataModel::Nullable<uint64_t> & nullableInt64u)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_256(nullableInt64u);
    }

    static void OnFailureCallback_257(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_257(error);
    }

    static void OnSuccessCallback_257(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_257(); }

    static void OnFailureCallback_258(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_258(error);
    }

    static void OnSuccessCallback_258(void * context, const chip::app::DataModel::Nullable<uint64_t> & nullableInt64u)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_258(nullableInt64u);
    }

    static void OnFailureCallback_259(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_259(error);
    }

    static void OnSuccessCallback_259(void * context, const chip::app::DataModel::Nullable<uint64_t> & nullableInt64u)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_259(nullableInt64u);
    }

    static void OnFailureCallback_260(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_260(error);
    }

    static void OnSuccessCallback_260(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_260(); }

    static void OnFailureCallback_261(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_261(error);
    }

    static void OnSuccessCallback_261(void * context, const chip::app::DataModel::Nullable<int8_t> & nullableInt8s)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_261(nullableInt8s);
    }

    static void OnFailureCallback_262(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_262(error);
    }

    static void OnSuccessCallback_262(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_262(); }

    static void OnFailureCallback_263(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_263(error);
    }

    static void OnSuccessCallback_263(void * context, const chip::app::DataModel::Nullable<int8_t> & nullableInt8s)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_263(nullableInt8s);
    }

    static void OnFailureCallback_264(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_264(error);
    }

    static void OnSuccessCallback_264(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_264(); }

    static void OnFailureCallback_265(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_265(error);
    }

    static void OnSuccessCallback_265(void * context, const chip::app::DataModel::Nullable<int8_t> & nullableInt8s)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_265(nullableInt8s);
    }

    static void OnFailureCallback_266(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_266(error);
    }

    static void OnSuccessCallback_266(void * context, const chip::app::DataModel::Nullable<int8_t> & nullableInt8s)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_266(nullableInt8s);
    }

    static void OnFailureCallback_267(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_267(error);
    }

    static void OnSuccessCallback_267(void * context, const chip::app::DataModel::Nullable<int8_t> & nullableInt8s)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_267(nullableInt8s);
    }

    static void OnFailureCallback_268(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_268(error);
    }

    static void OnSuccessCallback_268(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_268(); }

    static void OnFailureCallback_269(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_269(error);
    }

    static void OnSuccessCallback_269(void * context, const chip::app::DataModel::Nullable<int8_t> & nullableInt8s)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_269(nullableInt8s);
    }

    static void OnFailureCallback_270(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_270(error);
    }

    static void OnSuccessCallback_270(void * context, const chip::app::DataModel::Nullable<int8_t> & nullableInt8s)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_270(nullableInt8s);
    }

    static void OnFailureCallback_271(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_271(error);
    }

    static void OnSuccessCallback_271(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_271(); }

    static void OnFailureCallback_272(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_272(error);
    }

    static void OnSuccessCallback_272(void * context, const chip::app::DataModel::Nullable<int16_t> & nullableInt16s)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_272(nullableInt16s);
    }

    static void OnFailureCallback_273(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_273(error);
    }

    static void OnSuccessCallback_273(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_273(); }

    static void OnFailureCallback_274(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_274(error);
    }

    static void OnSuccessCallback_274(void * context, const chip::app::DataModel::Nullable<int16_t> & nullableInt16s)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_274(nullableInt16s);
    }

    static void OnFailureCallback_275(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_275(error);
    }

    static void OnSuccessCallback_275(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_275(); }

    static void OnFailureCallback_276(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_276(error);
    }

    static void OnSuccessCallback_276(void * context, const chip::app::DataModel::Nullable<int16_t> & nullableInt16s)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_276(nullableInt16s);
    }

    static void OnFailureCallback_277(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_277(error);
    }

    static void OnSuccessCallback_277(void * context, const chip::app::DataModel::Nullable<int16_t> & nullableInt16s)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_277(nullableInt16s);
    }

    static void OnFailureCallback_278(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_278(error);
    }

    static void OnSuccessCallback_278(void * context, const chip::app::DataModel::Nullable<int16_t> & nullableInt16s)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_278(nullableInt16s);
    }

    static void OnFailureCallback_279(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_279(error);
    }

    static void OnSuccessCallback_279(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_279(); }

    static void OnFailureCallback_280(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_280(error);
    }

    static void OnSuccessCallback_280(void * context, const chip::app::DataModel::Nullable<int16_t> & nullableInt16s)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_280(nullableInt16s);
    }

    static void OnFailureCallback_281(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_281(error);
    }

    static void OnSuccessCallback_281(void * context, const chip::app::DataModel::Nullable<int16_t> & nullableInt16s)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_281(nullableInt16s);
    }

    static void OnFailureCallback_282(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_282(error);
    }

    static void OnSuccessCallback_282(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_282(); }

    static void OnFailureCallback_283(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_283(error);
    }

    static void OnSuccessCallback_283(void * context, const chip::app::DataModel::Nullable<int32_t> & nullableInt32s)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_283(nullableInt32s);
    }

    static void OnFailureCallback_284(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_284(error);
    }

    static void OnSuccessCallback_284(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_284(); }

    static void OnFailureCallback_285(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_285(error);
    }

    static void OnSuccessCallback_285(void * context, const chip::app::DataModel::Nullable<int32_t> & nullableInt32s)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_285(nullableInt32s);
    }

    static void OnFailureCallback_286(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_286(error);
    }

    static void OnSuccessCallback_286(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_286(); }

    static void OnFailureCallback_287(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_287(error);
    }

    static void OnSuccessCallback_287(void * context, const chip::app::DataModel::Nullable<int32_t> & nullableInt32s)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_287(nullableInt32s);
    }

    static void OnFailureCallback_288(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_288(error);
    }

    static void OnSuccessCallback_288(void * context, const chip::app::DataModel::Nullable<int32_t> & nullableInt32s)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_288(nullableInt32s);
    }

    static void OnFailureCallback_289(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_289(error);
    }

    static void OnSuccessCallback_289(void * context, const chip::app::DataModel::Nullable<int32_t> & nullableInt32s)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_289(nullableInt32s);
    }

    static void OnFailureCallback_290(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_290(error);
    }

    static void OnSuccessCallback_290(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_290(); }

    static void OnFailureCallback_291(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_291(error);
    }

    static void OnSuccessCallback_291(void * context, const chip::app::DataModel::Nullable<int32_t> & nullableInt32s)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_291(nullableInt32s);
    }

    static void OnFailureCallback_292(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_292(error);
    }

    static void OnSuccessCallback_292(void * context, const chip::app::DataModel::Nullable<int32_t> & nullableInt32s)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_292(nullableInt32s);
    }

    static void OnFailureCallback_293(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_293(error);
    }

    static void OnSuccessCallback_293(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_293(); }

    static void OnFailureCallback_294(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_294(error);
    }

    static void OnSuccessCallback_294(void * context, const chip::app::DataModel::Nullable<int64_t> & nullableInt64s)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_294(nullableInt64s);
    }

    static void OnFailureCallback_295(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_295(error);
    }

    static void OnSuccessCallback_295(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_295(); }

    static void OnFailureCallback_296(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_296(error);
    }

    static void OnSuccessCallback_296(void * context, const chip::app::DataModel::Nullable<int64_t> & nullableInt64s)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_296(nullableInt64s);
    }

    static void OnFailureCallback_297(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_297(error);
    }

    static void OnSuccessCallback_297(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_297(); }

    static void OnFailureCallback_298(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_298(error);
    }

    static void OnSuccessCallback_298(void * context, const chip::app::DataModel::Nullable<int64_t> & nullableInt64s)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_298(nullableInt64s);
    }

    static void OnFailureCallback_299(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_299(error);
    }

    static void OnSuccessCallback_299(void * context, const chip::app::DataModel::Nullable<int64_t> & nullableInt64s)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_299(nullableInt64s);
    }

    static void OnFailureCallback_300(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_300(error);
    }

    static void OnSuccessCallback_300(void * context, const chip::app::DataModel::Nullable<int64_t> & nullableInt64s)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_300(nullableInt64s);
    }

    static void OnFailureCallback_301(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_301(error);
    }

    static void OnSuccessCallback_301(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_301(); }

    static void OnFailureCallback_302(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_302(error);
    }

    static void OnSuccessCallback_302(void * context, const chip::app::DataModel::Nullable<int64_t> & nullableInt64s)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_302(nullableInt64s);
    }

    static void OnFailureCallback_303(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_303(error);
    }

    static void OnSuccessCallback_303(void * context, const chip::app::DataModel::Nullable<int64_t> & nullableInt64s)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_303(nullableInt64s);
    }

    static void OnFailureCallback_304(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_304(error);
    }

    static void OnSuccessCallback_304(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_304(); }

    static void OnFailureCallback_305(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_305(error);
    }

    static void OnSuccessCallback_305(void * context, const chip::app::DataModel::Nullable<float> & nullableFloatSingle)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_305(nullableFloatSingle);
    }

    static void OnFailureCallback_306(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_306(error);
    }

    static void OnSuccessCallback_306(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_306(); }

    static void OnFailureCallback_307(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_307(error);
    }

    static void OnSuccessCallback_307(void * context, const chip::app::DataModel::Nullable<float> & nullableFloatSingle)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_307(nullableFloatSingle);
    }

    static void OnFailureCallback_308(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_308(error);
    }

    static void OnSuccessCallback_308(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_308(); }

    static void OnFailureCallback_309(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_309(error);
    }

    static void OnSuccessCallback_309(void * context, const chip::app::DataModel::Nullable<float> & nullableFloatSingle)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_309(nullableFloatSingle);
    }

    static void OnFailureCallback_310(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_310(error);
    }

    static void OnSuccessCallback_310(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_310(); }

    static void OnFailureCallback_311(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_311(error);
    }

    static void OnSuccessCallback_311(void * context, const chip::app::DataModel::Nullable<float> & nullableFloatSingle)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_311(nullableFloatSingle);
    }

    static void OnFailureCallback_312(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_312(error);
    }

    static void OnSuccessCallback_312(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_312(); }

    static void OnFailureCallback_313(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_313(error);
    }

    static void OnSuccessCallback_313(void * context, const chip::app::DataModel::Nullable<float> & nullableFloatSingle)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_313(nullableFloatSingle);
    }

    static void OnFailureCallback_314(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_314(error);
    }

    static void OnSuccessCallback_314(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_314(); }

    static void OnFailureCallback_315(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_315(error);
    }

    static void OnSuccessCallback_315(void * context, const chip::app::DataModel::Nullable<double> & nullableFloatDouble)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_315(nullableFloatDouble);
    }

    static void OnFailureCallback_316(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_316(error);
    }

    static void OnSuccessCallback_316(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_316(); }

    static void OnFailureCallback_317(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_317(error);
    }

    static void OnSuccessCallback_317(void * context, const chip::app::DataModel::Nullable<double> & nullableFloatDouble)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_317(nullableFloatDouble);
    }

    static void OnFailureCallback_318(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_318(error);
    }

    static void OnSuccessCallback_318(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_318(); }

    static void OnFailureCallback_319(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_319(error);
    }

    static void OnSuccessCallback_319(void * context, const chip::app::DataModel::Nullable<double> & nullableFloatDouble)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_319(nullableFloatDouble);
    }

    static void OnFailureCallback_320(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_320(error);
    }

    static void OnSuccessCallback_320(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_320(); }

    static void OnFailureCallback_321(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_321(error);
    }

    static void OnSuccessCallback_321(void * context, const chip::app::DataModel::Nullable<double> & nullableFloatDouble)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_321(nullableFloatDouble);
    }

    static void OnFailureCallback_322(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_322(error);
    }

    static void OnSuccessCallback_322(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_322(); }

    static void OnFailureCallback_323(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_323(error);
    }

    static void OnSuccessCallback_323(void * context, const chip::app::DataModel::Nullable<double> & nullableFloatDouble)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_323(nullableFloatDouble);
    }

    static void OnFailureCallback_324(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_324(error);
    }

    static void OnSuccessCallback_324(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_324(); }

    static void OnFailureCallback_325(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_325(error);
    }

    static void OnSuccessCallback_325(void * context, const chip::app::DataModel::Nullable<uint8_t> & nullableEnum8)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_325(nullableEnum8);
    }

    static void OnFailureCallback_326(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_326(error);
    }

    static void OnSuccessCallback_326(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_326(); }

    static void OnFailureCallback_327(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_327(error);
    }

    static void OnSuccessCallback_327(void * context, const chip::app::DataModel::Nullable<uint8_t> & nullableEnum8)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_327(nullableEnum8);
    }

    static void OnFailureCallback_328(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_328(error);
    }

    static void OnSuccessCallback_328(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_328(); }

    static void OnFailureCallback_329(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_329(error);
    }

    static void OnSuccessCallback_329(void * context, const chip::app::DataModel::Nullable<uint8_t> & nullableEnum8)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_329(nullableEnum8);
    }

    static void OnFailureCallback_330(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_330(error);
    }

    static void OnSuccessCallback_330(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_330(); }

    static void OnFailureCallback_331(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_331(error);
    }

    static void OnSuccessCallback_331(void * context, const chip::app::DataModel::Nullable<uint8_t> & nullableEnum8)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_331(nullableEnum8);
    }

    static void OnFailureCallback_332(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_332(error);
    }

    static void OnSuccessCallback_332(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_332(); }

    static void OnFailureCallback_333(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_333(error);
    }

    static void OnSuccessCallback_333(void * context, const chip::app::DataModel::Nullable<uint16_t> & nullableEnum16)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_333(nullableEnum16);
    }

    static void OnFailureCallback_334(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_334(error);
    }

    static void OnSuccessCallback_334(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_334(); }

    static void OnFailureCallback_335(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_335(error);
    }

    static void OnSuccessCallback_335(void * context, const chip::app::DataModel::Nullable<uint16_t> & nullableEnum16)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_335(nullableEnum16);
    }

    static void OnFailureCallback_336(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_336(error);
    }

    static void OnSuccessCallback_336(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_336(); }

    static void OnFailureCallback_337(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_337(error);
    }

    static void OnSuccessCallback_337(void * context, const chip::app::DataModel::Nullable<uint16_t> & nullableEnum16)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_337(nullableEnum16);
    }

    static void OnFailureCallback_338(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_338(error);
    }

    static void OnSuccessCallback_338(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_338(); }

    static void OnFailureCallback_339(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_339(error);
    }

    static void OnSuccessCallback_339(void * context, const chip::app::DataModel::Nullable<uint16_t> & nullableEnum16)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_339(nullableEnum16);
    }

    static void OnFailureCallback_340(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_340(error);
    }

    static void OnSuccessCallback_340(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_340(); }

    static void OnFailureCallback_341(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_341(error);
    }

    static void
    OnSuccessCallback_341(void * context,
                          const chip::app::DataModel::Nullable<chip::app::Clusters::TestCluster::SimpleEnum> & nullableEnumAttr)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_341(nullableEnumAttr);
    }

    static void OnFailureCallback_342(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_342(error);
    }

    static void OnSuccessCallback_342(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_342(); }

    static void OnFailureCallback_343(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_343(error);
    }

    static void
    OnSuccessCallback_343(void * context,
                          const chip::app::DataModel::Nullable<chip::app::Clusters::TestCluster::SimpleEnum> & nullableEnumAttr)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_343(nullableEnumAttr);
    }

    static void OnFailureCallback_344(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_344(error);
    }

    static void OnSuccessCallback_344(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_344(); }

    static void OnFailureCallback_345(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_345(error);
    }

    static void
    OnSuccessCallback_345(void * context,
                          const chip::app::DataModel::Nullable<chip::app::Clusters::TestCluster::SimpleEnum> & nullableEnumAttr)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_345(nullableEnumAttr);
    }

    static void OnFailureCallback_346(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_346(error);
    }

    static void OnSuccessCallback_346(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_346(); }

    static void OnFailureCallback_347(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_347(error);
    }

    static void
    OnSuccessCallback_347(void * context,
                          const chip::app::DataModel::Nullable<chip::app::Clusters::TestCluster::SimpleEnum> & nullableEnumAttr)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_347(nullableEnumAttr);
    }

    static void OnFailureCallback_348(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_348(error);
    }

    static void OnSuccessCallback_348(void * context, const chip::app::DataModel::Nullable<chip::ByteSpan> & nullableOctetString)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_348(nullableOctetString);
    }

    static void OnFailureCallback_349(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_349(error);
    }

    static void OnSuccessCallback_349(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_349(); }

    static void OnFailureCallback_350(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_350(error);
    }

    static void OnSuccessCallback_350(void * context, const chip::app::DataModel::Nullable<chip::ByteSpan> & nullableOctetString)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_350(nullableOctetString);
    }

    static void OnFailureCallback_351(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_351(error);
    }

    static void OnSuccessCallback_351(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_351(); }

    static void OnFailureCallback_352(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_352(error);
    }

    static void OnSuccessCallback_352(void * context, const chip::app::DataModel::Nullable<chip::ByteSpan> & nullableOctetString)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_352(nullableOctetString);
    }

    static void OnFailureCallback_353(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_353(error);
    }

    static void OnSuccessCallback_353(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_353(); }

    static void OnFailureCallback_354(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_354(error);
    }

    static void OnSuccessCallback_354(void * context, const chip::app::DataModel::Nullable<chip::ByteSpan> & nullableOctetString)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_354(nullableOctetString);
    }

    static void OnFailureCallback_355(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_355(error);
    }

    static void OnSuccessCallback_355(void * context, const chip::app::DataModel::Nullable<chip::CharSpan> & nullableCharString)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_355(nullableCharString);
    }

    static void OnFailureCallback_356(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_356(error);
    }

    static void OnSuccessCallback_356(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_356(); }

    static void OnFailureCallback_357(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_357(error);
    }

    static void OnSuccessCallback_357(void * context, const chip::app::DataModel::Nullable<chip::CharSpan> & nullableCharString)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_357(nullableCharString);
    }

    static void OnFailureCallback_358(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_358(error);
    }

    static void OnSuccessCallback_358(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_358(); }

    static void OnFailureCallback_359(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_359(error);
    }

    static void OnSuccessCallback_359(void * context, const chip::app::DataModel::Nullable<chip::CharSpan> & nullableCharString)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_359(nullableCharString);
    }

    static void OnFailureCallback_360(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_360(error);
    }

    static void OnSuccessCallback_360(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_360(); }

    static void OnFailureCallback_361(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_361(error);
    }

    static void OnSuccessCallback_361(void * context, const chip::app::DataModel::Nullable<chip::CharSpan> & nullableCharString)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_361(nullableCharString);
    }

    static void OnFailureCallback_362(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_362(error);
    }

    static void OnSuccessCallback_362(void * context, const chip::app::DataModel::DecodableList<uint8_t> & listInt8u)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_362(listInt8u);
    }

    static void OnFailureCallback_363(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_363(error);
    }

    static void OnSuccessCallback_363(void * context, const chip::app::DataModel::DecodableList<uint8_t> & listInt8u)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_363(listInt8u);
    }

    static void OnFailureCallback_366(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_366(error);
    }

    static void OnSuccessCallback_366(void * context, const chip::app::DataModel::DecodableList<uint8_t> & listInt8u)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_366(listInt8u);
    }

    bool mReceivedReport_366 = false;

    static void OnFailureCallback_367(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_367(error);
    }

    static void OnSuccessCallback_367(void * context, const chip::app::DataModel::DecodableList<uint8_t> & listInt8u)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_367(listInt8u);
    }

    static void OnSubscriptionEstablished_367(void * context)
    {
        (static_cast<TestClusterSuite *>(context))->OnSubscriptionEstablishedResponse_367();
    }

    static void OnFailureCallback_368(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_368(error);
    }

    static void OnSuccessCallback_368(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_368(); }

    static void OnFailureCallback_369(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_369(error);
    }

    static void OnSuccessCallback_369(void * context, const chip::app::DataModel::DecodableList<uint8_t> & listInt8u)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_369(listInt8u);
    }

    bool mReceivedReport_369 = false;

    static void OnFailureCallback_370(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_370(error);
    }

    static void OnSuccessCallback_370(void * context, uint8_t rangeRestrictedInt8u)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_370(rangeRestrictedInt8u);
    }

    static void OnFailureCallback_371(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_371(error);
    }

    static void OnSuccessCallback_371(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_371(); }

    static void OnFailureCallback_372(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_372(error);
    }

    static void OnSuccessCallback_372(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_372(); }

    static void OnFailureCallback_373(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_373(error);
    }

    static void OnSuccessCallback_373(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_373(); }

    static void OnFailureCallback_374(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_374(error);
    }

    static void OnSuccessCallback_374(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_374(); }

    static void OnFailureCallback_375(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_375(error);
    }

    static void OnSuccessCallback_375(void * context, uint8_t rangeRestrictedInt8u)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_375(rangeRestrictedInt8u);
    }

    static void OnFailureCallback_376(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_376(error);
    }

    static void OnSuccessCallback_376(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_376(); }

    static void OnFailureCallback_377(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_377(error);
    }

    static void OnSuccessCallback_377(void * context, uint8_t rangeRestrictedInt8u)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_377(rangeRestrictedInt8u);
    }

    static void OnFailureCallback_378(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_378(error);
    }

    static void OnSuccessCallback_378(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_378(); }

    static void OnFailureCallback_379(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_379(error);
    }

    static void OnSuccessCallback_379(void * context, uint8_t rangeRestrictedInt8u)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_379(rangeRestrictedInt8u);
    }

    static void OnFailureCallback_380(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_380(error);
    }

    static void OnSuccessCallback_380(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_380(); }

    static void OnFailureCallback_381(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_381(error);
    }

    static void OnSuccessCallback_381(void * context, uint8_t rangeRestrictedInt8u)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_381(rangeRestrictedInt8u);
    }

    static void OnFailureCallback_382(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_382(error);
    }

    static void OnSuccessCallback_382(void * context, uint16_t rangeRestrictedInt16u)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_382(rangeRestrictedInt16u);
    }

    static void OnFailureCallback_383(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_383(error);
    }

    static void OnSuccessCallback_383(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_383(); }

    static void OnFailureCallback_384(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_384(error);
    }

    static void OnSuccessCallback_384(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_384(); }

    static void OnFailureCallback_385(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_385(error);
    }

    static void OnSuccessCallback_385(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_385(); }

    static void OnFailureCallback_386(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_386(error);
    }

    static void OnSuccessCallback_386(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_386(); }

    static void OnFailureCallback_387(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_387(error);
    }

    static void OnSuccessCallback_387(void * context, uint16_t rangeRestrictedInt16u)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_387(rangeRestrictedInt16u);
    }

    static void OnFailureCallback_388(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_388(error);
    }

    static void OnSuccessCallback_388(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_388(); }

    static void OnFailureCallback_389(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_389(error);
    }

    static void OnSuccessCallback_389(void * context, uint16_t rangeRestrictedInt16u)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_389(rangeRestrictedInt16u);
    }

    static void OnFailureCallback_390(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_390(error);
    }

    static void OnSuccessCallback_390(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_390(); }

    static void OnFailureCallback_391(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_391(error);
    }

    static void OnSuccessCallback_391(void * context, uint16_t rangeRestrictedInt16u)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_391(rangeRestrictedInt16u);
    }

    static void OnFailureCallback_392(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_392(error);
    }

    static void OnSuccessCallback_392(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_392(); }

    static void OnFailureCallback_393(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_393(error);
    }

    static void OnSuccessCallback_393(void * context, uint16_t rangeRestrictedInt16u)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_393(rangeRestrictedInt16u);
    }

    static void OnFailureCallback_394(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_394(error);
    }

    static void OnSuccessCallback_394(void * context, int8_t rangeRestrictedInt8s)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_394(rangeRestrictedInt8s);
    }

    static void OnFailureCallback_395(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_395(error);
    }

    static void OnSuccessCallback_395(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_395(); }

    static void OnFailureCallback_396(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_396(error);
    }

    static void OnSuccessCallback_396(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_396(); }

    static void OnFailureCallback_397(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_397(error);
    }

    static void OnSuccessCallback_397(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_397(); }

    static void OnFailureCallback_398(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_398(error);
    }

    static void OnSuccessCallback_398(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_398(); }

    static void OnFailureCallback_399(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_399(error);
    }

    static void OnSuccessCallback_399(void * context, int8_t rangeRestrictedInt8s)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_399(rangeRestrictedInt8s);
    }

    static void OnFailureCallback_400(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_400(error);
    }

    static void OnSuccessCallback_400(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_400(); }

    static void OnFailureCallback_401(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_401(error);
    }

    static void OnSuccessCallback_401(void * context, int8_t rangeRestrictedInt8s)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_401(rangeRestrictedInt8s);
    }

    static void OnFailureCallback_402(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_402(error);
    }

    static void OnSuccessCallback_402(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_402(); }

    static void OnFailureCallback_403(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_403(error);
    }

    static void OnSuccessCallback_403(void * context, int8_t rangeRestrictedInt8s)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_403(rangeRestrictedInt8s);
    }

    static void OnFailureCallback_404(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_404(error);
    }

    static void OnSuccessCallback_404(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_404(); }

    static void OnFailureCallback_405(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_405(error);
    }

    static void OnSuccessCallback_405(void * context, int8_t rangeRestrictedInt8s)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_405(rangeRestrictedInt8s);
    }

    static void OnFailureCallback_406(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_406(error);
    }

    static void OnSuccessCallback_406(void * context, int16_t rangeRestrictedInt16s)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_406(rangeRestrictedInt16s);
    }

    static void OnFailureCallback_407(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_407(error);
    }

    static void OnSuccessCallback_407(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_407(); }

    static void OnFailureCallback_408(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_408(error);
    }

    static void OnSuccessCallback_408(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_408(); }

    static void OnFailureCallback_409(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_409(error);
    }

    static void OnSuccessCallback_409(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_409(); }

    static void OnFailureCallback_410(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_410(error);
    }

    static void OnSuccessCallback_410(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_410(); }

    static void OnFailureCallback_411(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_411(error);
    }

    static void OnSuccessCallback_411(void * context, int16_t rangeRestrictedInt16s)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_411(rangeRestrictedInt16s);
    }

    static void OnFailureCallback_412(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_412(error);
    }

    static void OnSuccessCallback_412(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_412(); }

    static void OnFailureCallback_413(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_413(error);
    }

    static void OnSuccessCallback_413(void * context, int16_t rangeRestrictedInt16s)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_413(rangeRestrictedInt16s);
    }

    static void OnFailureCallback_414(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_414(error);
    }

    static void OnSuccessCallback_414(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_414(); }

    static void OnFailureCallback_415(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_415(error);
    }

    static void OnSuccessCallback_415(void * context, int16_t rangeRestrictedInt16s)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_415(rangeRestrictedInt16s);
    }

    static void OnFailureCallback_416(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_416(error);
    }

    static void OnSuccessCallback_416(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_416(); }

    static void OnFailureCallback_417(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_417(error);
    }

    static void OnSuccessCallback_417(void * context, int16_t rangeRestrictedInt16s)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_417(rangeRestrictedInt16s);
    }

    static void OnFailureCallback_418(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_418(error);
    }

    static void OnSuccessCallback_418(void * context, const chip::app::DataModel::Nullable<uint8_t> & nullableRangeRestrictedInt8u)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_418(nullableRangeRestrictedInt8u);
    }

    static void OnFailureCallback_419(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_419(error);
    }

    static void OnSuccessCallback_419(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_419(); }

    static void OnFailureCallback_420(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_420(error);
    }

    static void OnSuccessCallback_420(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_420(); }

    static void OnFailureCallback_421(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_421(error);
    }

    static void OnSuccessCallback_421(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_421(); }

    static void OnFailureCallback_422(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_422(error);
    }

    static void OnSuccessCallback_422(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_422(); }

    static void OnFailureCallback_423(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_423(error);
    }

    static void OnSuccessCallback_423(void * context, const chip::app::DataModel::Nullable<uint8_t> & nullableRangeRestrictedInt8u)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_423(nullableRangeRestrictedInt8u);
    }

    static void OnFailureCallback_424(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_424(error);
    }

    static void OnSuccessCallback_424(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_424(); }

    static void OnFailureCallback_425(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_425(error);
    }

    static void OnSuccessCallback_425(void * context, const chip::app::DataModel::Nullable<uint8_t> & nullableRangeRestrictedInt8u)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_425(nullableRangeRestrictedInt8u);
    }

    static void OnFailureCallback_426(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_426(error);
    }

    static void OnSuccessCallback_426(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_426(); }

    static void OnFailureCallback_427(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_427(error);
    }

    static void OnSuccessCallback_427(void * context, const chip::app::DataModel::Nullable<uint8_t> & nullableRangeRestrictedInt8u)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_427(nullableRangeRestrictedInt8u);
    }

    static void OnFailureCallback_428(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_428(error);
    }

    static void OnSuccessCallback_428(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_428(); }

    static void OnFailureCallback_429(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_429(error);
    }

    static void OnSuccessCallback_429(void * context, const chip::app::DataModel::Nullable<uint8_t> & nullableRangeRestrictedInt8u)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_429(nullableRangeRestrictedInt8u);
    }

    static void OnFailureCallback_430(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_430(error);
    }

    static void OnSuccessCallback_430(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_430(); }

    static void OnFailureCallback_431(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_431(error);
    }

    static void OnSuccessCallback_431(void * context, const chip::app::DataModel::Nullable<uint8_t> & nullableRangeRestrictedInt8u)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_431(nullableRangeRestrictedInt8u);
    }

    static void OnFailureCallback_432(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_432(error);
    }

    static void OnSuccessCallback_432(void * context,
                                      const chip::app::DataModel::Nullable<uint16_t> & nullableRangeRestrictedInt16u)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_432(nullableRangeRestrictedInt16u);
    }

    static void OnFailureCallback_433(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_433(error);
    }

    static void OnSuccessCallback_433(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_433(); }

    static void OnFailureCallback_434(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_434(error);
    }

    static void OnSuccessCallback_434(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_434(); }

    static void OnFailureCallback_435(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_435(error);
    }

    static void OnSuccessCallback_435(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_435(); }

    static void OnFailureCallback_436(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_436(error);
    }

    static void OnSuccessCallback_436(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_436(); }

    static void OnFailureCallback_437(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_437(error);
    }

    static void OnSuccessCallback_437(void * context,
                                      const chip::app::DataModel::Nullable<uint16_t> & nullableRangeRestrictedInt16u)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_437(nullableRangeRestrictedInt16u);
    }

    static void OnFailureCallback_438(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_438(error);
    }

    static void OnSuccessCallback_438(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_438(); }

    static void OnFailureCallback_439(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_439(error);
    }

    static void OnSuccessCallback_439(void * context,
                                      const chip::app::DataModel::Nullable<uint16_t> & nullableRangeRestrictedInt16u)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_439(nullableRangeRestrictedInt16u);
    }

    static void OnFailureCallback_440(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_440(error);
    }

    static void OnSuccessCallback_440(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_440(); }

    static void OnFailureCallback_441(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_441(error);
    }

    static void OnSuccessCallback_441(void * context,
                                      const chip::app::DataModel::Nullable<uint16_t> & nullableRangeRestrictedInt16u)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_441(nullableRangeRestrictedInt16u);
    }

    static void OnFailureCallback_442(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_442(error);
    }

    static void OnSuccessCallback_442(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_442(); }

    static void OnFailureCallback_443(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_443(error);
    }

    static void OnSuccessCallback_443(void * context,
                                      const chip::app::DataModel::Nullable<uint16_t> & nullableRangeRestrictedInt16u)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_443(nullableRangeRestrictedInt16u);
    }

    static void OnFailureCallback_444(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_444(error);
    }

    static void OnSuccessCallback_444(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_444(); }

    static void OnFailureCallback_445(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_445(error);
    }

    static void OnSuccessCallback_445(void * context,
                                      const chip::app::DataModel::Nullable<uint16_t> & nullableRangeRestrictedInt16u)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_445(nullableRangeRestrictedInt16u);
    }

    static void OnFailureCallback_446(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_446(error);
    }

    static void OnSuccessCallback_446(void * context, const chip::app::DataModel::Nullable<int8_t> & nullableRangeRestrictedInt8s)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_446(nullableRangeRestrictedInt8s);
    }

    static void OnFailureCallback_447(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_447(error);
    }

    static void OnSuccessCallback_447(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_447(); }

    static void OnFailureCallback_448(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_448(error);
    }

    static void OnSuccessCallback_448(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_448(); }

    static void OnFailureCallback_449(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_449(error);
    }

    static void OnSuccessCallback_449(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_449(); }

    static void OnFailureCallback_450(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_450(error);
    }

    static void OnSuccessCallback_450(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_450(); }

    static void OnFailureCallback_451(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_451(error);
    }

    static void OnSuccessCallback_451(void * context, const chip::app::DataModel::Nullable<int8_t> & nullableRangeRestrictedInt8s)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_451(nullableRangeRestrictedInt8s);
    }

    static void OnFailureCallback_452(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_452(error);
    }

    static void OnSuccessCallback_452(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_452(); }

    static void OnFailureCallback_453(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_453(error);
    }

    static void OnSuccessCallback_453(void * context, const chip::app::DataModel::Nullable<int8_t> & nullableRangeRestrictedInt8s)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_453(nullableRangeRestrictedInt8s);
    }

    static void OnFailureCallback_454(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_454(error);
    }

    static void OnSuccessCallback_454(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_454(); }

    static void OnFailureCallback_455(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_455(error);
    }

    static void OnSuccessCallback_455(void * context, const chip::app::DataModel::Nullable<int8_t> & nullableRangeRestrictedInt8s)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_455(nullableRangeRestrictedInt8s);
    }

    static void OnFailureCallback_456(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_456(error);
    }

    static void OnSuccessCallback_456(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_456(); }

    static void OnFailureCallback_457(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_457(error);
    }

    static void OnSuccessCallback_457(void * context, const chip::app::DataModel::Nullable<int8_t> & nullableRangeRestrictedInt8s)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_457(nullableRangeRestrictedInt8s);
    }

    static void OnFailureCallback_458(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_458(error);
    }

    static void OnSuccessCallback_458(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_458(); }

    static void OnFailureCallback_459(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_459(error);
    }

    static void OnSuccessCallback_459(void * context, const chip::app::DataModel::Nullable<int8_t> & nullableRangeRestrictedInt8s)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_459(nullableRangeRestrictedInt8s);
    }

    static void OnFailureCallback_460(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_460(error);
    }

    static void OnSuccessCallback_460(void * context, const chip::app::DataModel::Nullable<int16_t> & nullableRangeRestrictedInt16s)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_460(nullableRangeRestrictedInt16s);
    }

    static void OnFailureCallback_461(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_461(error);
    }

    static void OnSuccessCallback_461(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_461(); }

    static void OnFailureCallback_462(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_462(error);
    }

    static void OnSuccessCallback_462(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_462(); }

    static void OnFailureCallback_463(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_463(error);
    }

    static void OnSuccessCallback_463(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_463(); }

    static void OnFailureCallback_464(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_464(error);
    }

    static void OnSuccessCallback_464(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_464(); }

    static void OnFailureCallback_465(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_465(error);
    }

    static void OnSuccessCallback_465(void * context, const chip::app::DataModel::Nullable<int16_t> & nullableRangeRestrictedInt16s)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_465(nullableRangeRestrictedInt16s);
    }

    static void OnFailureCallback_466(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_466(error);
    }

    static void OnSuccessCallback_466(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_466(); }

    static void OnFailureCallback_467(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_467(error);
    }

    static void OnSuccessCallback_467(void * context, const chip::app::DataModel::Nullable<int16_t> & nullableRangeRestrictedInt16s)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_467(nullableRangeRestrictedInt16s);
    }

    static void OnFailureCallback_468(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_468(error);
    }

    static void OnSuccessCallback_468(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_468(); }

    static void OnFailureCallback_469(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_469(error);
    }

    static void OnSuccessCallback_469(void * context, const chip::app::DataModel::Nullable<int16_t> & nullableRangeRestrictedInt16s)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_469(nullableRangeRestrictedInt16s);
    }

    static void OnFailureCallback_470(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_470(error);
    }

    static void OnSuccessCallback_470(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_470(); }

    static void OnFailureCallback_471(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_471(error);
    }

    static void OnSuccessCallback_471(void * context, const chip::app::DataModel::Nullable<int16_t> & nullableRangeRestrictedInt16s)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_471(nullableRangeRestrictedInt16s);
    }

    static void OnFailureCallback_472(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_472(error);
    }

    static void OnSuccessCallback_472(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_472(); }

    static void OnFailureCallback_473(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_473(error);
    }

    static void OnSuccessCallback_473(void * context, const chip::app::DataModel::Nullable<int16_t> & nullableRangeRestrictedInt16s)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_473(nullableRangeRestrictedInt16s);
    }

    static void OnFailureCallback_474(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_474(error);
    }

    static void OnSuccessCallback_474(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_474(); }

    static void OnFailureCallback_475(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_475(error);
    }

    static void OnSuccessCallback_475(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_475(); }

    static void OnFailureCallback_476(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_476(error);
    }

    static void OnSuccessCallback_476(void * context, bool generalErrorBoolean)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_476(generalErrorBoolean);
    }

    static void OnFailureCallback_477(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_477(error);
    }

    static void OnSuccessCallback_477(void * context, bool clusterErrorBoolean)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_477(clusterErrorBoolean);
    }

    static void OnFailureCallback_478(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_478(error);
    }

    static void OnSuccessCallback_478(void * context,
                                      const chip::app::DataModel::DecodableList<chip::CommandId> & clientGeneratedCommandList)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_478(clientGeneratedCommandList);
    }

    static void OnFailureCallback_479(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_479(error);
    }

    static void OnSuccessCallback_479(void * context,
                                      const chip::app::DataModel::DecodableList<chip::CommandId> & serverGeneratedCommandList)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_479(serverGeneratedCommandList);
    }

    static void OnFailureCallback_480(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_480(error);
    }

    static void OnSuccessCallback_480(void * context) { (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_480(); }

    static void OnFailureCallback_481(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterSuite *>(context))->OnFailureResponse_481(error);
    }

    static void OnSuccessCallback_481(void * context,
                                      const chip::app::Clusters::TestCluster::Structs::SimpleStruct::DecodableType & structAttr)
    {
        (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_481(structAttr);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestSendTestCommand_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::Test::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestClusterSuite *>(context))->OnFailureResponse_1(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestSendTestNotHandledCommand_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::TestNotHandled::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestClusterSuite *>(context))->OnFailureResponse_2(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_COMMAND));
        NextTest();
    }

    void OnSuccessResponse_2() { ThrowSuccessResponse(); }

    CHIP_ERROR TestSendTestSpecificCommand_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::TestSpecific::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_3(data.returnValue);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestClusterSuite *>(context))->OnFailureResponse_3(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3(uint8_t returnValue)
    {
        VerifyOrReturn(CheckValue("returnValue", returnValue, 7));

        NextTest();
    }

    CHIP_ERROR TestSendTestAddArgumentsCommand_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::TestAddArguments::Type;

        RequestType request;
        request.arg1 = 3;
        request.arg2 = 17;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_4(data.returnValue);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestClusterSuite *>(context))->OnFailureResponse_4(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_4(uint8_t returnValue)
    {
        VerifyOrReturn(CheckValue("returnValue", returnValue, 20));

        NextTest();
    }

    CHIP_ERROR TestSendFailingTestAddArgumentsCommand_5()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::TestAddArguments::Type;

        RequestType request;
        request.arg1 = 250;
        request.arg2 = 6;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_5(data.returnValue);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestClusterSuite *>(context))->OnFailureResponse_5(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_COMMAND));
        NextTest();
    }

    void OnSuccessResponse_5(uint8_t returnValue) { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadAttributeBooleanDefaultValue_6()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Boolean::TypeInfo>(
            this, OnSuccessCallback_6, OnFailureCallback_6, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_6(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_6(bool boolean)
    {
        VerifyOrReturn(CheckValue("boolean", boolean, 0));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeBooleanTrue_7()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        bool booleanArgument;
        booleanArgument = 1;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Boolean::TypeInfo>(
            booleanArgument, this, OnSuccessCallback_7, OnFailureCallback_7));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_7(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_7() { NextTest(); }

    CHIP_ERROR TestReadAttributeBooleanTrue_8()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Boolean::TypeInfo>(
            this, OnSuccessCallback_8, OnFailureCallback_8, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_8(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_8(bool boolean)
    {
        VerifyOrReturn(CheckValue("boolean", boolean, 1));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeBooleanFalse_9()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        bool booleanArgument;
        booleanArgument = 0;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Boolean::TypeInfo>(
            booleanArgument, this, OnSuccessCallback_9, OnFailureCallback_9));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_9(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_9() { NextTest(); }

    CHIP_ERROR TestReadAttributeBooleanFalse_10()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Boolean::TypeInfo>(
            this, OnSuccessCallback_10, OnFailureCallback_10, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_10(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_10(bool boolean)
    {
        VerifyOrReturn(CheckValue("boolean", boolean, 0));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeBitmap8DefaultValue_11()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap8::TypeInfo>(
            this, OnSuccessCallback_11, OnFailureCallback_11, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_11(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_11(uint8_t bitmap8)
    {
        VerifyOrReturn(CheckValue("bitmap8", bitmap8, 0));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeBitmap8MaxValue_12()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t bitmap8Argument;
        bitmap8Argument = 255;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap8::TypeInfo>(
            bitmap8Argument, this, OnSuccessCallback_12, OnFailureCallback_12));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_12(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_12() { NextTest(); }

    CHIP_ERROR TestReadAttributeBitmap8MaxValue_13()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap8::TypeInfo>(
            this, OnSuccessCallback_13, OnFailureCallback_13, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_13(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_13(uint8_t bitmap8)
    {
        VerifyOrReturn(CheckValue("bitmap8", bitmap8, 255));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeBitmap8MinValue_14()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t bitmap8Argument;
        bitmap8Argument = 0;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap8::TypeInfo>(
            bitmap8Argument, this, OnSuccessCallback_14, OnFailureCallback_14));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_14(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_14() { NextTest(); }

    CHIP_ERROR TestReadAttributeBitmap8MinValue_15()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap8::TypeInfo>(
            this, OnSuccessCallback_15, OnFailureCallback_15, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_15(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_15(uint8_t bitmap8)
    {
        VerifyOrReturn(CheckValue("bitmap8", bitmap8, 0));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeBitmap16DefaultValue_16()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap16::TypeInfo>(
            this, OnSuccessCallback_16, OnFailureCallback_16, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_16(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_16(uint16_t bitmap16)
    {
        VerifyOrReturn(CheckValue("bitmap16", bitmap16, 0U));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeBitmap16MaxValue_17()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t bitmap16Argument;
        bitmap16Argument = 65535U;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap16::TypeInfo>(
            bitmap16Argument, this, OnSuccessCallback_17, OnFailureCallback_17));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_17(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_17() { NextTest(); }

    CHIP_ERROR TestReadAttributeBitmap16MaxValue_18()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap16::TypeInfo>(
            this, OnSuccessCallback_18, OnFailureCallback_18, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_18(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_18(uint16_t bitmap16)
    {
        VerifyOrReturn(CheckValue("bitmap16", bitmap16, 65535U));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeBitmap16MinValue_19()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t bitmap16Argument;
        bitmap16Argument = 0U;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap16::TypeInfo>(
            bitmap16Argument, this, OnSuccessCallback_19, OnFailureCallback_19));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_19(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_19() { NextTest(); }

    CHIP_ERROR TestReadAttributeBitmap16MinValue_20()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap16::TypeInfo>(
            this, OnSuccessCallback_20, OnFailureCallback_20, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_20(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_20(uint16_t bitmap16)
    {
        VerifyOrReturn(CheckValue("bitmap16", bitmap16, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeBitmap32DefaultValue_21()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap32::TypeInfo>(
            this, OnSuccessCallback_21, OnFailureCallback_21, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_21(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_21(uint32_t bitmap32)
    {
        VerifyOrReturn(CheckValue("bitmap32", bitmap32, 0UL));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeBitmap32MaxValue_22()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint32_t bitmap32Argument;
        bitmap32Argument = 4294967295UL;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap32::TypeInfo>(
            bitmap32Argument, this, OnSuccessCallback_22, OnFailureCallback_22));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_22(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_22() { NextTest(); }

    CHIP_ERROR TestReadAttributeBitmap32MaxValue_23()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap32::TypeInfo>(
            this, OnSuccessCallback_23, OnFailureCallback_23, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_23(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_23(uint32_t bitmap32)
    {
        VerifyOrReturn(CheckValue("bitmap32", bitmap32, 4294967295UL));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeBitmap32MinValue_24()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint32_t bitmap32Argument;
        bitmap32Argument = 0UL;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap32::TypeInfo>(
            bitmap32Argument, this, OnSuccessCallback_24, OnFailureCallback_24));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_24(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_24() { NextTest(); }

    CHIP_ERROR TestReadAttributeBitmap32MinValue_25()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap32::TypeInfo>(
            this, OnSuccessCallback_25, OnFailureCallback_25, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_25(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_25(uint32_t bitmap32)
    {
        VerifyOrReturn(CheckValue("bitmap32", bitmap32, 0UL));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeBitmap64DefaultValue_26()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap64::TypeInfo>(
            this, OnSuccessCallback_26, OnFailureCallback_26, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_26(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_26(uint64_t bitmap64)
    {
        VerifyOrReturn(CheckValue("bitmap64", bitmap64, 0ULL));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeBitmap64MaxValue_27()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint64_t bitmap64Argument;
        bitmap64Argument = 18446744073709551615ULL;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap64::TypeInfo>(
            bitmap64Argument, this, OnSuccessCallback_27, OnFailureCallback_27));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_27(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_27() { NextTest(); }

    CHIP_ERROR TestReadAttributeBitmap64MaxValue_28()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap64::TypeInfo>(
            this, OnSuccessCallback_28, OnFailureCallback_28, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_28(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_28(uint64_t bitmap64)
    {
        VerifyOrReturn(CheckValue("bitmap64", bitmap64, 18446744073709551615ULL));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeBitmap64MinValue_29()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint64_t bitmap64Argument;
        bitmap64Argument = 0ULL;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap64::TypeInfo>(
            bitmap64Argument, this, OnSuccessCallback_29, OnFailureCallback_29));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_29(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_29() { NextTest(); }

    CHIP_ERROR TestReadAttributeBitmap64MinValue_30()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap64::TypeInfo>(
            this, OnSuccessCallback_30, OnFailureCallback_30, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_30(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_30(uint64_t bitmap64)
    {
        VerifyOrReturn(CheckValue("bitmap64", bitmap64, 0ULL));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeInt8uDefaultValue_31()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int8u::TypeInfo>(
            this, OnSuccessCallback_31, OnFailureCallback_31, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_31(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_31(uint8_t int8u)
    {
        VerifyOrReturn(CheckValue("int8u", int8u, 0));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt8uMaxValue_32()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t int8uArgument;
        int8uArgument = 255;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int8u::TypeInfo>(
            int8uArgument, this, OnSuccessCallback_32, OnFailureCallback_32));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_32(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_32() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt8uMaxValue_33()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int8u::TypeInfo>(
            this, OnSuccessCallback_33, OnFailureCallback_33, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_33(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_33(uint8_t int8u)
    {
        VerifyOrReturn(CheckValue("int8u", int8u, 255));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt8uMinValue_34()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t int8uArgument;
        int8uArgument = 0;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int8u::TypeInfo>(
            int8uArgument, this, OnSuccessCallback_34, OnFailureCallback_34));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_34(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_34() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt8uMinValue_35()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int8u::TypeInfo>(
            this, OnSuccessCallback_35, OnFailureCallback_35, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_35(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_35(uint8_t int8u)
    {
        VerifyOrReturn(CheckValue("int8u", int8u, 0));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeInt16uDefaultValue_36()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int16u::TypeInfo>(
            this, OnSuccessCallback_36, OnFailureCallback_36, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_36(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_36(uint16_t int16u)
    {
        VerifyOrReturn(CheckValue("int16u", int16u, 0U));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt16uMaxValue_37()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t int16uArgument;
        int16uArgument = 65535U;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int16u::TypeInfo>(
            int16uArgument, this, OnSuccessCallback_37, OnFailureCallback_37));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_37(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_37() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt16uMaxValue_38()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int16u::TypeInfo>(
            this, OnSuccessCallback_38, OnFailureCallback_38, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_38(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_38(uint16_t int16u)
    {
        VerifyOrReturn(CheckValue("int16u", int16u, 65535U));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt16uMinValue_39()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t int16uArgument;
        int16uArgument = 0U;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int16u::TypeInfo>(
            int16uArgument, this, OnSuccessCallback_39, OnFailureCallback_39));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_39(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_39() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt16uMinValue_40()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int16u::TypeInfo>(
            this, OnSuccessCallback_40, OnFailureCallback_40, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_40(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_40(uint16_t int16u)
    {
        VerifyOrReturn(CheckValue("int16u", int16u, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeInt32uDefaultValue_41()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int32u::TypeInfo>(
            this, OnSuccessCallback_41, OnFailureCallback_41, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_41(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_41(uint32_t int32u)
    {
        VerifyOrReturn(CheckValue("int32u", int32u, 0UL));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt32uMaxValue_42()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint32_t int32uArgument;
        int32uArgument = 4294967295UL;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int32u::TypeInfo>(
            int32uArgument, this, OnSuccessCallback_42, OnFailureCallback_42));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_42(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_42() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt32uMaxValue_43()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int32u::TypeInfo>(
            this, OnSuccessCallback_43, OnFailureCallback_43, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_43(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_43(uint32_t int32u)
    {
        VerifyOrReturn(CheckValue("int32u", int32u, 4294967295UL));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt32uMinValue_44()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint32_t int32uArgument;
        int32uArgument = 0UL;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int32u::TypeInfo>(
            int32uArgument, this, OnSuccessCallback_44, OnFailureCallback_44));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_44(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_44() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt32uMinValue_45()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int32u::TypeInfo>(
            this, OnSuccessCallback_45, OnFailureCallback_45, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_45(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_45(uint32_t int32u)
    {
        VerifyOrReturn(CheckValue("int32u", int32u, 0UL));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeInt64uDefaultValue_46()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int64u::TypeInfo>(
            this, OnSuccessCallback_46, OnFailureCallback_46, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_46(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_46(uint64_t int64u)
    {
        VerifyOrReturn(CheckValue("int64u", int64u, 0ULL));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt64uMaxValue_47()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint64_t int64uArgument;
        int64uArgument = 18446744073709551615ULL;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int64u::TypeInfo>(
            int64uArgument, this, OnSuccessCallback_47, OnFailureCallback_47));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_47(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_47() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt64uMaxValue_48()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int64u::TypeInfo>(
            this, OnSuccessCallback_48, OnFailureCallback_48, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_48(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_48(uint64_t int64u)
    {
        VerifyOrReturn(CheckValue("int64u", int64u, 18446744073709551615ULL));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt64uMinValue_49()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint64_t int64uArgument;
        int64uArgument = 0ULL;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int64u::TypeInfo>(
            int64uArgument, this, OnSuccessCallback_49, OnFailureCallback_49));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_49(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_49() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt64uMinValue_50()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int64u::TypeInfo>(
            this, OnSuccessCallback_50, OnFailureCallback_50, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_50(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_50(uint64_t int64u)
    {
        VerifyOrReturn(CheckValue("int64u", int64u, 0ULL));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeInt8sDefaultValue_51()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int8s::TypeInfo>(
            this, OnSuccessCallback_51, OnFailureCallback_51, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_51(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_51(int8_t int8s)
    {
        VerifyOrReturn(CheckValue("int8s", int8s, 0));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt8sMaxValue_52()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int8_t int8sArgument;
        int8sArgument = 127;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int8s::TypeInfo>(
            int8sArgument, this, OnSuccessCallback_52, OnFailureCallback_52));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_52(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_52() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt8sMaxValue_53()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int8s::TypeInfo>(
            this, OnSuccessCallback_53, OnFailureCallback_53, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_53(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_53(int8_t int8s)
    {
        VerifyOrReturn(CheckValue("int8s", int8s, 127));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt8sMinValue_54()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int8_t int8sArgument;
        int8sArgument = -128;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int8s::TypeInfo>(
            int8sArgument, this, OnSuccessCallback_54, OnFailureCallback_54));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_54(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_54() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt8sMinValue_55()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int8s::TypeInfo>(
            this, OnSuccessCallback_55, OnFailureCallback_55, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_55(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_55(int8_t int8s)
    {
        VerifyOrReturn(CheckValue("int8s", int8s, -128));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt8sDefaultValue_56()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int8_t int8sArgument;
        int8sArgument = 0;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int8s::TypeInfo>(
            int8sArgument, this, OnSuccessCallback_56, OnFailureCallback_56));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_56(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_56() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt8sDefaultValue_57()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int8s::TypeInfo>(
            this, OnSuccessCallback_57, OnFailureCallback_57, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_57(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_57(int8_t int8s)
    {
        VerifyOrReturn(CheckValue("int8s", int8s, 0));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeInt16sDefaultValue_58()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int16s::TypeInfo>(
            this, OnSuccessCallback_58, OnFailureCallback_58, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_58(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_58(int16_t int16s)
    {
        VerifyOrReturn(CheckValue("int16s", int16s, 0));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt16sMaxValue_59()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t int16sArgument;
        int16sArgument = 32767;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int16s::TypeInfo>(
            int16sArgument, this, OnSuccessCallback_59, OnFailureCallback_59));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_59(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_59() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt16sMaxValue_60()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int16s::TypeInfo>(
            this, OnSuccessCallback_60, OnFailureCallback_60, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_60(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_60(int16_t int16s)
    {
        VerifyOrReturn(CheckValue("int16s", int16s, 32767));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt16sMinValue_61()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t int16sArgument;
        int16sArgument = -32768;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int16s::TypeInfo>(
            int16sArgument, this, OnSuccessCallback_61, OnFailureCallback_61));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_61(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_61() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt16sMinValue_62()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int16s::TypeInfo>(
            this, OnSuccessCallback_62, OnFailureCallback_62, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_62(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_62(int16_t int16s)
    {
        VerifyOrReturn(CheckValue("int16s", int16s, -32768));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt16sDefaultValue_63()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t int16sArgument;
        int16sArgument = 0;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int16s::TypeInfo>(
            int16sArgument, this, OnSuccessCallback_63, OnFailureCallback_63));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_63(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_63() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt16sDefaultValue_64()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int16s::TypeInfo>(
            this, OnSuccessCallback_64, OnFailureCallback_64, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_64(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_64(int16_t int16s)
    {
        VerifyOrReturn(CheckValue("int16s", int16s, 0));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeInt32sDefaultValue_65()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int32s::TypeInfo>(
            this, OnSuccessCallback_65, OnFailureCallback_65, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_65(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_65(int32_t int32s)
    {
        VerifyOrReturn(CheckValue("int32s", int32s, 0L));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt32sMaxValue_66()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int32_t int32sArgument;
        int32sArgument = 2147483647L;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int32s::TypeInfo>(
            int32sArgument, this, OnSuccessCallback_66, OnFailureCallback_66));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_66(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_66() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt32sMaxValue_67()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int32s::TypeInfo>(
            this, OnSuccessCallback_67, OnFailureCallback_67, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_67(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_67(int32_t int32s)
    {
        VerifyOrReturn(CheckValue("int32s", int32s, 2147483647L));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt32sMinValue_68()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int32_t int32sArgument;
        int32sArgument = -2147483648L;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int32s::TypeInfo>(
            int32sArgument, this, OnSuccessCallback_68, OnFailureCallback_68));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_68(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_68() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt32sMinValue_69()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int32s::TypeInfo>(
            this, OnSuccessCallback_69, OnFailureCallback_69, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_69(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_69(int32_t int32s)
    {
        VerifyOrReturn(CheckValue("int32s", int32s, -2147483648L));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt32sDefaultValue_70()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int32_t int32sArgument;
        int32sArgument = 0L;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int32s::TypeInfo>(
            int32sArgument, this, OnSuccessCallback_70, OnFailureCallback_70));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_70(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_70() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt32sDefaultValue_71()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int32s::TypeInfo>(
            this, OnSuccessCallback_71, OnFailureCallback_71, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_71(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_71(int32_t int32s)
    {
        VerifyOrReturn(CheckValue("int32s", int32s, 0L));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeInt64sDefaultValue_72()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int64s::TypeInfo>(
            this, OnSuccessCallback_72, OnFailureCallback_72, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_72(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_72(int64_t int64s)
    {
        VerifyOrReturn(CheckValue("int64s", int64s, 0LL));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt64sMaxValue_73()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int64_t int64sArgument;
        int64sArgument = 9223372036854775807LL;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int64s::TypeInfo>(
            int64sArgument, this, OnSuccessCallback_73, OnFailureCallback_73));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_73(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_73() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt64sMaxValue_74()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int64s::TypeInfo>(
            this, OnSuccessCallback_74, OnFailureCallback_74, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_74(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_74(int64_t int64s)
    {
        VerifyOrReturn(CheckValue("int64s", int64s, 9223372036854775807LL));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt64sMinValue_75()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int64_t int64sArgument;
        int64sArgument = -9223372036854775807LL;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int64s::TypeInfo>(
            int64sArgument, this, OnSuccessCallback_75, OnFailureCallback_75));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_75(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_75() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt64sMinValue_76()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int64s::TypeInfo>(
            this, OnSuccessCallback_76, OnFailureCallback_76, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_76(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_76(int64_t int64s)
    {
        VerifyOrReturn(CheckValue("int64s", int64s, -9223372036854775807LL));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt64sDefaultValue_77()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int64_t int64sArgument;
        int64sArgument = 0LL;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int64s::TypeInfo>(
            int64sArgument, this, OnSuccessCallback_77, OnFailureCallback_77));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_77(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_77() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt64sDefaultValue_78()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int64s::TypeInfo>(
            this, OnSuccessCallback_78, OnFailureCallback_78, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_78(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_78(int64_t int64s)
    {
        VerifyOrReturn(CheckValue("int64s", int64s, 0LL));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeSingleDefaultValue_79()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::FloatSingle::TypeInfo>(
            this, OnSuccessCallback_79, OnFailureCallback_79, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_79(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_79(float floatSingle)
    {
        VerifyOrReturn(CheckValue("floatSingle", floatSingle, 0.0f));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeSingleMediumValue_80()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        float floatSingleArgument;
        floatSingleArgument = 0.1f;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::FloatSingle::TypeInfo>(
            floatSingleArgument, this, OnSuccessCallback_80, OnFailureCallback_80));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_80(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_80() { NextTest(); }

    CHIP_ERROR TestReadAttributeSingleMediumValue_81()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::FloatSingle::TypeInfo>(
            this, OnSuccessCallback_81, OnFailureCallback_81, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_81(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_81(float floatSingle)
    {
        VerifyOrReturn(CheckValue("floatSingle", floatSingle, 0.1f));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeSingleLargeValue_82()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        float floatSingleArgument;
        floatSingleArgument = 17000000000.0f;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::FloatSingle::TypeInfo>(
            floatSingleArgument, this, OnSuccessCallback_82, OnFailureCallback_82));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_82(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_82() { NextTest(); }

    CHIP_ERROR TestReadAttributeSingleLargeValue_83()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::FloatSingle::TypeInfo>(
            this, OnSuccessCallback_83, OnFailureCallback_83, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_83(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_83(float floatSingle)
    {
        VerifyOrReturn(CheckValue("floatSingle", floatSingle, 17000000000.0f));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeSingleSmallValue_84()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        float floatSingleArgument;
        floatSingleArgument = 1.7e-10f;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::FloatSingle::TypeInfo>(
            floatSingleArgument, this, OnSuccessCallback_84, OnFailureCallback_84));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_84(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_84() { NextTest(); }

    CHIP_ERROR TestReadAttributeSingleSmallValue_85()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::FloatSingle::TypeInfo>(
            this, OnSuccessCallback_85, OnFailureCallback_85, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_85(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_85(float floatSingle)
    {
        VerifyOrReturn(CheckValue("floatSingle", floatSingle, 1.7e-10f));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeSingleDefaultValue_86()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        float floatSingleArgument;
        floatSingleArgument = 0.0f;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::FloatSingle::TypeInfo>(
            floatSingleArgument, this, OnSuccessCallback_86, OnFailureCallback_86));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_86(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_86() { NextTest(); }

    CHIP_ERROR TestReadAttributeSingleDefaultValue_87()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::FloatSingle::TypeInfo>(
            this, OnSuccessCallback_87, OnFailureCallback_87, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_87(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_87(float floatSingle)
    {
        VerifyOrReturn(CheckValue("floatSingle", floatSingle, 0.0f));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeDoubleDefaultValue_88()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::FloatDouble::TypeInfo>(
            this, OnSuccessCallback_88, OnFailureCallback_88, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_88(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_88(double floatDouble)
    {
        VerifyOrReturn(CheckValue("floatDouble", floatDouble, 0));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeDoubleMediumValue_89()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        double floatDoubleArgument;
        floatDoubleArgument = 0.1234567890123;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::FloatDouble::TypeInfo>(
            floatDoubleArgument, this, OnSuccessCallback_89, OnFailureCallback_89));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_89(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_89() { NextTest(); }

    CHIP_ERROR TestReadAttributeDoubleMediumValue_90()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::FloatDouble::TypeInfo>(
            this, OnSuccessCallback_90, OnFailureCallback_90, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_90(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_90(double floatDouble)
    {
        VerifyOrReturn(CheckValue("floatDouble", floatDouble, 0.1234567890123));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeDoubleLargeValue_91()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        double floatDoubleArgument;
        floatDoubleArgument = 1.7e+200;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::FloatDouble::TypeInfo>(
            floatDoubleArgument, this, OnSuccessCallback_91, OnFailureCallback_91));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_91(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_91() { NextTest(); }

    CHIP_ERROR TestReadAttributeDoubleLargeValue_92()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::FloatDouble::TypeInfo>(
            this, OnSuccessCallback_92, OnFailureCallback_92, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_92(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_92(double floatDouble)
    {
        VerifyOrReturn(CheckValue("floatDouble", floatDouble, 1.7e+200));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeDoubleSmallValue_93()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        double floatDoubleArgument;
        floatDoubleArgument = 1.7e-200;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::FloatDouble::TypeInfo>(
            floatDoubleArgument, this, OnSuccessCallback_93, OnFailureCallback_93));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_93(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_93() { NextTest(); }

    CHIP_ERROR TestReadAttributeDoubleSmallValue_94()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::FloatDouble::TypeInfo>(
            this, OnSuccessCallback_94, OnFailureCallback_94, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_94(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_94(double floatDouble)
    {
        VerifyOrReturn(CheckValue("floatDouble", floatDouble, 1.7e-200));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeDoubleDefaultValue_95()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        double floatDoubleArgument;
        floatDoubleArgument = 0;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::FloatDouble::TypeInfo>(
            floatDoubleArgument, this, OnSuccessCallback_95, OnFailureCallback_95));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_95(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_95() { NextTest(); }

    CHIP_ERROR TestReadAttributeDoubleDefaultValue_96()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::FloatDouble::TypeInfo>(
            this, OnSuccessCallback_96, OnFailureCallback_96, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_96(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_96(double floatDouble)
    {
        VerifyOrReturn(CheckValue("floatDouble", floatDouble, 0));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeEnum8DefaultValue_97()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Enum8::TypeInfo>(
            this, OnSuccessCallback_97, OnFailureCallback_97, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_97(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_97(uint8_t enum8)
    {
        VerifyOrReturn(CheckValue("enum8", enum8, 0));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeEnum8MaxValue_98()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t enum8Argument;
        enum8Argument = 255;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Enum8::TypeInfo>(
            enum8Argument, this, OnSuccessCallback_98, OnFailureCallback_98));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_98(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_98() { NextTest(); }

    CHIP_ERROR TestReadAttributeEnum8MaxValue_99()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Enum8::TypeInfo>(
            this, OnSuccessCallback_99, OnFailureCallback_99, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_99(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_99(uint8_t enum8)
    {
        VerifyOrReturn(CheckValue("enum8", enum8, 255));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeEnum8MinValue_100()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t enum8Argument;
        enum8Argument = 0;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Enum8::TypeInfo>(
            enum8Argument, this, OnSuccessCallback_100, OnFailureCallback_100));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_100(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_100() { NextTest(); }

    CHIP_ERROR TestReadAttributeEnum8MinValue_101()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Enum8::TypeInfo>(
            this, OnSuccessCallback_101, OnFailureCallback_101, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_101(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_101(uint8_t enum8)
    {
        VerifyOrReturn(CheckValue("enum8", enum8, 0));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeEnum16DefaultValue_102()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Enum16::TypeInfo>(
            this, OnSuccessCallback_102, OnFailureCallback_102, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_102(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_102(uint16_t enum16)
    {
        VerifyOrReturn(CheckValue("enum16", enum16, 0U));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeEnum16MaxValue_103()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t enum16Argument;
        enum16Argument = 65535U;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Enum16::TypeInfo>(
            enum16Argument, this, OnSuccessCallback_103, OnFailureCallback_103));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_103(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_103() { NextTest(); }

    CHIP_ERROR TestReadAttributeEnum16MaxValue_104()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Enum16::TypeInfo>(
            this, OnSuccessCallback_104, OnFailureCallback_104, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_104(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_104(uint16_t enum16)
    {
        VerifyOrReturn(CheckValue("enum16", enum16, 65535U));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeEnum16MinValue_105()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t enum16Argument;
        enum16Argument = 0U;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Enum16::TypeInfo>(
            enum16Argument, this, OnSuccessCallback_105, OnFailureCallback_105));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_105(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_105() { NextTest(); }

    CHIP_ERROR TestReadAttributeEnum16MinValue_106()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Enum16::TypeInfo>(
            this, OnSuccessCallback_106, OnFailureCallback_106, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_106(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_106(uint16_t enum16)
    {
        VerifyOrReturn(CheckValue("enum16", enum16, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeOctetStringDefaultValue_107()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::OctetString::TypeInfo>(
            this, OnSuccessCallback_107, OnFailureCallback_107, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_107(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_107(chip::ByteSpan octetString)
    {
        VerifyOrReturn(CheckValueAsString("octetString", octetString, chip::ByteSpan(chip::Uint8::from_const_char(""), 0)));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeOctetStringWithEmbeddedNull_108()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::ByteSpan octetStringArgument;
        octetStringArgument = chip::ByteSpan(chip::Uint8::from_const_char("Tes\x00ti\x00nggarbage: not in length on purpose"), 9);

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::OctetString::TypeInfo>(
            octetStringArgument, this, OnSuccessCallback_108, OnFailureCallback_108));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_108(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_108() { NextTest(); }

    CHIP_ERROR TestReadAttributeOctetStringWithEmbeddedNull_109()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::OctetString::TypeInfo>(
            this, OnSuccessCallback_109, OnFailureCallback_109, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_109(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_109(chip::ByteSpan octetString)
    {
        VerifyOrReturn(
            CheckValueAsString("octetString", octetString, chip::ByteSpan(chip::Uint8::from_const_char("Tes\x00ti\x00ng"), 9)));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeOctetStringWithWeirdChars_110()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::ByteSpan octetStringArgument;
        octetStringArgument =
            chip::ByteSpan(chip::Uint8::from_const_char("\x0d\x0a\xff\x22\xa0garbage: not in length on purpose"), 5);

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::OctetString::TypeInfo>(
            octetStringArgument, this, OnSuccessCallback_110, OnFailureCallback_110));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_110(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_110() { NextTest(); }

    CHIP_ERROR TestReadAttributeOctetStringWithWeirdChars_111()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::OctetString::TypeInfo>(
            this, OnSuccessCallback_111, OnFailureCallback_111, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_111(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_111(chip::ByteSpan octetString)
    {
        VerifyOrReturn(CheckValueAsString("octetString", octetString,
                                          chip::ByteSpan(chip::Uint8::from_const_char("\x0d\x0a\xff\x22\xa0"), 5)));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeOctetString_112()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::ByteSpan octetStringArgument;
        octetStringArgument = chip::ByteSpan(chip::Uint8::from_const_char("TestValuegarbage: not in length on purpose"), 9);

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::OctetString::TypeInfo>(
            octetStringArgument, this, OnSuccessCallback_112, OnFailureCallback_112));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_112(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_112() { NextTest(); }

    CHIP_ERROR TestReadAttributeOctetString_113()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::OctetString::TypeInfo>(
            this, OnSuccessCallback_113, OnFailureCallback_113, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_113(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_113(chip::ByteSpan octetString)
    {
        VerifyOrReturn(
            CheckValueAsString("octetString", octetString, chip::ByteSpan(chip::Uint8::from_const_char("TestValue"), 9)));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeOctetString_114()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::ByteSpan octetStringArgument;
        octetStringArgument =
            chip::ByteSpan(chip::Uint8::from_const_char("TestValueLongerThan10garbage: not in length on purpose"), 21);

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::OctetString::TypeInfo>(
            octetStringArgument, this, OnSuccessCallback_114, OnFailureCallback_114));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_114(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
        NextTest();
    }

    void OnSuccessResponse_114() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadAttributeOctetString_115()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::OctetString::TypeInfo>(
            this, OnSuccessCallback_115, OnFailureCallback_115, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_115(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_115(chip::ByteSpan octetString)
    {
        VerifyOrReturn(
            CheckValueAsString("octetString", octetString, chip::ByteSpan(chip::Uint8::from_const_char("TestValue"), 9)));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeOctetString_116()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::ByteSpan octetStringArgument;
        octetStringArgument = chip::ByteSpan(chip::Uint8::from_const_char("garbage: not in length on purpose"), 0);

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::OctetString::TypeInfo>(
            octetStringArgument, this, OnSuccessCallback_116, OnFailureCallback_116));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_116(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_116() { NextTest(); }

    CHIP_ERROR TestReadAttributeLongOctetStringDefaultValue_117()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::LongOctetString::TypeInfo>(
            this, OnSuccessCallback_117, OnFailureCallback_117, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_117(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_117(chip::ByteSpan longOctetString)
    {
        VerifyOrReturn(CheckValueAsString("longOctetString", longOctetString, chip::ByteSpan(chip::Uint8::from_const_char(""), 0)));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeLongOctetString_118()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::ByteSpan longOctetStringArgument;
        longOctetStringArgument = chip::ByteSpan(
            chip::Uint8::from_const_char(
                "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
                "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
                "111111111111111111111111111111111111111111111111111111111111111111111111garbage: not in length on purpose"),
            300);

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::LongOctetString::TypeInfo>(
            longOctetStringArgument, this, OnSuccessCallback_118, OnFailureCallback_118));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_118(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_118() { NextTest(); }

    CHIP_ERROR TestReadAttributeLongOctetString_119()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::LongOctetString::TypeInfo>(
            this, OnSuccessCallback_119, OnFailureCallback_119, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_119(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_119(chip::ByteSpan longOctetString)
    {
        VerifyOrReturn(CheckValueAsString(
            "longOctetString", longOctetString,
            chip::ByteSpan(
                chip::Uint8::from_const_char(
                    "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
                    "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
                    "11111111111111111111111111111111111111111111111111111111111111111111111111111111"),
                300)));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeLongOctetString_120()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::ByteSpan longOctetStringArgument;
        longOctetStringArgument = chip::ByteSpan(chip::Uint8::from_const_char("garbage: not in length on purpose"), 0);

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::LongOctetString::TypeInfo>(
            longOctetStringArgument, this, OnSuccessCallback_120, OnFailureCallback_120));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_120(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_120() { NextTest(); }

    CHIP_ERROR TestReadAttributeCharStringDefaultValue_121()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::CharString::TypeInfo>(
            this, OnSuccessCallback_121, OnFailureCallback_121, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_121(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_121(chip::CharSpan charString)
    {
        VerifyOrReturn(CheckValueAsString("charString", charString, chip::CharSpan("", 0)));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeCharString_122()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::CharSpan charStringArgument;
        charStringArgument = chip::Span<const char>("☉T☉garbage: not in length on purpose", 7);

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::CharString::TypeInfo>(
            charStringArgument, this, OnSuccessCallback_122, OnFailureCallback_122));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_122(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_122() { NextTest(); }

    CHIP_ERROR TestReadAttributeCharString_123()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::CharString::TypeInfo>(
            this, OnSuccessCallback_123, OnFailureCallback_123, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_123(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_123(chip::CharSpan charString)
    {
        VerifyOrReturn(CheckValueAsString("charString", charString, chip::CharSpan("☉T☉", 7)));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeCharStringValueTooLong_124()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::CharSpan charStringArgument;
        charStringArgument = chip::Span<const char>("☉TestValueLongerThan10☉garbage: not in length on purpose", 27);

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::CharString::TypeInfo>(
            charStringArgument, this, OnSuccessCallback_124, OnFailureCallback_124));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_124(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
        NextTest();
    }

    void OnSuccessResponse_124() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadAttributeCharString_125()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::CharString::TypeInfo>(
            this, OnSuccessCallback_125, OnFailureCallback_125, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_125(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_125(chip::CharSpan charString)
    {
        VerifyOrReturn(CheckValueAsString("charString", charString, chip::CharSpan("☉T☉", 7)));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeCharStringEmpty_126()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::CharSpan charStringArgument;
        charStringArgument = chip::Span<const char>("garbage: not in length on purpose", 0);

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::CharString::TypeInfo>(
            charStringArgument, this, OnSuccessCallback_126, OnFailureCallback_126));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_126(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_126() { NextTest(); }

    CHIP_ERROR TestReadAttributeLongCharStringDefaultValue_127()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::LongCharString::TypeInfo>(
            this, OnSuccessCallback_127, OnFailureCallback_127, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_127(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_127(chip::CharSpan longCharString)
    {
        VerifyOrReturn(CheckValueAsString("longCharString", longCharString, chip::CharSpan("", 0)));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeLongCharString_128()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::CharSpan longCharStringArgument;
        longCharStringArgument = chip::Span<const char>(
            "☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉"
            "☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉"
            "☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉garbage: not in length on purpose",
            900);

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::LongCharString::TypeInfo>(
            longCharStringArgument, this, OnSuccessCallback_128, OnFailureCallback_128));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_128(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_128() { NextTest(); }

    CHIP_ERROR TestReadAttributeLongCharString_129()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::LongCharString::TypeInfo>(
            this, OnSuccessCallback_129, OnFailureCallback_129, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_129(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_129(chip::CharSpan longCharString)
    {
        VerifyOrReturn(CheckValueAsString(
            "longCharString", longCharString,
            chip::CharSpan("☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉"
                           "☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉"
                           "☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉",
                           900)));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeLongCharString_130()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::CharSpan longCharStringArgument;
        longCharStringArgument = chip::Span<const char>("garbage: not in length on purpose", 0);

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::LongCharString::TypeInfo>(
            longCharStringArgument, this, OnSuccessCallback_130, OnFailureCallback_130));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_130(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_130() { NextTest(); }

    CHIP_ERROR TestReadAttributeListLongOctetStringForChunkedRead_131()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::ListLongOctetString::TypeInfo>(
            this, OnSuccessCallback_131, OnFailureCallback_131, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_131(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_131(const chip::app::DataModel::DecodableList<chip::ByteSpan> & listLongOctetString)
    {
        {
            auto iter_0 = listLongOctetString.begin();
            VerifyOrReturn(CheckNextListItemDecodes<decltype(listLongOctetString)>("listLongOctetString", iter_0, 0));
            VerifyOrReturn(CheckValueAsString(
                "listLongOctetString[0]", iter_0.GetValue(),
                chip::ByteSpan(
                    chip::Uint8::from_const_char(
                        "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789"
                        "abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123"
                        "456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcd"
                        "ef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef01234567"
                        "89abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"),
                    512)));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(listLongOctetString)>("listLongOctetString", iter_0, 1));
            VerifyOrReturn(CheckValueAsString(
                "listLongOctetString[1]", iter_0.GetValue(),
                chip::ByteSpan(
                    chip::Uint8::from_const_char(
                        "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789"
                        "abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123"
                        "456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcd"
                        "ef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef01234567"
                        "89abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"),
                    512)));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(listLongOctetString)>("listLongOctetString", iter_0, 2));
            VerifyOrReturn(CheckValueAsString(
                "listLongOctetString[2]", iter_0.GetValue(),
                chip::ByteSpan(
                    chip::Uint8::from_const_char(
                        "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789"
                        "abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123"
                        "456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcd"
                        "ef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef01234567"
                        "89abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"),
                    512)));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(listLongOctetString)>("listLongOctetString", iter_0, 3));
            VerifyOrReturn(CheckValueAsString(
                "listLongOctetString[3]", iter_0.GetValue(),
                chip::ByteSpan(
                    chip::Uint8::from_const_char(
                        "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789"
                        "abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123"
                        "456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcd"
                        "ef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef01234567"
                        "89abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"),
                    512)));
            VerifyOrReturn(CheckNoMoreListItems<decltype(listLongOctetString)>("listLongOctetString", iter_0, 4));
        }

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeListLongOctetStringForChunkedWrite_132()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ListFreer listFreer;
        chip::app::DataModel::List<const chip::ByteSpan> listLongOctetStringArgument;

        {
            auto * listHolder_0 = new ListHolder<chip::ByteSpan>(5);
            listFreer.add(listHolder_0);
            listHolder_0->mList[0] = chip::ByteSpan(
                chip::Uint8::from_const_char(
                    "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcd"
                    "ef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789ab"
                    "cdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789"
                    "abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef01234567"
                    "89abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdefgarbage: not in length on purpose"),
                512);
            listHolder_0->mList[1] = chip::ByteSpan(
                chip::Uint8::from_const_char(
                    "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcd"
                    "ef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789ab"
                    "cdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789"
                    "abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef01234567"
                    "89abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdefgarbage: not in length on purpose"),
                512);
            listHolder_0->mList[2] = chip::ByteSpan(
                chip::Uint8::from_const_char(
                    "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcd"
                    "ef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789ab"
                    "cdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789"
                    "abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef01234567"
                    "89abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdefgarbage: not in length on purpose"),
                512);
            listHolder_0->mList[3] = chip::ByteSpan(
                chip::Uint8::from_const_char(
                    "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcd"
                    "ef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789ab"
                    "cdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789"
                    "abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef01234567"
                    "89abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdefgarbage: not in length on purpose"),
                512);
            listHolder_0->mList[4] = chip::ByteSpan(
                chip::Uint8::from_const_char(
                    "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcd"
                    "ef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789ab"
                    "cdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789"
                    "abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef01234567"
                    "89abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdefgarbage: not in length on purpose"),
                512);
            listLongOctetStringArgument = chip::app::DataModel::List<chip::ByteSpan>(listHolder_0->mList, 5);
        }

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::ListLongOctetString::TypeInfo>(
            listLongOctetStringArgument, this, OnSuccessCallback_132, OnFailureCallback_132));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_132(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_132() { NextTest(); }

    CHIP_ERROR TestReadAttributeListLongOctetStringForChunkedRead_133()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::ListLongOctetString::TypeInfo>(
            this, OnSuccessCallback_133, OnFailureCallback_133, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_133(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_133(const chip::app::DataModel::DecodableList<chip::ByteSpan> & listLongOctetString)
    {
        {
            auto iter_0 = listLongOctetString.begin();
            VerifyOrReturn(CheckNextListItemDecodes<decltype(listLongOctetString)>("listLongOctetString", iter_0, 0));
            VerifyOrReturn(CheckValueAsString(
                "listLongOctetString[0]", iter_0.GetValue(),
                chip::ByteSpan(
                    chip::Uint8::from_const_char(
                        "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789"
                        "abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123"
                        "456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcd"
                        "ef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef01234567"
                        "89abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"),
                    512)));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(listLongOctetString)>("listLongOctetString", iter_0, 1));
            VerifyOrReturn(CheckValueAsString(
                "listLongOctetString[1]", iter_0.GetValue(),
                chip::ByteSpan(
                    chip::Uint8::from_const_char(
                        "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789"
                        "abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123"
                        "456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcd"
                        "ef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef01234567"
                        "89abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"),
                    512)));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(listLongOctetString)>("listLongOctetString", iter_0, 2));
            VerifyOrReturn(CheckValueAsString(
                "listLongOctetString[2]", iter_0.GetValue(),
                chip::ByteSpan(
                    chip::Uint8::from_const_char(
                        "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789"
                        "abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123"
                        "456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcd"
                        "ef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef01234567"
                        "89abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"),
                    512)));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(listLongOctetString)>("listLongOctetString", iter_0, 3));
            VerifyOrReturn(CheckValueAsString(
                "listLongOctetString[3]", iter_0.GetValue(),
                chip::ByteSpan(
                    chip::Uint8::from_const_char(
                        "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789"
                        "abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123"
                        "456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcd"
                        "ef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef01234567"
                        "89abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"),
                    512)));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(listLongOctetString)>("listLongOctetString", iter_0, 4));
            VerifyOrReturn(CheckValueAsString(
                "listLongOctetString[4]", iter_0.GetValue(),
                chip::ByteSpan(
                    chip::Uint8::from_const_char(
                        "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789"
                        "abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123"
                        "456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcd"
                        "ef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef01234567"
                        "89abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"),
                    512)));
            VerifyOrReturn(CheckNoMoreListItems<decltype(listLongOctetString)>("listLongOctetString", iter_0, 5));
        }

        NextTest();
    }

    CHIP_ERROR TestReadAttributeEpochUsDefaultValue_134()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::EpochUs::TypeInfo>(
            this, OnSuccessCallback_134, OnFailureCallback_134, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_134(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_134(uint64_t epochUs)
    {
        VerifyOrReturn(CheckValue("epochUs", epochUs, 0ULL));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeEpochUsMaxValue_135()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint64_t epochUsArgument;
        epochUsArgument = 18446744073709551615ULL;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::EpochUs::TypeInfo>(
            epochUsArgument, this, OnSuccessCallback_135, OnFailureCallback_135));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_135(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_135() { NextTest(); }

    CHIP_ERROR TestReadAttributeEpochUsMaxValue_136()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::EpochUs::TypeInfo>(
            this, OnSuccessCallback_136, OnFailureCallback_136, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_136(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_136(uint64_t epochUs)
    {
        VerifyOrReturn(CheckValue("epochUs", epochUs, 18446744073709551615ULL));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeEpochUsMinValue_137()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint64_t epochUsArgument;
        epochUsArgument = 0ULL;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::EpochUs::TypeInfo>(
            epochUsArgument, this, OnSuccessCallback_137, OnFailureCallback_137));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_137(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_137() { NextTest(); }

    CHIP_ERROR TestReadAttributeEpochUsMinValue_138()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::EpochUs::TypeInfo>(
            this, OnSuccessCallback_138, OnFailureCallback_138, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_138(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_138(uint64_t epochUs)
    {
        VerifyOrReturn(CheckValue("epochUs", epochUs, 0ULL));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeEpochSDefaultValue_139()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::EpochS::TypeInfo>(
            this, OnSuccessCallback_139, OnFailureCallback_139, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_139(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_139(uint32_t epochS)
    {
        VerifyOrReturn(CheckValue("epochS", epochS, 0UL));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeEpochSMaxValue_140()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint32_t epochSArgument;
        epochSArgument = 4294967295UL;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::EpochS::TypeInfo>(
            epochSArgument, this, OnSuccessCallback_140, OnFailureCallback_140));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_140(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_140() { NextTest(); }

    CHIP_ERROR TestReadAttributeEpochSMaxValue_141()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::EpochS::TypeInfo>(
            this, OnSuccessCallback_141, OnFailureCallback_141, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_141(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_141(uint32_t epochS)
    {
        VerifyOrReturn(CheckValue("epochS", epochS, 4294967295UL));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeEpochSMinValue_142()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint32_t epochSArgument;
        epochSArgument = 0UL;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::EpochS::TypeInfo>(
            epochSArgument, this, OnSuccessCallback_142, OnFailureCallback_142));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_142(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_142() { NextTest(); }

    CHIP_ERROR TestReadAttributeEpochSMinValue_143()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::EpochS::TypeInfo>(
            this, OnSuccessCallback_143, OnFailureCallback_143, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_143(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_143(uint32_t epochS)
    {
        VerifyOrReturn(CheckValue("epochS", epochS, 0UL));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeUnsupported_144()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Unsupported::TypeInfo>(
            this, OnSuccessCallback_144, OnFailureCallback_144, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_144(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_144(bool unsupported)
    {
        VerifyOrReturn(CheckValue("unsupported", unsupported, 0));

        NextTest();
    }

    CHIP_ERROR TestWriteattributeUnsupported_145()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        bool unsupportedArgument;
        unsupportedArgument = 0;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Unsupported::TypeInfo>(
            unsupportedArgument, this, OnSuccessCallback_145, OnFailureCallback_145));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_145(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_145() { NextTest(); }

    CHIP_ERROR TestSendTestCommandToUnsupportedEndpoint_146()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 200;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::Test::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_146();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestClusterSuite *>(context))->OnFailureResponse_146(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_146(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_ENDPOINT));
        NextTest();
    }

    void OnSuccessResponse_146() { ThrowSuccessResponse(); }

    CHIP_ERROR TestSendTestCommandToUnsupportedCluster_147()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::Test::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_147();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestClusterSuite *>(context))->OnFailureResponse_147(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_147(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_CLUSTER));
        NextTest();
    }

    void OnSuccessResponse_147() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadAttributeVendorIdDefaultValue_148()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::VendorId::TypeInfo>(
            this, OnSuccessCallback_148, OnFailureCallback_148, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_148(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_148(chip::VendorId vendorId)
    {
        VerifyOrReturn(CheckValue("vendorId", vendorId, 0U));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeVendorId_149()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::VendorId vendorIdArgument;
        vendorIdArgument = static_cast<chip::VendorId>(17);

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::VendorId::TypeInfo>(
            vendorIdArgument, this, OnSuccessCallback_149, OnFailureCallback_149));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_149(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_149() { NextTest(); }

    CHIP_ERROR TestReadAttributeVendorId_150()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::VendorId::TypeInfo>(
            this, OnSuccessCallback_150, OnFailureCallback_150, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_150(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_150(chip::VendorId vendorId)
    {
        VerifyOrReturn(CheckValue("vendorId", vendorId, 17U));

        NextTest();
    }

    CHIP_ERROR TestRestoreAttributeVendorId_151()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::VendorId vendorIdArgument;
        vendorIdArgument = static_cast<chip::VendorId>(0);

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::VendorId::TypeInfo>(
            vendorIdArgument, this, OnSuccessCallback_151, OnFailureCallback_151));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_151(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_151() { NextTest(); }

    CHIP_ERROR TestSendACommandWithAVendorIdAndEnum_152()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::TestEnumsRequest::Type;

        RequestType request;
        request.arg1 = static_cast<chip::VendorId>(20003);
        request.arg2 = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(101);

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_152(data.arg1, data.arg2);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestClusterSuite *>(context))->OnFailureResponse_152(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_152(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_152(chip::VendorId arg1, chip::app::Clusters::TestCluster::SimpleEnum arg2)
    {
        VerifyOrReturn(CheckValue("arg1", arg1, 20003U));

        VerifyOrReturn(CheckValue("arg2", arg2, 101));

        NextTest();
    }

    CHIP_ERROR TestSendTestCommandWithStructArgumentAndArg1bIsTrue_153()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::TestStructArgumentRequest::Type;

        RequestType request;

        request.arg1.a = 0;
        request.arg1.b = true;
        request.arg1.c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(2);
        request.arg1.d = chip::ByteSpan(chip::Uint8::from_const_char("octet_stringgarbage: not in length on purpose"), 12);
        request.arg1.e = chip::Span<const char>("char_stringgarbage: not in length on purpose", 11);
        request.arg1.f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);
        request.arg1.g = 0.0f;
        request.arg1.h = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_153(data.value);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestClusterSuite *>(context))->OnFailureResponse_153(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_153(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_153(bool value)
    {
        VerifyOrReturn(CheckValue("value", value, true));

        NextTest();
    }

    CHIP_ERROR TestSendTestCommandWithStructArgumentAndArg1bIsFalse_154()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::TestStructArgumentRequest::Type;

        RequestType request;

        request.arg1.a = 0;
        request.arg1.b = false;
        request.arg1.c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(2);
        request.arg1.d = chip::ByteSpan(chip::Uint8::from_const_char("octet_stringgarbage: not in length on purpose"), 12);
        request.arg1.e = chip::Span<const char>("char_stringgarbage: not in length on purpose", 11);
        request.arg1.f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);
        request.arg1.g = 0.0f;
        request.arg1.h = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_154(data.value);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestClusterSuite *>(context))->OnFailureResponse_154(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_154(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_154(bool value)
    {
        VerifyOrReturn(CheckValue("value", value, false));

        NextTest();
    }

    CHIP_ERROR TestSendTestCommandWithNestedStructArgumentAndArg1cbIsTrue_155()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::TestNestedStructArgumentRequest::Type;

        RequestType request;

        request.arg1.a = 0;
        request.arg1.b = true;

        request.arg1.c.a = 0;
        request.arg1.c.b = true;
        request.arg1.c.c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(2);
        request.arg1.c.d = chip::ByteSpan(chip::Uint8::from_const_char("octet_stringgarbage: not in length on purpose"), 12);
        request.arg1.c.e = chip::Span<const char>("char_stringgarbage: not in length on purpose", 11);
        request.arg1.c.f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);
        request.arg1.c.g = 0.0f;
        request.arg1.c.h = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_155(data.value);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestClusterSuite *>(context))->OnFailureResponse_155(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_155(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_155(bool value)
    {
        VerifyOrReturn(CheckValue("value", value, true));

        NextTest();
    }

    CHIP_ERROR TestSendTestCommandWithNestedStructArgumentArg1cbIsFalse_156()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::TestNestedStructArgumentRequest::Type;

        RequestType request;

        request.arg1.a = 0;
        request.arg1.b = true;

        request.arg1.c.a = 0;
        request.arg1.c.b = false;
        request.arg1.c.c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(2);
        request.arg1.c.d = chip::ByteSpan(chip::Uint8::from_const_char("octet_stringgarbage: not in length on purpose"), 12);
        request.arg1.c.e = chip::Span<const char>("char_stringgarbage: not in length on purpose", 11);
        request.arg1.c.f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);
        request.arg1.c.g = 0.0f;
        request.arg1.c.h = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_156(data.value);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestClusterSuite *>(context))->OnFailureResponse_156(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_156(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_156(bool value)
    {
        VerifyOrReturn(CheckValue("value", value, false));

        NextTest();
    }

    CHIP_ERROR TestSendTestCommandWithNestedStructListArgumentAndAllFieldsBOfArg1dAreTrue_157()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::TestNestedStructListArgumentRequest::Type;

        ListFreer listFreer;
        RequestType request;

        request.arg1.a = 0;
        request.arg1.b = true;

        request.arg1.c.a = 0;
        request.arg1.c.b = true;
        request.arg1.c.c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(2);
        request.arg1.c.d = chip::ByteSpan(chip::Uint8::from_const_char("octet_stringgarbage: not in length on purpose"), 12);
        request.arg1.c.e = chip::Span<const char>("char_stringgarbage: not in length on purpose", 11);
        request.arg1.c.f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);
        request.arg1.c.g = 0.0f;
        request.arg1.c.h = 0;

        {
            auto * listHolder_1 = new ListHolder<chip::app::Clusters::TestCluster::Structs::SimpleStruct::Type>(2);
            listFreer.add(listHolder_1);

            listHolder_1->mList[0].a = 1;
            listHolder_1->mList[0].b = true;
            listHolder_1->mList[0].c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(3);
            listHolder_1->mList[0].d =
                chip::ByteSpan(chip::Uint8::from_const_char("nested_octet_stringgarbage: not in length on purpose"), 19);
            listHolder_1->mList[0].e = chip::Span<const char>("nested_char_stringgarbage: not in length on purpose", 18);
            listHolder_1->mList[0].f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);
            listHolder_1->mList[0].g = 0.0f;
            listHolder_1->mList[0].h = 0;

            listHolder_1->mList[1].a = 2;
            listHolder_1->mList[1].b = true;
            listHolder_1->mList[1].c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(3);
            listHolder_1->mList[1].d =
                chip::ByteSpan(chip::Uint8::from_const_char("nested_octet_stringgarbage: not in length on purpose"), 19);
            listHolder_1->mList[1].e = chip::Span<const char>("nested_char_stringgarbage: not in length on purpose", 18);
            listHolder_1->mList[1].f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);
            listHolder_1->mList[1].g = 0.0f;
            listHolder_1->mList[1].h = 0;

            request.arg1.d =
                chip::app::DataModel::List<chip::app::Clusters::TestCluster::Structs::SimpleStruct::Type>(listHolder_1->mList, 2);
        }

        {
            auto * listHolder_1 = new ListHolder<uint32_t>(3);
            listFreer.add(listHolder_1);
            listHolder_1->mList[0] = 1UL;
            listHolder_1->mList[1] = 2UL;
            listHolder_1->mList[2] = 3UL;
            request.arg1.e         = chip::app::DataModel::List<uint32_t>(listHolder_1->mList, 3);
        }

        {
            auto * listHolder_1 = new ListHolder<chip::ByteSpan>(3);
            listFreer.add(listHolder_1);
            listHolder_1->mList[0] =
                chip::ByteSpan(chip::Uint8::from_const_char("octet_string_1garbage: not in length on purpose"), 14);
            listHolder_1->mList[1] =
                chip::ByteSpan(chip::Uint8::from_const_char("octect_string_2garbage: not in length on purpose"), 15);
            listHolder_1->mList[2] =
                chip::ByteSpan(chip::Uint8::from_const_char("octet_string_3garbage: not in length on purpose"), 14);
            request.arg1.f = chip::app::DataModel::List<chip::ByteSpan>(listHolder_1->mList, 3);
        }

        {
            auto * listHolder_1 = new ListHolder<uint8_t>(2);
            listFreer.add(listHolder_1);
            listHolder_1->mList[0] = 0;
            listHolder_1->mList[1] = 255;
            request.arg1.g         = chip::app::DataModel::List<uint8_t>(listHolder_1->mList, 2);
        }

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_157(data.value);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestClusterSuite *>(context))->OnFailureResponse_157(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_157(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_157(bool value)
    {
        VerifyOrReturn(CheckValue("value", value, true));

        NextTest();
    }

    CHIP_ERROR TestSendTestCommandWithNestedStructListArgumentAndSomeFieldsBOfArg1dAreFalse_158()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::TestNestedStructListArgumentRequest::Type;

        ListFreer listFreer;
        RequestType request;

        request.arg1.a = 0;
        request.arg1.b = true;

        request.arg1.c.a = 0;
        request.arg1.c.b = true;
        request.arg1.c.c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(2);
        request.arg1.c.d = chip::ByteSpan(chip::Uint8::from_const_char("octet_stringgarbage: not in length on purpose"), 12);
        request.arg1.c.e = chip::Span<const char>("char_stringgarbage: not in length on purpose", 11);
        request.arg1.c.f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);
        request.arg1.c.g = 0.0f;
        request.arg1.c.h = 0;

        {
            auto * listHolder_1 = new ListHolder<chip::app::Clusters::TestCluster::Structs::SimpleStruct::Type>(2);
            listFreer.add(listHolder_1);

            listHolder_1->mList[0].a = 1;
            listHolder_1->mList[0].b = true;
            listHolder_1->mList[0].c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(3);
            listHolder_1->mList[0].d =
                chip::ByteSpan(chip::Uint8::from_const_char("nested_octet_stringgarbage: not in length on purpose"), 19);
            listHolder_1->mList[0].e = chip::Span<const char>("nested_char_stringgarbage: not in length on purpose", 18);
            listHolder_1->mList[0].f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);
            listHolder_1->mList[0].g = 0.0f;
            listHolder_1->mList[0].h = 0;

            listHolder_1->mList[1].a = 2;
            listHolder_1->mList[1].b = false;
            listHolder_1->mList[1].c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(3);
            listHolder_1->mList[1].d =
                chip::ByteSpan(chip::Uint8::from_const_char("nested_octet_stringgarbage: not in length on purpose"), 19);
            listHolder_1->mList[1].e = chip::Span<const char>("nested_char_stringgarbage: not in length on purpose", 18);
            listHolder_1->mList[1].f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);
            listHolder_1->mList[1].g = 0.0f;
            listHolder_1->mList[1].h = 0;

            request.arg1.d =
                chip::app::DataModel::List<chip::app::Clusters::TestCluster::Structs::SimpleStruct::Type>(listHolder_1->mList, 2);
        }

        {
            auto * listHolder_1 = new ListHolder<uint32_t>(3);
            listFreer.add(listHolder_1);
            listHolder_1->mList[0] = 1UL;
            listHolder_1->mList[1] = 2UL;
            listHolder_1->mList[2] = 3UL;
            request.arg1.e         = chip::app::DataModel::List<uint32_t>(listHolder_1->mList, 3);
        }

        {
            auto * listHolder_1 = new ListHolder<chip::ByteSpan>(3);
            listFreer.add(listHolder_1);
            listHolder_1->mList[0] =
                chip::ByteSpan(chip::Uint8::from_const_char("octet_string_1garbage: not in length on purpose"), 14);
            listHolder_1->mList[1] =
                chip::ByteSpan(chip::Uint8::from_const_char("octect_string_2garbage: not in length on purpose"), 15);
            listHolder_1->mList[2] =
                chip::ByteSpan(chip::Uint8::from_const_char("octet_string_3garbage: not in length on purpose"), 14);
            request.arg1.f = chip::app::DataModel::List<chip::ByteSpan>(listHolder_1->mList, 3);
        }

        {
            auto * listHolder_1 = new ListHolder<uint8_t>(2);
            listFreer.add(listHolder_1);
            listHolder_1->mList[0] = 0;
            listHolder_1->mList[1] = 255;
            request.arg1.g         = chip::app::DataModel::List<uint8_t>(listHolder_1->mList, 2);
        }

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_158(data.value);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestClusterSuite *>(context))->OnFailureResponse_158(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_158(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_158(bool value)
    {
        VerifyOrReturn(CheckValue("value", value, false));

        NextTest();
    }

    CHIP_ERROR TestSendTestCommandWithStructArgumentAndSeeWhatWeGetBack_159()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::SimpleStructEchoRequest::Type;

        RequestType request;

        request.arg1.a = 17;
        request.arg1.b = false;
        request.arg1.c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(2);
        request.arg1.d = chip::ByteSpan(chip::Uint8::from_const_char("octet_stringgarbage: not in length on purpose"), 12);
        request.arg1.e = chip::Span<const char>("char_stringgarbage: not in length on purpose", 11);
        request.arg1.f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);
        request.arg1.g = 0.1f;
        request.arg1.h = 0.1;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_159(data.arg1);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestClusterSuite *>(context))->OnFailureResponse_159(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_159(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_159(const chip::app::Clusters::TestCluster::Structs::SimpleStruct::DecodableType & arg1)
    {
        VerifyOrReturn(CheckValue("arg1.a", arg1.a, 17));
        VerifyOrReturn(CheckValue("arg1.b", arg1.b, false));
        VerifyOrReturn(CheckValue("arg1.c", arg1.c, 2));
        VerifyOrReturn(CheckValueAsString("arg1.d", arg1.d, chip::ByteSpan(chip::Uint8::from_const_char("octet_string"), 12)));
        VerifyOrReturn(CheckValueAsString("arg1.e", arg1.e, chip::CharSpan("char_string", 11)));
        VerifyOrReturn(CheckValue("arg1.f", arg1.f, 1));
        VerifyOrReturn(CheckValue("arg1.g", arg1.g, 0.1f));
        VerifyOrReturn(CheckValue("arg1.h", arg1.h, 0.1));

        NextTest();
    }

    CHIP_ERROR TestSendTestCommandWithListOfInt8uAndNoneOfThemIsSetTo0_160()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::TestListInt8UArgumentRequest::Type;

        ListFreer listFreer;
        RequestType request;

        {
            auto * listHolder_0 = new ListHolder<uint8_t>(9);
            listFreer.add(listHolder_0);
            listHolder_0->mList[0] = 1;
            listHolder_0->mList[1] = 2;
            listHolder_0->mList[2] = 3;
            listHolder_0->mList[3] = 4;
            listHolder_0->mList[4] = 5;
            listHolder_0->mList[5] = 6;
            listHolder_0->mList[6] = 7;
            listHolder_0->mList[7] = 8;
            listHolder_0->mList[8] = 9;
            request.arg1           = chip::app::DataModel::List<uint8_t>(listHolder_0->mList, 9);
        }

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_160(data.value);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestClusterSuite *>(context))->OnFailureResponse_160(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_160(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_160(bool value)
    {
        VerifyOrReturn(CheckValue("value", value, true));

        NextTest();
    }

    CHIP_ERROR TestSendTestCommandWithListOfInt8uAndOneOfThemIsSetTo0_161()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::TestListInt8UArgumentRequest::Type;

        ListFreer listFreer;
        RequestType request;

        {
            auto * listHolder_0 = new ListHolder<uint8_t>(10);
            listFreer.add(listHolder_0);
            listHolder_0->mList[0] = 1;
            listHolder_0->mList[1] = 2;
            listHolder_0->mList[2] = 3;
            listHolder_0->mList[3] = 4;
            listHolder_0->mList[4] = 5;
            listHolder_0->mList[5] = 6;
            listHolder_0->mList[6] = 7;
            listHolder_0->mList[7] = 8;
            listHolder_0->mList[8] = 9;
            listHolder_0->mList[9] = 0;
            request.arg1           = chip::app::DataModel::List<uint8_t>(listHolder_0->mList, 10);
        }

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_161(data.value);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestClusterSuite *>(context))->OnFailureResponse_161(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_161(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_161(bool value)
    {
        VerifyOrReturn(CheckValue("value", value, false));

        NextTest();
    }

    CHIP_ERROR TestSendTestCommandWithListOfInt8uAndGetItReversed_162()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::TestListInt8UReverseRequest::Type;

        ListFreer listFreer;
        RequestType request;

        {
            auto * listHolder_0 = new ListHolder<uint8_t>(9);
            listFreer.add(listHolder_0);
            listHolder_0->mList[0] = 1;
            listHolder_0->mList[1] = 2;
            listHolder_0->mList[2] = 3;
            listHolder_0->mList[3] = 4;
            listHolder_0->mList[4] = 5;
            listHolder_0->mList[5] = 6;
            listHolder_0->mList[6] = 7;
            listHolder_0->mList[7] = 8;
            listHolder_0->mList[8] = 9;
            request.arg1           = chip::app::DataModel::List<uint8_t>(listHolder_0->mList, 9);
        }

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_162(data.arg1);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestClusterSuite *>(context))->OnFailureResponse_162(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_162(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_162(const chip::app::DataModel::DecodableList<uint8_t> & arg1)
    {
        {
            auto iter_0 = arg1.begin();
            VerifyOrReturn(CheckNextListItemDecodes<decltype(arg1)>("arg1", iter_0, 0));
            VerifyOrReturn(CheckValue("arg1[0]", iter_0.GetValue(), 9));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(arg1)>("arg1", iter_0, 1));
            VerifyOrReturn(CheckValue("arg1[1]", iter_0.GetValue(), 8));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(arg1)>("arg1", iter_0, 2));
            VerifyOrReturn(CheckValue("arg1[2]", iter_0.GetValue(), 7));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(arg1)>("arg1", iter_0, 3));
            VerifyOrReturn(CheckValue("arg1[3]", iter_0.GetValue(), 6));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(arg1)>("arg1", iter_0, 4));
            VerifyOrReturn(CheckValue("arg1[4]", iter_0.GetValue(), 5));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(arg1)>("arg1", iter_0, 5));
            VerifyOrReturn(CheckValue("arg1[5]", iter_0.GetValue(), 4));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(arg1)>("arg1", iter_0, 6));
            VerifyOrReturn(CheckValue("arg1[6]", iter_0.GetValue(), 3));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(arg1)>("arg1", iter_0, 7));
            VerifyOrReturn(CheckValue("arg1[7]", iter_0.GetValue(), 2));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(arg1)>("arg1", iter_0, 8));
            VerifyOrReturn(CheckValue("arg1[8]", iter_0.GetValue(), 1));
            VerifyOrReturn(CheckNoMoreListItems<decltype(arg1)>("arg1", iter_0, 9));
        }

        NextTest();
    }

    CHIP_ERROR TestSendTestCommandWithEmptyListOfInt8uAndGetAnEmptyListBack_163()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::TestListInt8UReverseRequest::Type;

        ListFreer listFreer;
        RequestType request;

        request.arg1 = chip::app::DataModel::List<uint8_t>();

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_163(data.arg1);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestClusterSuite *>(context))->OnFailureResponse_163(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_163(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_163(const chip::app::DataModel::DecodableList<uint8_t> & arg1)
    {
        {
            auto iter_0 = arg1.begin();
            VerifyOrReturn(CheckNoMoreListItems<decltype(arg1)>("arg1", iter_0, 0));
        }

        NextTest();
    }

    CHIP_ERROR TestSendTestCommandWithListOfStructArgumentAndArg1bOfFirstItemIsTrue_164()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::TestListStructArgumentRequest::Type;

        ListFreer listFreer;
        RequestType request;

        {
            auto * listHolder_0 = new ListHolder<chip::app::Clusters::TestCluster::Structs::SimpleStruct::Type>(2);
            listFreer.add(listHolder_0);

            listHolder_0->mList[0].a = 0;
            listHolder_0->mList[0].b = true;
            listHolder_0->mList[0].c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(2);
            listHolder_0->mList[0].d =
                chip::ByteSpan(chip::Uint8::from_const_char("first_octet_stringgarbage: not in length on purpose"), 18);
            listHolder_0->mList[0].e = chip::Span<const char>("first_char_stringgarbage: not in length on purpose", 17);
            listHolder_0->mList[0].f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);
            listHolder_0->mList[0].g = 0.0f;
            listHolder_0->mList[0].h = 0;

            listHolder_0->mList[1].a = 1;
            listHolder_0->mList[1].b = true;
            listHolder_0->mList[1].c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(3);
            listHolder_0->mList[1].d =
                chip::ByteSpan(chip::Uint8::from_const_char("second_octet_stringgarbage: not in length on purpose"), 19);
            listHolder_0->mList[1].e = chip::Span<const char>("second_char_stringgarbage: not in length on purpose", 18);
            listHolder_0->mList[1].f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);
            listHolder_0->mList[1].g = 0.0f;
            listHolder_0->mList[1].h = 0;

            request.arg1 =
                chip::app::DataModel::List<chip::app::Clusters::TestCluster::Structs::SimpleStruct::Type>(listHolder_0->mList, 2);
        }

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_164(data.value);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestClusterSuite *>(context))->OnFailureResponse_164(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_164(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_164(bool value)
    {
        VerifyOrReturn(CheckValue("value", value, true));

        NextTest();
    }

    CHIP_ERROR TestSendTestCommandWithListOfStructArgumentAndArg1bOfFirstItemIsFalse_165()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::TestListStructArgumentRequest::Type;

        ListFreer listFreer;
        RequestType request;

        {
            auto * listHolder_0 = new ListHolder<chip::app::Clusters::TestCluster::Structs::SimpleStruct::Type>(2);
            listFreer.add(listHolder_0);

            listHolder_0->mList[0].a = 1;
            listHolder_0->mList[0].b = true;
            listHolder_0->mList[0].c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(3);
            listHolder_0->mList[0].d =
                chip::ByteSpan(chip::Uint8::from_const_char("second_octet_stringgarbage: not in length on purpose"), 19);
            listHolder_0->mList[0].e = chip::Span<const char>("second_char_stringgarbage: not in length on purpose", 18);
            listHolder_0->mList[0].f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);
            listHolder_0->mList[0].g = 0.0f;
            listHolder_0->mList[0].h = 0;

            listHolder_0->mList[1].a = 0;
            listHolder_0->mList[1].b = false;
            listHolder_0->mList[1].c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(2);
            listHolder_0->mList[1].d =
                chip::ByteSpan(chip::Uint8::from_const_char("first_octet_stringgarbage: not in length on purpose"), 18);
            listHolder_0->mList[1].e = chip::Span<const char>("first_char_stringgarbage: not in length on purpose", 17);
            listHolder_0->mList[1].f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);
            listHolder_0->mList[1].g = 0.0f;
            listHolder_0->mList[1].h = 0;

            request.arg1 =
                chip::app::DataModel::List<chip::app::Clusters::TestCluster::Structs::SimpleStruct::Type>(listHolder_0->mList, 2);
        }

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_165(data.value);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestClusterSuite *>(context))->OnFailureResponse_165(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_165(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_165(bool value)
    {
        VerifyOrReturn(CheckValue("value", value, false));

        NextTest();
    }

    CHIP_ERROR TestSendTestCommandWithListOfNestedStructListArgumentAndAllFieldsBOfElementsOfArg1dAreTrue_166()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::TestListNestedStructListArgumentRequest::Type;

        ListFreer listFreer;
        RequestType request;

        {
            auto * listHolder_0 = new ListHolder<chip::app::Clusters::TestCluster::Structs::NestedStructList::Type>(1);
            listFreer.add(listHolder_0);

            listHolder_0->mList[0].a = 0;
            listHolder_0->mList[0].b = true;

            listHolder_0->mList[0].c.a = 0;
            listHolder_0->mList[0].c.b = true;
            listHolder_0->mList[0].c.c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(2);
            listHolder_0->mList[0].c.d =
                chip::ByteSpan(chip::Uint8::from_const_char("octet_stringgarbage: not in length on purpose"), 12);
            listHolder_0->mList[0].c.e = chip::Span<const char>("char_stringgarbage: not in length on purpose", 11);
            listHolder_0->mList[0].c.f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);
            listHolder_0->mList[0].c.g = 0.0f;
            listHolder_0->mList[0].c.h = 0;

            {
                auto * listHolder_2 = new ListHolder<chip::app::Clusters::TestCluster::Structs::SimpleStruct::Type>(2);
                listFreer.add(listHolder_2);

                listHolder_2->mList[0].a = 1;
                listHolder_2->mList[0].b = true;
                listHolder_2->mList[0].c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(3);
                listHolder_2->mList[0].d =
                    chip::ByteSpan(chip::Uint8::from_const_char("nested_octet_stringgarbage: not in length on purpose"), 19);
                listHolder_2->mList[0].e = chip::Span<const char>("nested_char_stringgarbage: not in length on purpose", 18);
                listHolder_2->mList[0].f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);
                listHolder_2->mList[0].g = 0.0f;
                listHolder_2->mList[0].h = 0;

                listHolder_2->mList[1].a = 2;
                listHolder_2->mList[1].b = true;
                listHolder_2->mList[1].c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(3);
                listHolder_2->mList[1].d =
                    chip::ByteSpan(chip::Uint8::from_const_char("nested_octet_stringgarbage: not in length on purpose"), 19);
                listHolder_2->mList[1].e = chip::Span<const char>("nested_char_stringgarbage: not in length on purpose", 18);
                listHolder_2->mList[1].f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);
                listHolder_2->mList[1].g = 0.0f;
                listHolder_2->mList[1].h = 0;

                listHolder_0->mList[0].d =
                    chip::app::DataModel::List<chip::app::Clusters::TestCluster::Structs::SimpleStruct::Type>(listHolder_2->mList,
                                                                                                              2);
            }

            {
                auto * listHolder_2 = new ListHolder<uint32_t>(3);
                listFreer.add(listHolder_2);
                listHolder_2->mList[0]   = 1UL;
                listHolder_2->mList[1]   = 2UL;
                listHolder_2->mList[2]   = 3UL;
                listHolder_0->mList[0].e = chip::app::DataModel::List<uint32_t>(listHolder_2->mList, 3);
            }

            {
                auto * listHolder_2 = new ListHolder<chip::ByteSpan>(3);
                listFreer.add(listHolder_2);
                listHolder_2->mList[0] =
                    chip::ByteSpan(chip::Uint8::from_const_char("octet_string_1garbage: not in length on purpose"), 14);
                listHolder_2->mList[1] =
                    chip::ByteSpan(chip::Uint8::from_const_char("octect_string_2garbage: not in length on purpose"), 15);
                listHolder_2->mList[2] =
                    chip::ByteSpan(chip::Uint8::from_const_char("octet_string_3garbage: not in length on purpose"), 14);
                listHolder_0->mList[0].f = chip::app::DataModel::List<chip::ByteSpan>(listHolder_2->mList, 3);
            }

            {
                auto * listHolder_2 = new ListHolder<uint8_t>(2);
                listFreer.add(listHolder_2);
                listHolder_2->mList[0]   = 0;
                listHolder_2->mList[1]   = 255;
                listHolder_0->mList[0].g = chip::app::DataModel::List<uint8_t>(listHolder_2->mList, 2);
            }

            request.arg1 = chip::app::DataModel::List<chip::app::Clusters::TestCluster::Structs::NestedStructList::Type>(
                listHolder_0->mList, 1);
        }

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_166(data.value);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestClusterSuite *>(context))->OnFailureResponse_166(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_166(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_166(bool value)
    {
        VerifyOrReturn(CheckValue("value", value, true));

        NextTest();
    }

    CHIP_ERROR TestSendTestCommandWithNestedStructListArgumentAndSomeFieldsBOfElementsOfArg1dAreFalse_167()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::TestListNestedStructListArgumentRequest::Type;

        ListFreer listFreer;
        RequestType request;

        {
            auto * listHolder_0 = new ListHolder<chip::app::Clusters::TestCluster::Structs::NestedStructList::Type>(1);
            listFreer.add(listHolder_0);

            listHolder_0->mList[0].a = 0;
            listHolder_0->mList[0].b = true;

            listHolder_0->mList[0].c.a = 0;
            listHolder_0->mList[0].c.b = true;
            listHolder_0->mList[0].c.c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(2);
            listHolder_0->mList[0].c.d =
                chip::ByteSpan(chip::Uint8::from_const_char("octet_stringgarbage: not in length on purpose"), 12);
            listHolder_0->mList[0].c.e = chip::Span<const char>("char_stringgarbage: not in length on purpose", 11);
            listHolder_0->mList[0].c.f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);
            listHolder_0->mList[0].c.g = 0.0f;
            listHolder_0->mList[0].c.h = 0;

            {
                auto * listHolder_2 = new ListHolder<chip::app::Clusters::TestCluster::Structs::SimpleStruct::Type>(2);
                listFreer.add(listHolder_2);

                listHolder_2->mList[0].a = 1;
                listHolder_2->mList[0].b = true;
                listHolder_2->mList[0].c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(3);
                listHolder_2->mList[0].d =
                    chip::ByteSpan(chip::Uint8::from_const_char("nested_octet_stringgarbage: not in length on purpose"), 19);
                listHolder_2->mList[0].e = chip::Span<const char>("nested_char_stringgarbage: not in length on purpose", 18);
                listHolder_2->mList[0].f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);
                listHolder_2->mList[0].g = 0.0f;
                listHolder_2->mList[0].h = 0;

                listHolder_2->mList[1].a = 2;
                listHolder_2->mList[1].b = false;
                listHolder_2->mList[1].c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(3);
                listHolder_2->mList[1].d =
                    chip::ByteSpan(chip::Uint8::from_const_char("nested_octet_stringgarbage: not in length on purpose"), 19);
                listHolder_2->mList[1].e = chip::Span<const char>("nested_char_stringgarbage: not in length on purpose", 18);
                listHolder_2->mList[1].f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);
                listHolder_2->mList[1].g = 0.0f;
                listHolder_2->mList[1].h = 0;

                listHolder_0->mList[0].d =
                    chip::app::DataModel::List<chip::app::Clusters::TestCluster::Structs::SimpleStruct::Type>(listHolder_2->mList,
                                                                                                              2);
            }

            {
                auto * listHolder_2 = new ListHolder<uint32_t>(3);
                listFreer.add(listHolder_2);
                listHolder_2->mList[0]   = 1UL;
                listHolder_2->mList[1]   = 2UL;
                listHolder_2->mList[2]   = 3UL;
                listHolder_0->mList[0].e = chip::app::DataModel::List<uint32_t>(listHolder_2->mList, 3);
            }

            {
                auto * listHolder_2 = new ListHolder<chip::ByteSpan>(3);
                listFreer.add(listHolder_2);
                listHolder_2->mList[0] =
                    chip::ByteSpan(chip::Uint8::from_const_char("octet_string_1garbage: not in length on purpose"), 14);
                listHolder_2->mList[1] =
                    chip::ByteSpan(chip::Uint8::from_const_char("octect_string_2garbage: not in length on purpose"), 15);
                listHolder_2->mList[2] =
                    chip::ByteSpan(chip::Uint8::from_const_char("octet_string_3garbage: not in length on purpose"), 14);
                listHolder_0->mList[0].f = chip::app::DataModel::List<chip::ByteSpan>(listHolder_2->mList, 3);
            }

            {
                auto * listHolder_2 = new ListHolder<uint8_t>(2);
                listFreer.add(listHolder_2);
                listHolder_2->mList[0]   = 0;
                listHolder_2->mList[1]   = 255;
                listHolder_0->mList[0].g = chip::app::DataModel::List<uint8_t>(listHolder_2->mList, 2);
            }

            request.arg1 = chip::app::DataModel::List<chip::app::Clusters::TestCluster::Structs::NestedStructList::Type>(
                listHolder_0->mList, 1);
        }

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_167(data.value);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestClusterSuite *>(context))->OnFailureResponse_167(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_167(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_167(bool value)
    {
        VerifyOrReturn(CheckValue("value", value, false));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeListWithListOfInt8uAndNoneOfThemIsSetTo0_168()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ListFreer listFreer;
        chip::app::DataModel::List<const uint8_t> listInt8uArgument;

        {
            auto * listHolder_0 = new ListHolder<uint8_t>(4);
            listFreer.add(listHolder_0);
            listHolder_0->mList[0] = 1;
            listHolder_0->mList[1] = 2;
            listHolder_0->mList[2] = 3;
            listHolder_0->mList[3] = 4;
            listInt8uArgument      = chip::app::DataModel::List<uint8_t>(listHolder_0->mList, 4);
        }

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::ListInt8u::TypeInfo>(
            listInt8uArgument, this, OnSuccessCallback_168, OnFailureCallback_168));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_168(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_168() { NextTest(); }

    CHIP_ERROR TestReadAttributeListWithListOfInt8u_169()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::ListInt8u::TypeInfo>(
            this, OnSuccessCallback_169, OnFailureCallback_169, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_169(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_169(const chip::app::DataModel::DecodableList<uint8_t> & listInt8u)
    {
        {
            auto iter_0 = listInt8u.begin();
            VerifyOrReturn(CheckNextListItemDecodes<decltype(listInt8u)>("listInt8u", iter_0, 0));
            VerifyOrReturn(CheckValue("listInt8u[0]", iter_0.GetValue(), 1));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(listInt8u)>("listInt8u", iter_0, 1));
            VerifyOrReturn(CheckValue("listInt8u[1]", iter_0.GetValue(), 2));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(listInt8u)>("listInt8u", iter_0, 2));
            VerifyOrReturn(CheckValue("listInt8u[2]", iter_0.GetValue(), 3));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(listInt8u)>("listInt8u", iter_0, 3));
            VerifyOrReturn(CheckValue("listInt8u[3]", iter_0.GetValue(), 4));
            VerifyOrReturn(CheckNoMoreListItems<decltype(listInt8u)>("listInt8u", iter_0, 4));
        }

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeListWithListOfOctetString_170()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ListFreer listFreer;
        chip::app::DataModel::List<const chip::ByteSpan> listOctetStringArgument;

        {
            auto * listHolder_0 = new ListHolder<chip::ByteSpan>(4);
            listFreer.add(listHolder_0);
            listHolder_0->mList[0]  = chip::ByteSpan(chip::Uint8::from_const_char("Test0garbage: not in length on purpose"), 5);
            listHolder_0->mList[1]  = chip::ByteSpan(chip::Uint8::from_const_char("Test1garbage: not in length on purpose"), 5);
            listHolder_0->mList[2]  = chip::ByteSpan(chip::Uint8::from_const_char("Test2garbage: not in length on purpose"), 5);
            listHolder_0->mList[3]  = chip::ByteSpan(chip::Uint8::from_const_char("Test3garbage: not in length on purpose"), 5);
            listOctetStringArgument = chip::app::DataModel::List<chip::ByteSpan>(listHolder_0->mList, 4);
        }

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::ListOctetString::TypeInfo>(
            listOctetStringArgument, this, OnSuccessCallback_170, OnFailureCallback_170));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_170(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_170() { NextTest(); }

    CHIP_ERROR TestReadAttributeListWithListOfOctetString_171()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::ListOctetString::TypeInfo>(
            this, OnSuccessCallback_171, OnFailureCallback_171, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_171(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_171(const chip::app::DataModel::DecodableList<chip::ByteSpan> & listOctetString)
    {
        {
            auto iter_0 = listOctetString.begin();
            VerifyOrReturn(CheckNextListItemDecodes<decltype(listOctetString)>("listOctetString", iter_0, 0));
            VerifyOrReturn(CheckValueAsString("listOctetString[0]", iter_0.GetValue(),
                                              chip::ByteSpan(chip::Uint8::from_const_char("Test0"), 5)));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(listOctetString)>("listOctetString", iter_0, 1));
            VerifyOrReturn(CheckValueAsString("listOctetString[1]", iter_0.GetValue(),
                                              chip::ByteSpan(chip::Uint8::from_const_char("Test1"), 5)));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(listOctetString)>("listOctetString", iter_0, 2));
            VerifyOrReturn(CheckValueAsString("listOctetString[2]", iter_0.GetValue(),
                                              chip::ByteSpan(chip::Uint8::from_const_char("Test2"), 5)));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(listOctetString)>("listOctetString", iter_0, 3));
            VerifyOrReturn(CheckValueAsString("listOctetString[3]", iter_0.GetValue(),
                                              chip::ByteSpan(chip::Uint8::from_const_char("Test3"), 5)));
            VerifyOrReturn(CheckNoMoreListItems<decltype(listOctetString)>("listOctetString", iter_0, 4));
        }

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeListWithListOfListStructOctetString_172()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ListFreer listFreer;
        chip::app::DataModel::List<const chip::app::Clusters::TestCluster::Structs::TestListStructOctet::Type>
            listStructOctetStringArgument;

        {
            auto * listHolder_0 = new ListHolder<chip::app::Clusters::TestCluster::Structs::TestListStructOctet::Type>(4);
            listFreer.add(listHolder_0);

            listHolder_0->mList[0].fabricIndex = 0ULL;
            listHolder_0->mList[0].operationalCert =
                chip::ByteSpan(chip::Uint8::from_const_char("Test0garbage: not in length on purpose"), 5);

            listHolder_0->mList[1].fabricIndex = 1ULL;
            listHolder_0->mList[1].operationalCert =
                chip::ByteSpan(chip::Uint8::from_const_char("Test1garbage: not in length on purpose"), 5);

            listHolder_0->mList[2].fabricIndex = 2ULL;
            listHolder_0->mList[2].operationalCert =
                chip::ByteSpan(chip::Uint8::from_const_char("Test2garbage: not in length on purpose"), 5);

            listHolder_0->mList[3].fabricIndex = 3ULL;
            listHolder_0->mList[3].operationalCert =
                chip::ByteSpan(chip::Uint8::from_const_char("Test3garbage: not in length on purpose"), 5);

            listStructOctetStringArgument =
                chip::app::DataModel::List<chip::app::Clusters::TestCluster::Structs::TestListStructOctet::Type>(
                    listHolder_0->mList, 4);
        }

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::ListStructOctetString::TypeInfo>(
            listStructOctetStringArgument, this, OnSuccessCallback_172, OnFailureCallback_172));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_172(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_172() { NextTest(); }

    CHIP_ERROR TestReadAttributeListWithListOfListStructOctetString_173()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::ListStructOctetString::TypeInfo>(
            this, OnSuccessCallback_173, OnFailureCallback_173, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_173(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_173(
        const chip::app::DataModel::DecodableList<chip::app::Clusters::TestCluster::Structs::TestListStructOctet::DecodableType> &
            listStructOctetString)
    {
        {
            auto iter_0 = listStructOctetString.begin();
            VerifyOrReturn(CheckNextListItemDecodes<decltype(listStructOctetString)>("listStructOctetString", iter_0, 0));
            VerifyOrReturn(CheckValue("listStructOctetString[0].fabricIndex", iter_0.GetValue().fabricIndex, 0ULL));
            VerifyOrReturn(CheckValueAsString("listStructOctetString[0].operationalCert", iter_0.GetValue().operationalCert,
                                              chip::ByteSpan(chip::Uint8::from_const_char("Test0"), 5)));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(listStructOctetString)>("listStructOctetString", iter_0, 1));
            VerifyOrReturn(CheckValue("listStructOctetString[1].fabricIndex", iter_0.GetValue().fabricIndex, 1ULL));
            VerifyOrReturn(CheckValueAsString("listStructOctetString[1].operationalCert", iter_0.GetValue().operationalCert,
                                              chip::ByteSpan(chip::Uint8::from_const_char("Test1"), 5)));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(listStructOctetString)>("listStructOctetString", iter_0, 2));
            VerifyOrReturn(CheckValue("listStructOctetString[2].fabricIndex", iter_0.GetValue().fabricIndex, 2ULL));
            VerifyOrReturn(CheckValueAsString("listStructOctetString[2].operationalCert", iter_0.GetValue().operationalCert,
                                              chip::ByteSpan(chip::Uint8::from_const_char("Test2"), 5)));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(listStructOctetString)>("listStructOctetString", iter_0, 3));
            VerifyOrReturn(CheckValue("listStructOctetString[3].fabricIndex", iter_0.GetValue().fabricIndex, 3ULL));
            VerifyOrReturn(CheckValueAsString("listStructOctetString[3].operationalCert", iter_0.GetValue().operationalCert,
                                              chip::ByteSpan(chip::Uint8::from_const_char("Test3"), 5)));
            VerifyOrReturn(CheckNoMoreListItems<decltype(listStructOctetString)>("listStructOctetString", iter_0, 4));
        }

        NextTest();
    }

    CHIP_ERROR TestSendTestCommandWithOptionalArgSet_174()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::TestNullableOptionalRequest::Type;

        RequestType request;
        request.arg1.Emplace();
        request.arg1.Value().SetNonNull();
        request.arg1.Value().Value() = 5;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestClusterSuite *>(context))
                ->OnSuccessResponse_174(data.wasPresent, data.wasNull, data.value, data.originalValue);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestClusterSuite *>(context))->OnFailureResponse_174(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_174(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_174(bool wasPresent, const chip::Optional<bool> & wasNull, const chip::Optional<uint8_t> & value,
                               const chip::Optional<chip::app::DataModel::Nullable<uint8_t>> & originalValue)
    {
        VerifyOrReturn(CheckValue("wasPresent", wasPresent, true));

        VerifyOrReturn(CheckValuePresent("wasNull", wasNull));
        VerifyOrReturn(CheckValue("wasNull.Value()", wasNull.Value(), false));

        VerifyOrReturn(CheckValuePresent("value", value));
        VerifyOrReturn(CheckValue("value.Value()", value.Value(), 5));

        VerifyOrReturn(CheckValuePresent("originalValue", originalValue));
        VerifyOrReturn(CheckValueNonNull("originalValue.Value()", originalValue.Value()));
        VerifyOrReturn(CheckValue("originalValue.Value().Value()", originalValue.Value().Value(), 5));

        NextTest();
    }

    CHIP_ERROR TestSendTestCommandWithoutItsOptionalArg_175()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::TestNullableOptionalRequest::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestClusterSuite *>(context))
                ->OnSuccessResponse_175(data.wasPresent, data.wasNull, data.value, data.originalValue);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestClusterSuite *>(context))->OnFailureResponse_175(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_175(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_175(bool wasPresent, const chip::Optional<bool> & wasNull, const chip::Optional<uint8_t> & value,
                               const chip::Optional<chip::app::DataModel::Nullable<uint8_t>> & originalValue)
    {
        VerifyOrReturn(CheckValue("wasPresent", wasPresent, false));

        NextTest();
    }

    CHIP_ERROR TestReadListOfStructsContainingNullablesAndOptionals_176()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::ListNullablesAndOptionalsStruct::TypeInfo>(
                this, OnSuccessCallback_176, OnFailureCallback_176, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_176(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_176(const chip::app::DataModel::DecodableList<
                               chip::app::Clusters::TestCluster::Structs::NullablesAndOptionalsStruct::DecodableType> &
                                   listNullablesAndOptionalsStruct)
    {
        {
            auto iter_0 = listNullablesAndOptionalsStruct.begin();
            VerifyOrReturn(
                CheckNextListItemDecodes<decltype(listNullablesAndOptionalsStruct)>("listNullablesAndOptionalsStruct", iter_0, 0));
            VerifyOrReturn(CheckValueNull("listNullablesAndOptionalsStruct[0].nullableInt", iter_0.GetValue().nullableInt));
            VerifyOrReturn(CheckValueNull("listNullablesAndOptionalsStruct[0].nullableString", iter_0.GetValue().nullableString));
            VerifyOrReturn(CheckValueNull("listNullablesAndOptionalsStruct[0].nullableStruct", iter_0.GetValue().nullableStruct));
            VerifyOrReturn(CheckValueNull("listNullablesAndOptionalsStruct[0].nullableList", iter_0.GetValue().nullableList));
            VerifyOrReturn(
                CheckNoMoreListItems<decltype(listNullablesAndOptionalsStruct)>("listNullablesAndOptionalsStruct", iter_0, 1));
        }

        NextTest();
    }

    CHIP_ERROR TestWriteListOfStructsContainingNullablesAndOptionals_177()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ListFreer listFreer;
        chip::app::DataModel::List<const chip::app::Clusters::TestCluster::Structs::NullablesAndOptionalsStruct::Type>
            listNullablesAndOptionalsStructArgument;

        {
            auto * listHolder_0 = new ListHolder<chip::app::Clusters::TestCluster::Structs::NullablesAndOptionalsStruct::Type>(1);
            listFreer.add(listHolder_0);

            listHolder_0->mList[0].nullableInt.SetNull();
            listHolder_0->mList[0].nullableString.SetNull();
            listHolder_0->mList[0].nullableStruct.SetNull();
            listHolder_0->mList[0].nullableList.SetNonNull();

            {
                auto * listHolder_3 = new ListHolder<chip::app::Clusters::TestCluster::SimpleEnum>(2);
                listFreer.add(listHolder_3);
                listHolder_3->mList[0] = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(1);
                listHolder_3->mList[1] = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(2);
                listHolder_0->mList[0].nullableList.Value() =
                    chip::app::DataModel::List<chip::app::Clusters::TestCluster::SimpleEnum>(listHolder_3->mList, 2);
            }

            listNullablesAndOptionalsStructArgument =
                chip::app::DataModel::List<chip::app::Clusters::TestCluster::Structs::NullablesAndOptionalsStruct::Type>(
                    listHolder_0->mList, 1);
        }

        ReturnErrorOnFailure(
            cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::ListNullablesAndOptionalsStruct::TypeInfo>(
                listNullablesAndOptionalsStructArgument, this, OnSuccessCallback_177, OnFailureCallback_177));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_177(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_177() { NextTest(); }

    CHIP_ERROR TestReadListOfStructsContainingNullablesAndOptionalsAfterWriting_178()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::ListNullablesAndOptionalsStruct::TypeInfo>(
                this, OnSuccessCallback_178, OnFailureCallback_178, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_178(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_178(const chip::app::DataModel::DecodableList<
                               chip::app::Clusters::TestCluster::Structs::NullablesAndOptionalsStruct::DecodableType> &
                                   listNullablesAndOptionalsStruct)
    {
        {
            auto iter_0 = listNullablesAndOptionalsStruct.begin();
            VerifyOrReturn(
                CheckNextListItemDecodes<decltype(listNullablesAndOptionalsStruct)>("listNullablesAndOptionalsStruct", iter_0, 0));
            VerifyOrReturn(CheckValueNull("listNullablesAndOptionalsStruct[0].nullableInt", iter_0.GetValue().nullableInt));
            VerifyOrReturn(CheckValueNull("listNullablesAndOptionalsStruct[0].nullableString", iter_0.GetValue().nullableString));
            VerifyOrReturn(CheckValueNull("listNullablesAndOptionalsStruct[0].nullableStruct", iter_0.GetValue().nullableStruct));
            VerifyOrReturn(CheckValueNonNull("listNullablesAndOptionalsStruct[0].nullableList", iter_0.GetValue().nullableList));
            {
                auto iter_NaN = iter_0.GetValue().nullableList.Value().begin();
                VerifyOrReturn(CheckNextListItemDecodes<decltype(iter_0.GetValue().nullableList.Value())>(
                    "listNullablesAndOptionalsStruct[0].nullableList.Value()", iter_NaN, 0));
                VerifyOrReturn(CheckValue("listNullablesAndOptionalsStruct[0].nullableList.Value()[0]", iter_NaN.GetValue(), 1));
                VerifyOrReturn(CheckNextListItemDecodes<decltype(iter_0.GetValue().nullableList.Value())>(
                    "listNullablesAndOptionalsStruct[0].nullableList.Value()", iter_NaN, 1));
                VerifyOrReturn(CheckValue("listNullablesAndOptionalsStruct[0].nullableList.Value()[1]", iter_NaN.GetValue(), 2));
                VerifyOrReturn(CheckNoMoreListItems<decltype(iter_0.GetValue().nullableList.Value())>(
                    "listNullablesAndOptionalsStruct[0].nullableList.Value()", iter_NaN, 2));
            }
            VerifyOrReturn(
                CheckNoMoreListItems<decltype(listNullablesAndOptionalsStruct)>("listNullablesAndOptionalsStruct", iter_0, 1));
        }

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableBooleanNull_179()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<bool> nullableBooleanArgument;
        nullableBooleanArgument.SetNull();

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableBoolean::TypeInfo>(
            nullableBooleanArgument, this, OnSuccessCallback_179, OnFailureCallback_179));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_179(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_179() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableBooleanNull_180()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableBoolean::TypeInfo>(
            this, OnSuccessCallback_180, OnFailureCallback_180, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_180(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_180(const chip::app::DataModel::Nullable<bool> & nullableBoolean)
    {
        VerifyOrReturn(CheckValueNull("nullableBoolean", nullableBoolean));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableBooleanTrue_181()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<bool> nullableBooleanArgument;
        nullableBooleanArgument.SetNonNull();
        nullableBooleanArgument.Value() = true;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableBoolean::TypeInfo>(
            nullableBooleanArgument, this, OnSuccessCallback_181, OnFailureCallback_181));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_181(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_181() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableBooleanTrue_182()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableBoolean::TypeInfo>(
            this, OnSuccessCallback_182, OnFailureCallback_182, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_182(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_182(const chip::app::DataModel::Nullable<bool> & nullableBoolean)
    {
        VerifyOrReturn(CheckValueNonNull("nullableBoolean", nullableBoolean));
        VerifyOrReturn(CheckValue("nullableBoolean.Value()", nullableBoolean.Value(), true));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableBitmap8MaxValue_183()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint8_t> nullableBitmap8Argument;
        nullableBitmap8Argument.SetNonNull();
        nullableBitmap8Argument.Value() = 254;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableBitmap8::TypeInfo>(
            nullableBitmap8Argument, this, OnSuccessCallback_183, OnFailureCallback_183));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_183(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_183() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableBitmap8MaxValue_184()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableBitmap8::TypeInfo>(
            this, OnSuccessCallback_184, OnFailureCallback_184, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_184(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_184(const chip::app::DataModel::Nullable<uint8_t> & nullableBitmap8)
    {
        VerifyOrReturn(CheckValueNonNull("nullableBitmap8", nullableBitmap8));
        VerifyOrReturn(CheckValue("nullableBitmap8.Value()", nullableBitmap8.Value(), 254));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableBitmap8InvalidValue_185()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint8_t> nullableBitmap8Argument;
        nullableBitmap8Argument.SetNonNull();
        nullableBitmap8Argument.Value() = 255;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableBitmap8::TypeInfo>(
            nullableBitmap8Argument, this, OnSuccessCallback_185, OnFailureCallback_185));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_185(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
        NextTest();
    }

    void OnSuccessResponse_185() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadAttributeNullableBitmap8UnchangedValue_186()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableBitmap8::TypeInfo>(
            this, OnSuccessCallback_186, OnFailureCallback_186, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_186(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_186(const chip::app::DataModel::Nullable<uint8_t> & nullableBitmap8)
    {
        VerifyOrReturn(CheckValueNonNull("nullableBitmap8", nullableBitmap8));
        VerifyOrReturn(CheckValue("nullableBitmap8.Value()", nullableBitmap8.Value(), 254));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableBitmap8NullValue_187()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint8_t> nullableBitmap8Argument;
        nullableBitmap8Argument.SetNull();

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableBitmap8::TypeInfo>(
            nullableBitmap8Argument, this, OnSuccessCallback_187, OnFailureCallback_187));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_187(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_187() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableBitmap8NullValue_188()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableBitmap8::TypeInfo>(
            this, OnSuccessCallback_188, OnFailureCallback_188, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_188(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_188(const chip::app::DataModel::Nullable<uint8_t> & nullableBitmap8)
    {
        VerifyOrReturn(CheckValueNull("nullableBitmap8", nullableBitmap8));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableBitmap16MaxValue_189()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint16_t> nullableBitmap16Argument;
        nullableBitmap16Argument.SetNonNull();
        nullableBitmap16Argument.Value() = 65534U;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableBitmap16::TypeInfo>(
            nullableBitmap16Argument, this, OnSuccessCallback_189, OnFailureCallback_189));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_189(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_189() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableBitmap16MaxValue_190()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableBitmap16::TypeInfo>(
            this, OnSuccessCallback_190, OnFailureCallback_190, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_190(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_190(const chip::app::DataModel::Nullable<uint16_t> & nullableBitmap16)
    {
        VerifyOrReturn(CheckValueNonNull("nullableBitmap16", nullableBitmap16));
        VerifyOrReturn(CheckValue("nullableBitmap16.Value()", nullableBitmap16.Value(), 65534U));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableBitmap16InvalidValue_191()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint16_t> nullableBitmap16Argument;
        nullableBitmap16Argument.SetNonNull();
        nullableBitmap16Argument.Value() = 65535U;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableBitmap16::TypeInfo>(
            nullableBitmap16Argument, this, OnSuccessCallback_191, OnFailureCallback_191));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_191(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
        NextTest();
    }

    void OnSuccessResponse_191() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadAttributeNullableBitmap16UnchangedValue_192()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableBitmap16::TypeInfo>(
            this, OnSuccessCallback_192, OnFailureCallback_192, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_192(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_192(const chip::app::DataModel::Nullable<uint16_t> & nullableBitmap16)
    {
        VerifyOrReturn(CheckValueNonNull("nullableBitmap16", nullableBitmap16));
        VerifyOrReturn(CheckValue("nullableBitmap16.Value()", nullableBitmap16.Value(), 65534U));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableBitmap16NullValue_193()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint16_t> nullableBitmap16Argument;
        nullableBitmap16Argument.SetNull();

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableBitmap16::TypeInfo>(
            nullableBitmap16Argument, this, OnSuccessCallback_193, OnFailureCallback_193));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_193(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_193() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableBitmap16NullValue_194()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableBitmap16::TypeInfo>(
            this, OnSuccessCallback_194, OnFailureCallback_194, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_194(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_194(const chip::app::DataModel::Nullable<uint16_t> & nullableBitmap16)
    {
        VerifyOrReturn(CheckValueNull("nullableBitmap16", nullableBitmap16));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableBitmap32MaxValue_195()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint32_t> nullableBitmap32Argument;
        nullableBitmap32Argument.SetNonNull();
        nullableBitmap32Argument.Value() = 4294967294UL;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableBitmap32::TypeInfo>(
            nullableBitmap32Argument, this, OnSuccessCallback_195, OnFailureCallback_195));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_195(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_195() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableBitmap32MaxValue_196()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableBitmap32::TypeInfo>(
            this, OnSuccessCallback_196, OnFailureCallback_196, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_196(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_196(const chip::app::DataModel::Nullable<uint32_t> & nullableBitmap32)
    {
        VerifyOrReturn(CheckValueNonNull("nullableBitmap32", nullableBitmap32));
        VerifyOrReturn(CheckValue("nullableBitmap32.Value()", nullableBitmap32.Value(), 4294967294UL));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableBitmap32InvalidValue_197()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint32_t> nullableBitmap32Argument;
        nullableBitmap32Argument.SetNonNull();
        nullableBitmap32Argument.Value() = 4294967295UL;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableBitmap32::TypeInfo>(
            nullableBitmap32Argument, this, OnSuccessCallback_197, OnFailureCallback_197));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_197(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
        NextTest();
    }

    void OnSuccessResponse_197() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadAttributeNullableBitmap32UnchangedValue_198()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableBitmap32::TypeInfo>(
            this, OnSuccessCallback_198, OnFailureCallback_198, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_198(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_198(const chip::app::DataModel::Nullable<uint32_t> & nullableBitmap32)
    {
        VerifyOrReturn(CheckValueNonNull("nullableBitmap32", nullableBitmap32));
        VerifyOrReturn(CheckValue("nullableBitmap32.Value()", nullableBitmap32.Value(), 4294967294UL));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableBitmap32NullValue_199()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint32_t> nullableBitmap32Argument;
        nullableBitmap32Argument.SetNull();

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableBitmap32::TypeInfo>(
            nullableBitmap32Argument, this, OnSuccessCallback_199, OnFailureCallback_199));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_199(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_199() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableBitmap32NullValue_200()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableBitmap32::TypeInfo>(
            this, OnSuccessCallback_200, OnFailureCallback_200, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_200(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_200(const chip::app::DataModel::Nullable<uint32_t> & nullableBitmap32)
    {
        VerifyOrReturn(CheckValueNull("nullableBitmap32", nullableBitmap32));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableBitmap64MaxValue_201()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint64_t> nullableBitmap64Argument;
        nullableBitmap64Argument.SetNonNull();
        nullableBitmap64Argument.Value() = 18446744073709551614ULL;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableBitmap64::TypeInfo>(
            nullableBitmap64Argument, this, OnSuccessCallback_201, OnFailureCallback_201));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_201(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_201() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableBitmap64MaxValue_202()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableBitmap64::TypeInfo>(
            this, OnSuccessCallback_202, OnFailureCallback_202, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_202(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_202(const chip::app::DataModel::Nullable<uint64_t> & nullableBitmap64)
    {
        VerifyOrReturn(CheckValueNonNull("nullableBitmap64", nullableBitmap64));
        VerifyOrReturn(CheckValue("nullableBitmap64.Value()", nullableBitmap64.Value(), 18446744073709551614ULL));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableBitmap64InvalidValue_203()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint64_t> nullableBitmap64Argument;
        nullableBitmap64Argument.SetNonNull();
        nullableBitmap64Argument.Value() = 18446744073709551615ULL;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableBitmap64::TypeInfo>(
            nullableBitmap64Argument, this, OnSuccessCallback_203, OnFailureCallback_203));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_203(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
        NextTest();
    }

    void OnSuccessResponse_203() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadAttributeNullableBitmap64UnchangedValue_204()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableBitmap64::TypeInfo>(
            this, OnSuccessCallback_204, OnFailureCallback_204, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_204(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_204(const chip::app::DataModel::Nullable<uint64_t> & nullableBitmap64)
    {
        VerifyOrReturn(CheckValueNonNull("nullableBitmap64", nullableBitmap64));
        VerifyOrReturn(CheckValue("nullableBitmap64.Value()", nullableBitmap64.Value(), 18446744073709551614ULL));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableBitmap64NullValue_205()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint64_t> nullableBitmap64Argument;
        nullableBitmap64Argument.SetNull();

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableBitmap64::TypeInfo>(
            nullableBitmap64Argument, this, OnSuccessCallback_205, OnFailureCallback_205));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_205(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_205() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableBitmap64NullValue_206()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableBitmap64::TypeInfo>(
            this, OnSuccessCallback_206, OnFailureCallback_206, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_206(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_206(const chip::app::DataModel::Nullable<uint64_t> & nullableBitmap64)
    {
        VerifyOrReturn(CheckValueNull("nullableBitmap64", nullableBitmap64));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableInt8uMinValue_207()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint8_t> nullableInt8uArgument;
        nullableInt8uArgument.SetNonNull();
        nullableInt8uArgument.Value() = 0;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt8u::TypeInfo>(
            nullableInt8uArgument, this, OnSuccessCallback_207, OnFailureCallback_207));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_207(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_207() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableInt8uMinValue_208()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt8u::TypeInfo>(
            this, OnSuccessCallback_208, OnFailureCallback_208, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_208(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_208(const chip::app::DataModel::Nullable<uint8_t> & nullableInt8u)
    {
        VerifyOrReturn(CheckValueNonNull("nullableInt8u", nullableInt8u));
        VerifyOrReturn(CheckValue("nullableInt8u.Value()", nullableInt8u.Value(), 0));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableInt8uMaxValue_209()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint8_t> nullableInt8uArgument;
        nullableInt8uArgument.SetNonNull();
        nullableInt8uArgument.Value() = 254;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt8u::TypeInfo>(
            nullableInt8uArgument, this, OnSuccessCallback_209, OnFailureCallback_209));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_209(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_209() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableInt8uMaxValue_210()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt8u::TypeInfo>(
            this, OnSuccessCallback_210, OnFailureCallback_210, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_210(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_210(const chip::app::DataModel::Nullable<uint8_t> & nullableInt8u)
    {
        VerifyOrReturn(CheckValueNonNull("nullableInt8u", nullableInt8u));
        VerifyOrReturn(CheckValue("nullableInt8u.Value()", nullableInt8u.Value(), 254));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableInt8uInvalidValue_211()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint8_t> nullableInt8uArgument;
        nullableInt8uArgument.SetNonNull();
        nullableInt8uArgument.Value() = 255;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt8u::TypeInfo>(
            nullableInt8uArgument, this, OnSuccessCallback_211, OnFailureCallback_211));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_211(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
        NextTest();
    }

    void OnSuccessResponse_211() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadAttributeNullableInt8uUnchangedValue_212()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt8u::TypeInfo>(
            this, OnSuccessCallback_212, OnFailureCallback_212, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_212(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_212(const chip::app::DataModel::Nullable<uint8_t> & nullableInt8u)
    {
        VerifyOrReturn(CheckValueNonNull("nullableInt8u", nullableInt8u));
        VerifyOrReturn(CheckValue("nullableInt8u.Value()", nullableInt8u.Value(), 254));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeNullableInt8uUnchangedValueWithConstraint_213()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt8u::TypeInfo>(
            this, OnSuccessCallback_213, OnFailureCallback_213, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_213(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_213(const chip::app::DataModel::Nullable<uint8_t> & nullableInt8u)
    {
        VerifyOrReturn(CheckValueNonNull("nullableInt8u", nullableInt8u));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableInt8uNullValue_214()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint8_t> nullableInt8uArgument;
        nullableInt8uArgument.SetNull();

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt8u::TypeInfo>(
            nullableInt8uArgument, this, OnSuccessCallback_214, OnFailureCallback_214));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_214(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_214() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableInt8uNullValue_215()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt8u::TypeInfo>(
            this, OnSuccessCallback_215, OnFailureCallback_215, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_215(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_215(const chip::app::DataModel::Nullable<uint8_t> & nullableInt8u)
    {
        VerifyOrReturn(CheckValueNull("nullableInt8u", nullableInt8u));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeNullableInt8uNullValueRange_216()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt8u::TypeInfo>(
            this, OnSuccessCallback_216, OnFailureCallback_216, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_216(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_216(const chip::app::DataModel::Nullable<uint8_t> & nullableInt8u)
    {
        VerifyOrReturn(CheckConstraintMinValue<uint8_t>("nullableInt8u", nullableInt8u, 0));
        VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("nullableInt8u", nullableInt8u, 254));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeNullableInt8uNullValueNot_217()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt8u::TypeInfo>(
            this, OnSuccessCallback_217, OnFailureCallback_217, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_217(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_217(const chip::app::DataModel::Nullable<uint8_t> & nullableInt8u)
    {
        VerifyOrReturn(CheckConstraintNotValue("nullableInt8u", nullableInt8u, 254));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableInt8uValue_218()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint8_t> nullableInt8uArgument;
        nullableInt8uArgument.SetNonNull();
        nullableInt8uArgument.Value() = 128;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt8u::TypeInfo>(
            nullableInt8uArgument, this, OnSuccessCallback_218, OnFailureCallback_218));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_218(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_218() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableInt8uValueInRange_219()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt8u::TypeInfo>(
            this, OnSuccessCallback_219, OnFailureCallback_219, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_219(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_219(const chip::app::DataModel::Nullable<uint8_t> & nullableInt8u)
    {
        VerifyOrReturn(CheckConstraintMinValue<uint8_t>("nullableInt8u", nullableInt8u, 0));
        VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("nullableInt8u", nullableInt8u, 254));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeNullableInt8uNotValueOk_220()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt8u::TypeInfo>(
            this, OnSuccessCallback_220, OnFailureCallback_220, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_220(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_220(const chip::app::DataModel::Nullable<uint8_t> & nullableInt8u)
    {
        VerifyOrReturn(CheckConstraintNotValue("nullableInt8u", nullableInt8u, 129));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableInt16uMinValue_221()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint16_t> nullableInt16uArgument;
        nullableInt16uArgument.SetNonNull();
        nullableInt16uArgument.Value() = 0U;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt16u::TypeInfo>(
            nullableInt16uArgument, this, OnSuccessCallback_221, OnFailureCallback_221));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_221(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_221() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableInt16uMinValue_222()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt16u::TypeInfo>(
            this, OnSuccessCallback_222, OnFailureCallback_222, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_222(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_222(const chip::app::DataModel::Nullable<uint16_t> & nullableInt16u)
    {
        VerifyOrReturn(CheckValueNonNull("nullableInt16u", nullableInt16u));
        VerifyOrReturn(CheckValue("nullableInt16u.Value()", nullableInt16u.Value(), 0U));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableInt16uMaxValue_223()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint16_t> nullableInt16uArgument;
        nullableInt16uArgument.SetNonNull();
        nullableInt16uArgument.Value() = 65534U;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt16u::TypeInfo>(
            nullableInt16uArgument, this, OnSuccessCallback_223, OnFailureCallback_223));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_223(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_223() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableInt16uMaxValue_224()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt16u::TypeInfo>(
            this, OnSuccessCallback_224, OnFailureCallback_224, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_224(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_224(const chip::app::DataModel::Nullable<uint16_t> & nullableInt16u)
    {
        VerifyOrReturn(CheckValueNonNull("nullableInt16u", nullableInt16u));
        VerifyOrReturn(CheckValue("nullableInt16u.Value()", nullableInt16u.Value(), 65534U));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableInt16uInvalidValue_225()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint16_t> nullableInt16uArgument;
        nullableInt16uArgument.SetNonNull();
        nullableInt16uArgument.Value() = 65535U;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt16u::TypeInfo>(
            nullableInt16uArgument, this, OnSuccessCallback_225, OnFailureCallback_225));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_225(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
        NextTest();
    }

    void OnSuccessResponse_225() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadAttributeNullableInt16uUnchangedValue_226()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt16u::TypeInfo>(
            this, OnSuccessCallback_226, OnFailureCallback_226, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_226(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_226(const chip::app::DataModel::Nullable<uint16_t> & nullableInt16u)
    {
        VerifyOrReturn(CheckValueNonNull("nullableInt16u", nullableInt16u));
        VerifyOrReturn(CheckValue("nullableInt16u.Value()", nullableInt16u.Value(), 65534U));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableInt16uNullValue_227()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint16_t> nullableInt16uArgument;
        nullableInt16uArgument.SetNull();

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt16u::TypeInfo>(
            nullableInt16uArgument, this, OnSuccessCallback_227, OnFailureCallback_227));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_227(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_227() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableInt16uNullValue_228()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt16u::TypeInfo>(
            this, OnSuccessCallback_228, OnFailureCallback_228, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_228(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_228(const chip::app::DataModel::Nullable<uint16_t> & nullableInt16u)
    {
        VerifyOrReturn(CheckValueNull("nullableInt16u", nullableInt16u));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeNullableInt16uNullValueRange_229()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt16u::TypeInfo>(
            this, OnSuccessCallback_229, OnFailureCallback_229, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_229(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_229(const chip::app::DataModel::Nullable<uint16_t> & nullableInt16u)
    {
        VerifyOrReturn(CheckConstraintMinValue<uint16_t>("nullableInt16u", nullableInt16u, 0U));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("nullableInt16u", nullableInt16u, 65534U));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeNullableInt16uNullValueNot_230()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt16u::TypeInfo>(
            this, OnSuccessCallback_230, OnFailureCallback_230, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_230(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_230(const chip::app::DataModel::Nullable<uint16_t> & nullableInt16u)
    {
        VerifyOrReturn(CheckConstraintNotValue("nullableInt16u", nullableInt16u, 65534U));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableInt16uValue_231()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint16_t> nullableInt16uArgument;
        nullableInt16uArgument.SetNonNull();
        nullableInt16uArgument.Value() = 32000U;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt16u::TypeInfo>(
            nullableInt16uArgument, this, OnSuccessCallback_231, OnFailureCallback_231));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_231(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_231() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableInt16uValueInRange_232()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt16u::TypeInfo>(
            this, OnSuccessCallback_232, OnFailureCallback_232, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_232(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_232(const chip::app::DataModel::Nullable<uint16_t> & nullableInt16u)
    {
        VerifyOrReturn(CheckConstraintMinValue<uint16_t>("nullableInt16u", nullableInt16u, 0U));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("nullableInt16u", nullableInt16u, 65534U));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeNullableInt16uNotValueOk_233()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt16u::TypeInfo>(
            this, OnSuccessCallback_233, OnFailureCallback_233, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_233(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_233(const chip::app::DataModel::Nullable<uint16_t> & nullableInt16u)
    {
        VerifyOrReturn(CheckConstraintNotValue("nullableInt16u", nullableInt16u, 32001U));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableInt32uMinValue_234()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint32_t> nullableInt32uArgument;
        nullableInt32uArgument.SetNonNull();
        nullableInt32uArgument.Value() = 0UL;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt32u::TypeInfo>(
            nullableInt32uArgument, this, OnSuccessCallback_234, OnFailureCallback_234));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_234(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_234() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableInt32uMinValue_235()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt32u::TypeInfo>(
            this, OnSuccessCallback_235, OnFailureCallback_235, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_235(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_235(const chip::app::DataModel::Nullable<uint32_t> & nullableInt32u)
    {
        VerifyOrReturn(CheckValueNonNull("nullableInt32u", nullableInt32u));
        VerifyOrReturn(CheckValue("nullableInt32u.Value()", nullableInt32u.Value(), 0UL));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableInt32uMaxValue_236()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint32_t> nullableInt32uArgument;
        nullableInt32uArgument.SetNonNull();
        nullableInt32uArgument.Value() = 4294967294UL;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt32u::TypeInfo>(
            nullableInt32uArgument, this, OnSuccessCallback_236, OnFailureCallback_236));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_236(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_236() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableInt32uMaxValue_237()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt32u::TypeInfo>(
            this, OnSuccessCallback_237, OnFailureCallback_237, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_237(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_237(const chip::app::DataModel::Nullable<uint32_t> & nullableInt32u)
    {
        VerifyOrReturn(CheckValueNonNull("nullableInt32u", nullableInt32u));
        VerifyOrReturn(CheckValue("nullableInt32u.Value()", nullableInt32u.Value(), 4294967294UL));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableInt32uInvalidValue_238()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint32_t> nullableInt32uArgument;
        nullableInt32uArgument.SetNonNull();
        nullableInt32uArgument.Value() = 4294967295UL;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt32u::TypeInfo>(
            nullableInt32uArgument, this, OnSuccessCallback_238, OnFailureCallback_238));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_238(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
        NextTest();
    }

    void OnSuccessResponse_238() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadAttributeNullableInt32uUnchangedValue_239()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt32u::TypeInfo>(
            this, OnSuccessCallback_239, OnFailureCallback_239, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_239(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_239(const chip::app::DataModel::Nullable<uint32_t> & nullableInt32u)
    {
        VerifyOrReturn(CheckValueNonNull("nullableInt32u", nullableInt32u));
        VerifyOrReturn(CheckValue("nullableInt32u.Value()", nullableInt32u.Value(), 4294967294UL));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableInt32uNullValue_240()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint32_t> nullableInt32uArgument;
        nullableInt32uArgument.SetNull();

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt32u::TypeInfo>(
            nullableInt32uArgument, this, OnSuccessCallback_240, OnFailureCallback_240));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_240(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_240() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableInt32uNullValue_241()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt32u::TypeInfo>(
            this, OnSuccessCallback_241, OnFailureCallback_241, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_241(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_241(const chip::app::DataModel::Nullable<uint32_t> & nullableInt32u)
    {
        VerifyOrReturn(CheckValueNull("nullableInt32u", nullableInt32u));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeNullableInt32uNullValueRange_242()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt32u::TypeInfo>(
            this, OnSuccessCallback_242, OnFailureCallback_242, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_242(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_242(const chip::app::DataModel::Nullable<uint32_t> & nullableInt32u)
    {
        VerifyOrReturn(CheckConstraintMinValue<uint32_t>("nullableInt32u", nullableInt32u, 0UL));
        VerifyOrReturn(CheckConstraintMaxValue<uint32_t>("nullableInt32u", nullableInt32u, 4294967294UL));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeNullableInt32uNullValueNot_243()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt32u::TypeInfo>(
            this, OnSuccessCallback_243, OnFailureCallback_243, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_243(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_243(const chip::app::DataModel::Nullable<uint32_t> & nullableInt32u)
    {
        VerifyOrReturn(CheckConstraintNotValue("nullableInt32u", nullableInt32u, 4294967294UL));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableInt32uValue_244()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint32_t> nullableInt32uArgument;
        nullableInt32uArgument.SetNonNull();
        nullableInt32uArgument.Value() = 2147483647UL;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt32u::TypeInfo>(
            nullableInt32uArgument, this, OnSuccessCallback_244, OnFailureCallback_244));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_244(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_244() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableInt32uValueInRange_245()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt32u::TypeInfo>(
            this, OnSuccessCallback_245, OnFailureCallback_245, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_245(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_245(const chip::app::DataModel::Nullable<uint32_t> & nullableInt32u)
    {
        VerifyOrReturn(CheckConstraintMinValue<uint32_t>("nullableInt32u", nullableInt32u, 0UL));
        VerifyOrReturn(CheckConstraintMaxValue<uint32_t>("nullableInt32u", nullableInt32u, 4294967294UL));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeNullableInt32uNotValueOk_246()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt32u::TypeInfo>(
            this, OnSuccessCallback_246, OnFailureCallback_246, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_246(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_246(const chip::app::DataModel::Nullable<uint32_t> & nullableInt32u)
    {
        VerifyOrReturn(CheckConstraintNotValue("nullableInt32u", nullableInt32u, 2147483648UL));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableInt64uMinValue_247()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint64_t> nullableInt64uArgument;
        nullableInt64uArgument.SetNonNull();
        nullableInt64uArgument.Value() = 0ULL;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt64u::TypeInfo>(
            nullableInt64uArgument, this, OnSuccessCallback_247, OnFailureCallback_247));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_247(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_247() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableInt64uMinValue_248()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt64u::TypeInfo>(
            this, OnSuccessCallback_248, OnFailureCallback_248, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_248(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_248(const chip::app::DataModel::Nullable<uint64_t> & nullableInt64u)
    {
        VerifyOrReturn(CheckValueNonNull("nullableInt64u", nullableInt64u));
        VerifyOrReturn(CheckValue("nullableInt64u.Value()", nullableInt64u.Value(), 0ULL));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableInt64uMaxValue_249()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint64_t> nullableInt64uArgument;
        nullableInt64uArgument.SetNonNull();
        nullableInt64uArgument.Value() = 18446744073709551614ULL;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt64u::TypeInfo>(
            nullableInt64uArgument, this, OnSuccessCallback_249, OnFailureCallback_249));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_249(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_249() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableInt64uMaxValue_250()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt64u::TypeInfo>(
            this, OnSuccessCallback_250, OnFailureCallback_250, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_250(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_250(const chip::app::DataModel::Nullable<uint64_t> & nullableInt64u)
    {
        VerifyOrReturn(CheckValueNonNull("nullableInt64u", nullableInt64u));
        VerifyOrReturn(CheckValue("nullableInt64u.Value()", nullableInt64u.Value(), 18446744073709551614ULL));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableInt64uInvalidValue_251()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint64_t> nullableInt64uArgument;
        nullableInt64uArgument.SetNonNull();
        nullableInt64uArgument.Value() = 18446744073709551615ULL;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt64u::TypeInfo>(
            nullableInt64uArgument, this, OnSuccessCallback_251, OnFailureCallback_251));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_251(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
        NextTest();
    }

    void OnSuccessResponse_251() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadAttributeNullableInt64uUnchangedValue_252()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt64u::TypeInfo>(
            this, OnSuccessCallback_252, OnFailureCallback_252, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_252(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_252(const chip::app::DataModel::Nullable<uint64_t> & nullableInt64u)
    {
        VerifyOrReturn(CheckValueNonNull("nullableInt64u", nullableInt64u));
        VerifyOrReturn(CheckValue("nullableInt64u.Value()", nullableInt64u.Value(), 18446744073709551614ULL));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableInt64uNullValue_253()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint64_t> nullableInt64uArgument;
        nullableInt64uArgument.SetNull();

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt64u::TypeInfo>(
            nullableInt64uArgument, this, OnSuccessCallback_253, OnFailureCallback_253));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_253(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_253() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableInt64uNullValue_254()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt64u::TypeInfo>(
            this, OnSuccessCallback_254, OnFailureCallback_254, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_254(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_254(const chip::app::DataModel::Nullable<uint64_t> & nullableInt64u)
    {
        VerifyOrReturn(CheckValueNull("nullableInt64u", nullableInt64u));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeNullableInt64uNullValueRange_255()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt64u::TypeInfo>(
            this, OnSuccessCallback_255, OnFailureCallback_255, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_255(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_255(const chip::app::DataModel::Nullable<uint64_t> & nullableInt64u)
    {
        VerifyOrReturn(CheckConstraintMinValue<uint64_t>("nullableInt64u", nullableInt64u, 0ULL));
        VerifyOrReturn(CheckConstraintMaxValue<uint64_t>("nullableInt64u", nullableInt64u, 18446744073709551614ULL));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeNullableInt64uNullValueNot_256()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt64u::TypeInfo>(
            this, OnSuccessCallback_256, OnFailureCallback_256, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_256(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_256(const chip::app::DataModel::Nullable<uint64_t> & nullableInt64u)
    {
        VerifyOrReturn(CheckConstraintNotValue("nullableInt64u", nullableInt64u, 18446744073709551614ULL));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableInt64uValue_257()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint64_t> nullableInt64uArgument;
        nullableInt64uArgument.SetNonNull();
        nullableInt64uArgument.Value() = 18000000000000000000ULL;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt64u::TypeInfo>(
            nullableInt64uArgument, this, OnSuccessCallback_257, OnFailureCallback_257));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_257(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_257() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableInt64uValueInRange_258()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt64u::TypeInfo>(
            this, OnSuccessCallback_258, OnFailureCallback_258, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_258(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_258(const chip::app::DataModel::Nullable<uint64_t> & nullableInt64u)
    {
        VerifyOrReturn(CheckConstraintMinValue<uint64_t>("nullableInt64u", nullableInt64u, 0ULL));
        VerifyOrReturn(CheckConstraintMaxValue<uint64_t>("nullableInt64u", nullableInt64u, 18446744073709551614ULL));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeNullableInt64uNotValueOk_259()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt64u::TypeInfo>(
            this, OnSuccessCallback_259, OnFailureCallback_259, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_259(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_259(const chip::app::DataModel::Nullable<uint64_t> & nullableInt64u)
    {
        VerifyOrReturn(CheckConstraintNotValue("nullableInt64u", nullableInt64u, 18000000000000000001ULL));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableInt8sMinValue_260()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<int8_t> nullableInt8sArgument;
        nullableInt8sArgument.SetNonNull();
        nullableInt8sArgument.Value() = -127;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt8s::TypeInfo>(
            nullableInt8sArgument, this, OnSuccessCallback_260, OnFailureCallback_260));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_260(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_260() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableInt8sMinValue_261()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt8s::TypeInfo>(
            this, OnSuccessCallback_261, OnFailureCallback_261, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_261(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_261(const chip::app::DataModel::Nullable<int8_t> & nullableInt8s)
    {
        VerifyOrReturn(CheckValueNonNull("nullableInt8s", nullableInt8s));
        VerifyOrReturn(CheckValue("nullableInt8s.Value()", nullableInt8s.Value(), -127));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableInt8sInvalidValue_262()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<int8_t> nullableInt8sArgument;
        nullableInt8sArgument.SetNonNull();
        nullableInt8sArgument.Value() = -128;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt8s::TypeInfo>(
            nullableInt8sArgument, this, OnSuccessCallback_262, OnFailureCallback_262));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_262(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
        NextTest();
    }

    void OnSuccessResponse_262() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadAttributeNullableInt8sUnchangedValue_263()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt8s::TypeInfo>(
            this, OnSuccessCallback_263, OnFailureCallback_263, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_263(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_263(const chip::app::DataModel::Nullable<int8_t> & nullableInt8s)
    {
        VerifyOrReturn(CheckValueNonNull("nullableInt8s", nullableInt8s));
        VerifyOrReturn(CheckValue("nullableInt8s.Value()", nullableInt8s.Value(), -127));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableInt8sNullValue_264()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<int8_t> nullableInt8sArgument;
        nullableInt8sArgument.SetNull();

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt8s::TypeInfo>(
            nullableInt8sArgument, this, OnSuccessCallback_264, OnFailureCallback_264));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_264(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_264() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableInt8sNullValue_265()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt8s::TypeInfo>(
            this, OnSuccessCallback_265, OnFailureCallback_265, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_265(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_265(const chip::app::DataModel::Nullable<int8_t> & nullableInt8s)
    {
        VerifyOrReturn(CheckValueNull("nullableInt8s", nullableInt8s));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeNullableInt8sNullValueRange_266()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt8s::TypeInfo>(
            this, OnSuccessCallback_266, OnFailureCallback_266, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_266(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_266(const chip::app::DataModel::Nullable<int8_t> & nullableInt8s)
    {
        VerifyOrReturn(CheckConstraintMinValue<int8_t>("nullableInt8s", nullableInt8s, -127));
        VerifyOrReturn(CheckConstraintMaxValue<int8_t>("nullableInt8s", nullableInt8s, 127));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeNullableInt8sNullValueNot_267()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt8s::TypeInfo>(
            this, OnSuccessCallback_267, OnFailureCallback_267, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_267(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_267(const chip::app::DataModel::Nullable<int8_t> & nullableInt8s)
    {
        VerifyOrReturn(CheckConstraintNotValue("nullableInt8s", nullableInt8s, -127));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableInt8sValue_268()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<int8_t> nullableInt8sArgument;
        nullableInt8sArgument.SetNonNull();
        nullableInt8sArgument.Value() = -127;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt8s::TypeInfo>(
            nullableInt8sArgument, this, OnSuccessCallback_268, OnFailureCallback_268));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_268(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_268() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableInt8sValueInRange_269()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt8s::TypeInfo>(
            this, OnSuccessCallback_269, OnFailureCallback_269, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_269(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_269(const chip::app::DataModel::Nullable<int8_t> & nullableInt8s)
    {
        VerifyOrReturn(CheckConstraintMinValue<int8_t>("nullableInt8s", nullableInt8s, -127));
        VerifyOrReturn(CheckConstraintMaxValue<int8_t>("nullableInt8s", nullableInt8s, 127));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeNullableInt8sNotValueOk_270()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt8s::TypeInfo>(
            this, OnSuccessCallback_270, OnFailureCallback_270, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_270(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_270(const chip::app::DataModel::Nullable<int8_t> & nullableInt8s)
    {
        VerifyOrReturn(CheckConstraintNotValue("nullableInt8s", nullableInt8s, -126));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableInt16sMinValue_271()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<int16_t> nullableInt16sArgument;
        nullableInt16sArgument.SetNonNull();
        nullableInt16sArgument.Value() = -32767;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt16s::TypeInfo>(
            nullableInt16sArgument, this, OnSuccessCallback_271, OnFailureCallback_271));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_271(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_271() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableInt16sMinValue_272()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt16s::TypeInfo>(
            this, OnSuccessCallback_272, OnFailureCallback_272, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_272(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_272(const chip::app::DataModel::Nullable<int16_t> & nullableInt16s)
    {
        VerifyOrReturn(CheckValueNonNull("nullableInt16s", nullableInt16s));
        VerifyOrReturn(CheckValue("nullableInt16s.Value()", nullableInt16s.Value(), -32767));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableInt16sInvalidValue_273()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<int16_t> nullableInt16sArgument;
        nullableInt16sArgument.SetNonNull();
        nullableInt16sArgument.Value() = -32768;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt16s::TypeInfo>(
            nullableInt16sArgument, this, OnSuccessCallback_273, OnFailureCallback_273));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_273(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
        NextTest();
    }

    void OnSuccessResponse_273() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadAttributeNullableInt16sUnchangedValue_274()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt16s::TypeInfo>(
            this, OnSuccessCallback_274, OnFailureCallback_274, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_274(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_274(const chip::app::DataModel::Nullable<int16_t> & nullableInt16s)
    {
        VerifyOrReturn(CheckValueNonNull("nullableInt16s", nullableInt16s));
        VerifyOrReturn(CheckValue("nullableInt16s.Value()", nullableInt16s.Value(), -32767));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableInt16sNullValue_275()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<int16_t> nullableInt16sArgument;
        nullableInt16sArgument.SetNull();

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt16s::TypeInfo>(
            nullableInt16sArgument, this, OnSuccessCallback_275, OnFailureCallback_275));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_275(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_275() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableInt16sNullValue_276()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt16s::TypeInfo>(
            this, OnSuccessCallback_276, OnFailureCallback_276, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_276(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_276(const chip::app::DataModel::Nullable<int16_t> & nullableInt16s)
    {
        VerifyOrReturn(CheckValueNull("nullableInt16s", nullableInt16s));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeNullableInt16sNullValueRange_277()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt16s::TypeInfo>(
            this, OnSuccessCallback_277, OnFailureCallback_277, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_277(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_277(const chip::app::DataModel::Nullable<int16_t> & nullableInt16s)
    {
        VerifyOrReturn(CheckConstraintMinValue<int16_t>("nullableInt16s", nullableInt16s, -32767));
        VerifyOrReturn(CheckConstraintMaxValue<int16_t>("nullableInt16s", nullableInt16s, 32767));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeNullableInt16sNullValueNot_278()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt16s::TypeInfo>(
            this, OnSuccessCallback_278, OnFailureCallback_278, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_278(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_278(const chip::app::DataModel::Nullable<int16_t> & nullableInt16s)
    {
        VerifyOrReturn(CheckConstraintNotValue("nullableInt16s", nullableInt16s, -32767));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableInt16sValue_279()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<int16_t> nullableInt16sArgument;
        nullableInt16sArgument.SetNonNull();
        nullableInt16sArgument.Value() = -32767;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt16s::TypeInfo>(
            nullableInt16sArgument, this, OnSuccessCallback_279, OnFailureCallback_279));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_279(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_279() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableInt16sValueInRange_280()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt16s::TypeInfo>(
            this, OnSuccessCallback_280, OnFailureCallback_280, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_280(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_280(const chip::app::DataModel::Nullable<int16_t> & nullableInt16s)
    {
        VerifyOrReturn(CheckConstraintMinValue<int16_t>("nullableInt16s", nullableInt16s, -32767));
        VerifyOrReturn(CheckConstraintMaxValue<int16_t>("nullableInt16s", nullableInt16s, 32767));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeNullableInt16sNotValueOk_281()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt16s::TypeInfo>(
            this, OnSuccessCallback_281, OnFailureCallback_281, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_281(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_281(const chip::app::DataModel::Nullable<int16_t> & nullableInt16s)
    {
        VerifyOrReturn(CheckConstraintNotValue("nullableInt16s", nullableInt16s, -32766));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableInt32sMinValue_282()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<int32_t> nullableInt32sArgument;
        nullableInt32sArgument.SetNonNull();
        nullableInt32sArgument.Value() = -2147483647L;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt32s::TypeInfo>(
            nullableInt32sArgument, this, OnSuccessCallback_282, OnFailureCallback_282));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_282(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_282() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableInt32sMinValue_283()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt32s::TypeInfo>(
            this, OnSuccessCallback_283, OnFailureCallback_283, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_283(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_283(const chip::app::DataModel::Nullable<int32_t> & nullableInt32s)
    {
        VerifyOrReturn(CheckValueNonNull("nullableInt32s", nullableInt32s));
        VerifyOrReturn(CheckValue("nullableInt32s.Value()", nullableInt32s.Value(), -2147483647L));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableInt32sInvalidValue_284()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<int32_t> nullableInt32sArgument;
        nullableInt32sArgument.SetNonNull();
        nullableInt32sArgument.Value() = -2147483648L;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt32s::TypeInfo>(
            nullableInt32sArgument, this, OnSuccessCallback_284, OnFailureCallback_284));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_284(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
        NextTest();
    }

    void OnSuccessResponse_284() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadAttributeNullableInt32sUnchangedValue_285()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt32s::TypeInfo>(
            this, OnSuccessCallback_285, OnFailureCallback_285, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_285(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_285(const chip::app::DataModel::Nullable<int32_t> & nullableInt32s)
    {
        VerifyOrReturn(CheckValueNonNull("nullableInt32s", nullableInt32s));
        VerifyOrReturn(CheckValue("nullableInt32s.Value()", nullableInt32s.Value(), -2147483647L));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableInt32sNullValue_286()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<int32_t> nullableInt32sArgument;
        nullableInt32sArgument.SetNull();

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt32s::TypeInfo>(
            nullableInt32sArgument, this, OnSuccessCallback_286, OnFailureCallback_286));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_286(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_286() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableInt32sNullValue_287()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt32s::TypeInfo>(
            this, OnSuccessCallback_287, OnFailureCallback_287, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_287(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_287(const chip::app::DataModel::Nullable<int32_t> & nullableInt32s)
    {
        VerifyOrReturn(CheckValueNull("nullableInt32s", nullableInt32s));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeNullableInt32sNullValueRange_288()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt32s::TypeInfo>(
            this, OnSuccessCallback_288, OnFailureCallback_288, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_288(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_288(const chip::app::DataModel::Nullable<int32_t> & nullableInt32s)
    {
        VerifyOrReturn(CheckConstraintMinValue<int32_t>("nullableInt32s", nullableInt32s, -2147483647L));
        VerifyOrReturn(CheckConstraintMaxValue<int32_t>("nullableInt32s", nullableInt32s, 2147483647L));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeNullableInt32sNullValueNot_289()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt32s::TypeInfo>(
            this, OnSuccessCallback_289, OnFailureCallback_289, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_289(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_289(const chip::app::DataModel::Nullable<int32_t> & nullableInt32s)
    {
        VerifyOrReturn(CheckConstraintNotValue("nullableInt32s", nullableInt32s, -2147483647L));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableInt32sValue_290()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<int32_t> nullableInt32sArgument;
        nullableInt32sArgument.SetNonNull();
        nullableInt32sArgument.Value() = -2147483647L;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt32s::TypeInfo>(
            nullableInt32sArgument, this, OnSuccessCallback_290, OnFailureCallback_290));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_290(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_290() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableInt32sValueInRange_291()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt32s::TypeInfo>(
            this, OnSuccessCallback_291, OnFailureCallback_291, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_291(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_291(const chip::app::DataModel::Nullable<int32_t> & nullableInt32s)
    {
        VerifyOrReturn(CheckConstraintMinValue<int32_t>("nullableInt32s", nullableInt32s, -2147483647L));
        VerifyOrReturn(CheckConstraintMaxValue<int32_t>("nullableInt32s", nullableInt32s, 2147483647L));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeNullableInt32sNotValueOk_292()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt32s::TypeInfo>(
            this, OnSuccessCallback_292, OnFailureCallback_292, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_292(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_292(const chip::app::DataModel::Nullable<int32_t> & nullableInt32s)
    {
        VerifyOrReturn(CheckConstraintNotValue("nullableInt32s", nullableInt32s, -2147483646L));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableInt64sMinValue_293()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<int64_t> nullableInt64sArgument;
        nullableInt64sArgument.SetNonNull();
        nullableInt64sArgument.Value() = -9223372036854775807LL;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt64s::TypeInfo>(
            nullableInt64sArgument, this, OnSuccessCallback_293, OnFailureCallback_293));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_293(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_293() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableInt64sMinValue_294()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt64s::TypeInfo>(
            this, OnSuccessCallback_294, OnFailureCallback_294, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_294(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_294(const chip::app::DataModel::Nullable<int64_t> & nullableInt64s)
    {
        VerifyOrReturn(CheckValueNonNull("nullableInt64s", nullableInt64s));
        VerifyOrReturn(CheckValue("nullableInt64s.Value()", nullableInt64s.Value(), -9223372036854775807LL));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableInt64sInvalidValue_295()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<int64_t> nullableInt64sArgument;
        nullableInt64sArgument.SetNonNull();
        nullableInt64sArgument.Value() = -9223372036854775807LL - 1;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt64s::TypeInfo>(
            nullableInt64sArgument, this, OnSuccessCallback_295, OnFailureCallback_295));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_295(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
        NextTest();
    }

    void OnSuccessResponse_295() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadAttributeNullableInt64sUnchangedValue_296()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt64s::TypeInfo>(
            this, OnSuccessCallback_296, OnFailureCallback_296, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_296(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_296(const chip::app::DataModel::Nullable<int64_t> & nullableInt64s)
    {
        VerifyOrReturn(CheckValueNonNull("nullableInt64s", nullableInt64s));
        VerifyOrReturn(CheckValue("nullableInt64s.Value()", nullableInt64s.Value(), -9223372036854775807LL));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableInt64sNullValue_297()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<int64_t> nullableInt64sArgument;
        nullableInt64sArgument.SetNull();

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt64s::TypeInfo>(
            nullableInt64sArgument, this, OnSuccessCallback_297, OnFailureCallback_297));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_297(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_297() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableInt64sNullValue_298()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt64s::TypeInfo>(
            this, OnSuccessCallback_298, OnFailureCallback_298, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_298(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_298(const chip::app::DataModel::Nullable<int64_t> & nullableInt64s)
    {
        VerifyOrReturn(CheckValueNull("nullableInt64s", nullableInt64s));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeNullableInt64sNullValueRange_299()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt64s::TypeInfo>(
            this, OnSuccessCallback_299, OnFailureCallback_299, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_299(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_299(const chip::app::DataModel::Nullable<int64_t> & nullableInt64s)
    {
        VerifyOrReturn(CheckConstraintMinValue<int64_t>("nullableInt64s", nullableInt64s, -9223372036854775807LL));
        VerifyOrReturn(CheckConstraintMaxValue<int64_t>("nullableInt64s", nullableInt64s, 9223372036854775807LL));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeNullableInt64sNullValueNot_300()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt64s::TypeInfo>(
            this, OnSuccessCallback_300, OnFailureCallback_300, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_300(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_300(const chip::app::DataModel::Nullable<int64_t> & nullableInt64s)
    {
        VerifyOrReturn(CheckConstraintNotValue("nullableInt64s", nullableInt64s, -9223372036854775807LL));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableInt64sValue_301()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<int64_t> nullableInt64sArgument;
        nullableInt64sArgument.SetNonNull();
        nullableInt64sArgument.Value() = -9223372036854775807LL;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt64s::TypeInfo>(
            nullableInt64sArgument, this, OnSuccessCallback_301, OnFailureCallback_301));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_301(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_301() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableInt64sValueInRange_302()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt64s::TypeInfo>(
            this, OnSuccessCallback_302, OnFailureCallback_302, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_302(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_302(const chip::app::DataModel::Nullable<int64_t> & nullableInt64s)
    {
        VerifyOrReturn(CheckConstraintMinValue<int64_t>("nullableInt64s", nullableInt64s, -9223372036854775807LL));
        VerifyOrReturn(CheckConstraintMaxValue<int64_t>("nullableInt64s", nullableInt64s, 9223372036854775807LL));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeNullableInt64sNotValueOk_303()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt64s::TypeInfo>(
            this, OnSuccessCallback_303, OnFailureCallback_303, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_303(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_303(const chip::app::DataModel::Nullable<int64_t> & nullableInt64s)
    {
        VerifyOrReturn(CheckConstraintNotValue("nullableInt64s", nullableInt64s, -9223372036854775806LL));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableSingleMediumValue_304()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<float> nullableFloatSingleArgument;
        nullableFloatSingleArgument.SetNonNull();
        nullableFloatSingleArgument.Value() = 0.1f;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableFloatSingle::TypeInfo>(
            nullableFloatSingleArgument, this, OnSuccessCallback_304, OnFailureCallback_304));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_304(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_304() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableSingleMediumValue_305()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableFloatSingle::TypeInfo>(
            this, OnSuccessCallback_305, OnFailureCallback_305, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_305(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_305(const chip::app::DataModel::Nullable<float> & nullableFloatSingle)
    {
        VerifyOrReturn(CheckValueNonNull("nullableFloatSingle", nullableFloatSingle));
        VerifyOrReturn(CheckValue("nullableFloatSingle.Value()", nullableFloatSingle.Value(), 0.1f));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableSingleLargestValue_306()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<float> nullableFloatSingleArgument;
        nullableFloatSingleArgument.SetNonNull();
        nullableFloatSingleArgument.Value() = INFINITY;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableFloatSingle::TypeInfo>(
            nullableFloatSingleArgument, this, OnSuccessCallback_306, OnFailureCallback_306));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_306(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_306() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableSingleLargestValue_307()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableFloatSingle::TypeInfo>(
            this, OnSuccessCallback_307, OnFailureCallback_307, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_307(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_307(const chip::app::DataModel::Nullable<float> & nullableFloatSingle)
    {
        VerifyOrReturn(CheckValueNonNull("nullableFloatSingle", nullableFloatSingle));
        VerifyOrReturn(CheckValue("nullableFloatSingle.Value()", nullableFloatSingle.Value(), INFINITY));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableSingleSmallestValue_308()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<float> nullableFloatSingleArgument;
        nullableFloatSingleArgument.SetNonNull();
        nullableFloatSingleArgument.Value() = -INFINITY;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableFloatSingle::TypeInfo>(
            nullableFloatSingleArgument, this, OnSuccessCallback_308, OnFailureCallback_308));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_308(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_308() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableSingleSmallestValue_309()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableFloatSingle::TypeInfo>(
            this, OnSuccessCallback_309, OnFailureCallback_309, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_309(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_309(const chip::app::DataModel::Nullable<float> & nullableFloatSingle)
    {
        VerifyOrReturn(CheckValueNonNull("nullableFloatSingle", nullableFloatSingle));
        VerifyOrReturn(CheckValue("nullableFloatSingle.Value()", nullableFloatSingle.Value(), -INFINITY));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableSingleNullValue_310()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<float> nullableFloatSingleArgument;
        nullableFloatSingleArgument.SetNull();

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableFloatSingle::TypeInfo>(
            nullableFloatSingleArgument, this, OnSuccessCallback_310, OnFailureCallback_310));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_310(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_310() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableSingleNullValue_311()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableFloatSingle::TypeInfo>(
            this, OnSuccessCallback_311, OnFailureCallback_311, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_311(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_311(const chip::app::DataModel::Nullable<float> & nullableFloatSingle)
    {
        VerifyOrReturn(CheckValueNull("nullableFloatSingle", nullableFloatSingle));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableSingle0Value_312()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<float> nullableFloatSingleArgument;
        nullableFloatSingleArgument.SetNonNull();
        nullableFloatSingleArgument.Value() = 0.0f;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableFloatSingle::TypeInfo>(
            nullableFloatSingleArgument, this, OnSuccessCallback_312, OnFailureCallback_312));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_312(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_312() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableSingle0Value_313()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableFloatSingle::TypeInfo>(
            this, OnSuccessCallback_313, OnFailureCallback_313, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_313(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_313(const chip::app::DataModel::Nullable<float> & nullableFloatSingle)
    {
        VerifyOrReturn(CheckValueNonNull("nullableFloatSingle", nullableFloatSingle));
        VerifyOrReturn(CheckValue("nullableFloatSingle.Value()", nullableFloatSingle.Value(), 0.0f));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableDoubleMediumValue_314()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<double> nullableFloatDoubleArgument;
        nullableFloatDoubleArgument.SetNonNull();
        nullableFloatDoubleArgument.Value() = 0.1234567890123;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableFloatDouble::TypeInfo>(
            nullableFloatDoubleArgument, this, OnSuccessCallback_314, OnFailureCallback_314));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_314(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_314() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableDoubleMediumValue_315()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableFloatDouble::TypeInfo>(
            this, OnSuccessCallback_315, OnFailureCallback_315, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_315(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_315(const chip::app::DataModel::Nullable<double> & nullableFloatDouble)
    {
        VerifyOrReturn(CheckValueNonNull("nullableFloatDouble", nullableFloatDouble));
        VerifyOrReturn(CheckValue("nullableFloatDouble.Value()", nullableFloatDouble.Value(), 0.1234567890123));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableDoubleLargestValue_316()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<double> nullableFloatDoubleArgument;
        nullableFloatDoubleArgument.SetNonNull();
        nullableFloatDoubleArgument.Value() = INFINITY;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableFloatDouble::TypeInfo>(
            nullableFloatDoubleArgument, this, OnSuccessCallback_316, OnFailureCallback_316));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_316(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_316() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableDoubleLargestValue_317()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableFloatDouble::TypeInfo>(
            this, OnSuccessCallback_317, OnFailureCallback_317, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_317(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_317(const chip::app::DataModel::Nullable<double> & nullableFloatDouble)
    {
        VerifyOrReturn(CheckValueNonNull("nullableFloatDouble", nullableFloatDouble));
        VerifyOrReturn(CheckValue("nullableFloatDouble.Value()", nullableFloatDouble.Value(), INFINITY));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableDoubleSmallestValue_318()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<double> nullableFloatDoubleArgument;
        nullableFloatDoubleArgument.SetNonNull();
        nullableFloatDoubleArgument.Value() = -INFINITY;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableFloatDouble::TypeInfo>(
            nullableFloatDoubleArgument, this, OnSuccessCallback_318, OnFailureCallback_318));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_318(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_318() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableDoubleSmallestValue_319()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableFloatDouble::TypeInfo>(
            this, OnSuccessCallback_319, OnFailureCallback_319, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_319(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_319(const chip::app::DataModel::Nullable<double> & nullableFloatDouble)
    {
        VerifyOrReturn(CheckValueNonNull("nullableFloatDouble", nullableFloatDouble));
        VerifyOrReturn(CheckValue("nullableFloatDouble.Value()", nullableFloatDouble.Value(), -INFINITY));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableDoubleNullValue_320()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<double> nullableFloatDoubleArgument;
        nullableFloatDoubleArgument.SetNull();

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableFloatDouble::TypeInfo>(
            nullableFloatDoubleArgument, this, OnSuccessCallback_320, OnFailureCallback_320));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_320(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_320() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableDoubleNullValue_321()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableFloatDouble::TypeInfo>(
            this, OnSuccessCallback_321, OnFailureCallback_321, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_321(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_321(const chip::app::DataModel::Nullable<double> & nullableFloatDouble)
    {
        VerifyOrReturn(CheckValueNull("nullableFloatDouble", nullableFloatDouble));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableDouble0Value_322()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<double> nullableFloatDoubleArgument;
        nullableFloatDoubleArgument.SetNonNull();
        nullableFloatDoubleArgument.Value() = 0;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableFloatDouble::TypeInfo>(
            nullableFloatDoubleArgument, this, OnSuccessCallback_322, OnFailureCallback_322));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_322(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_322() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableDouble0Value_323()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableFloatDouble::TypeInfo>(
            this, OnSuccessCallback_323, OnFailureCallback_323, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_323(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_323(const chip::app::DataModel::Nullable<double> & nullableFloatDouble)
    {
        VerifyOrReturn(CheckValueNonNull("nullableFloatDouble", nullableFloatDouble));
        VerifyOrReturn(CheckValue("nullableFloatDouble.Value()", nullableFloatDouble.Value(), 0));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableEnum8MinValue_324()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint8_t> nullableEnum8Argument;
        nullableEnum8Argument.SetNonNull();
        nullableEnum8Argument.Value() = 0;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableEnum8::TypeInfo>(
            nullableEnum8Argument, this, OnSuccessCallback_324, OnFailureCallback_324));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_324(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_324() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableEnum8MinValue_325()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableEnum8::TypeInfo>(
            this, OnSuccessCallback_325, OnFailureCallback_325, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_325(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_325(const chip::app::DataModel::Nullable<uint8_t> & nullableEnum8)
    {
        VerifyOrReturn(CheckValueNonNull("nullableEnum8", nullableEnum8));
        VerifyOrReturn(CheckValue("nullableEnum8.Value()", nullableEnum8.Value(), 0));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableEnum8MaxValue_326()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint8_t> nullableEnum8Argument;
        nullableEnum8Argument.SetNonNull();
        nullableEnum8Argument.Value() = 254;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableEnum8::TypeInfo>(
            nullableEnum8Argument, this, OnSuccessCallback_326, OnFailureCallback_326));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_326(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_326() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableEnum8MaxValue_327()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableEnum8::TypeInfo>(
            this, OnSuccessCallback_327, OnFailureCallback_327, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_327(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_327(const chip::app::DataModel::Nullable<uint8_t> & nullableEnum8)
    {
        VerifyOrReturn(CheckValueNonNull("nullableEnum8", nullableEnum8));
        VerifyOrReturn(CheckValue("nullableEnum8.Value()", nullableEnum8.Value(), 254));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableEnum8InvalidValue_328()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint8_t> nullableEnum8Argument;
        nullableEnum8Argument.SetNonNull();
        nullableEnum8Argument.Value() = 255;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableEnum8::TypeInfo>(
            nullableEnum8Argument, this, OnSuccessCallback_328, OnFailureCallback_328));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_328(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
        NextTest();
    }

    void OnSuccessResponse_328() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadAttributeNullableEnum8UnchangedValue_329()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableEnum8::TypeInfo>(
            this, OnSuccessCallback_329, OnFailureCallback_329, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_329(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_329(const chip::app::DataModel::Nullable<uint8_t> & nullableEnum8)
    {
        VerifyOrReturn(CheckValueNonNull("nullableEnum8", nullableEnum8));
        VerifyOrReturn(CheckValue("nullableEnum8.Value()", nullableEnum8.Value(), 254));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableEnum8NullValue_330()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint8_t> nullableEnum8Argument;
        nullableEnum8Argument.SetNull();

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableEnum8::TypeInfo>(
            nullableEnum8Argument, this, OnSuccessCallback_330, OnFailureCallback_330));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_330(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_330() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableEnum8NullValue_331()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableEnum8::TypeInfo>(
            this, OnSuccessCallback_331, OnFailureCallback_331, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_331(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_331(const chip::app::DataModel::Nullable<uint8_t> & nullableEnum8)
    {
        VerifyOrReturn(CheckValueNull("nullableEnum8", nullableEnum8));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableEnum16MinValue_332()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint16_t> nullableEnum16Argument;
        nullableEnum16Argument.SetNonNull();
        nullableEnum16Argument.Value() = 0U;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableEnum16::TypeInfo>(
            nullableEnum16Argument, this, OnSuccessCallback_332, OnFailureCallback_332));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_332(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_332() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableEnum16MinValue_333()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableEnum16::TypeInfo>(
            this, OnSuccessCallback_333, OnFailureCallback_333, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_333(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_333(const chip::app::DataModel::Nullable<uint16_t> & nullableEnum16)
    {
        VerifyOrReturn(CheckValueNonNull("nullableEnum16", nullableEnum16));
        VerifyOrReturn(CheckValue("nullableEnum16.Value()", nullableEnum16.Value(), 0U));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableEnum16MaxValue_334()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint16_t> nullableEnum16Argument;
        nullableEnum16Argument.SetNonNull();
        nullableEnum16Argument.Value() = 65534U;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableEnum16::TypeInfo>(
            nullableEnum16Argument, this, OnSuccessCallback_334, OnFailureCallback_334));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_334(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_334() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableEnum16MaxValue_335()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableEnum16::TypeInfo>(
            this, OnSuccessCallback_335, OnFailureCallback_335, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_335(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_335(const chip::app::DataModel::Nullable<uint16_t> & nullableEnum16)
    {
        VerifyOrReturn(CheckValueNonNull("nullableEnum16", nullableEnum16));
        VerifyOrReturn(CheckValue("nullableEnum16.Value()", nullableEnum16.Value(), 65534U));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableEnum16InvalidValue_336()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint16_t> nullableEnum16Argument;
        nullableEnum16Argument.SetNonNull();
        nullableEnum16Argument.Value() = 65535U;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableEnum16::TypeInfo>(
            nullableEnum16Argument, this, OnSuccessCallback_336, OnFailureCallback_336));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_336(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
        NextTest();
    }

    void OnSuccessResponse_336() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadAttributeNullableEnum16UnchangedValue_337()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableEnum16::TypeInfo>(
            this, OnSuccessCallback_337, OnFailureCallback_337, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_337(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_337(const chip::app::DataModel::Nullable<uint16_t> & nullableEnum16)
    {
        VerifyOrReturn(CheckValueNonNull("nullableEnum16", nullableEnum16));
        VerifyOrReturn(CheckValue("nullableEnum16.Value()", nullableEnum16.Value(), 65534U));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableEnum16NullValue_338()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint16_t> nullableEnum16Argument;
        nullableEnum16Argument.SetNull();

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableEnum16::TypeInfo>(
            nullableEnum16Argument, this, OnSuccessCallback_338, OnFailureCallback_338));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_338(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_338() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableEnum16NullValue_339()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableEnum16::TypeInfo>(
            this, OnSuccessCallback_339, OnFailureCallback_339, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_339(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_339(const chip::app::DataModel::Nullable<uint16_t> & nullableEnum16)
    {
        VerifyOrReturn(CheckValueNull("nullableEnum16", nullableEnum16));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableSimpleEnumMinValue_340()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<chip::app::Clusters::TestCluster::SimpleEnum> nullableEnumAttrArgument;
        nullableEnumAttrArgument.SetNonNull();
        nullableEnumAttrArgument.Value() = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(0);

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableEnumAttr::TypeInfo>(
            nullableEnumAttrArgument, this, OnSuccessCallback_340, OnFailureCallback_340));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_340(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_340() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableSimpleEnumMinValue_341()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableEnumAttr::TypeInfo>(
            this, OnSuccessCallback_341, OnFailureCallback_341, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_341(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void
    OnSuccessResponse_341(const chip::app::DataModel::Nullable<chip::app::Clusters::TestCluster::SimpleEnum> & nullableEnumAttr)
    {
        VerifyOrReturn(CheckValueNonNull("nullableEnumAttr", nullableEnumAttr));
        VerifyOrReturn(CheckValue("nullableEnumAttr.Value()", nullableEnumAttr.Value(), 0));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableSimpleEnumMaxValue_342()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<chip::app::Clusters::TestCluster::SimpleEnum> nullableEnumAttrArgument;
        nullableEnumAttrArgument.SetNonNull();
        nullableEnumAttrArgument.Value() = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(254);

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableEnumAttr::TypeInfo>(
            nullableEnumAttrArgument, this, OnSuccessCallback_342, OnFailureCallback_342));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_342(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_342() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableSimpleEnumMaxValue_343()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableEnumAttr::TypeInfo>(
            this, OnSuccessCallback_343, OnFailureCallback_343, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_343(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void
    OnSuccessResponse_343(const chip::app::DataModel::Nullable<chip::app::Clusters::TestCluster::SimpleEnum> & nullableEnumAttr)
    {
        VerifyOrReturn(CheckValueNonNull("nullableEnumAttr", nullableEnumAttr));
        VerifyOrReturn(CheckValue("nullableEnumAttr.Value()", nullableEnumAttr.Value(), 254));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableSimpleEnumInvalidValue_344()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<chip::app::Clusters::TestCluster::SimpleEnum> nullableEnumAttrArgument;
        nullableEnumAttrArgument.SetNonNull();
        nullableEnumAttrArgument.Value() = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(255);

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableEnumAttr::TypeInfo>(
            nullableEnumAttrArgument, this, OnSuccessCallback_344, OnFailureCallback_344));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_344(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
        NextTest();
    }

    void OnSuccessResponse_344() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadAttributeNullableSimpleEnumUnchangedValue_345()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableEnumAttr::TypeInfo>(
            this, OnSuccessCallback_345, OnFailureCallback_345, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_345(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void
    OnSuccessResponse_345(const chip::app::DataModel::Nullable<chip::app::Clusters::TestCluster::SimpleEnum> & nullableEnumAttr)
    {
        VerifyOrReturn(CheckValueNonNull("nullableEnumAttr", nullableEnumAttr));
        VerifyOrReturn(CheckValue("nullableEnumAttr.Value()", nullableEnumAttr.Value(), 254));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableSimpleEnumNullValue_346()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<chip::app::Clusters::TestCluster::SimpleEnum> nullableEnumAttrArgument;
        nullableEnumAttrArgument.SetNull();

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableEnumAttr::TypeInfo>(
            nullableEnumAttrArgument, this, OnSuccessCallback_346, OnFailureCallback_346));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_346(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_346() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableSimpleEnumNullValue_347()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableEnumAttr::TypeInfo>(
            this, OnSuccessCallback_347, OnFailureCallback_347, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_347(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void
    OnSuccessResponse_347(const chip::app::DataModel::Nullable<chip::app::Clusters::TestCluster::SimpleEnum> & nullableEnumAttr)
    {
        VerifyOrReturn(CheckValueNull("nullableEnumAttr", nullableEnumAttr));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeNullableOctetStringDefaultValue_348()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableOctetString::TypeInfo>(
            this, OnSuccessCallback_348, OnFailureCallback_348, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_348(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_348(const chip::app::DataModel::Nullable<chip::ByteSpan> & nullableOctetString)
    {
        VerifyOrReturn(CheckValueNonNull("nullableOctetString", nullableOctetString));
        VerifyOrReturn(CheckValueAsString("nullableOctetString.Value()", nullableOctetString.Value(),
                                          chip::ByteSpan(chip::Uint8::from_const_char(""), 0)));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableOctetString_349()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<chip::ByteSpan> nullableOctetStringArgument;
        nullableOctetStringArgument.SetNonNull();
        nullableOctetStringArgument.Value() =
            chip::ByteSpan(chip::Uint8::from_const_char("TestValuegarbage: not in length on purpose"), 9);

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableOctetString::TypeInfo>(
            nullableOctetStringArgument, this, OnSuccessCallback_349, OnFailureCallback_349));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_349(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_349() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableOctetString_350()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableOctetString::TypeInfo>(
            this, OnSuccessCallback_350, OnFailureCallback_350, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_350(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_350(const chip::app::DataModel::Nullable<chip::ByteSpan> & nullableOctetString)
    {
        VerifyOrReturn(CheckValueNonNull("nullableOctetString", nullableOctetString));
        VerifyOrReturn(CheckValueAsString("nullableOctetString.Value()", nullableOctetString.Value(),
                                          chip::ByteSpan(chip::Uint8::from_const_char("TestValue"), 9)));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableOctetString_351()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<chip::ByteSpan> nullableOctetStringArgument;
        nullableOctetStringArgument.SetNull();

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableOctetString::TypeInfo>(
            nullableOctetStringArgument, this, OnSuccessCallback_351, OnFailureCallback_351));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_351(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_351() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableOctetString_352()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableOctetString::TypeInfo>(
            this, OnSuccessCallback_352, OnFailureCallback_352, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_352(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_352(const chip::app::DataModel::Nullable<chip::ByteSpan> & nullableOctetString)
    {
        VerifyOrReturn(CheckValueNull("nullableOctetString", nullableOctetString));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableOctetString_353()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<chip::ByteSpan> nullableOctetStringArgument;
        nullableOctetStringArgument.SetNonNull();
        nullableOctetStringArgument.Value() = chip::ByteSpan(chip::Uint8::from_const_char("garbage: not in length on purpose"), 0);

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableOctetString::TypeInfo>(
            nullableOctetStringArgument, this, OnSuccessCallback_353, OnFailureCallback_353));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_353(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_353() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableOctetString_354()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableOctetString::TypeInfo>(
            this, OnSuccessCallback_354, OnFailureCallback_354, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_354(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_354(const chip::app::DataModel::Nullable<chip::ByteSpan> & nullableOctetString)
    {
        VerifyOrReturn(CheckValueNonNull("nullableOctetString", nullableOctetString));
        VerifyOrReturn(CheckValueAsString("nullableOctetString.Value()", nullableOctetString.Value(),
                                          chip::ByteSpan(chip::Uint8::from_const_char(""), 0)));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeNullableCharStringDefaultValue_355()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableCharString::TypeInfo>(
            this, OnSuccessCallback_355, OnFailureCallback_355, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_355(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_355(const chip::app::DataModel::Nullable<chip::CharSpan> & nullableCharString)
    {
        VerifyOrReturn(CheckValueNonNull("nullableCharString", nullableCharString));
        VerifyOrReturn(CheckValueAsString("nullableCharString.Value()", nullableCharString.Value(), chip::CharSpan("", 0)));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableCharString_356()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<chip::CharSpan> nullableCharStringArgument;
        nullableCharStringArgument.SetNonNull();
        nullableCharStringArgument.Value() = chip::Span<const char>("☉T☉garbage: not in length on purpose", 7);

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableCharString::TypeInfo>(
            nullableCharStringArgument, this, OnSuccessCallback_356, OnFailureCallback_356));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_356(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_356() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableCharString_357()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableCharString::TypeInfo>(
            this, OnSuccessCallback_357, OnFailureCallback_357, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_357(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_357(const chip::app::DataModel::Nullable<chip::CharSpan> & nullableCharString)
    {
        VerifyOrReturn(CheckValueNonNull("nullableCharString", nullableCharString));
        VerifyOrReturn(CheckValueAsString("nullableCharString.Value()", nullableCharString.Value(), chip::CharSpan("☉T☉", 7)));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableCharStringValueTooLong_358()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<chip::CharSpan> nullableCharStringArgument;
        nullableCharStringArgument.SetNull();

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableCharString::TypeInfo>(
            nullableCharStringArgument, this, OnSuccessCallback_358, OnFailureCallback_358));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_358(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_358() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableCharString_359()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableCharString::TypeInfo>(
            this, OnSuccessCallback_359, OnFailureCallback_359, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_359(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_359(const chip::app::DataModel::Nullable<chip::CharSpan> & nullableCharString)
    {
        VerifyOrReturn(CheckValueNull("nullableCharString", nullableCharString));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableCharStringEmpty_360()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<chip::CharSpan> nullableCharStringArgument;
        nullableCharStringArgument.SetNonNull();
        nullableCharStringArgument.Value() = chip::Span<const char>("garbage: not in length on purpose", 0);

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableCharString::TypeInfo>(
            nullableCharStringArgument, this, OnSuccessCallback_360, OnFailureCallback_360));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_360(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_360() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableCharString_361()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableCharString::TypeInfo>(
            this, OnSuccessCallback_361, OnFailureCallback_361, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_361(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_361(const chip::app::DataModel::Nullable<chip::CharSpan> & nullableCharString)
    {
        VerifyOrReturn(CheckValueNonNull("nullableCharString", nullableCharString));
        VerifyOrReturn(CheckValueAsString("nullableCharString.Value()", nullableCharString.Value(), chip::CharSpan("", 0)));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeFromNonexistentEndpoint_362()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 200;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::ListInt8u::TypeInfo>(
            this, OnSuccessCallback_362, OnFailureCallback_362, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_362(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_ENDPOINT));
        NextTest();
    }

    void OnSuccessResponse_362(const chip::app::DataModel::DecodableList<uint8_t> & listInt8u) { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadAttributeFromNonexistentCluster_363()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::ListInt8u::TypeInfo>(
            this, OnSuccessCallback_363, OnFailureCallback_363, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_363(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_CLUSTER));
        NextTest();
    }

    void OnSuccessResponse_363(const chip::app::DataModel::DecodableList<uint8_t> & listInt8u) { ThrowSuccessResponse(); }

    CHIP_ERROR TestSendACommandThatTakesAnOptionalParameterButDoNotSetIt_364()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::TestSimpleOptionalArgumentRequest::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_364();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestClusterSuite *>(context))->OnFailureResponse_364(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_364(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_VALUE));
        NextTest();
    }

    void OnSuccessResponse_364() { ThrowSuccessResponse(); }

    CHIP_ERROR TestSendACommandThatTakesAnOptionalParameterButDoNotSetIt_365()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::TestSimpleOptionalArgumentRequest::Type;

        RequestType request;
        request.arg1.Emplace();
        request.arg1.Value() = 1;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestClusterSuite *>(context))->OnSuccessResponse_365();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestClusterSuite *>(context))->OnFailureResponse_365(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_365(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_365() { NextTest(); }

    CHIP_ERROR TestReportSubscribeToListAttribute_366()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        mTest_TestCluster_list_int8u_Reported = OnSuccessCallback_366;
        return WaitForMs(0);
    }

    void OnFailureResponse_366(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_366(const chip::app::DataModel::DecodableList<uint8_t> & listInt8u)
    {
        mReceivedReport_366 = true;
        {
            auto iter_0 = listInt8u.begin();
            VerifyOrReturn(CheckNextListItemDecodes<decltype(listInt8u)>("listInt8u", iter_0, 0));
            VerifyOrReturn(CheckValue("listInt8u[0]", iter_0.GetValue(), 1));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(listInt8u)>("listInt8u", iter_0, 1));
            VerifyOrReturn(CheckValue("listInt8u[1]", iter_0.GetValue(), 2));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(listInt8u)>("listInt8u", iter_0, 2));
            VerifyOrReturn(CheckValue("listInt8u[2]", iter_0.GetValue(), 3));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(listInt8u)>("listInt8u", iter_0, 3));
            VerifyOrReturn(CheckValue("listInt8u[3]", iter_0.GetValue(), 4));
            VerifyOrReturn(CheckNoMoreListItems<decltype(listInt8u)>("listInt8u", iter_0, 4));
        }
    }

    CHIP_ERROR TestSubscribeToListAttribute_367()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t minIntervalArgument;
        minIntervalArgument = 2U;
        uint16_t maxIntervalArgument;
        maxIntervalArgument = 5U;

        ReturnErrorOnFailure(cluster.SubscribeAttribute<chip::app::Clusters::TestCluster::Attributes::ListInt8u::TypeInfo>(
            this, OnSuccessCallback_367, OnFailureCallback_367, minIntervalArgument, maxIntervalArgument,
            OnSubscriptionEstablished_367, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_367(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_367(const chip::app::DataModel::DecodableList<uint8_t> & value)
    {
        if (mTest_TestCluster_list_int8u_Reported)
        {
            auto callback                         = mTest_TestCluster_list_int8u_Reported;
            mTest_TestCluster_list_int8u_Reported = nullptr;
            callback(this, value);
        }
    }

    void OnSubscriptionEstablishedResponse_367()
    {
        VerifyOrReturn(mReceivedReport_366, Exit("Initial report not received!"));
        NextTest();
    }

    CHIP_ERROR TestWriteSubscribedToListAttribute_368()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ListFreer listFreer;
        chip::app::DataModel::List<const uint8_t> listInt8uArgument;

        {
            auto * listHolder_0 = new ListHolder<uint8_t>(4);
            listFreer.add(listHolder_0);
            listHolder_0->mList[0] = 5;
            listHolder_0->mList[1] = 6;
            listHolder_0->mList[2] = 7;
            listHolder_0->mList[3] = 8;
            listInt8uArgument      = chip::app::DataModel::List<uint8_t>(listHolder_0->mList, 4);
        }

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::ListInt8u::TypeInfo>(
            listInt8uArgument, this, OnSuccessCallback_368, OnFailureCallback_368));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_368(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_368() { NextTest(); }

    CHIP_ERROR TestCheckForListAttributeReport_369()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        mTest_TestCluster_list_int8u_Reported = OnSuccessCallback_369;
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_369(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_369(const chip::app::DataModel::DecodableList<uint8_t> & listInt8u)
    {
        mReceivedReport_369 = true;
        {
            auto iter_0 = listInt8u.begin();
            VerifyOrReturn(CheckNextListItemDecodes<decltype(listInt8u)>("listInt8u", iter_0, 0));
            VerifyOrReturn(CheckValue("listInt8u[0]", iter_0.GetValue(), 5));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(listInt8u)>("listInt8u", iter_0, 1));
            VerifyOrReturn(CheckValue("listInt8u[1]", iter_0.GetValue(), 6));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(listInt8u)>("listInt8u", iter_0, 2));
            VerifyOrReturn(CheckValue("listInt8u[2]", iter_0.GetValue(), 7));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(listInt8u)>("listInt8u", iter_0, 3));
            VerifyOrReturn(CheckValue("listInt8u[3]", iter_0.GetValue(), 8));
            VerifyOrReturn(CheckNoMoreListItems<decltype(listInt8u)>("listInt8u", iter_0, 4));
        }

        NextTest();
    }

    CHIP_ERROR TestReadRangeRestrictedUnsigned8BitInteger_370()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::RangeRestrictedInt8u::TypeInfo>(
            this, OnSuccessCallback_370, OnFailureCallback_370, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_370(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_370(uint8_t rangeRestrictedInt8u)
    {
        VerifyOrReturn(CheckValue("rangeRestrictedInt8u", rangeRestrictedInt8u, 70));

        NextTest();
    }

    CHIP_ERROR TestWriteMinValueToARangeRestrictedUnsigned8BitInteger_371()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t rangeRestrictedInt8uArgument;
        rangeRestrictedInt8uArgument = 0;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::RangeRestrictedInt8u::TypeInfo>(
            rangeRestrictedInt8uArgument, this, OnSuccessCallback_371, OnFailureCallback_371));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_371(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
        NextTest();
    }

    void OnSuccessResponse_371() { ThrowSuccessResponse(); }

    CHIP_ERROR TestWriteJustBelowRangeValueToARangeRestrictedUnsigned8BitInteger_372()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t rangeRestrictedInt8uArgument;
        rangeRestrictedInt8uArgument = 19;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::RangeRestrictedInt8u::TypeInfo>(
            rangeRestrictedInt8uArgument, this, OnSuccessCallback_372, OnFailureCallback_372));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_372(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
        NextTest();
    }

    void OnSuccessResponse_372() { ThrowSuccessResponse(); }

    CHIP_ERROR TestWriteJustAboveRangeValueToARangeRestrictedUnsigned8BitInteger_373()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t rangeRestrictedInt8uArgument;
        rangeRestrictedInt8uArgument = 101;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::RangeRestrictedInt8u::TypeInfo>(
            rangeRestrictedInt8uArgument, this, OnSuccessCallback_373, OnFailureCallback_373));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_373(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
        NextTest();
    }

    void OnSuccessResponse_373() { ThrowSuccessResponse(); }

    CHIP_ERROR TestWriteMaxValueToARangeRestrictedUnsigned8BitInteger_374()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t rangeRestrictedInt8uArgument;
        rangeRestrictedInt8uArgument = 255;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::RangeRestrictedInt8u::TypeInfo>(
            rangeRestrictedInt8uArgument, this, OnSuccessCallback_374, OnFailureCallback_374));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_374(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
        NextTest();
    }

    void OnSuccessResponse_374() { ThrowSuccessResponse(); }

    CHIP_ERROR TestVerifyRangeRestrictedUnsigned8BitIntegerValueHasNotChanged_375()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::RangeRestrictedInt8u::TypeInfo>(
            this, OnSuccessCallback_375, OnFailureCallback_375, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_375(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_375(uint8_t rangeRestrictedInt8u)
    {
        VerifyOrReturn(CheckValue("rangeRestrictedInt8u", rangeRestrictedInt8u, 70));

        NextTest();
    }

    CHIP_ERROR TestWriteMinValidValueToARangeRestrictedUnsigned8BitInteger_376()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t rangeRestrictedInt8uArgument;
        rangeRestrictedInt8uArgument = 20;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::RangeRestrictedInt8u::TypeInfo>(
            rangeRestrictedInt8uArgument, this, OnSuccessCallback_376, OnFailureCallback_376));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_376(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_376() { NextTest(); }

    CHIP_ERROR TestVerifyRangeRestrictedUnsigned8BitIntegerValueIsAtMinValid_377()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::RangeRestrictedInt8u::TypeInfo>(
            this, OnSuccessCallback_377, OnFailureCallback_377, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_377(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_377(uint8_t rangeRestrictedInt8u)
    {
        VerifyOrReturn(CheckValue("rangeRestrictedInt8u", rangeRestrictedInt8u, 20));

        NextTest();
    }

    CHIP_ERROR TestWriteMaxValidValueToARangeRestrictedUnsigned8BitInteger_378()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t rangeRestrictedInt8uArgument;
        rangeRestrictedInt8uArgument = 100;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::RangeRestrictedInt8u::TypeInfo>(
            rangeRestrictedInt8uArgument, this, OnSuccessCallback_378, OnFailureCallback_378));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_378(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_378() { NextTest(); }

    CHIP_ERROR TestVerifyRangeRestrictedUnsigned8BitIntegerValueIsAtMaxValid_379()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::RangeRestrictedInt8u::TypeInfo>(
            this, OnSuccessCallback_379, OnFailureCallback_379, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_379(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_379(uint8_t rangeRestrictedInt8u)
    {
        VerifyOrReturn(CheckValue("rangeRestrictedInt8u", rangeRestrictedInt8u, 100));

        NextTest();
    }

    CHIP_ERROR TestWriteMiddleValidValueToARangeRestrictedUnsigned8BitInteger_380()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t rangeRestrictedInt8uArgument;
        rangeRestrictedInt8uArgument = 50;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::RangeRestrictedInt8u::TypeInfo>(
            rangeRestrictedInt8uArgument, this, OnSuccessCallback_380, OnFailureCallback_380));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_380(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_380() { NextTest(); }

    CHIP_ERROR TestVerifyRangeRestrictedUnsigned8BitIntegerValueIsAtMidValid_381()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::RangeRestrictedInt8u::TypeInfo>(
            this, OnSuccessCallback_381, OnFailureCallback_381, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_381(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_381(uint8_t rangeRestrictedInt8u)
    {
        VerifyOrReturn(CheckValue("rangeRestrictedInt8u", rangeRestrictedInt8u, 50));

        NextTest();
    }

    CHIP_ERROR TestReadRangeRestrictedUnsigned16BitInteger_382()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::RangeRestrictedInt16u::TypeInfo>(
            this, OnSuccessCallback_382, OnFailureCallback_382, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_382(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_382(uint16_t rangeRestrictedInt16u)
    {
        VerifyOrReturn(CheckValue("rangeRestrictedInt16u", rangeRestrictedInt16u, 200U));

        NextTest();
    }

    CHIP_ERROR TestWriteMinValueToARangeRestrictedUnsigned16BitInteger_383()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t rangeRestrictedInt16uArgument;
        rangeRestrictedInt16uArgument = 0U;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::RangeRestrictedInt16u::TypeInfo>(
            rangeRestrictedInt16uArgument, this, OnSuccessCallback_383, OnFailureCallback_383));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_383(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
        NextTest();
    }

    void OnSuccessResponse_383() { ThrowSuccessResponse(); }

    CHIP_ERROR TestWriteJustBelowRangeValueToARangeRestrictedUnsigned16BitInteger_384()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t rangeRestrictedInt16uArgument;
        rangeRestrictedInt16uArgument = 99U;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::RangeRestrictedInt16u::TypeInfo>(
            rangeRestrictedInt16uArgument, this, OnSuccessCallback_384, OnFailureCallback_384));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_384(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
        NextTest();
    }

    void OnSuccessResponse_384() { ThrowSuccessResponse(); }

    CHIP_ERROR TestWriteJustAboveRangeValueToARangeRestrictedUnsigned16BitInteger_385()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t rangeRestrictedInt16uArgument;
        rangeRestrictedInt16uArgument = 1001U;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::RangeRestrictedInt16u::TypeInfo>(
            rangeRestrictedInt16uArgument, this, OnSuccessCallback_385, OnFailureCallback_385));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_385(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
        NextTest();
    }

    void OnSuccessResponse_385() { ThrowSuccessResponse(); }

    CHIP_ERROR TestWriteMaxValueToARangeRestrictedUnsigned16BitInteger_386()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t rangeRestrictedInt16uArgument;
        rangeRestrictedInt16uArgument = 65535U;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::RangeRestrictedInt16u::TypeInfo>(
            rangeRestrictedInt16uArgument, this, OnSuccessCallback_386, OnFailureCallback_386));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_386(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
        NextTest();
    }

    void OnSuccessResponse_386() { ThrowSuccessResponse(); }

    CHIP_ERROR TestVerifyRangeRestrictedUnsigned16BitIntegerValueHasNotChanged_387()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::RangeRestrictedInt16u::TypeInfo>(
            this, OnSuccessCallback_387, OnFailureCallback_387, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_387(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_387(uint16_t rangeRestrictedInt16u)
    {
        VerifyOrReturn(CheckValue("rangeRestrictedInt16u", rangeRestrictedInt16u, 200U));

        NextTest();
    }

    CHIP_ERROR TestWriteMinValidValueToARangeRestrictedUnsigned16BitInteger_388()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t rangeRestrictedInt16uArgument;
        rangeRestrictedInt16uArgument = 100U;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::RangeRestrictedInt16u::TypeInfo>(
            rangeRestrictedInt16uArgument, this, OnSuccessCallback_388, OnFailureCallback_388));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_388(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_388() { NextTest(); }

    CHIP_ERROR TestVerifyRangeRestrictedUnsigned16BitIntegerValueIsAtMinValid_389()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::RangeRestrictedInt16u::TypeInfo>(
            this, OnSuccessCallback_389, OnFailureCallback_389, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_389(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_389(uint16_t rangeRestrictedInt16u)
    {
        VerifyOrReturn(CheckValue("rangeRestrictedInt16u", rangeRestrictedInt16u, 100U));

        NextTest();
    }

    CHIP_ERROR TestWriteMaxValidValueToARangeRestrictedUnsigned16BitInteger_390()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t rangeRestrictedInt16uArgument;
        rangeRestrictedInt16uArgument = 1000U;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::RangeRestrictedInt16u::TypeInfo>(
            rangeRestrictedInt16uArgument, this, OnSuccessCallback_390, OnFailureCallback_390));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_390(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_390() { NextTest(); }

    CHIP_ERROR TestVerifyRangeRestrictedUnsigned16BitIntegerValueIsAtMaxValid_391()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::RangeRestrictedInt16u::TypeInfo>(
            this, OnSuccessCallback_391, OnFailureCallback_391, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_391(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_391(uint16_t rangeRestrictedInt16u)
    {
        VerifyOrReturn(CheckValue("rangeRestrictedInt16u", rangeRestrictedInt16u, 1000U));

        NextTest();
    }

    CHIP_ERROR TestWriteMiddleValidValueToARangeRestrictedUnsigned16BitInteger_392()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t rangeRestrictedInt16uArgument;
        rangeRestrictedInt16uArgument = 500U;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::RangeRestrictedInt16u::TypeInfo>(
            rangeRestrictedInt16uArgument, this, OnSuccessCallback_392, OnFailureCallback_392));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_392(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_392() { NextTest(); }

    CHIP_ERROR TestVerifyRangeRestrictedUnsigned16BitIntegerValueIsAtMidValid_393()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::RangeRestrictedInt16u::TypeInfo>(
            this, OnSuccessCallback_393, OnFailureCallback_393, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_393(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_393(uint16_t rangeRestrictedInt16u)
    {
        VerifyOrReturn(CheckValue("rangeRestrictedInt16u", rangeRestrictedInt16u, 500U));

        NextTest();
    }

    CHIP_ERROR TestReadRangeRestrictedSigned8BitInteger_394()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::RangeRestrictedInt8s::TypeInfo>(
            this, OnSuccessCallback_394, OnFailureCallback_394, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_394(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_394(int8_t rangeRestrictedInt8s)
    {
        VerifyOrReturn(CheckValue("rangeRestrictedInt8s", rangeRestrictedInt8s, -20));

        NextTest();
    }

    CHIP_ERROR TestWriteMinValueToARangeRestrictedSigned8BitInteger_395()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int8_t rangeRestrictedInt8sArgument;
        rangeRestrictedInt8sArgument = -128;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::RangeRestrictedInt8s::TypeInfo>(
            rangeRestrictedInt8sArgument, this, OnSuccessCallback_395, OnFailureCallback_395));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_395(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
        NextTest();
    }

    void OnSuccessResponse_395() { ThrowSuccessResponse(); }

    CHIP_ERROR TestWriteJustBelowRangeValueToARangeRestrictedSigned8BitInteger_396()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int8_t rangeRestrictedInt8sArgument;
        rangeRestrictedInt8sArgument = -41;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::RangeRestrictedInt8s::TypeInfo>(
            rangeRestrictedInt8sArgument, this, OnSuccessCallback_396, OnFailureCallback_396));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_396(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
        NextTest();
    }

    void OnSuccessResponse_396() { ThrowSuccessResponse(); }

    CHIP_ERROR TestWriteJustAboveRangeValueToARangeRestrictedSigned8BitInteger_397()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int8_t rangeRestrictedInt8sArgument;
        rangeRestrictedInt8sArgument = 51;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::RangeRestrictedInt8s::TypeInfo>(
            rangeRestrictedInt8sArgument, this, OnSuccessCallback_397, OnFailureCallback_397));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_397(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
        NextTest();
    }

    void OnSuccessResponse_397() { ThrowSuccessResponse(); }

    CHIP_ERROR TestWriteMaxValueToARangeRestrictedSigned8BitInteger_398()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int8_t rangeRestrictedInt8sArgument;
        rangeRestrictedInt8sArgument = 127;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::RangeRestrictedInt8s::TypeInfo>(
            rangeRestrictedInt8sArgument, this, OnSuccessCallback_398, OnFailureCallback_398));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_398(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
        NextTest();
    }

    void OnSuccessResponse_398() { ThrowSuccessResponse(); }

    CHIP_ERROR TestVerifyRangeRestrictedSigned8BitIntegerValueHasNotChanged_399()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::RangeRestrictedInt8s::TypeInfo>(
            this, OnSuccessCallback_399, OnFailureCallback_399, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_399(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_399(int8_t rangeRestrictedInt8s)
    {
        VerifyOrReturn(CheckValue("rangeRestrictedInt8s", rangeRestrictedInt8s, -20));

        NextTest();
    }

    CHIP_ERROR TestWriteMinValidValueToARangeRestrictedSigned8BitInteger_400()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int8_t rangeRestrictedInt8sArgument;
        rangeRestrictedInt8sArgument = -40;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::RangeRestrictedInt8s::TypeInfo>(
            rangeRestrictedInt8sArgument, this, OnSuccessCallback_400, OnFailureCallback_400));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_400(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_400() { NextTest(); }

    CHIP_ERROR TestVerifyRangeRestrictedSigned8BitIntegerValueIsAtMinValid_401()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::RangeRestrictedInt8s::TypeInfo>(
            this, OnSuccessCallback_401, OnFailureCallback_401, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_401(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_401(int8_t rangeRestrictedInt8s)
    {
        VerifyOrReturn(CheckValue("rangeRestrictedInt8s", rangeRestrictedInt8s, -40));

        NextTest();
    }

    CHIP_ERROR TestWriteMaxValidValueToARangeRestrictedSigned8BitInteger_402()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int8_t rangeRestrictedInt8sArgument;
        rangeRestrictedInt8sArgument = 50;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::RangeRestrictedInt8s::TypeInfo>(
            rangeRestrictedInt8sArgument, this, OnSuccessCallback_402, OnFailureCallback_402));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_402(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_402() { NextTest(); }

    CHIP_ERROR TestVerifyRangeRestrictedSigned8BitIntegerValueIsAtMaxValid_403()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::RangeRestrictedInt8s::TypeInfo>(
            this, OnSuccessCallback_403, OnFailureCallback_403, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_403(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_403(int8_t rangeRestrictedInt8s)
    {
        VerifyOrReturn(CheckValue("rangeRestrictedInt8s", rangeRestrictedInt8s, 50));

        NextTest();
    }

    CHIP_ERROR TestWriteMiddleValidValueToARangeRestrictedSigned8BitInteger_404()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int8_t rangeRestrictedInt8sArgument;
        rangeRestrictedInt8sArgument = 6;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::RangeRestrictedInt8s::TypeInfo>(
            rangeRestrictedInt8sArgument, this, OnSuccessCallback_404, OnFailureCallback_404));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_404(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_404() { NextTest(); }

    CHIP_ERROR TestVerifyRangeRestrictedSigned8BitIntegerValueIsAtMidValid_405()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::RangeRestrictedInt8s::TypeInfo>(
            this, OnSuccessCallback_405, OnFailureCallback_405, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_405(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_405(int8_t rangeRestrictedInt8s)
    {
        VerifyOrReturn(CheckValue("rangeRestrictedInt8s", rangeRestrictedInt8s, 6));

        NextTest();
    }

    CHIP_ERROR TestReadRangeRestrictedSigned16BitInteger_406()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::RangeRestrictedInt16s::TypeInfo>(
            this, OnSuccessCallback_406, OnFailureCallback_406, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_406(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_406(int16_t rangeRestrictedInt16s)
    {
        VerifyOrReturn(CheckValue("rangeRestrictedInt16s", rangeRestrictedInt16s, -100));

        NextTest();
    }

    CHIP_ERROR TestWriteMinValueToARangeRestrictedSigned16BitInteger_407()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t rangeRestrictedInt16sArgument;
        rangeRestrictedInt16sArgument = -32768;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::RangeRestrictedInt16s::TypeInfo>(
            rangeRestrictedInt16sArgument, this, OnSuccessCallback_407, OnFailureCallback_407));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_407(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
        NextTest();
    }

    void OnSuccessResponse_407() { ThrowSuccessResponse(); }

    CHIP_ERROR TestWriteJustBelowRangeValueToARangeRestrictedSigned16BitInteger_408()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t rangeRestrictedInt16sArgument;
        rangeRestrictedInt16sArgument = -151;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::RangeRestrictedInt16s::TypeInfo>(
            rangeRestrictedInt16sArgument, this, OnSuccessCallback_408, OnFailureCallback_408));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_408(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
        NextTest();
    }

    void OnSuccessResponse_408() { ThrowSuccessResponse(); }

    CHIP_ERROR TestWriteJustAboveRangeValueToARangeRestrictedSigned16BitInteger_409()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t rangeRestrictedInt16sArgument;
        rangeRestrictedInt16sArgument = 201;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::RangeRestrictedInt16s::TypeInfo>(
            rangeRestrictedInt16sArgument, this, OnSuccessCallback_409, OnFailureCallback_409));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_409(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
        NextTest();
    }

    void OnSuccessResponse_409() { ThrowSuccessResponse(); }

    CHIP_ERROR TestWriteMaxValueToARangeRestrictedSigned16BitInteger_410()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t rangeRestrictedInt16sArgument;
        rangeRestrictedInt16sArgument = 32767;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::RangeRestrictedInt16s::TypeInfo>(
            rangeRestrictedInt16sArgument, this, OnSuccessCallback_410, OnFailureCallback_410));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_410(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
        NextTest();
    }

    void OnSuccessResponse_410() { ThrowSuccessResponse(); }

    CHIP_ERROR TestVerifyRangeRestrictedSigned16BitIntegerValueHasNotChanged_411()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::RangeRestrictedInt16s::TypeInfo>(
            this, OnSuccessCallback_411, OnFailureCallback_411, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_411(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_411(int16_t rangeRestrictedInt16s)
    {
        VerifyOrReturn(CheckValue("rangeRestrictedInt16s", rangeRestrictedInt16s, -100));

        NextTest();
    }

    CHIP_ERROR TestWriteMinValidValueToARangeRestrictedSigned16BitInteger_412()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t rangeRestrictedInt16sArgument;
        rangeRestrictedInt16sArgument = -150;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::RangeRestrictedInt16s::TypeInfo>(
            rangeRestrictedInt16sArgument, this, OnSuccessCallback_412, OnFailureCallback_412));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_412(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_412() { NextTest(); }

    CHIP_ERROR TestVerifyRangeRestrictedSigned16BitIntegerValueIsAtMinValid_413()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::RangeRestrictedInt16s::TypeInfo>(
            this, OnSuccessCallback_413, OnFailureCallback_413, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_413(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_413(int16_t rangeRestrictedInt16s)
    {
        VerifyOrReturn(CheckValue("rangeRestrictedInt16s", rangeRestrictedInt16s, -150));

        NextTest();
    }

    CHIP_ERROR TestWriteMaxValidValueToARangeRestrictedSigned16BitInteger_414()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t rangeRestrictedInt16sArgument;
        rangeRestrictedInt16sArgument = 200;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::RangeRestrictedInt16s::TypeInfo>(
            rangeRestrictedInt16sArgument, this, OnSuccessCallback_414, OnFailureCallback_414));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_414(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_414() { NextTest(); }

    CHIP_ERROR TestVerifyRangeRestrictedSigned16BitIntegerValueIsAtMaxValid_415()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::RangeRestrictedInt16s::TypeInfo>(
            this, OnSuccessCallback_415, OnFailureCallback_415, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_415(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_415(int16_t rangeRestrictedInt16s)
    {
        VerifyOrReturn(CheckValue("rangeRestrictedInt16s", rangeRestrictedInt16s, 200));

        NextTest();
    }

    CHIP_ERROR TestWriteMiddleValidValueToARangeRestrictedSigned16BitInteger_416()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t rangeRestrictedInt16sArgument;
        rangeRestrictedInt16sArgument = 7;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::RangeRestrictedInt16s::TypeInfo>(
            rangeRestrictedInt16sArgument, this, OnSuccessCallback_416, OnFailureCallback_416));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_416(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_416() { NextTest(); }

    CHIP_ERROR TestVerifyRangeRestrictedSigned16BitIntegerValueIsAtMidValid_417()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::RangeRestrictedInt16s::TypeInfo>(
            this, OnSuccessCallback_417, OnFailureCallback_417, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_417(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_417(int16_t rangeRestrictedInt16s)
    {
        VerifyOrReturn(CheckValue("rangeRestrictedInt16s", rangeRestrictedInt16s, 7));

        NextTest();
    }

    CHIP_ERROR TestReadNullableRangeRestrictedUnsigned8BitInteger_418()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableRangeRestrictedInt8u::TypeInfo>(
                this, OnSuccessCallback_418, OnFailureCallback_418, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_418(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_418(const chip::app::DataModel::Nullable<uint8_t> & nullableRangeRestrictedInt8u)
    {
        VerifyOrReturn(CheckValueNonNull("nullableRangeRestrictedInt8u", nullableRangeRestrictedInt8u));
        VerifyOrReturn(CheckValue("nullableRangeRestrictedInt8u.Value()", nullableRangeRestrictedInt8u.Value(), 70));

        NextTest();
    }

    CHIP_ERROR TestWriteMinValueToANullableRangeRestrictedUnsigned8BitInteger_419()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint8_t> nullableRangeRestrictedInt8uArgument;
        nullableRangeRestrictedInt8uArgument.SetNonNull();
        nullableRangeRestrictedInt8uArgument.Value() = 0;

        ReturnErrorOnFailure(
            cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableRangeRestrictedInt8u::TypeInfo>(
                nullableRangeRestrictedInt8uArgument, this, OnSuccessCallback_419, OnFailureCallback_419));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_419(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
        NextTest();
    }

    void OnSuccessResponse_419() { ThrowSuccessResponse(); }

    CHIP_ERROR TestWriteJustBelowRangeValueToANullableRangeRestrictedUnsigned8BitInteger_420()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint8_t> nullableRangeRestrictedInt8uArgument;
        nullableRangeRestrictedInt8uArgument.SetNonNull();
        nullableRangeRestrictedInt8uArgument.Value() = 19;

        ReturnErrorOnFailure(
            cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableRangeRestrictedInt8u::TypeInfo>(
                nullableRangeRestrictedInt8uArgument, this, OnSuccessCallback_420, OnFailureCallback_420));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_420(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
        NextTest();
    }

    void OnSuccessResponse_420() { ThrowSuccessResponse(); }

    CHIP_ERROR TestWriteJustAboveRangeValueToANullableRangeRestrictedUnsigned8BitInteger_421()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint8_t> nullableRangeRestrictedInt8uArgument;
        nullableRangeRestrictedInt8uArgument.SetNonNull();
        nullableRangeRestrictedInt8uArgument.Value() = 101;

        ReturnErrorOnFailure(
            cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableRangeRestrictedInt8u::TypeInfo>(
                nullableRangeRestrictedInt8uArgument, this, OnSuccessCallback_421, OnFailureCallback_421));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_421(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
        NextTest();
    }

    void OnSuccessResponse_421() { ThrowSuccessResponse(); }

    CHIP_ERROR TestWriteMaxValueToANullableRangeRestrictedUnsigned8BitInteger_422()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint8_t> nullableRangeRestrictedInt8uArgument;
        nullableRangeRestrictedInt8uArgument.SetNonNull();
        nullableRangeRestrictedInt8uArgument.Value() = 254;

        ReturnErrorOnFailure(
            cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableRangeRestrictedInt8u::TypeInfo>(
                nullableRangeRestrictedInt8uArgument, this, OnSuccessCallback_422, OnFailureCallback_422));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_422(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
        NextTest();
    }

    void OnSuccessResponse_422() { ThrowSuccessResponse(); }

    CHIP_ERROR TestVerifyNullableRangeRestrictedUnsigned8BitIntegerValueHasNotChanged_423()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableRangeRestrictedInt8u::TypeInfo>(
                this, OnSuccessCallback_423, OnFailureCallback_423, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_423(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_423(const chip::app::DataModel::Nullable<uint8_t> & nullableRangeRestrictedInt8u)
    {
        VerifyOrReturn(CheckValueNonNull("nullableRangeRestrictedInt8u", nullableRangeRestrictedInt8u));
        VerifyOrReturn(CheckValue("nullableRangeRestrictedInt8u.Value()", nullableRangeRestrictedInt8u.Value(), 70));

        NextTest();
    }

    CHIP_ERROR TestWriteMinValidValueToANullableRangeRestrictedUnsigned8BitInteger_424()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint8_t> nullableRangeRestrictedInt8uArgument;
        nullableRangeRestrictedInt8uArgument.SetNonNull();
        nullableRangeRestrictedInt8uArgument.Value() = 20;

        ReturnErrorOnFailure(
            cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableRangeRestrictedInt8u::TypeInfo>(
                nullableRangeRestrictedInt8uArgument, this, OnSuccessCallback_424, OnFailureCallback_424));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_424(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_424() { NextTest(); }

    CHIP_ERROR TestVerifyNullableRangeRestrictedUnsigned8BitIntegerValueIsAtMinValid_425()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableRangeRestrictedInt8u::TypeInfo>(
                this, OnSuccessCallback_425, OnFailureCallback_425, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_425(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_425(const chip::app::DataModel::Nullable<uint8_t> & nullableRangeRestrictedInt8u)
    {
        VerifyOrReturn(CheckValueNonNull("nullableRangeRestrictedInt8u", nullableRangeRestrictedInt8u));
        VerifyOrReturn(CheckValue("nullableRangeRestrictedInt8u.Value()", nullableRangeRestrictedInt8u.Value(), 20));

        NextTest();
    }

    CHIP_ERROR TestWriteMaxValidValueToANullableRangeRestrictedUnsigned8BitInteger_426()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint8_t> nullableRangeRestrictedInt8uArgument;
        nullableRangeRestrictedInt8uArgument.SetNonNull();
        nullableRangeRestrictedInt8uArgument.Value() = 100;

        ReturnErrorOnFailure(
            cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableRangeRestrictedInt8u::TypeInfo>(
                nullableRangeRestrictedInt8uArgument, this, OnSuccessCallback_426, OnFailureCallback_426));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_426(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_426() { NextTest(); }

    CHIP_ERROR TestVerifyNullableRangeRestrictedUnsigned8BitIntegerValueIsAtMaxValid_427()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableRangeRestrictedInt8u::TypeInfo>(
                this, OnSuccessCallback_427, OnFailureCallback_427, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_427(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_427(const chip::app::DataModel::Nullable<uint8_t> & nullableRangeRestrictedInt8u)
    {
        VerifyOrReturn(CheckValueNonNull("nullableRangeRestrictedInt8u", nullableRangeRestrictedInt8u));
        VerifyOrReturn(CheckValue("nullableRangeRestrictedInt8u.Value()", nullableRangeRestrictedInt8u.Value(), 100));

        NextTest();
    }

    CHIP_ERROR TestWriteMiddleValidValueToANullableRangeRestrictedUnsigned8BitInteger_428()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint8_t> nullableRangeRestrictedInt8uArgument;
        nullableRangeRestrictedInt8uArgument.SetNonNull();
        nullableRangeRestrictedInt8uArgument.Value() = 50;

        ReturnErrorOnFailure(
            cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableRangeRestrictedInt8u::TypeInfo>(
                nullableRangeRestrictedInt8uArgument, this, OnSuccessCallback_428, OnFailureCallback_428));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_428(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_428() { NextTest(); }

    CHIP_ERROR TestVerifyNullableRangeRestrictedUnsigned8BitIntegerValueIsAtMidValid_429()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableRangeRestrictedInt8u::TypeInfo>(
                this, OnSuccessCallback_429, OnFailureCallback_429, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_429(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_429(const chip::app::DataModel::Nullable<uint8_t> & nullableRangeRestrictedInt8u)
    {
        VerifyOrReturn(CheckValueNonNull("nullableRangeRestrictedInt8u", nullableRangeRestrictedInt8u));
        VerifyOrReturn(CheckValue("nullableRangeRestrictedInt8u.Value()", nullableRangeRestrictedInt8u.Value(), 50));

        NextTest();
    }

    CHIP_ERROR TestWriteNullValueToANullableRangeRestrictedUnsigned8BitInteger_430()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint8_t> nullableRangeRestrictedInt8uArgument;
        nullableRangeRestrictedInt8uArgument.SetNull();

        ReturnErrorOnFailure(
            cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableRangeRestrictedInt8u::TypeInfo>(
                nullableRangeRestrictedInt8uArgument, this, OnSuccessCallback_430, OnFailureCallback_430));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_430(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_430() { NextTest(); }

    CHIP_ERROR TestVerifyNullableRangeRestrictedUnsigned8BitIntegerValueIsNull_431()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableRangeRestrictedInt8u::TypeInfo>(
                this, OnSuccessCallback_431, OnFailureCallback_431, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_431(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_431(const chip::app::DataModel::Nullable<uint8_t> & nullableRangeRestrictedInt8u)
    {
        VerifyOrReturn(CheckValueNull("nullableRangeRestrictedInt8u", nullableRangeRestrictedInt8u));

        NextTest();
    }

    CHIP_ERROR TestReadNullableRangeRestrictedUnsigned16BitInteger_432()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableRangeRestrictedInt16u::TypeInfo>(
                this, OnSuccessCallback_432, OnFailureCallback_432, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_432(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_432(const chip::app::DataModel::Nullable<uint16_t> & nullableRangeRestrictedInt16u)
    {
        VerifyOrReturn(CheckValueNonNull("nullableRangeRestrictedInt16u", nullableRangeRestrictedInt16u));
        VerifyOrReturn(CheckValue("nullableRangeRestrictedInt16u.Value()", nullableRangeRestrictedInt16u.Value(), 200U));

        NextTest();
    }

    CHIP_ERROR TestWriteMinValueToANullableRangeRestrictedUnsigned16BitInteger_433()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint16_t> nullableRangeRestrictedInt16uArgument;
        nullableRangeRestrictedInt16uArgument.SetNonNull();
        nullableRangeRestrictedInt16uArgument.Value() = 0U;

        ReturnErrorOnFailure(
            cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableRangeRestrictedInt16u::TypeInfo>(
                nullableRangeRestrictedInt16uArgument, this, OnSuccessCallback_433, OnFailureCallback_433));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_433(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
        NextTest();
    }

    void OnSuccessResponse_433() { ThrowSuccessResponse(); }

    CHIP_ERROR TestWriteJustBelowRangeValueToANullableRangeRestrictedUnsigned16BitInteger_434()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint16_t> nullableRangeRestrictedInt16uArgument;
        nullableRangeRestrictedInt16uArgument.SetNonNull();
        nullableRangeRestrictedInt16uArgument.Value() = 99U;

        ReturnErrorOnFailure(
            cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableRangeRestrictedInt16u::TypeInfo>(
                nullableRangeRestrictedInt16uArgument, this, OnSuccessCallback_434, OnFailureCallback_434));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_434(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
        NextTest();
    }

    void OnSuccessResponse_434() { ThrowSuccessResponse(); }

    CHIP_ERROR TestWriteJustAboveRangeValueToANullableRangeRestrictedUnsigned16BitInteger_435()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint16_t> nullableRangeRestrictedInt16uArgument;
        nullableRangeRestrictedInt16uArgument.SetNonNull();
        nullableRangeRestrictedInt16uArgument.Value() = 1001U;

        ReturnErrorOnFailure(
            cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableRangeRestrictedInt16u::TypeInfo>(
                nullableRangeRestrictedInt16uArgument, this, OnSuccessCallback_435, OnFailureCallback_435));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_435(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
        NextTest();
    }

    void OnSuccessResponse_435() { ThrowSuccessResponse(); }

    CHIP_ERROR TestWriteMaxValueToANullableRangeRestrictedUnsigned16BitInteger_436()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint16_t> nullableRangeRestrictedInt16uArgument;
        nullableRangeRestrictedInt16uArgument.SetNonNull();
        nullableRangeRestrictedInt16uArgument.Value() = 65534U;

        ReturnErrorOnFailure(
            cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableRangeRestrictedInt16u::TypeInfo>(
                nullableRangeRestrictedInt16uArgument, this, OnSuccessCallback_436, OnFailureCallback_436));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_436(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
        NextTest();
    }

    void OnSuccessResponse_436() { ThrowSuccessResponse(); }

    CHIP_ERROR TestVerifyNullableRangeRestrictedUnsigned16BitIntegerValueHasNotChanged_437()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableRangeRestrictedInt16u::TypeInfo>(
                this, OnSuccessCallback_437, OnFailureCallback_437, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_437(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_437(const chip::app::DataModel::Nullable<uint16_t> & nullableRangeRestrictedInt16u)
    {
        VerifyOrReturn(CheckValueNonNull("nullableRangeRestrictedInt16u", nullableRangeRestrictedInt16u));
        VerifyOrReturn(CheckValue("nullableRangeRestrictedInt16u.Value()", nullableRangeRestrictedInt16u.Value(), 200U));

        NextTest();
    }

    CHIP_ERROR TestWriteMinValidValueToANullableRangeRestrictedUnsigned16BitInteger_438()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint16_t> nullableRangeRestrictedInt16uArgument;
        nullableRangeRestrictedInt16uArgument.SetNonNull();
        nullableRangeRestrictedInt16uArgument.Value() = 100U;

        ReturnErrorOnFailure(
            cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableRangeRestrictedInt16u::TypeInfo>(
                nullableRangeRestrictedInt16uArgument, this, OnSuccessCallback_438, OnFailureCallback_438));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_438(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_438() { NextTest(); }

    CHIP_ERROR TestVerifyNullableRangeRestrictedUnsigned16BitIntegerValueIsAtMinValid_439()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableRangeRestrictedInt16u::TypeInfo>(
                this, OnSuccessCallback_439, OnFailureCallback_439, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_439(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_439(const chip::app::DataModel::Nullable<uint16_t> & nullableRangeRestrictedInt16u)
    {
        VerifyOrReturn(CheckValueNonNull("nullableRangeRestrictedInt16u", nullableRangeRestrictedInt16u));
        VerifyOrReturn(CheckValue("nullableRangeRestrictedInt16u.Value()", nullableRangeRestrictedInt16u.Value(), 100U));

        NextTest();
    }

    CHIP_ERROR TestWriteMaxValidValueToANullableRangeRestrictedUnsigned16BitInteger_440()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint16_t> nullableRangeRestrictedInt16uArgument;
        nullableRangeRestrictedInt16uArgument.SetNonNull();
        nullableRangeRestrictedInt16uArgument.Value() = 1000U;

        ReturnErrorOnFailure(
            cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableRangeRestrictedInt16u::TypeInfo>(
                nullableRangeRestrictedInt16uArgument, this, OnSuccessCallback_440, OnFailureCallback_440));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_440(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_440() { NextTest(); }

    CHIP_ERROR TestVerifyNullableRangeRestrictedUnsigned16BitIntegerValueIsAtMaxValid_441()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableRangeRestrictedInt16u::TypeInfo>(
                this, OnSuccessCallback_441, OnFailureCallback_441, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_441(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_441(const chip::app::DataModel::Nullable<uint16_t> & nullableRangeRestrictedInt16u)
    {
        VerifyOrReturn(CheckValueNonNull("nullableRangeRestrictedInt16u", nullableRangeRestrictedInt16u));
        VerifyOrReturn(CheckValue("nullableRangeRestrictedInt16u.Value()", nullableRangeRestrictedInt16u.Value(), 1000U));

        NextTest();
    }

    CHIP_ERROR TestWriteMiddleValidValueToANullableRangeRestrictedUnsigned16BitInteger_442()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint16_t> nullableRangeRestrictedInt16uArgument;
        nullableRangeRestrictedInt16uArgument.SetNonNull();
        nullableRangeRestrictedInt16uArgument.Value() = 500U;

        ReturnErrorOnFailure(
            cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableRangeRestrictedInt16u::TypeInfo>(
                nullableRangeRestrictedInt16uArgument, this, OnSuccessCallback_442, OnFailureCallback_442));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_442(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_442() { NextTest(); }

    CHIP_ERROR TestVerifyNullableRangeRestrictedUnsigned16BitIntegerValueIsAtMidValid_443()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableRangeRestrictedInt16u::TypeInfo>(
                this, OnSuccessCallback_443, OnFailureCallback_443, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_443(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_443(const chip::app::DataModel::Nullable<uint16_t> & nullableRangeRestrictedInt16u)
    {
        VerifyOrReturn(CheckValueNonNull("nullableRangeRestrictedInt16u", nullableRangeRestrictedInt16u));
        VerifyOrReturn(CheckValue("nullableRangeRestrictedInt16u.Value()", nullableRangeRestrictedInt16u.Value(), 500U));

        NextTest();
    }

    CHIP_ERROR TestWriteNullValueToANullableRangeRestrictedUnsigned16BitInteger_444()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint16_t> nullableRangeRestrictedInt16uArgument;
        nullableRangeRestrictedInt16uArgument.SetNull();

        ReturnErrorOnFailure(
            cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableRangeRestrictedInt16u::TypeInfo>(
                nullableRangeRestrictedInt16uArgument, this, OnSuccessCallback_444, OnFailureCallback_444));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_444(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_444() { NextTest(); }

    CHIP_ERROR TestVerifyNullableRangeRestrictedUnsigned16BitIntegerValueIsNull_445()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableRangeRestrictedInt16u::TypeInfo>(
                this, OnSuccessCallback_445, OnFailureCallback_445, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_445(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_445(const chip::app::DataModel::Nullable<uint16_t> & nullableRangeRestrictedInt16u)
    {
        VerifyOrReturn(CheckValueNull("nullableRangeRestrictedInt16u", nullableRangeRestrictedInt16u));

        NextTest();
    }

    CHIP_ERROR TestReadNullableRangeRestrictedSigned8BitInteger_446()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableRangeRestrictedInt8s::TypeInfo>(
                this, OnSuccessCallback_446, OnFailureCallback_446, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_446(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_446(const chip::app::DataModel::Nullable<int8_t> & nullableRangeRestrictedInt8s)
    {
        VerifyOrReturn(CheckValueNonNull("nullableRangeRestrictedInt8s", nullableRangeRestrictedInt8s));
        VerifyOrReturn(CheckValue("nullableRangeRestrictedInt8s.Value()", nullableRangeRestrictedInt8s.Value(), -20));

        NextTest();
    }

    CHIP_ERROR TestWriteMinValueToANullableRangeRestrictedSigned8BitInteger_447()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<int8_t> nullableRangeRestrictedInt8sArgument;
        nullableRangeRestrictedInt8sArgument.SetNonNull();
        nullableRangeRestrictedInt8sArgument.Value() = -127;

        ReturnErrorOnFailure(
            cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableRangeRestrictedInt8s::TypeInfo>(
                nullableRangeRestrictedInt8sArgument, this, OnSuccessCallback_447, OnFailureCallback_447));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_447(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
        NextTest();
    }

    void OnSuccessResponse_447() { ThrowSuccessResponse(); }

    CHIP_ERROR TestWriteJustBelowRangeValueToANullableRangeRestrictedSigned8BitInteger_448()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<int8_t> nullableRangeRestrictedInt8sArgument;
        nullableRangeRestrictedInt8sArgument.SetNonNull();
        nullableRangeRestrictedInt8sArgument.Value() = -41;

        ReturnErrorOnFailure(
            cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableRangeRestrictedInt8s::TypeInfo>(
                nullableRangeRestrictedInt8sArgument, this, OnSuccessCallback_448, OnFailureCallback_448));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_448(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
        NextTest();
    }

    void OnSuccessResponse_448() { ThrowSuccessResponse(); }

    CHIP_ERROR TestWriteJustAboveRangeValueToANullableRangeRestrictedSigned8BitInteger_449()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<int8_t> nullableRangeRestrictedInt8sArgument;
        nullableRangeRestrictedInt8sArgument.SetNonNull();
        nullableRangeRestrictedInt8sArgument.Value() = 51;

        ReturnErrorOnFailure(
            cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableRangeRestrictedInt8s::TypeInfo>(
                nullableRangeRestrictedInt8sArgument, this, OnSuccessCallback_449, OnFailureCallback_449));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_449(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
        NextTest();
    }

    void OnSuccessResponse_449() { ThrowSuccessResponse(); }

    CHIP_ERROR TestWriteMaxValueToANullableRangeRestrictedSigned8BitInteger_450()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<int8_t> nullableRangeRestrictedInt8sArgument;
        nullableRangeRestrictedInt8sArgument.SetNonNull();
        nullableRangeRestrictedInt8sArgument.Value() = 127;

        ReturnErrorOnFailure(
            cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableRangeRestrictedInt8s::TypeInfo>(
                nullableRangeRestrictedInt8sArgument, this, OnSuccessCallback_450, OnFailureCallback_450));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_450(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
        NextTest();
    }

    void OnSuccessResponse_450() { ThrowSuccessResponse(); }

    CHIP_ERROR TestVerifyNullableRangeRestrictedSigned8BitIntegerValueHasNotChanged_451()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableRangeRestrictedInt8s::TypeInfo>(
                this, OnSuccessCallback_451, OnFailureCallback_451, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_451(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_451(const chip::app::DataModel::Nullable<int8_t> & nullableRangeRestrictedInt8s)
    {
        VerifyOrReturn(CheckValueNonNull("nullableRangeRestrictedInt8s", nullableRangeRestrictedInt8s));
        VerifyOrReturn(CheckValue("nullableRangeRestrictedInt8s.Value()", nullableRangeRestrictedInt8s.Value(), -20));

        NextTest();
    }

    CHIP_ERROR TestWriteMinValidValueToANullableRangeRestrictedSigned8BitInteger_452()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<int8_t> nullableRangeRestrictedInt8sArgument;
        nullableRangeRestrictedInt8sArgument.SetNonNull();
        nullableRangeRestrictedInt8sArgument.Value() = -40;

        ReturnErrorOnFailure(
            cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableRangeRestrictedInt8s::TypeInfo>(
                nullableRangeRestrictedInt8sArgument, this, OnSuccessCallback_452, OnFailureCallback_452));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_452(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_452() { NextTest(); }

    CHIP_ERROR TestVerifyNullableRangeRestrictedSigned8BitIntegerValueIsAtMinValid_453()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableRangeRestrictedInt8s::TypeInfo>(
                this, OnSuccessCallback_453, OnFailureCallback_453, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_453(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_453(const chip::app::DataModel::Nullable<int8_t> & nullableRangeRestrictedInt8s)
    {
        VerifyOrReturn(CheckValueNonNull("nullableRangeRestrictedInt8s", nullableRangeRestrictedInt8s));
        VerifyOrReturn(CheckValue("nullableRangeRestrictedInt8s.Value()", nullableRangeRestrictedInt8s.Value(), -40));

        NextTest();
    }

    CHIP_ERROR TestWriteMaxValidValueToANullableRangeRestrictedSigned8BitInteger_454()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<int8_t> nullableRangeRestrictedInt8sArgument;
        nullableRangeRestrictedInt8sArgument.SetNonNull();
        nullableRangeRestrictedInt8sArgument.Value() = 50;

        ReturnErrorOnFailure(
            cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableRangeRestrictedInt8s::TypeInfo>(
                nullableRangeRestrictedInt8sArgument, this, OnSuccessCallback_454, OnFailureCallback_454));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_454(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_454() { NextTest(); }

    CHIP_ERROR TestVerifyNullableRangeRestrictedSigned8BitIntegerValueIsAtMaxValid_455()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableRangeRestrictedInt8s::TypeInfo>(
                this, OnSuccessCallback_455, OnFailureCallback_455, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_455(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_455(const chip::app::DataModel::Nullable<int8_t> & nullableRangeRestrictedInt8s)
    {
        VerifyOrReturn(CheckValueNonNull("nullableRangeRestrictedInt8s", nullableRangeRestrictedInt8s));
        VerifyOrReturn(CheckValue("nullableRangeRestrictedInt8s.Value()", nullableRangeRestrictedInt8s.Value(), 50));

        NextTest();
    }

    CHIP_ERROR TestWriteMiddleValidValueToANullableRangeRestrictedSigned8BitInteger_456()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<int8_t> nullableRangeRestrictedInt8sArgument;
        nullableRangeRestrictedInt8sArgument.SetNonNull();
        nullableRangeRestrictedInt8sArgument.Value() = 6;

        ReturnErrorOnFailure(
            cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableRangeRestrictedInt8s::TypeInfo>(
                nullableRangeRestrictedInt8sArgument, this, OnSuccessCallback_456, OnFailureCallback_456));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_456(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_456() { NextTest(); }

    CHIP_ERROR TestVerifyNullableRangeRestrictedSigned8BitIntegerValueIsAtMidValid_457()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableRangeRestrictedInt8s::TypeInfo>(
                this, OnSuccessCallback_457, OnFailureCallback_457, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_457(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_457(const chip::app::DataModel::Nullable<int8_t> & nullableRangeRestrictedInt8s)
    {
        VerifyOrReturn(CheckValueNonNull("nullableRangeRestrictedInt8s", nullableRangeRestrictedInt8s));
        VerifyOrReturn(CheckValue("nullableRangeRestrictedInt8s.Value()", nullableRangeRestrictedInt8s.Value(), 6));

        NextTest();
    }

    CHIP_ERROR TestWriteNullValueToANullableRangeRestrictedSigned8BitInteger_458()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<int8_t> nullableRangeRestrictedInt8sArgument;
        nullableRangeRestrictedInt8sArgument.SetNull();

        ReturnErrorOnFailure(
            cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableRangeRestrictedInt8s::TypeInfo>(
                nullableRangeRestrictedInt8sArgument, this, OnSuccessCallback_458, OnFailureCallback_458));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_458(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_458() { NextTest(); }

    CHIP_ERROR TestVerifyNullableRangeRestrictedSigned8BitIntegerValueIsAtNull_459()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableRangeRestrictedInt8s::TypeInfo>(
                this, OnSuccessCallback_459, OnFailureCallback_459, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_459(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_459(const chip::app::DataModel::Nullable<int8_t> & nullableRangeRestrictedInt8s)
    {
        VerifyOrReturn(CheckValueNull("nullableRangeRestrictedInt8s", nullableRangeRestrictedInt8s));

        NextTest();
    }

    CHIP_ERROR TestReadNullableRangeRestrictedSigned16BitInteger_460()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableRangeRestrictedInt16s::TypeInfo>(
                this, OnSuccessCallback_460, OnFailureCallback_460, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_460(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_460(const chip::app::DataModel::Nullable<int16_t> & nullableRangeRestrictedInt16s)
    {
        VerifyOrReturn(CheckValueNonNull("nullableRangeRestrictedInt16s", nullableRangeRestrictedInt16s));
        VerifyOrReturn(CheckValue("nullableRangeRestrictedInt16s.Value()", nullableRangeRestrictedInt16s.Value(), -100));

        NextTest();
    }

    CHIP_ERROR TestWriteMinValueToANullableRangeRestrictedSigned16BitInteger_461()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<int16_t> nullableRangeRestrictedInt16sArgument;
        nullableRangeRestrictedInt16sArgument.SetNonNull();
        nullableRangeRestrictedInt16sArgument.Value() = -32767;

        ReturnErrorOnFailure(
            cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableRangeRestrictedInt16s::TypeInfo>(
                nullableRangeRestrictedInt16sArgument, this, OnSuccessCallback_461, OnFailureCallback_461));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_461(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
        NextTest();
    }

    void OnSuccessResponse_461() { ThrowSuccessResponse(); }

    CHIP_ERROR TestWriteJustBelowRangeValueToANullableRangeRestrictedSigned16BitInteger_462()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<int16_t> nullableRangeRestrictedInt16sArgument;
        nullableRangeRestrictedInt16sArgument.SetNonNull();
        nullableRangeRestrictedInt16sArgument.Value() = -151;

        ReturnErrorOnFailure(
            cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableRangeRestrictedInt16s::TypeInfo>(
                nullableRangeRestrictedInt16sArgument, this, OnSuccessCallback_462, OnFailureCallback_462));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_462(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
        NextTest();
    }

    void OnSuccessResponse_462() { ThrowSuccessResponse(); }

    CHIP_ERROR TestWriteJustAboveRangeValueToANullableRangeRestrictedSigned16BitInteger_463()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<int16_t> nullableRangeRestrictedInt16sArgument;
        nullableRangeRestrictedInt16sArgument.SetNonNull();
        nullableRangeRestrictedInt16sArgument.Value() = 201;

        ReturnErrorOnFailure(
            cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableRangeRestrictedInt16s::TypeInfo>(
                nullableRangeRestrictedInt16sArgument, this, OnSuccessCallback_463, OnFailureCallback_463));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_463(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
        NextTest();
    }

    void OnSuccessResponse_463() { ThrowSuccessResponse(); }

    CHIP_ERROR TestWriteMaxValueToANullableRangeRestrictedSigned16BitInteger_464()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<int16_t> nullableRangeRestrictedInt16sArgument;
        nullableRangeRestrictedInt16sArgument.SetNonNull();
        nullableRangeRestrictedInt16sArgument.Value() = 32767;

        ReturnErrorOnFailure(
            cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableRangeRestrictedInt16s::TypeInfo>(
                nullableRangeRestrictedInt16sArgument, this, OnSuccessCallback_464, OnFailureCallback_464));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_464(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
        NextTest();
    }

    void OnSuccessResponse_464() { ThrowSuccessResponse(); }

    CHIP_ERROR TestVerifyNullableRangeRestrictedSigned16BitIntegerValueHasNotChanged_465()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableRangeRestrictedInt16s::TypeInfo>(
                this, OnSuccessCallback_465, OnFailureCallback_465, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_465(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_465(const chip::app::DataModel::Nullable<int16_t> & nullableRangeRestrictedInt16s)
    {
        VerifyOrReturn(CheckValueNonNull("nullableRangeRestrictedInt16s", nullableRangeRestrictedInt16s));
        VerifyOrReturn(CheckValue("nullableRangeRestrictedInt16s.Value()", nullableRangeRestrictedInt16s.Value(), -100));

        NextTest();
    }

    CHIP_ERROR TestWriteMinValidValueToANullableRangeRestrictedSigned16BitInteger_466()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<int16_t> nullableRangeRestrictedInt16sArgument;
        nullableRangeRestrictedInt16sArgument.SetNonNull();
        nullableRangeRestrictedInt16sArgument.Value() = -150;

        ReturnErrorOnFailure(
            cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableRangeRestrictedInt16s::TypeInfo>(
                nullableRangeRestrictedInt16sArgument, this, OnSuccessCallback_466, OnFailureCallback_466));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_466(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_466() { NextTest(); }

    CHIP_ERROR TestVerifyNullableRangeRestrictedSigned16BitIntegerValueIsAtMinValid_467()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableRangeRestrictedInt16s::TypeInfo>(
                this, OnSuccessCallback_467, OnFailureCallback_467, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_467(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_467(const chip::app::DataModel::Nullable<int16_t> & nullableRangeRestrictedInt16s)
    {
        VerifyOrReturn(CheckValueNonNull("nullableRangeRestrictedInt16s", nullableRangeRestrictedInt16s));
        VerifyOrReturn(CheckValue("nullableRangeRestrictedInt16s.Value()", nullableRangeRestrictedInt16s.Value(), -150));

        NextTest();
    }

    CHIP_ERROR TestWriteMaxValidValueToANullableRangeRestrictedSigned16BitInteger_468()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<int16_t> nullableRangeRestrictedInt16sArgument;
        nullableRangeRestrictedInt16sArgument.SetNonNull();
        nullableRangeRestrictedInt16sArgument.Value() = 200;

        ReturnErrorOnFailure(
            cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableRangeRestrictedInt16s::TypeInfo>(
                nullableRangeRestrictedInt16sArgument, this, OnSuccessCallback_468, OnFailureCallback_468));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_468(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_468() { NextTest(); }

    CHIP_ERROR TestVerifyNullableRangeRestrictedSigned16BitIntegerValueIsAtMaxValid_469()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableRangeRestrictedInt16s::TypeInfo>(
                this, OnSuccessCallback_469, OnFailureCallback_469, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_469(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_469(const chip::app::DataModel::Nullable<int16_t> & nullableRangeRestrictedInt16s)
    {
        VerifyOrReturn(CheckValueNonNull("nullableRangeRestrictedInt16s", nullableRangeRestrictedInt16s));
        VerifyOrReturn(CheckValue("nullableRangeRestrictedInt16s.Value()", nullableRangeRestrictedInt16s.Value(), 200));

        NextTest();
    }

    CHIP_ERROR TestWriteMiddleValidValueToANullableRangeRestrictedSigned16BitInteger_470()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<int16_t> nullableRangeRestrictedInt16sArgument;
        nullableRangeRestrictedInt16sArgument.SetNonNull();
        nullableRangeRestrictedInt16sArgument.Value() = 7;

        ReturnErrorOnFailure(
            cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableRangeRestrictedInt16s::TypeInfo>(
                nullableRangeRestrictedInt16sArgument, this, OnSuccessCallback_470, OnFailureCallback_470));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_470(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_470() { NextTest(); }

    CHIP_ERROR TestVerifyNullableRangeRestrictedSigned16BitIntegerValueIsAtMidValid_471()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableRangeRestrictedInt16s::TypeInfo>(
                this, OnSuccessCallback_471, OnFailureCallback_471, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_471(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_471(const chip::app::DataModel::Nullable<int16_t> & nullableRangeRestrictedInt16s)
    {
        VerifyOrReturn(CheckValueNonNull("nullableRangeRestrictedInt16s", nullableRangeRestrictedInt16s));
        VerifyOrReturn(CheckValue("nullableRangeRestrictedInt16s.Value()", nullableRangeRestrictedInt16s.Value(), 7));

        NextTest();
    }

    CHIP_ERROR TestWriteNullValueToANullableRangeRestrictedSigned16BitInteger_472()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<int16_t> nullableRangeRestrictedInt16sArgument;
        nullableRangeRestrictedInt16sArgument.SetNull();

        ReturnErrorOnFailure(
            cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableRangeRestrictedInt16s::TypeInfo>(
                nullableRangeRestrictedInt16sArgument, this, OnSuccessCallback_472, OnFailureCallback_472));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_472(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_472() { NextTest(); }

    CHIP_ERROR TestVerifyNullableRangeRestrictedSigned16BitIntegerValueIsNull_473()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableRangeRestrictedInt16s::TypeInfo>(
                this, OnSuccessCallback_473, OnFailureCallback_473, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_473(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_473(const chip::app::DataModel::Nullable<int16_t> & nullableRangeRestrictedInt16s)
    {
        VerifyOrReturn(CheckValueNull("nullableRangeRestrictedInt16s", nullableRangeRestrictedInt16s));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeThatReturnsGeneralStatusOnWrite_474()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        bool generalErrorBooleanArgument;
        generalErrorBooleanArgument = false;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::GeneralErrorBoolean::TypeInfo>(
            generalErrorBooleanArgument, this, OnSuccessCallback_474, OnFailureCallback_474));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_474(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_DATA_TYPE));
        NextTest();
    }

    void OnSuccessResponse_474() { ThrowSuccessResponse(); }

    CHIP_ERROR TestWriteAttributeThatReturnsClusterSpecificStatusOnWrite_475()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        bool clusterErrorBooleanArgument;
        clusterErrorBooleanArgument = false;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::ClusterErrorBoolean::TypeInfo>(
            clusterErrorBooleanArgument, this, OnSuccessCallback_475, OnFailureCallback_475));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_475(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_FAILURE));
        NextTest();
    }

    void OnSuccessResponse_475() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadAttributeThatReturnsGeneralStatusOnRead_476()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::GeneralErrorBoolean::TypeInfo>(
            this, OnSuccessCallback_476, OnFailureCallback_476, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_476(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_DATA_TYPE));
        NextTest();
    }

    void OnSuccessResponse_476(bool generalErrorBoolean) { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadAttributeThatReturnsClusterSpecificStatusOnRead_477()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::ClusterErrorBoolean::TypeInfo>(
            this, OnSuccessCallback_477, OnFailureCallback_477, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_477(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_FAILURE));
        NextTest();
    }

    void OnSuccessResponse_477(bool clusterErrorBoolean) { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadClientGeneratedCommandListAttribute_478()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::ClientGeneratedCommandList::TypeInfo>(
                this, OnSuccessCallback_478, OnFailureCallback_478, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_478(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_478(const chip::app::DataModel::DecodableList<chip::CommandId> & clientGeneratedCommandList)
    {
        {
            auto iter_0 = clientGeneratedCommandList.begin();
            VerifyOrReturn(CheckNextListItemDecodes<decltype(clientGeneratedCommandList)>("clientGeneratedCommandList", iter_0, 0));
            VerifyOrReturn(CheckValue("clientGeneratedCommandList[0]", iter_0.GetValue(), 0UL));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(clientGeneratedCommandList)>("clientGeneratedCommandList", iter_0, 1));
            VerifyOrReturn(CheckValue("clientGeneratedCommandList[1]", iter_0.GetValue(), 1UL));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(clientGeneratedCommandList)>("clientGeneratedCommandList", iter_0, 2));
            VerifyOrReturn(CheckValue("clientGeneratedCommandList[2]", iter_0.GetValue(), 2UL));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(clientGeneratedCommandList)>("clientGeneratedCommandList", iter_0, 3));
            VerifyOrReturn(CheckValue("clientGeneratedCommandList[3]", iter_0.GetValue(), 4UL));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(clientGeneratedCommandList)>("clientGeneratedCommandList", iter_0, 4));
            VerifyOrReturn(CheckValue("clientGeneratedCommandList[4]", iter_0.GetValue(), 7UL));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(clientGeneratedCommandList)>("clientGeneratedCommandList", iter_0, 5));
            VerifyOrReturn(CheckValue("clientGeneratedCommandList[5]", iter_0.GetValue(), 8UL));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(clientGeneratedCommandList)>("clientGeneratedCommandList", iter_0, 6));
            VerifyOrReturn(CheckValue("clientGeneratedCommandList[6]", iter_0.GetValue(), 9UL));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(clientGeneratedCommandList)>("clientGeneratedCommandList", iter_0, 7));
            VerifyOrReturn(CheckValue("clientGeneratedCommandList[7]", iter_0.GetValue(), 10UL));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(clientGeneratedCommandList)>("clientGeneratedCommandList", iter_0, 8));
            VerifyOrReturn(CheckValue("clientGeneratedCommandList[8]", iter_0.GetValue(), 11UL));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(clientGeneratedCommandList)>("clientGeneratedCommandList", iter_0, 9));
            VerifyOrReturn(CheckValue("clientGeneratedCommandList[9]", iter_0.GetValue(), 12UL));
            VerifyOrReturn(
                CheckNextListItemDecodes<decltype(clientGeneratedCommandList)>("clientGeneratedCommandList", iter_0, 10));
            VerifyOrReturn(CheckValue("clientGeneratedCommandList[10]", iter_0.GetValue(), 13UL));
            VerifyOrReturn(
                CheckNextListItemDecodes<decltype(clientGeneratedCommandList)>("clientGeneratedCommandList", iter_0, 11));
            VerifyOrReturn(CheckValue("clientGeneratedCommandList[11]", iter_0.GetValue(), 14UL));
            VerifyOrReturn(
                CheckNextListItemDecodes<decltype(clientGeneratedCommandList)>("clientGeneratedCommandList", iter_0, 12));
            VerifyOrReturn(CheckValue("clientGeneratedCommandList[12]", iter_0.GetValue(), 15UL));
            VerifyOrReturn(
                CheckNextListItemDecodes<decltype(clientGeneratedCommandList)>("clientGeneratedCommandList", iter_0, 13));
            VerifyOrReturn(CheckValue("clientGeneratedCommandList[13]", iter_0.GetValue(), 17UL));
            VerifyOrReturn(
                CheckNextListItemDecodes<decltype(clientGeneratedCommandList)>("clientGeneratedCommandList", iter_0, 14));
            VerifyOrReturn(CheckValue("clientGeneratedCommandList[14]", iter_0.GetValue(), 18UL));
            VerifyOrReturn(
                CheckNextListItemDecodes<decltype(clientGeneratedCommandList)>("clientGeneratedCommandList", iter_0, 15));
            VerifyOrReturn(CheckValue("clientGeneratedCommandList[15]", iter_0.GetValue(), 19UL));
            VerifyOrReturn(
                CheckNextListItemDecodes<decltype(clientGeneratedCommandList)>("clientGeneratedCommandList", iter_0, 16));
            VerifyOrReturn(CheckValue("clientGeneratedCommandList[16]", iter_0.GetValue(), 20UL));
            VerifyOrReturn(
                CheckNextListItemDecodes<decltype(clientGeneratedCommandList)>("clientGeneratedCommandList", iter_0, 17));
            VerifyOrReturn(CheckValue("clientGeneratedCommandList[17]", iter_0.GetValue(), 21UL));
            VerifyOrReturn(CheckNoMoreListItems<decltype(clientGeneratedCommandList)>("clientGeneratedCommandList", iter_0, 18));
        }

        NextTest();
    }

    CHIP_ERROR TestReadServerGeneratedCommandListAttribute_479()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::ServerGeneratedCommandList::TypeInfo>(
                this, OnSuccessCallback_479, OnFailureCallback_479, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_479(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_479(const chip::app::DataModel::DecodableList<chip::CommandId> & serverGeneratedCommandList)
    {
        {
            auto iter_0 = serverGeneratedCommandList.begin();
            VerifyOrReturn(CheckNextListItemDecodes<decltype(serverGeneratedCommandList)>("serverGeneratedCommandList", iter_0, 0));
            VerifyOrReturn(CheckValue("serverGeneratedCommandList[0]", iter_0.GetValue(), 0UL));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(serverGeneratedCommandList)>("serverGeneratedCommandList", iter_0, 1));
            VerifyOrReturn(CheckValue("serverGeneratedCommandList[1]", iter_0.GetValue(), 1UL));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(serverGeneratedCommandList)>("serverGeneratedCommandList", iter_0, 2));
            VerifyOrReturn(CheckValue("serverGeneratedCommandList[2]", iter_0.GetValue(), 4UL));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(serverGeneratedCommandList)>("serverGeneratedCommandList", iter_0, 3));
            VerifyOrReturn(CheckValue("serverGeneratedCommandList[3]", iter_0.GetValue(), 5UL));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(serverGeneratedCommandList)>("serverGeneratedCommandList", iter_0, 4));
            VerifyOrReturn(CheckValue("serverGeneratedCommandList[4]", iter_0.GetValue(), 6UL));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(serverGeneratedCommandList)>("serverGeneratedCommandList", iter_0, 5));
            VerifyOrReturn(CheckValue("serverGeneratedCommandList[5]", iter_0.GetValue(), 9UL));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(serverGeneratedCommandList)>("serverGeneratedCommandList", iter_0, 6));
            VerifyOrReturn(CheckValue("serverGeneratedCommandList[6]", iter_0.GetValue(), 10UL));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(serverGeneratedCommandList)>("serverGeneratedCommandList", iter_0, 7));
            VerifyOrReturn(CheckValue("serverGeneratedCommandList[7]", iter_0.GetValue(), 11UL));
            VerifyOrReturn(CheckNoMoreListItems<decltype(serverGeneratedCommandList)>("serverGeneratedCommandList", iter_0, 8));
        }

        NextTest();
    }

    CHIP_ERROR TestWriteStructTypedAttribute_480()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::Clusters::TestCluster::Structs::SimpleStruct::Type structAttrArgument;

        structAttrArgument.a = 5;
        structAttrArgument.b = true;
        structAttrArgument.c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(2);
        structAttrArgument.d = chip::ByteSpan(chip::Uint8::from_const_char("abcgarbage: not in length on purpose"), 3);
        structAttrArgument.e = chip::Span<const char>("garbage: not in length on purpose", 0);
        structAttrArgument.f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(17);
        structAttrArgument.g = 1.5f;
        structAttrArgument.h = 3.14159265358979;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::StructAttr::TypeInfo>(
            structAttrArgument, this, OnSuccessCallback_480, OnFailureCallback_480));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_480(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_480() { NextTest(); }

    CHIP_ERROR TestReadStructTypedAttribute_481()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::StructAttr::TypeInfo>(
            this, OnSuccessCallback_481, OnFailureCallback_481, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_481(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_481(const chip::app::Clusters::TestCluster::Structs::SimpleStruct::DecodableType & structAttr)
    {
        VerifyOrReturn(CheckValue("structAttr.a", structAttr.a, 5));
        VerifyOrReturn(CheckValue("structAttr.b", structAttr.b, true));
        VerifyOrReturn(CheckValue("structAttr.c", structAttr.c, 2));
        VerifyOrReturn(CheckValueAsString("structAttr.d", structAttr.d, chip::ByteSpan(chip::Uint8::from_const_char("abc"), 3)));
        VerifyOrReturn(CheckValueAsString("structAttr.e", structAttr.e, chip::CharSpan("", 0)));
        VerifyOrReturn(CheckValue("structAttr.f", structAttr.f, 17));
        VerifyOrReturn(CheckValue("structAttr.g", structAttr.g, 1.5f));
        VerifyOrReturn(CheckValue("structAttr.h", structAttr.h, 3.14159265358979));

        NextTest();
    }
};

class TestClusterComplexTypesSuite : public TestCommand
{
public:
    TestClusterComplexTypesSuite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("TestClusterComplexTypes", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~TestClusterComplexTypesSuite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestClusterComplexTypes\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestClusterComplexTypes\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Send Test Command with optional arg set to null.\n");
            err = TestSendTestCommandWithOptionalArgSetToNull_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Send command that needs timed invoke without a timeout value\n");
            err = TestSendCommandThatNeedsTimedInvokeWithoutATimeoutValue_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Send command that needs timed invoke with a long timeout value\n");
            err = TestSendCommandThatNeedsTimedInvokeWithALongTimeoutValue_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Send command that needs timed invoke with a too-short timeout value\n");
            err = TestSendCommandThatNeedsTimedInvokeWithATooShortTimeoutValue_4();
            break;
        case 5:
            ChipLogProgress(chipTool,
                            " ***** Test Step 5 : Send command that does not need timed invoke with a long timeout value\n");
            err = TestSendCommandThatDoesNotNeedTimedInvokeWithALongTimeoutValue_5();
            break;
        case 6:
            ChipLogProgress(chipTool,
                            " ***** Test Step 6 : Send command that does not need timed invoke with a too-short timeout value\n");
            err = TestSendCommandThatDoesNotNeedTimedInvokeWithATooShortTimeoutValue_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Read attribute that needs timed write initial state\n");
            err = TestReadAttributeThatNeedsTimedWriteInitialState_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Write attribute that needs timed write without a timeout value\n");
            err = TestWriteAttributeThatNeedsTimedWriteWithoutATimeoutValue_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Read attribute that needs timed write state unchanged 1\n");
            err = TestReadAttributeThatNeedsTimedWriteStateUnchanged1_9();
            break;
        case 10:
            ChipLogProgress(chipTool,
                            " ***** Test Step 10 : Write attribute that needs timed write with a too-short timeout value\n");
            err = TestWriteAttributeThatNeedsTimedWriteWithATooShortTimeoutValue_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : Read attribute that needs timed write state unchanged 2\n");
            err = TestReadAttributeThatNeedsTimedWriteStateUnchanged2_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : Write attribute that needs timed write with a long timeout value\n");
            err = TestWriteAttributeThatNeedsTimedWriteWithALongTimeoutValue_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : Read attribute that needs timed write state changed\n");
            err = TestReadAttributeThatNeedsTimedWriteStateChanged_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : Write attribute that needs timed write reset to default\n");
            err = TestWriteAttributeThatNeedsTimedWriteResetToDefault_14();
            break;
        case 15:
            ChipLogProgress(chipTool, " ***** Test Step 15 : Read attribute that does not need timed write initial value\n");
            err = TestReadAttributeThatDoesNotNeedTimedWriteInitialValue_15();
            break;
        case 16:
            ChipLogProgress(
                chipTool, " ***** Test Step 16 : Write attribute that does not need timed write with a too-short timeout value\n");
            err = TestWriteAttributeThatDoesNotNeedTimedWriteWithATooShortTimeoutValue_16();
            break;
        case 17:
            ChipLogProgress(chipTool, " ***** Test Step 17 : Read attribute that does not need timed write unchanged value\n");
            err = TestReadAttributeThatDoesNotNeedTimedWriteUnchangedValue_17();
            break;
        case 18:
            ChipLogProgress(chipTool,
                            " ***** Test Step 18 : Write attribute that does not need timed write with a long timeout value\n");
            err = TestWriteAttributeThatDoesNotNeedTimedWriteWithALongTimeoutValue_18();
            break;
        case 19:
            ChipLogProgress(chipTool, " ***** Test Step 19 : Read attribute that does not need timed write changed value\n");
            err = TestReadAttributeThatDoesNotNeedTimedWriteChangedValue_19();
            break;
        case 20:
            ChipLogProgress(chipTool, " ***** Test Step 20 : Write attribute that does not need timed write reset to default\n");
            err = TestWriteAttributeThatDoesNotNeedTimedWriteResetToDefault_20();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 21;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_7(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterComplexTypesSuite *>(context))->OnFailureResponse_7(error);
    }

    static void OnSuccessCallback_7(void * context, bool timedWriteBoolean)
    {
        (static_cast<TestClusterComplexTypesSuite *>(context))->OnSuccessResponse_7(timedWriteBoolean);
    }

    static void OnFailureCallback_8(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterComplexTypesSuite *>(context))->OnFailureResponse_8(error);
    }

    static void OnSuccessCallback_8(void * context)
    {
        (static_cast<TestClusterComplexTypesSuite *>(context))->OnSuccessResponse_8();
    }

    static void OnFailureCallback_9(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterComplexTypesSuite *>(context))->OnFailureResponse_9(error);
    }

    static void OnSuccessCallback_9(void * context, bool timedWriteBoolean)
    {
        (static_cast<TestClusterComplexTypesSuite *>(context))->OnSuccessResponse_9(timedWriteBoolean);
    }

    static void OnFailureCallback_10(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterComplexTypesSuite *>(context))->OnFailureResponse_10(error);
    }

    static void OnSuccessCallback_10(void * context)
    {
        (static_cast<TestClusterComplexTypesSuite *>(context))->OnSuccessResponse_10();
    }

    static void OnFailureCallback_11(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterComplexTypesSuite *>(context))->OnFailureResponse_11(error);
    }

    static void OnSuccessCallback_11(void * context, bool timedWriteBoolean)
    {
        (static_cast<TestClusterComplexTypesSuite *>(context))->OnSuccessResponse_11(timedWriteBoolean);
    }

    static void OnFailureCallback_12(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterComplexTypesSuite *>(context))->OnFailureResponse_12(error);
    }

    static void OnSuccessCallback_12(void * context)
    {
        (static_cast<TestClusterComplexTypesSuite *>(context))->OnSuccessResponse_12();
    }

    static void OnFailureCallback_13(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterComplexTypesSuite *>(context))->OnFailureResponse_13(error);
    }

    static void OnSuccessCallback_13(void * context, bool timedWriteBoolean)
    {
        (static_cast<TestClusterComplexTypesSuite *>(context))->OnSuccessResponse_13(timedWriteBoolean);
    }

    static void OnFailureCallback_14(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterComplexTypesSuite *>(context))->OnFailureResponse_14(error);
    }

    static void OnSuccessCallback_14(void * context)
    {
        (static_cast<TestClusterComplexTypesSuite *>(context))->OnSuccessResponse_14();
    }

    static void OnFailureCallback_15(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterComplexTypesSuite *>(context))->OnFailureResponse_15(error);
    }

    static void OnSuccessCallback_15(void * context, bool boolean)
    {
        (static_cast<TestClusterComplexTypesSuite *>(context))->OnSuccessResponse_15(boolean);
    }

    static void OnFailureCallback_16(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterComplexTypesSuite *>(context))->OnFailureResponse_16(error);
    }

    static void OnSuccessCallback_16(void * context)
    {
        (static_cast<TestClusterComplexTypesSuite *>(context))->OnSuccessResponse_16();
    }

    static void OnFailureCallback_17(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterComplexTypesSuite *>(context))->OnFailureResponse_17(error);
    }

    static void OnSuccessCallback_17(void * context, bool boolean)
    {
        (static_cast<TestClusterComplexTypesSuite *>(context))->OnSuccessResponse_17(boolean);
    }

    static void OnFailureCallback_18(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterComplexTypesSuite *>(context))->OnFailureResponse_18(error);
    }

    static void OnSuccessCallback_18(void * context)
    {
        (static_cast<TestClusterComplexTypesSuite *>(context))->OnSuccessResponse_18();
    }

    static void OnFailureCallback_19(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterComplexTypesSuite *>(context))->OnFailureResponse_19(error);
    }

    static void OnSuccessCallback_19(void * context, bool boolean)
    {
        (static_cast<TestClusterComplexTypesSuite *>(context))->OnSuccessResponse_19(boolean);
    }

    static void OnFailureCallback_20(void * context, CHIP_ERROR error)
    {
        (static_cast<TestClusterComplexTypesSuite *>(context))->OnFailureResponse_20(error);
    }

    static void OnSuccessCallback_20(void * context)
    {
        (static_cast<TestClusterComplexTypesSuite *>(context))->OnSuccessResponse_20();
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestSendTestCommandWithOptionalArgSetToNull_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::TestNullableOptionalRequest::Type;

        RequestType request;
        request.arg1.Emplace();
        request.arg1.Value().SetNull();

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestClusterComplexTypesSuite *>(context))
                ->OnSuccessResponse_1(data.wasPresent, data.wasNull, data.value, data.originalValue);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestClusterComplexTypesSuite *>(context))->OnFailureResponse_1(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1(bool wasPresent, const chip::Optional<bool> & wasNull, const chip::Optional<uint8_t> & value,
                             const chip::Optional<chip::app::DataModel::Nullable<uint8_t>> & originalValue)
    {
        VerifyOrReturn(CheckValue("wasPresent", wasPresent, true));

        VerifyOrReturn(CheckValuePresent("wasNull", wasNull));
        VerifyOrReturn(CheckValue("wasNull.Value()", wasNull.Value(), true));

        VerifyOrReturn(CheckValuePresent("originalValue", originalValue));
        VerifyOrReturn(CheckValueNull("originalValue.Value()", originalValue.Value()));

        NextTest();
    }

    CHIP_ERROR TestSendCommandThatNeedsTimedInvokeWithoutATimeoutValue_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::TimedInvokeRequest::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestClusterComplexTypesSuite *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestClusterComplexTypesSuite *>(context))->OnFailureResponse_2(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request,
                                                             chip::NullOptional));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_NEEDS_TIMED_INTERACTION));
        NextTest();
    }

    void OnSuccessResponse_2() { ThrowSuccessResponse(); }

    CHIP_ERROR TestSendCommandThatNeedsTimedInvokeWithALongTimeoutValue_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::TimedInvokeRequest::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestClusterComplexTypesSuite *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestClusterComplexTypesSuite *>(context))->OnFailureResponse_3(error);
        };

        ReturnErrorOnFailure(
            chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request, 10000));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestSendCommandThatNeedsTimedInvokeWithATooShortTimeoutValue_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::TimedInvokeRequest::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestClusterComplexTypesSuite *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestClusterComplexTypesSuite *>(context))->OnFailureResponse_4(error);
        };

        ReturnErrorOnFailure(
            chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request, 1));
        using namespace chip::System::Clock::Literals;
        BusyWaitFor(100_ms);
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_ACCESS));
        NextTest();
    }

    void OnSuccessResponse_4() { ThrowSuccessResponse(); }

    CHIP_ERROR TestSendCommandThatDoesNotNeedTimedInvokeWithALongTimeoutValue_5()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::Test::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestClusterComplexTypesSuite *>(context))->OnSuccessResponse_5();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestClusterComplexTypesSuite *>(context))->OnFailureResponse_5(error);
        };

        ReturnErrorOnFailure(
            chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request, 10000));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_5() { NextTest(); }

    CHIP_ERROR TestSendCommandThatDoesNotNeedTimedInvokeWithATooShortTimeoutValue_6()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::Test::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestClusterComplexTypesSuite *>(context))->OnSuccessResponse_6();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestClusterComplexTypesSuite *>(context))->OnFailureResponse_6(error);
        };

        ReturnErrorOnFailure(
            chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request, 1));
        using namespace chip::System::Clock::Literals;
        BusyWaitFor(100_ms);
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_6(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_ACCESS));
        NextTest();
    }

    void OnSuccessResponse_6() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadAttributeThatNeedsTimedWriteInitialState_7()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::TimedWriteBoolean::TypeInfo>(
            this, OnSuccessCallback_7, OnFailureCallback_7, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_7(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_7(bool timedWriteBoolean)
    {
        VerifyOrReturn(CheckValue("timedWriteBoolean", timedWriteBoolean, false));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeThatNeedsTimedWriteWithoutATimeoutValue_8()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        bool timedWriteBooleanArgument;
        timedWriteBooleanArgument = true;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::TimedWriteBoolean::TypeInfo>(
            timedWriteBooleanArgument, this, OnSuccessCallback_8, OnFailureCallback_8, chip::NullOptional));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_8(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_NEEDS_TIMED_INTERACTION));
        NextTest();
    }

    void OnSuccessResponse_8() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadAttributeThatNeedsTimedWriteStateUnchanged1_9()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::TimedWriteBoolean::TypeInfo>(
            this, OnSuccessCallback_9, OnFailureCallback_9, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_9(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_9(bool timedWriteBoolean)
    {
        VerifyOrReturn(CheckValue("timedWriteBoolean", timedWriteBoolean, false));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeThatNeedsTimedWriteWithATooShortTimeoutValue_10()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        bool timedWriteBooleanArgument;
        timedWriteBooleanArgument = true;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::TimedWriteBoolean::TypeInfo>(
            timedWriteBooleanArgument, this, OnSuccessCallback_10, OnFailureCallback_10, 1));
        using namespace chip::System::Clock::Literals;
        BusyWaitFor(100_ms);
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_10(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_ACCESS));
        NextTest();
    }

    void OnSuccessResponse_10() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadAttributeThatNeedsTimedWriteStateUnchanged2_11()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::TimedWriteBoolean::TypeInfo>(
            this, OnSuccessCallback_11, OnFailureCallback_11, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_11(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_11(bool timedWriteBoolean)
    {
        VerifyOrReturn(CheckValue("timedWriteBoolean", timedWriteBoolean, false));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeThatNeedsTimedWriteWithALongTimeoutValue_12()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        bool timedWriteBooleanArgument;
        timedWriteBooleanArgument = true;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::TimedWriteBoolean::TypeInfo>(
            timedWriteBooleanArgument, this, OnSuccessCallback_12, OnFailureCallback_12, 10000));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_12(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_12() { NextTest(); }

    CHIP_ERROR TestReadAttributeThatNeedsTimedWriteStateChanged_13()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::TimedWriteBoolean::TypeInfo>(
            this, OnSuccessCallback_13, OnFailureCallback_13, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_13(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_13(bool timedWriteBoolean)
    {
        VerifyOrReturn(CheckValue("timedWriteBoolean", timedWriteBoolean, true));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeThatNeedsTimedWriteResetToDefault_14()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        bool timedWriteBooleanArgument;
        timedWriteBooleanArgument = false;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::TimedWriteBoolean::TypeInfo>(
            timedWriteBooleanArgument, this, OnSuccessCallback_14, OnFailureCallback_14, 10000));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_14(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_14() { NextTest(); }

    CHIP_ERROR TestReadAttributeThatDoesNotNeedTimedWriteInitialValue_15()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Boolean::TypeInfo>(
            this, OnSuccessCallback_15, OnFailureCallback_15, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_15(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_15(bool boolean)
    {
        VerifyOrReturn(CheckValue("boolean", boolean, false));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeThatDoesNotNeedTimedWriteWithATooShortTimeoutValue_16()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        bool booleanArgument;
        booleanArgument = true;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Boolean::TypeInfo>(
            booleanArgument, this, OnSuccessCallback_16, OnFailureCallback_16, 1));
        using namespace chip::System::Clock::Literals;
        BusyWaitFor(100_ms);
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_16(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_ACCESS));
        NextTest();
    }

    void OnSuccessResponse_16() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadAttributeThatDoesNotNeedTimedWriteUnchangedValue_17()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Boolean::TypeInfo>(
            this, OnSuccessCallback_17, OnFailureCallback_17, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_17(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_17(bool boolean)
    {
        VerifyOrReturn(CheckValue("boolean", boolean, false));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeThatDoesNotNeedTimedWriteWithALongTimeoutValue_18()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        bool booleanArgument;
        booleanArgument = true;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Boolean::TypeInfo>(
            booleanArgument, this, OnSuccessCallback_18, OnFailureCallback_18, 10000));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_18(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_18() { NextTest(); }

    CHIP_ERROR TestReadAttributeThatDoesNotNeedTimedWriteChangedValue_19()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Boolean::TypeInfo>(
            this, OnSuccessCallback_19, OnFailureCallback_19, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_19(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_19(bool boolean)
    {
        VerifyOrReturn(CheckValue("boolean", boolean, true));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeThatDoesNotNeedTimedWriteResetToDefault_20()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        bool booleanArgument;
        booleanArgument = false;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Boolean::TypeInfo>(
            booleanArgument, this, OnSuccessCallback_20, OnFailureCallback_20));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_20(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_20() { NextTest(); }
};

class TestConstraintsSuite : public TestCommand
{
public:
    TestConstraintsSuite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("TestConstraints", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~TestConstraintsSuite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestConstraints\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestConstraints\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Write attribute INT32U Value\n");
            err = TestWriteAttributeInt32uValue_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read attribute INT32U Value MinValue Constraints\n");
            err = TestReadAttributeInt32uValueMinValueConstraints_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read attribute INT32U Value MaxValue Constraints\n");
            err = TestReadAttributeInt32uValueMaxValueConstraints_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Read attribute INT32U Value NotValue Constraints\n");
            err = TestReadAttributeInt32uValueNotValueConstraints_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Write attribute INT32U Value Back to Default Value\n");
            err = TestWriteAttributeInt32uValueBackToDefaultValue_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Write attribute CHAR_STRING Value\n");
            err = TestWriteAttributeCharStringValue_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Read attribute CHAR_STRING Value MinLength Constraints\n");
            err = TestReadAttributeCharStringValueMinLengthConstraints_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Read attribute CHAR_STRING Value MaxLength Constraints\n");
            err = TestReadAttributeCharStringValueMaxLengthConstraints_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Read attribute CHAR_STRING Value StartsWith Constraints\n");
            err = TestReadAttributeCharStringValueStartsWithConstraints_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Read attribute CHAR_STRING Value EndsWith Constraints\n");
            err = TestReadAttributeCharStringValueEndsWithConstraints_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : Write attribute CHAR_STRING Value\n");
            err = TestWriteAttributeCharStringValue_11();
            break;
        case 12:
            ChipLogProgress(chipTool,
                            " ***** Test Step 12 : Read attribute CHAR_STRING Value isLowerCase/isUpperCase Constraints\n");
            err = TestReadAttributeCharStringValueIsLowerCaseIsUpperCaseConstraints_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : Write attribute CHAR_STRING Value\n");
            err = TestWriteAttributeCharStringValue_13();
            break;
        case 14:
            ChipLogProgress(chipTool,
                            " ***** Test Step 14 : Read attribute CHAR_STRING Value isLowerCase/isUpperCase Constraints\n");
            err = TestReadAttributeCharStringValueIsLowerCaseIsUpperCaseConstraints_14();
            break;
        case 15:
            ChipLogProgress(chipTool, " ***** Test Step 15 : Write attribute CHAR_STRING Value\n");
            err = TestWriteAttributeCharStringValue_15();
            break;
        case 16:
            ChipLogProgress(chipTool,
                            " ***** Test Step 16 : Read attribute CHAR_STRING Value isLowerCase/isUpperCase Constraints\n");
            err = TestReadAttributeCharStringValueIsLowerCaseIsUpperCaseConstraints_16();
            break;
        case 17:
            ChipLogProgress(chipTool, " ***** Test Step 17 : Write attribute CHAR_STRING Value\n");
            err = TestWriteAttributeCharStringValue_17();
            break;
        case 18:
            ChipLogProgress(chipTool, " ***** Test Step 18 : Read attribute CHAR_STRING Value isHexString Constraints\n");
            err = TestReadAttributeCharStringValueIsHexStringConstraints_18();
            break;
        case 19:
            ChipLogProgress(chipTool, " ***** Test Step 19 : Write attribute CHAR_STRING Value\n");
            err = TestWriteAttributeCharStringValue_19();
            break;
        case 20:
            ChipLogProgress(chipTool, " ***** Test Step 20 : Read attribute CHAR_STRING Value isHexString Constraints\n");
            err = TestReadAttributeCharStringValueIsHexStringConstraints_20();
            break;
        case 21:
            ChipLogProgress(chipTool, " ***** Test Step 21 : Write attribute CHAR_STRING Value Back to Default Value\n");
            err = TestWriteAttributeCharStringValueBackToDefaultValue_21();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 22;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_1(void * context, CHIP_ERROR error)
    {
        (static_cast<TestConstraintsSuite *>(context))->OnFailureResponse_1(error);
    }

    static void OnSuccessCallback_1(void * context) { (static_cast<TestConstraintsSuite *>(context))->OnSuccessResponse_1(); }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<TestConstraintsSuite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context, uint32_t int32u)
    {
        (static_cast<TestConstraintsSuite *>(context))->OnSuccessResponse_2(int32u);
    }

    static void OnFailureCallback_3(void * context, CHIP_ERROR error)
    {
        (static_cast<TestConstraintsSuite *>(context))->OnFailureResponse_3(error);
    }

    static void OnSuccessCallback_3(void * context, uint32_t int32u)
    {
        (static_cast<TestConstraintsSuite *>(context))->OnSuccessResponse_3(int32u);
    }

    static void OnFailureCallback_4(void * context, CHIP_ERROR error)
    {
        (static_cast<TestConstraintsSuite *>(context))->OnFailureResponse_4(error);
    }

    static void OnSuccessCallback_4(void * context, uint32_t int32u)
    {
        (static_cast<TestConstraintsSuite *>(context))->OnSuccessResponse_4(int32u);
    }

    static void OnFailureCallback_5(void * context, CHIP_ERROR error)
    {
        (static_cast<TestConstraintsSuite *>(context))->OnFailureResponse_5(error);
    }

    static void OnSuccessCallback_5(void * context) { (static_cast<TestConstraintsSuite *>(context))->OnSuccessResponse_5(); }

    static void OnFailureCallback_6(void * context, CHIP_ERROR error)
    {
        (static_cast<TestConstraintsSuite *>(context))->OnFailureResponse_6(error);
    }

    static void OnSuccessCallback_6(void * context) { (static_cast<TestConstraintsSuite *>(context))->OnSuccessResponse_6(); }

    static void OnFailureCallback_7(void * context, CHIP_ERROR error)
    {
        (static_cast<TestConstraintsSuite *>(context))->OnFailureResponse_7(error);
    }

    static void OnSuccessCallback_7(void * context, chip::CharSpan charString)
    {
        (static_cast<TestConstraintsSuite *>(context))->OnSuccessResponse_7(charString);
    }

    static void OnFailureCallback_8(void * context, CHIP_ERROR error)
    {
        (static_cast<TestConstraintsSuite *>(context))->OnFailureResponse_8(error);
    }

    static void OnSuccessCallback_8(void * context, chip::CharSpan charString)
    {
        (static_cast<TestConstraintsSuite *>(context))->OnSuccessResponse_8(charString);
    }

    static void OnFailureCallback_9(void * context, CHIP_ERROR error)
    {
        (static_cast<TestConstraintsSuite *>(context))->OnFailureResponse_9(error);
    }

    static void OnSuccessCallback_9(void * context, chip::CharSpan charString)
    {
        (static_cast<TestConstraintsSuite *>(context))->OnSuccessResponse_9(charString);
    }

    static void OnFailureCallback_10(void * context, CHIP_ERROR error)
    {
        (static_cast<TestConstraintsSuite *>(context))->OnFailureResponse_10(error);
    }

    static void OnSuccessCallback_10(void * context, chip::CharSpan charString)
    {
        (static_cast<TestConstraintsSuite *>(context))->OnSuccessResponse_10(charString);
    }

    static void OnFailureCallback_11(void * context, CHIP_ERROR error)
    {
        (static_cast<TestConstraintsSuite *>(context))->OnFailureResponse_11(error);
    }

    static void OnSuccessCallback_11(void * context) { (static_cast<TestConstraintsSuite *>(context))->OnSuccessResponse_11(); }

    static void OnFailureCallback_12(void * context, CHIP_ERROR error)
    {
        (static_cast<TestConstraintsSuite *>(context))->OnFailureResponse_12(error);
    }

    static void OnSuccessCallback_12(void * context, chip::CharSpan charString)
    {
        (static_cast<TestConstraintsSuite *>(context))->OnSuccessResponse_12(charString);
    }

    static void OnFailureCallback_13(void * context, CHIP_ERROR error)
    {
        (static_cast<TestConstraintsSuite *>(context))->OnFailureResponse_13(error);
    }

    static void OnSuccessCallback_13(void * context) { (static_cast<TestConstraintsSuite *>(context))->OnSuccessResponse_13(); }

    static void OnFailureCallback_14(void * context, CHIP_ERROR error)
    {
        (static_cast<TestConstraintsSuite *>(context))->OnFailureResponse_14(error);
    }

    static void OnSuccessCallback_14(void * context, chip::CharSpan charString)
    {
        (static_cast<TestConstraintsSuite *>(context))->OnSuccessResponse_14(charString);
    }

    static void OnFailureCallback_15(void * context, CHIP_ERROR error)
    {
        (static_cast<TestConstraintsSuite *>(context))->OnFailureResponse_15(error);
    }

    static void OnSuccessCallback_15(void * context) { (static_cast<TestConstraintsSuite *>(context))->OnSuccessResponse_15(); }

    static void OnFailureCallback_16(void * context, CHIP_ERROR error)
    {
        (static_cast<TestConstraintsSuite *>(context))->OnFailureResponse_16(error);
    }

    static void OnSuccessCallback_16(void * context, chip::CharSpan charString)
    {
        (static_cast<TestConstraintsSuite *>(context))->OnSuccessResponse_16(charString);
    }

    static void OnFailureCallback_17(void * context, CHIP_ERROR error)
    {
        (static_cast<TestConstraintsSuite *>(context))->OnFailureResponse_17(error);
    }

    static void OnSuccessCallback_17(void * context) { (static_cast<TestConstraintsSuite *>(context))->OnSuccessResponse_17(); }

    static void OnFailureCallback_18(void * context, CHIP_ERROR error)
    {
        (static_cast<TestConstraintsSuite *>(context))->OnFailureResponse_18(error);
    }

    static void OnSuccessCallback_18(void * context, chip::CharSpan charString)
    {
        (static_cast<TestConstraintsSuite *>(context))->OnSuccessResponse_18(charString);
    }

    static void OnFailureCallback_19(void * context, CHIP_ERROR error)
    {
        (static_cast<TestConstraintsSuite *>(context))->OnFailureResponse_19(error);
    }

    static void OnSuccessCallback_19(void * context) { (static_cast<TestConstraintsSuite *>(context))->OnSuccessResponse_19(); }

    static void OnFailureCallback_20(void * context, CHIP_ERROR error)
    {
        (static_cast<TestConstraintsSuite *>(context))->OnFailureResponse_20(error);
    }

    static void OnSuccessCallback_20(void * context, chip::CharSpan charString)
    {
        (static_cast<TestConstraintsSuite *>(context))->OnSuccessResponse_20(charString);
    }

    static void OnFailureCallback_21(void * context, CHIP_ERROR error)
    {
        (static_cast<TestConstraintsSuite *>(context))->OnFailureResponse_21(error);
    }

    static void OnSuccessCallback_21(void * context) { (static_cast<TestConstraintsSuite *>(context))->OnSuccessResponse_21(); }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestWriteAttributeInt32uValue_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint32_t int32uArgument;
        int32uArgument = 5UL;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int32u::TypeInfo>(
            int32uArgument, this, OnSuccessCallback_1, OnFailureCallback_1));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt32uValueMinValueConstraints_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int32u::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2(uint32_t int32u)
    {
        VerifyOrReturn(CheckConstraintMinValue<uint32_t>("int32u", int32u, 5UL));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeInt32uValueMaxValueConstraints_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int32u::TypeInfo>(
            this, OnSuccessCallback_3, OnFailureCallback_3, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3(uint32_t int32u)
    {
        VerifyOrReturn(CheckConstraintMaxValue<uint32_t>("int32u", int32u, 5UL));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeInt32uValueNotValueConstraints_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int32u::TypeInfo>(
            this, OnSuccessCallback_4, OnFailureCallback_4, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_4(uint32_t int32u)
    {
        VerifyOrReturn(CheckConstraintNotValue("int32u", int32u, 6UL));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt32uValueBackToDefaultValue_5()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint32_t int32uArgument;
        int32uArgument = 0UL;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int32u::TypeInfo>(
            int32uArgument, this, OnSuccessCallback_5, OnFailureCallback_5));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_5() { NextTest(); }

    CHIP_ERROR TestWriteAttributeCharStringValue_6()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::CharSpan charStringArgument;
        charStringArgument = chip::Span<const char>("** Test **garbage: not in length on purpose", 10);

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::CharString::TypeInfo>(
            charStringArgument, this, OnSuccessCallback_6, OnFailureCallback_6));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_6(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_6() { NextTest(); }

    CHIP_ERROR TestReadAttributeCharStringValueMinLengthConstraints_7()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::CharString::TypeInfo>(
            this, OnSuccessCallback_7, OnFailureCallback_7, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_7(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_7(chip::CharSpan charString)
    {
        VerifyOrReturn(CheckConstraintMinLength("charString", charString.size(), 5));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeCharStringValueMaxLengthConstraints_8()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::CharString::TypeInfo>(
            this, OnSuccessCallback_8, OnFailureCallback_8, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_8(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_8(chip::CharSpan charString)
    {
        VerifyOrReturn(CheckConstraintMaxLength("charString", charString.size(), 20));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeCharStringValueStartsWithConstraints_9()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::CharString::TypeInfo>(
            this, OnSuccessCallback_9, OnFailureCallback_9, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_9(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_9(chip::CharSpan charString)
    {
        VerifyOrReturn(CheckConstraintStartsWith("charString", charString, "**"));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeCharStringValueEndsWithConstraints_10()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::CharString::TypeInfo>(
            this, OnSuccessCallback_10, OnFailureCallback_10, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_10(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_10(chip::CharSpan charString)
    {
        VerifyOrReturn(CheckConstraintEndsWith("charString", charString, "**"));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeCharStringValue_11()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::CharSpan charStringArgument;
        charStringArgument = chip::Span<const char>("lowercasegarbage: not in length on purpose", 9);

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::CharString::TypeInfo>(
            charStringArgument, this, OnSuccessCallback_11, OnFailureCallback_11));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_11(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_11() { NextTest(); }

    CHIP_ERROR TestReadAttributeCharStringValueIsLowerCaseIsUpperCaseConstraints_12()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::CharString::TypeInfo>(
            this, OnSuccessCallback_12, OnFailureCallback_12, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_12(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_12(chip::CharSpan charString)
    {
        VerifyOrReturn(CheckConstraintIsUpperCase("charString", charString, false));
        VerifyOrReturn(CheckConstraintIsLowerCase("charString", charString, true));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeCharStringValue_13()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::CharSpan charStringArgument;
        charStringArgument = chip::Span<const char>("UPPERCASEgarbage: not in length on purpose", 9);

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::CharString::TypeInfo>(
            charStringArgument, this, OnSuccessCallback_13, OnFailureCallback_13));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_13(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_13() { NextTest(); }

    CHIP_ERROR TestReadAttributeCharStringValueIsLowerCaseIsUpperCaseConstraints_14()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::CharString::TypeInfo>(
            this, OnSuccessCallback_14, OnFailureCallback_14, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_14(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_14(chip::CharSpan charString)
    {
        VerifyOrReturn(CheckConstraintIsUpperCase("charString", charString, true));
        VerifyOrReturn(CheckConstraintIsLowerCase("charString", charString, false));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeCharStringValue_15()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::CharSpan charStringArgument;
        charStringArgument = chip::Span<const char>("lowUPPERgarbage: not in length on purpose", 8);

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::CharString::TypeInfo>(
            charStringArgument, this, OnSuccessCallback_15, OnFailureCallback_15));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_15(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_15() { NextTest(); }

    CHIP_ERROR TestReadAttributeCharStringValueIsLowerCaseIsUpperCaseConstraints_16()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::CharString::TypeInfo>(
            this, OnSuccessCallback_16, OnFailureCallback_16, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_16(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_16(chip::CharSpan charString)
    {
        VerifyOrReturn(CheckConstraintIsUpperCase("charString", charString, false));
        VerifyOrReturn(CheckConstraintIsLowerCase("charString", charString, false));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeCharStringValue_17()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::CharSpan charStringArgument;
        charStringArgument = chip::Span<const char>("ABCDEF012Vgarbage: not in length on purpose", 10);

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::CharString::TypeInfo>(
            charStringArgument, this, OnSuccessCallback_17, OnFailureCallback_17));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_17(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_17() { NextTest(); }

    CHIP_ERROR TestReadAttributeCharStringValueIsHexStringConstraints_18()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::CharString::TypeInfo>(
            this, OnSuccessCallback_18, OnFailureCallback_18, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_18(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_18(chip::CharSpan charString)
    {
        VerifyOrReturn(CheckConstraintIsHexString("charString", charString, false));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeCharStringValue_19()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::CharSpan charStringArgument;
        charStringArgument = chip::Span<const char>("ABCDEF0123garbage: not in length on purpose", 10);

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::CharString::TypeInfo>(
            charStringArgument, this, OnSuccessCallback_19, OnFailureCallback_19));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_19(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_19() { NextTest(); }

    CHIP_ERROR TestReadAttributeCharStringValueIsHexStringConstraints_20()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::CharString::TypeInfo>(
            this, OnSuccessCallback_20, OnFailureCallback_20, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_20(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_20(chip::CharSpan charString)
    {
        VerifyOrReturn(CheckConstraintIsHexString("charString", charString, true));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeCharStringValueBackToDefaultValue_21()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::CharSpan charStringArgument;
        charStringArgument = chip::Span<const char>("garbage: not in length on purpose", 0);

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::CharString::TypeInfo>(
            charStringArgument, this, OnSuccessCallback_21, OnFailureCallback_21));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_21(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_21() { NextTest(); }
};

class TestDelayCommandsSuite : public TestCommand
{
public:
    TestDelayCommandsSuite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("TestDelayCommands", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~TestDelayCommandsSuite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestDelayCommands\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestDelayCommands\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Wait 100ms\n");
            err = TestWait100ms_1();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 2;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestWait100ms_1()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForMs(100);
    }
};

class TestDiscoverySuite : public TestCommand
{
public:
    TestDiscoverySuite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("TestDiscovery", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("discriminator", 0, UINT16_MAX, &mDiscriminator);
        AddArgument("vendorId", 0, UINT16_MAX, &mVendorId);
        AddArgument("productId", 0, UINT16_MAX, &mProductId);
        AddArgument("deviceType", 0, UINT16_MAX, &mDeviceType);
    }

    ~TestDiscoverySuite()
    {
        if (deviceInstanceNameBeforeRebootBuffer != nullptr)
        {
            chip::Platform::MemoryFree(deviceInstanceNameBeforeRebootBuffer);
            deviceInstanceNameBeforeRebootBuffer = nullptr;
        }
    }

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestDiscovery\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestDiscovery\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Reboot target device\n");
            err = TestRebootTargetDevice_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Open Commissioning Window\n");
            err = TestOpenCommissioningWindow_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Check Instance Name\n");
            err = TestCheckInstanceName_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Check Long Discriminator _L\n");
            err = TestCheckLongDiscriminatorL_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Check Short Discriminator (_S)\n");
            err = TestCheckShortDiscriminatorS_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Check Commissioning Mode (_CM)\n");
            err = TestCheckCommissioningModeCm_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Check Vendor ID (_V)\n");
            if (ShouldSkip("VENDOR_SUBTYPE"))
            {
                NextTest();
                return;
            }
            err = TestCheckVendorIdV_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : TXT key for discriminator (D)\n");
            err = TestTxtKeyForDiscriminatorD_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : TXT key for Vendor ID and Product ID (VP)\n");
            if (ShouldSkip("VP_KEY"))
            {
                NextTest();
                return;
            }
            err = TestTxtKeyForVendorIdAndProductIdVp_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : TXT key for Vendor ID and Product ID (VP)\n");
            if (ShouldSkip("VP_KEY"))
            {
                NextTest();
                return;
            }
            err = TestTxtKeyForVendorIdAndProductIdVp_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : Optional TXT key for MRP Retry Interval Idle (CRI)\n");
            if (ShouldSkip("CRI_COMM_DISCOVERY_KEY"))
            {
                NextTest();
                return;
            }
            err = TestOptionalTxtKeyForMrpRetryIntervalIdleCri_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : Optional TXT key for MRP Retry Interval Active (CRA)\n");
            if (ShouldSkip("CRA_COMM_DISCOVERY_KEY"))
            {
                NextTest();
                return;
            }
            err = TestOptionalTxtKeyForMrpRetryIntervalActiveCra_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : TXT key for commissioning mode (CM)\n");
            err = TestTxtKeyForCommissioningModeCm_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : Optional TXT key for device name (DN)\n");
            if (ShouldSkip("DN_KEY"))
            {
                NextTest();
                return;
            }
            err = TestOptionalTxtKeyForDeviceNameDn_14();
            break;
        case 15:
            ChipLogProgress(chipTool, " ***** Test Step 15 : Optional TXT key for rotating device identifier (RI)\n");
            if (ShouldSkip("RI_KEY"))
            {
                NextTest();
                return;
            }
            err = TestOptionalTxtKeyForRotatingDeviceIdentifierRi_15();
            break;
        case 16:
            ChipLogProgress(chipTool, " ***** Test Step 16 : Optional TXT key for pairing hint (PH)\n");
            if (ShouldSkip("PH_KEY"))
            {
                NextTest();
                return;
            }
            err = TestOptionalTxtKeyForPairingHintPh_16();
            break;
        case 17:
            ChipLogProgress(chipTool, " ***** Test Step 17 : Optional TXT key for pairing instructions (PI)\n");
            if (ShouldSkip("PI_KEY"))
            {
                NextTest();
                return;
            }
            err = TestOptionalTxtKeyForPairingInstructionsPi_17();
            break;
        case 18:
            ChipLogProgress(chipTool, " ***** Test Step 18 : Check IPs\n");
            err = TestCheckIPs_18();
            break;
        case 19:
            ChipLogProgress(chipTool, " ***** Test Step 19 : Reboot target device\n");
            err = TestRebootTargetDevice_19();
            break;
        case 20:
            ChipLogProgress(chipTool, " ***** Test Step 20 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_20();
            break;
        case 21:
            ChipLogProgress(chipTool, " ***** Test Step 21 : Open Commissioning Window\n");
            err = TestOpenCommissioningWindow_21();
            break;
        case 22:
            ChipLogProgress(chipTool, " ***** Test Step 22 : Check Instance Name\n");
            err = TestCheckInstanceName_22();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 23;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mDiscriminator;
    chip::Optional<uint16_t> mVendorId;
    chip::Optional<uint16_t> mProductId;
    chip::Optional<uint16_t> mDeviceType;

    char * deviceInstanceNameBeforeRebootBuffer = nullptr;
    chip::CharSpan deviceInstanceNameBeforeReboot;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;
        if ((mTestIndex - 1) == 3)
        {
            isExpectedDnssdResult = true;

            VerifyOrReturn(CheckConstraintIsUpperCase("value.instanceName", value.instanceName, true));
            VerifyOrReturn(CheckConstraintIsHexString("value.instanceName", value.instanceName, true));
            VerifyOrReturn(CheckConstraintMinLength("value.instanceName", value.instanceName.size(), 16));
            VerifyOrReturn(CheckConstraintMaxLength("value.instanceName", value.instanceName.size(), 16));
            if (deviceInstanceNameBeforeRebootBuffer != nullptr)
            {
                chip::Platform::MemoryFree(deviceInstanceNameBeforeRebootBuffer);
            }
            deviceInstanceNameBeforeRebootBuffer = static_cast<char *>(chip::Platform::MemoryAlloc(value.instanceName.size()));
            memcpy(deviceInstanceNameBeforeRebootBuffer, value.instanceName.data(), value.instanceName.size());
            deviceInstanceNameBeforeReboot = chip::CharSpan(deviceInstanceNameBeforeRebootBuffer, value.instanceName.size());
        }
        if ((mTestIndex - 1) == 4)
        {
            isExpectedDnssdResult = true;
        }
        if ((mTestIndex - 1) == 5)
        {
            isExpectedDnssdResult = true;
        }
        if ((mTestIndex - 1) == 6)
        {
            isExpectedDnssdResult = true;
        }
        if ((mTestIndex - 1) == 7)
        {
            isExpectedDnssdResult = true;
        }
        if ((mTestIndex - 1) == 8)
        {
            isExpectedDnssdResult = true;

            VerifyOrReturn(CheckValue("longDiscriminator", value.longDiscriminator,
                                      mDiscriminator.HasValue() ? mDiscriminator.Value() : GetUniqueDiscriminator()));
            VerifyOrReturn(CheckConstraintMinValue<uint16_t>("value.longDiscriminator", value.longDiscriminator, 0U));
            VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("value.longDiscriminator", value.longDiscriminator, 4096U));
        }
        if ((mTestIndex - 1) == 9)
        {
            isExpectedDnssdResult = true;

            VerifyOrReturn(CheckValue("vendorId", value.vendorId, mVendorId.HasValue() ? mVendorId.Value() : 65521U));
        }
        if ((mTestIndex - 1) == 10)
        {
            isExpectedDnssdResult = true;

            VerifyOrReturn(CheckValue("productId", value.productId, mProductId.HasValue() ? mProductId.Value() : 32769U));
        }
        if ((mTestIndex - 1) == 11)
        {
            isExpectedDnssdResult = true;

            VerifyOrReturn(CheckValuePresent("value.mrpRetryIntervalIdle", value.mrpRetryIntervalIdle));
            VerifyOrReturn(CheckConstraintMaxValue<uint32_t>("value.mrpRetryIntervalIdle.Value()",
                                                             value.mrpRetryIntervalIdle.Value(), 3600000UL));
        }
        if ((mTestIndex - 1) == 12)
        {
            isExpectedDnssdResult = true;

            VerifyOrReturn(CheckValuePresent("value.mrpRetryIntervalActive", value.mrpRetryIntervalActive));
            VerifyOrReturn(CheckConstraintMaxValue<uint32_t>("value.mrpRetryIntervalActive.Value()",
                                                             value.mrpRetryIntervalActive.Value(), 3600000UL));
        }
        if ((mTestIndex - 1) == 13)
        {
            isExpectedDnssdResult = true;

            VerifyOrReturn(CheckValue("commissioningMode", value.commissioningMode, 1));
        }
        if ((mTestIndex - 1) == 14)
        {
            isExpectedDnssdResult = true;

            VerifyOrReturn(CheckConstraintMaxLength("value.deviceName", value.deviceName.size(), 32));
        }
        if ((mTestIndex - 1) == 15)
        {
            isExpectedDnssdResult = true;

            VerifyOrReturn(CheckConstraintMaxValue<uint64_t>("value.rotatingIdLen", value.rotatingIdLen, 100ULL));
        }
        if ((mTestIndex - 1) == 16)
        {
            isExpectedDnssdResult = true;
        }
        if ((mTestIndex - 1) == 17)
        {
            isExpectedDnssdResult = true;

            VerifyOrReturn(CheckConstraintMaxLength("value.pairingInstruction", value.pairingInstruction.size(), 128));
        }
        if ((mTestIndex - 1) == 18)
        {
            isExpectedDnssdResult = true;

            VerifyOrReturn(CheckConstraintMinValue<uint8_t>("value.numIPs", value.numIPs, 1));
        }
        if ((mTestIndex - 1) == 22)
        {
            isExpectedDnssdResult = true;

            VerifyOrReturn(CheckConstraintIsUpperCase("value.instanceName", value.instanceName, true));
            VerifyOrReturn(CheckConstraintIsHexString("value.instanceName", value.instanceName, true));
            VerifyOrReturn(CheckConstraintMinLength("value.instanceName", value.instanceName.size(), 16));
            VerifyOrReturn(CheckConstraintMaxLength("value.instanceName", value.instanceName.size(), 16));
            VerifyOrReturn(CheckConstraintNotValue("value.instanceName", value.instanceName, deviceInstanceNameBeforeReboot));
        }

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestRebootTargetDevice_0()
    {
        SetIdentity(kIdentityAlpha);
        return Reboot(mDiscriminator.HasValue() ? mDiscriminator.Value() : GetUniqueDiscriminator());
    }

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_1()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestOpenCommissioningWindow_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        using RequestType = chip::app::Clusters::AdministratorCommissioning::Commands::OpenBasicCommissioningWindow::Type;

        RequestType request;
        request.commissioningTimeout = 120U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestDiscoverySuite *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestDiscoverySuite *>(context))->OnFailureResponse_2(error);
        };

        ReturnErrorOnFailure(
            chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request, 10000));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestCheckInstanceName_3()
    {
        SetIdentity(kIdentityAlpha);
        return FindCommissionable();
    }

    CHIP_ERROR TestCheckLongDiscriminatorL_4()
    {
        SetIdentity(kIdentityAlpha);
        return FindCommissionableByLongDiscriminator(mDiscriminator.HasValue() ? mDiscriminator.Value() : GetUniqueDiscriminator());
    }

    CHIP_ERROR TestCheckShortDiscriminatorS_5()
    {
        SetIdentity(kIdentityAlpha);
        return FindCommissionableByShortDiscriminator(mDiscriminator.HasValue() ? mDiscriminator.Value()
                                                                                : GetUniqueDiscriminator());
    }

    CHIP_ERROR TestCheckCommissioningModeCm_6()
    {
        SetIdentity(kIdentityAlpha);
        return FindCommissionableByCommissioningMode();
    }

    CHIP_ERROR TestCheckVendorIdV_7()
    {
        SetIdentity(kIdentityAlpha);
        return FindCommissionableByVendorId(mVendorId.HasValue() ? mVendorId.Value() : 65521U);
    }

    CHIP_ERROR TestTxtKeyForDiscriminatorD_8()
    {
        SetIdentity(kIdentityAlpha);
        return FindCommissionable();
    }

    CHIP_ERROR TestTxtKeyForVendorIdAndProductIdVp_9()
    {
        SetIdentity(kIdentityAlpha);
        return FindCommissionable();
    }

    CHIP_ERROR TestTxtKeyForVendorIdAndProductIdVp_10()
    {
        SetIdentity(kIdentityAlpha);
        return FindCommissionable();
    }

    CHIP_ERROR TestOptionalTxtKeyForMrpRetryIntervalIdleCri_11()
    {
        SetIdentity(kIdentityAlpha);
        return FindCommissionable();
    }

    CHIP_ERROR TestOptionalTxtKeyForMrpRetryIntervalActiveCra_12()
    {
        SetIdentity(kIdentityAlpha);
        return FindCommissionable();
    }

    CHIP_ERROR TestTxtKeyForCommissioningModeCm_13()
    {
        SetIdentity(kIdentityAlpha);
        return FindCommissionable();
    }

    CHIP_ERROR TestOptionalTxtKeyForDeviceNameDn_14()
    {
        SetIdentity(kIdentityAlpha);
        return FindCommissionable();
    }

    CHIP_ERROR TestOptionalTxtKeyForRotatingDeviceIdentifierRi_15()
    {
        SetIdentity(kIdentityAlpha);
        return FindCommissionable();
    }

    CHIP_ERROR TestOptionalTxtKeyForPairingHintPh_16()
    {
        SetIdentity(kIdentityAlpha);
        return FindCommissionable();
    }

    CHIP_ERROR TestOptionalTxtKeyForPairingInstructionsPi_17()
    {
        SetIdentity(kIdentityAlpha);
        return FindCommissionable();
    }

    CHIP_ERROR TestCheckIPs_18()
    {
        SetIdentity(kIdentityAlpha);
        return FindCommissionable();
    }

    CHIP_ERROR TestRebootTargetDevice_19()
    {
        SetIdentity(kIdentityAlpha);
        return Reboot(mDiscriminator.HasValue() ? mDiscriminator.Value() : GetUniqueDiscriminator());
    }

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_20()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestOpenCommissioningWindow_21()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        using RequestType = chip::app::Clusters::AdministratorCommissioning::Commands::OpenBasicCommissioningWindow::Type;

        RequestType request;
        request.commissioningTimeout = 120U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestDiscoverySuite *>(context))->OnSuccessResponse_21();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestDiscoverySuite *>(context))->OnFailureResponse_21(error);
        };

        ReturnErrorOnFailure(
            chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request, 10000));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_21(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_21() { NextTest(); }

    CHIP_ERROR TestCheckInstanceName_22()
    {
        SetIdentity(kIdentityAlpha);
        return FindCommissionable();
    }
};

class TestLogCommandsSuite : public TestCommand
{
public:
    TestLogCommandsSuite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("TestLogCommands", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~TestLogCommandsSuite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestLogCommands\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestLogCommands\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Log a simple message\n");
            err = TestLogASimpleMessage_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Do a simple user prompt message\n");
            err = TestDoASimpleUserPromptMessage_2();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 3;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestLogASimpleMessage_1()
    {
        SetIdentity(kIdentityAlpha);
        return Log("This is a simple message");
    }

    CHIP_ERROR TestDoASimpleUserPromptMessage_2()
    {
        SetIdentity(kIdentityAlpha);
        return UserPrompt("This is a simple message");
    }
};

class TestSaveAsSuite : public TestCommand
{
public:
    TestSaveAsSuite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("TestSaveAs", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~TestSaveAsSuite()
    {
        if (readAttributeCharStringDefaultValueBuffer != nullptr)
        {
            chip::Platform::MemoryFree(readAttributeCharStringDefaultValueBuffer);
            readAttributeCharStringDefaultValueBuffer = nullptr;
        }
        if (readAttributeCharStringNotDefaultValueBuffer != nullptr)
        {
            chip::Platform::MemoryFree(readAttributeCharStringNotDefaultValueBuffer);
            readAttributeCharStringNotDefaultValueBuffer = nullptr;
        }
        if (readAttributeOctetStringDefaultValueBuffer != nullptr)
        {
            chip::Platform::MemoryFree(readAttributeOctetStringDefaultValueBuffer);
            readAttributeOctetStringDefaultValueBuffer = nullptr;
        }
        if (readAttributeOctetStringNotDefaultValueBuffer != nullptr)
        {
            chip::Platform::MemoryFree(readAttributeOctetStringNotDefaultValueBuffer);
            readAttributeOctetStringNotDefaultValueBuffer = nullptr;
        }
    }

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestSaveAs\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestSaveAs\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Send Test Add Arguments Command\n");
            err = TestSendTestAddArgumentsCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Send Test Add Arguments Command\n");
            err = TestSendTestAddArgumentsCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Send Test Add Arguments Command\n");
            err = TestSendTestAddArgumentsCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Read attribute BOOLEAN Default Value\n");
            err = TestReadAttributeBooleanDefaultValue_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Write attribute BOOLEAN Not Default Value\n");
            err = TestWriteAttributeBooleanNotDefaultValue_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Read attribute BOOLEAN Not Default Value\n");
            err = TestReadAttributeBooleanNotDefaultValue_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Write attribute BOOLEAN DefaultValue\n");
            err = TestWriteAttributeBooleanDefaultValue_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Read attribute BOOLEAN False\n");
            err = TestReadAttributeBooleanFalse_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Read attribute BITMAP8 Default Value\n");
            err = TestReadAttributeBitmap8DefaultValue_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Write attribute BITMAP8 Not Default Value\n");
            err = TestWriteAttributeBitmap8NotDefaultValue_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : Read attribute BITMAP8 Not Default Value\n");
            err = TestReadAttributeBitmap8NotDefaultValue_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : Write attribute BITMAP8 Default Value\n");
            err = TestWriteAttributeBitmap8DefaultValue_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : Read attribute BITMAP8 Default Value\n");
            err = TestReadAttributeBitmap8DefaultValue_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : Read attribute BITMAP16 Default Value\n");
            err = TestReadAttributeBitmap16DefaultValue_14();
            break;
        case 15:
            ChipLogProgress(chipTool, " ***** Test Step 15 : Write attribute BITMAP16 Not Default Value\n");
            err = TestWriteAttributeBitmap16NotDefaultValue_15();
            break;
        case 16:
            ChipLogProgress(chipTool, " ***** Test Step 16 : Read attribute BITMAP16 Not Default Value\n");
            err = TestReadAttributeBitmap16NotDefaultValue_16();
            break;
        case 17:
            ChipLogProgress(chipTool, " ***** Test Step 17 : Write attribute BITMAP16 Default Value\n");
            err = TestWriteAttributeBitmap16DefaultValue_17();
            break;
        case 18:
            ChipLogProgress(chipTool, " ***** Test Step 18 : Read attribute BITMAP16 Default Value\n");
            err = TestReadAttributeBitmap16DefaultValue_18();
            break;
        case 19:
            ChipLogProgress(chipTool, " ***** Test Step 19 : Read attribute BITMAP32 Default Value\n");
            err = TestReadAttributeBitmap32DefaultValue_19();
            break;
        case 20:
            ChipLogProgress(chipTool, " ***** Test Step 20 : Write attribute BITMAP32 Not Default Value\n");
            err = TestWriteAttributeBitmap32NotDefaultValue_20();
            break;
        case 21:
            ChipLogProgress(chipTool, " ***** Test Step 21 : Read attribute BITMAP32 Not Default Value\n");
            err = TestReadAttributeBitmap32NotDefaultValue_21();
            break;
        case 22:
            ChipLogProgress(chipTool, " ***** Test Step 22 : Write attribute BITMAP32 Default Value\n");
            err = TestWriteAttributeBitmap32DefaultValue_22();
            break;
        case 23:
            ChipLogProgress(chipTool, " ***** Test Step 23 : Read attribute BITMAP32 Default Value\n");
            err = TestReadAttributeBitmap32DefaultValue_23();
            break;
        case 24:
            ChipLogProgress(chipTool, " ***** Test Step 24 : Read attribute BITMAP64 Default Value\n");
            err = TestReadAttributeBitmap64DefaultValue_24();
            break;
        case 25:
            ChipLogProgress(chipTool, " ***** Test Step 25 : Write attribute BITMAP64 Not Default Value\n");
            err = TestWriteAttributeBitmap64NotDefaultValue_25();
            break;
        case 26:
            ChipLogProgress(chipTool, " ***** Test Step 26 : Read attribute BITMAP64 Default Value\n");
            err = TestReadAttributeBitmap64DefaultValue_26();
            break;
        case 27:
            ChipLogProgress(chipTool, " ***** Test Step 27 : Write attribute BITMAP64 Default Value\n");
            err = TestWriteAttributeBitmap64DefaultValue_27();
            break;
        case 28:
            ChipLogProgress(chipTool, " ***** Test Step 28 : Read attribute BITMAP64 Default Value\n");
            err = TestReadAttributeBitmap64DefaultValue_28();
            break;
        case 29:
            ChipLogProgress(chipTool, " ***** Test Step 29 : Read attribute INT8U Default Value\n");
            err = TestReadAttributeInt8uDefaultValue_29();
            break;
        case 30:
            ChipLogProgress(chipTool, " ***** Test Step 30 : Write attribute INT8U Not Default Value\n");
            err = TestWriteAttributeInt8uNotDefaultValue_30();
            break;
        case 31:
            ChipLogProgress(chipTool, " ***** Test Step 31 : Read attribute INT8U Not Default Value\n");
            err = TestReadAttributeInt8uNotDefaultValue_31();
            break;
        case 32:
            ChipLogProgress(chipTool, " ***** Test Step 32 : Write attribute INT8U Default Value\n");
            err = TestWriteAttributeInt8uDefaultValue_32();
            break;
        case 33:
            ChipLogProgress(chipTool, " ***** Test Step 33 : Read attribute INT8U Default Value\n");
            err = TestReadAttributeInt8uDefaultValue_33();
            break;
        case 34:
            ChipLogProgress(chipTool, " ***** Test Step 34 : Read attribute INT16U Default Value\n");
            err = TestReadAttributeInt16uDefaultValue_34();
            break;
        case 35:
            ChipLogProgress(chipTool, " ***** Test Step 35 : Write attribute INT16U Not Default Value\n");
            err = TestWriteAttributeInt16uNotDefaultValue_35();
            break;
        case 36:
            ChipLogProgress(chipTool, " ***** Test Step 36 : Read attribute INT16U Not Default Value\n");
            err = TestReadAttributeInt16uNotDefaultValue_36();
            break;
        case 37:
            ChipLogProgress(chipTool, " ***** Test Step 37 : Write attribute INT16U Default Value\n");
            err = TestWriteAttributeInt16uDefaultValue_37();
            break;
        case 38:
            ChipLogProgress(chipTool, " ***** Test Step 38 : Read attribute INT16U Default Value\n");
            err = TestReadAttributeInt16uDefaultValue_38();
            break;
        case 39:
            ChipLogProgress(chipTool, " ***** Test Step 39 : Read attribute INT32U Default Value\n");
            err = TestReadAttributeInt32uDefaultValue_39();
            break;
        case 40:
            ChipLogProgress(chipTool, " ***** Test Step 40 : Write attribute INT32U Not Default Value\n");
            err = TestWriteAttributeInt32uNotDefaultValue_40();
            break;
        case 41:
            ChipLogProgress(chipTool, " ***** Test Step 41 : Read attribute INT32U Not Default Value\n");
            err = TestReadAttributeInt32uNotDefaultValue_41();
            break;
        case 42:
            ChipLogProgress(chipTool, " ***** Test Step 42 : Write attribute INT32U Default Value\n");
            err = TestWriteAttributeInt32uDefaultValue_42();
            break;
        case 43:
            ChipLogProgress(chipTool, " ***** Test Step 43 : Read attribute INT32U Default Value\n");
            err = TestReadAttributeInt32uDefaultValue_43();
            break;
        case 44:
            ChipLogProgress(chipTool, " ***** Test Step 44 : Read attribute INT64U Default Value\n");
            err = TestReadAttributeInt64uDefaultValue_44();
            break;
        case 45:
            ChipLogProgress(chipTool, " ***** Test Step 45 : Write attribute INT64U Not Default Value\n");
            err = TestWriteAttributeInt64uNotDefaultValue_45();
            break;
        case 46:
            ChipLogProgress(chipTool, " ***** Test Step 46 : Read attribute INT64U Not Default Value\n");
            err = TestReadAttributeInt64uNotDefaultValue_46();
            break;
        case 47:
            ChipLogProgress(chipTool, " ***** Test Step 47 : Write attribute INT64U Default Value\n");
            err = TestWriteAttributeInt64uDefaultValue_47();
            break;
        case 48:
            ChipLogProgress(chipTool, " ***** Test Step 48 : Read attribute INT64U Default Value\n");
            err = TestReadAttributeInt64uDefaultValue_48();
            break;
        case 49:
            ChipLogProgress(chipTool, " ***** Test Step 49 : Read attribute INT8S Default Value\n");
            err = TestReadAttributeInt8sDefaultValue_49();
            break;
        case 50:
            ChipLogProgress(chipTool, " ***** Test Step 50 : Write attribute INT8S Not Default Value\n");
            err = TestWriteAttributeInt8sNotDefaultValue_50();
            break;
        case 51:
            ChipLogProgress(chipTool, " ***** Test Step 51 : Read attribute INT8S Not Default Value\n");
            err = TestReadAttributeInt8sNotDefaultValue_51();
            break;
        case 52:
            ChipLogProgress(chipTool, " ***** Test Step 52 : Write attribute INT8S Default Value\n");
            err = TestWriteAttributeInt8sDefaultValue_52();
            break;
        case 53:
            ChipLogProgress(chipTool, " ***** Test Step 53 : Read attribute INT8S Default Value\n");
            err = TestReadAttributeInt8sDefaultValue_53();
            break;
        case 54:
            ChipLogProgress(chipTool, " ***** Test Step 54 : Read attribute INT16S Default Value\n");
            err = TestReadAttributeInt16sDefaultValue_54();
            break;
        case 55:
            ChipLogProgress(chipTool, " ***** Test Step 55 : Write attribute INT16S Not Default Value\n");
            err = TestWriteAttributeInt16sNotDefaultValue_55();
            break;
        case 56:
            ChipLogProgress(chipTool, " ***** Test Step 56 : Read attribute INT16S Not Default Value\n");
            err = TestReadAttributeInt16sNotDefaultValue_56();
            break;
        case 57:
            ChipLogProgress(chipTool, " ***** Test Step 57 : Write attribute INT16S Default Value\n");
            err = TestWriteAttributeInt16sDefaultValue_57();
            break;
        case 58:
            ChipLogProgress(chipTool, " ***** Test Step 58 : Read attribute INT16S Default Value\n");
            err = TestReadAttributeInt16sDefaultValue_58();
            break;
        case 59:
            ChipLogProgress(chipTool, " ***** Test Step 59 : Read attribute INT32S Default Value\n");
            err = TestReadAttributeInt32sDefaultValue_59();
            break;
        case 60:
            ChipLogProgress(chipTool, " ***** Test Step 60 : Write attribute INT32S Not Default Value\n");
            err = TestWriteAttributeInt32sNotDefaultValue_60();
            break;
        case 61:
            ChipLogProgress(chipTool, " ***** Test Step 61 : Read attribute INT32S Not Default Value\n");
            err = TestReadAttributeInt32sNotDefaultValue_61();
            break;
        case 62:
            ChipLogProgress(chipTool, " ***** Test Step 62 : Write attribute INT32S Default Value\n");
            err = TestWriteAttributeInt32sDefaultValue_62();
            break;
        case 63:
            ChipLogProgress(chipTool, " ***** Test Step 63 : Read attribute INT32S Default Value\n");
            err = TestReadAttributeInt32sDefaultValue_63();
            break;
        case 64:
            ChipLogProgress(chipTool, " ***** Test Step 64 : Read attribute INT64S Default Value\n");
            err = TestReadAttributeInt64sDefaultValue_64();
            break;
        case 65:
            ChipLogProgress(chipTool, " ***** Test Step 65 : Write attribute INTS Not Default Value\n");
            err = TestWriteAttributeIntsNotDefaultValue_65();
            break;
        case 66:
            ChipLogProgress(chipTool, " ***** Test Step 66 : Read attribute INT64S Not Default Value\n");
            err = TestReadAttributeInt64sNotDefaultValue_66();
            break;
        case 67:
            ChipLogProgress(chipTool, " ***** Test Step 67 : Write attribute INT64S Default Value\n");
            err = TestWriteAttributeInt64sDefaultValue_67();
            break;
        case 68:
            ChipLogProgress(chipTool, " ***** Test Step 68 : Read attribute INT64S Default Value\n");
            err = TestReadAttributeInt64sDefaultValue_68();
            break;
        case 69:
            ChipLogProgress(chipTool, " ***** Test Step 69 : Read attribute ENUM8 Default Value\n");
            err = TestReadAttributeEnum8DefaultValue_69();
            break;
        case 70:
            ChipLogProgress(chipTool, " ***** Test Step 70 : Write attribute ENUM8 Not Default Value\n");
            err = TestWriteAttributeEnum8NotDefaultValue_70();
            break;
        case 71:
            ChipLogProgress(chipTool, " ***** Test Step 71 : Read attribute ENUM8 Not Default Value\n");
            err = TestReadAttributeEnum8NotDefaultValue_71();
            break;
        case 72:
            ChipLogProgress(chipTool, " ***** Test Step 72 : Write attribute ENUM8 Default Value\n");
            err = TestWriteAttributeEnum8DefaultValue_72();
            break;
        case 73:
            ChipLogProgress(chipTool, " ***** Test Step 73 : Read attribute ENUM8 Default Value\n");
            err = TestReadAttributeEnum8DefaultValue_73();
            break;
        case 74:
            ChipLogProgress(chipTool, " ***** Test Step 74 : Read attribute ENUM16 Default Value\n");
            err = TestReadAttributeEnum16DefaultValue_74();
            break;
        case 75:
            ChipLogProgress(chipTool, " ***** Test Step 75 : Write attribute ENUM16 Not Default Value\n");
            err = TestWriteAttributeEnum16NotDefaultValue_75();
            break;
        case 76:
            ChipLogProgress(chipTool, " ***** Test Step 76 : Read attribute ENUM16 Not Default Value\n");
            err = TestReadAttributeEnum16NotDefaultValue_76();
            break;
        case 77:
            ChipLogProgress(chipTool, " ***** Test Step 77 : Write attribute ENUM16 Default Value\n");
            err = TestWriteAttributeEnum16DefaultValue_77();
            break;
        case 78:
            ChipLogProgress(chipTool, " ***** Test Step 78 : Read attribute ENUM16 Default Value\n");
            err = TestReadAttributeEnum16DefaultValue_78();
            break;
        case 79:
            ChipLogProgress(chipTool, " ***** Test Step 79 : Read attribute EPOCH_US Default Value\n");
            err = TestReadAttributeEpochUsDefaultValue_79();
            break;
        case 80:
            ChipLogProgress(chipTool, " ***** Test Step 80 : Write attribute EPOCH_US Not Default Value\n");
            err = TestWriteAttributeEpochUsNotDefaultValue_80();
            break;
        case 81:
            ChipLogProgress(chipTool, " ***** Test Step 81 : Read attribute EPOCH_US Not Default Value\n");
            err = TestReadAttributeEpochUsNotDefaultValue_81();
            break;
        case 82:
            ChipLogProgress(chipTool, " ***** Test Step 82 : Write attribute EPOCH_US Default Value\n");
            err = TestWriteAttributeEpochUsDefaultValue_82();
            break;
        case 83:
            ChipLogProgress(chipTool, " ***** Test Step 83 : Read attribute EPOCH_US Default Value\n");
            err = TestReadAttributeEpochUsDefaultValue_83();
            break;
        case 84:
            ChipLogProgress(chipTool, " ***** Test Step 84 : Read attribute EPOCH_S Default Value\n");
            err = TestReadAttributeEpochSDefaultValue_84();
            break;
        case 85:
            ChipLogProgress(chipTool, " ***** Test Step 85 : Write attribute EPOCH_S Not Default Value\n");
            err = TestWriteAttributeEpochSNotDefaultValue_85();
            break;
        case 86:
            ChipLogProgress(chipTool, " ***** Test Step 86 : Read attribute EPOCH_S Not Default Value\n");
            err = TestReadAttributeEpochSNotDefaultValue_86();
            break;
        case 87:
            ChipLogProgress(chipTool, " ***** Test Step 87 : Write attribute EPOCH_S Default Value\n");
            err = TestWriteAttributeEpochSDefaultValue_87();
            break;
        case 88:
            ChipLogProgress(chipTool, " ***** Test Step 88 : Read attribute EPOCH_S Default Value\n");
            err = TestReadAttributeEpochSDefaultValue_88();
            break;
        case 89:
            ChipLogProgress(chipTool, " ***** Test Step 89 : Read attribute vendor_id Default Value\n");
            err = TestReadAttributeVendorIdDefaultValue_89();
            break;
        case 90:
            ChipLogProgress(chipTool, " ***** Test Step 90 : Write attribute vendor_id Not Default Value\n");
            err = TestWriteAttributeVendorIdNotDefaultValue_90();
            break;
        case 91:
            ChipLogProgress(chipTool, " ***** Test Step 91 : Read attribute vendor_id Not Default Value\n");
            err = TestReadAttributeVendorIdNotDefaultValue_91();
            break;
        case 92:
            ChipLogProgress(chipTool, " ***** Test Step 92 : Write attribute vendor_id Default Value\n");
            err = TestWriteAttributeVendorIdDefaultValue_92();
            break;
        case 93:
            ChipLogProgress(chipTool, " ***** Test Step 93 : Read attribute vendor_id Default Value\n");
            err = TestReadAttributeVendorIdDefaultValue_93();
            break;
        case 94:
            ChipLogProgress(chipTool, " ***** Test Step 94 : Read attribute char_string Default Value\n");
            err = TestReadAttributeCharStringDefaultValue_94();
            break;
        case 95:
            ChipLogProgress(chipTool,
                            " ***** Test Step 95 : Read attribute char_string Default Value and compare to saved value\n");
            err = TestReadAttributeCharStringDefaultValueAndCompareToSavedValue_95();
            break;
        case 96:
            ChipLogProgress(chipTool, " ***** Test Step 96 : Write attribute char_string Not Default Value\n");
            err = TestWriteAttributeCharStringNotDefaultValue_96();
            break;
        case 97:
            ChipLogProgress(chipTool, " ***** Test Step 97 : Read attribute char_string Not Default Value\n");
            err = TestReadAttributeCharStringNotDefaultValue_97();
            break;
        case 98:
            ChipLogProgress(chipTool,
                            " ***** Test Step 98 : Read attribute char_string Not Default Value and compare to saved value\n");
            err = TestReadAttributeCharStringNotDefaultValueAndCompareToSavedValue_98();
            break;
        case 99:
            ChipLogProgress(chipTool, " ***** Test Step 99 : Write attribute char_string Not Default Value from saved value\n");
            err = TestWriteAttributeCharStringNotDefaultValueFromSavedValue_99();
            break;
        case 100:
            ChipLogProgress(chipTool,
                            " ***** Test Step 100 : Read attribute char_string Not Default Value and compare to expected value\n");
            err = TestReadAttributeCharStringNotDefaultValueAndCompareToExpectedValue_100();
            break;
        case 101:
            ChipLogProgress(chipTool, " ***** Test Step 101 : Write attribute char_string Default Value\n");
            err = TestWriteAttributeCharStringDefaultValue_101();
            break;
        case 102:
            ChipLogProgress(chipTool, " ***** Test Step 102 : Read attribute octet_string Default Value\n");
            err = TestReadAttributeOctetStringDefaultValue_102();
            break;
        case 103:
            ChipLogProgress(chipTool,
                            " ***** Test Step 103 : Read attribute octet_string Default Value and compare to saved value\n");
            err = TestReadAttributeOctetStringDefaultValueAndCompareToSavedValue_103();
            break;
        case 104:
            ChipLogProgress(chipTool, " ***** Test Step 104 : Write attribute octet_string Not Default Value\n");
            err = TestWriteAttributeOctetStringNotDefaultValue_104();
            break;
        case 105:
            ChipLogProgress(chipTool, " ***** Test Step 105 : Read attribute octet_string Not Default Value\n");
            err = TestReadAttributeOctetStringNotDefaultValue_105();
            break;
        case 106:
            ChipLogProgress(chipTool,
                            " ***** Test Step 106 : Read attribute octet_string Not Default Value and compare to saved value\n");
            err = TestReadAttributeOctetStringNotDefaultValueAndCompareToSavedValue_106();
            break;
        case 107:
            ChipLogProgress(chipTool, " ***** Test Step 107 : Write attribute octet_string Not Default Value from saved value\n");
            err = TestWriteAttributeOctetStringNotDefaultValueFromSavedValue_107();
            break;
        case 108:
            ChipLogProgress(chipTool,
                            " ***** Test Step 108 : Read attribute octet_string Not Default Value and compare to expected value\n");
            err = TestReadAttributeOctetStringNotDefaultValueAndCompareToExpectedValue_108();
            break;
        case 109:
            ChipLogProgress(chipTool, " ***** Test Step 109 : Write attribute octet_string Default Value\n");
            err = TestWriteAttributeOctetStringDefaultValue_109();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 110;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    uint8_t TestAddArgumentDefaultValue;
    bool readAttributeBooleanDefaultValue;
    uint8_t readAttributeBitmap8DefaultValue;
    uint16_t readAttributeBitmap16DefaultValue;
    uint32_t readAttributeBitmap32DefaultValue;
    uint64_t readAttributeBitmap64DefaultValue;
    uint8_t readAttributeInt8uDefaultValue;
    uint16_t readAttributeInt16uDefaultValue;
    uint32_t readAttributeInt32uDefaultValue;
    uint64_t readAttributeInt64uDefaultValue;
    int8_t readAttributeInt8sDefaultValue;
    int16_t readAttributeInt16sDefaultValue;
    int32_t readAttributeInt32sDefaultValue;
    int64_t readAttributeInt64sDefaultValue;
    uint8_t readAttributeEnum8DefaultValue;
    uint16_t readAttributeEnum16DefaultValue;
    uint64_t readAttributeEpochUSDefaultValue;
    uint32_t readAttributeEpochSDefaultValue;
    chip::VendorId readAttributeVendorIdDefaultValue;
    char * readAttributeCharStringDefaultValueBuffer = nullptr;
    chip::CharSpan readAttributeCharStringDefaultValue;
    char * readAttributeCharStringNotDefaultValueBuffer = nullptr;
    chip::CharSpan readAttributeCharStringNotDefaultValue;
    uint8_t * readAttributeOctetStringDefaultValueBuffer = nullptr;
    chip::ByteSpan readAttributeOctetStringDefaultValue;
    uint8_t * readAttributeOctetStringNotDefaultValueBuffer = nullptr;
    chip::ByteSpan readAttributeOctetStringNotDefaultValue;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_4(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_4(error);
    }

    static void OnSuccessCallback_4(void * context, bool boolean)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_4(boolean);
    }

    static void OnFailureCallback_5(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_5(error);
    }

    static void OnSuccessCallback_5(void * context) { (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_5(); }

    static void OnFailureCallback_6(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_6(error);
    }

    static void OnSuccessCallback_6(void * context, bool boolean)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_6(boolean);
    }

    static void OnFailureCallback_7(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_7(error);
    }

    static void OnSuccessCallback_7(void * context) { (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_7(); }

    static void OnFailureCallback_8(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_8(error);
    }

    static void OnSuccessCallback_8(void * context, bool boolean)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_8(boolean);
    }

    static void OnFailureCallback_9(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_9(error);
    }

    static void OnSuccessCallback_9(void * context, uint8_t bitmap8)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_9(bitmap8);
    }

    static void OnFailureCallback_10(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_10(error);
    }

    static void OnSuccessCallback_10(void * context) { (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_10(); }

    static void OnFailureCallback_11(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_11(error);
    }

    static void OnSuccessCallback_11(void * context, uint8_t bitmap8)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_11(bitmap8);
    }

    static void OnFailureCallback_12(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_12(error);
    }

    static void OnSuccessCallback_12(void * context) { (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_12(); }

    static void OnFailureCallback_13(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_13(error);
    }

    static void OnSuccessCallback_13(void * context, uint8_t bitmap8)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_13(bitmap8);
    }

    static void OnFailureCallback_14(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_14(error);
    }

    static void OnSuccessCallback_14(void * context, uint16_t bitmap16)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_14(bitmap16);
    }

    static void OnFailureCallback_15(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_15(error);
    }

    static void OnSuccessCallback_15(void * context) { (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_15(); }

    static void OnFailureCallback_16(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_16(error);
    }

    static void OnSuccessCallback_16(void * context, uint16_t bitmap16)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_16(bitmap16);
    }

    static void OnFailureCallback_17(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_17(error);
    }

    static void OnSuccessCallback_17(void * context) { (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_17(); }

    static void OnFailureCallback_18(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_18(error);
    }

    static void OnSuccessCallback_18(void * context, uint16_t bitmap16)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_18(bitmap16);
    }

    static void OnFailureCallback_19(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_19(error);
    }

    static void OnSuccessCallback_19(void * context, uint32_t bitmap32)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_19(bitmap32);
    }

    static void OnFailureCallback_20(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_20(error);
    }

    static void OnSuccessCallback_20(void * context) { (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_20(); }

    static void OnFailureCallback_21(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_21(error);
    }

    static void OnSuccessCallback_21(void * context, uint32_t bitmap32)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_21(bitmap32);
    }

    static void OnFailureCallback_22(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_22(error);
    }

    static void OnSuccessCallback_22(void * context) { (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_22(); }

    static void OnFailureCallback_23(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_23(error);
    }

    static void OnSuccessCallback_23(void * context, uint32_t bitmap32)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_23(bitmap32);
    }

    static void OnFailureCallback_24(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_24(error);
    }

    static void OnSuccessCallback_24(void * context, uint64_t bitmap64)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_24(bitmap64);
    }

    static void OnFailureCallback_25(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_25(error);
    }

    static void OnSuccessCallback_25(void * context) { (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_25(); }

    static void OnFailureCallback_26(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_26(error);
    }

    static void OnSuccessCallback_26(void * context, uint64_t bitmap64)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_26(bitmap64);
    }

    static void OnFailureCallback_27(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_27(error);
    }

    static void OnSuccessCallback_27(void * context) { (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_27(); }

    static void OnFailureCallback_28(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_28(error);
    }

    static void OnSuccessCallback_28(void * context, uint64_t bitmap64)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_28(bitmap64);
    }

    static void OnFailureCallback_29(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_29(error);
    }

    static void OnSuccessCallback_29(void * context, uint8_t int8u)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_29(int8u);
    }

    static void OnFailureCallback_30(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_30(error);
    }

    static void OnSuccessCallback_30(void * context) { (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_30(); }

    static void OnFailureCallback_31(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_31(error);
    }

    static void OnSuccessCallback_31(void * context, uint8_t int8u)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_31(int8u);
    }

    static void OnFailureCallback_32(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_32(error);
    }

    static void OnSuccessCallback_32(void * context) { (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_32(); }

    static void OnFailureCallback_33(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_33(error);
    }

    static void OnSuccessCallback_33(void * context, uint8_t int8u)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_33(int8u);
    }

    static void OnFailureCallback_34(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_34(error);
    }

    static void OnSuccessCallback_34(void * context, uint16_t int16u)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_34(int16u);
    }

    static void OnFailureCallback_35(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_35(error);
    }

    static void OnSuccessCallback_35(void * context) { (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_35(); }

    static void OnFailureCallback_36(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_36(error);
    }

    static void OnSuccessCallback_36(void * context, uint16_t int16u)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_36(int16u);
    }

    static void OnFailureCallback_37(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_37(error);
    }

    static void OnSuccessCallback_37(void * context) { (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_37(); }

    static void OnFailureCallback_38(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_38(error);
    }

    static void OnSuccessCallback_38(void * context, uint16_t int16u)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_38(int16u);
    }

    static void OnFailureCallback_39(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_39(error);
    }

    static void OnSuccessCallback_39(void * context, uint32_t int32u)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_39(int32u);
    }

    static void OnFailureCallback_40(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_40(error);
    }

    static void OnSuccessCallback_40(void * context) { (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_40(); }

    static void OnFailureCallback_41(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_41(error);
    }

    static void OnSuccessCallback_41(void * context, uint32_t int32u)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_41(int32u);
    }

    static void OnFailureCallback_42(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_42(error);
    }

    static void OnSuccessCallback_42(void * context) { (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_42(); }

    static void OnFailureCallback_43(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_43(error);
    }

    static void OnSuccessCallback_43(void * context, uint32_t int32u)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_43(int32u);
    }

    static void OnFailureCallback_44(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_44(error);
    }

    static void OnSuccessCallback_44(void * context, uint64_t int64u)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_44(int64u);
    }

    static void OnFailureCallback_45(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_45(error);
    }

    static void OnSuccessCallback_45(void * context) { (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_45(); }

    static void OnFailureCallback_46(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_46(error);
    }

    static void OnSuccessCallback_46(void * context, uint64_t int64u)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_46(int64u);
    }

    static void OnFailureCallback_47(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_47(error);
    }

    static void OnSuccessCallback_47(void * context) { (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_47(); }

    static void OnFailureCallback_48(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_48(error);
    }

    static void OnSuccessCallback_48(void * context, uint64_t int64u)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_48(int64u);
    }

    static void OnFailureCallback_49(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_49(error);
    }

    static void OnSuccessCallback_49(void * context, int8_t int8s)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_49(int8s);
    }

    static void OnFailureCallback_50(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_50(error);
    }

    static void OnSuccessCallback_50(void * context) { (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_50(); }

    static void OnFailureCallback_51(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_51(error);
    }

    static void OnSuccessCallback_51(void * context, int8_t int8s)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_51(int8s);
    }

    static void OnFailureCallback_52(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_52(error);
    }

    static void OnSuccessCallback_52(void * context) { (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_52(); }

    static void OnFailureCallback_53(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_53(error);
    }

    static void OnSuccessCallback_53(void * context, int8_t int8s)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_53(int8s);
    }

    static void OnFailureCallback_54(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_54(error);
    }

    static void OnSuccessCallback_54(void * context, int16_t int16s)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_54(int16s);
    }

    static void OnFailureCallback_55(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_55(error);
    }

    static void OnSuccessCallback_55(void * context) { (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_55(); }

    static void OnFailureCallback_56(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_56(error);
    }

    static void OnSuccessCallback_56(void * context, int16_t int16s)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_56(int16s);
    }

    static void OnFailureCallback_57(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_57(error);
    }

    static void OnSuccessCallback_57(void * context) { (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_57(); }

    static void OnFailureCallback_58(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_58(error);
    }

    static void OnSuccessCallback_58(void * context, int16_t int16s)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_58(int16s);
    }

    static void OnFailureCallback_59(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_59(error);
    }

    static void OnSuccessCallback_59(void * context, int32_t int32s)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_59(int32s);
    }

    static void OnFailureCallback_60(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_60(error);
    }

    static void OnSuccessCallback_60(void * context) { (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_60(); }

    static void OnFailureCallback_61(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_61(error);
    }

    static void OnSuccessCallback_61(void * context, int32_t int32s)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_61(int32s);
    }

    static void OnFailureCallback_62(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_62(error);
    }

    static void OnSuccessCallback_62(void * context) { (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_62(); }

    static void OnFailureCallback_63(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_63(error);
    }

    static void OnSuccessCallback_63(void * context, int32_t int32s)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_63(int32s);
    }

    static void OnFailureCallback_64(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_64(error);
    }

    static void OnSuccessCallback_64(void * context, int64_t int64s)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_64(int64s);
    }

    static void OnFailureCallback_65(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_65(error);
    }

    static void OnSuccessCallback_65(void * context) { (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_65(); }

    static void OnFailureCallback_66(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_66(error);
    }

    static void OnSuccessCallback_66(void * context, int64_t int64s)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_66(int64s);
    }

    static void OnFailureCallback_67(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_67(error);
    }

    static void OnSuccessCallback_67(void * context) { (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_67(); }

    static void OnFailureCallback_68(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_68(error);
    }

    static void OnSuccessCallback_68(void * context, int64_t int64s)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_68(int64s);
    }

    static void OnFailureCallback_69(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_69(error);
    }

    static void OnSuccessCallback_69(void * context, uint8_t enum8)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_69(enum8);
    }

    static void OnFailureCallback_70(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_70(error);
    }

    static void OnSuccessCallback_70(void * context) { (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_70(); }

    static void OnFailureCallback_71(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_71(error);
    }

    static void OnSuccessCallback_71(void * context, uint8_t enum8)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_71(enum8);
    }

    static void OnFailureCallback_72(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_72(error);
    }

    static void OnSuccessCallback_72(void * context) { (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_72(); }

    static void OnFailureCallback_73(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_73(error);
    }

    static void OnSuccessCallback_73(void * context, uint8_t enum8)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_73(enum8);
    }

    static void OnFailureCallback_74(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_74(error);
    }

    static void OnSuccessCallback_74(void * context, uint16_t enum16)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_74(enum16);
    }

    static void OnFailureCallback_75(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_75(error);
    }

    static void OnSuccessCallback_75(void * context) { (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_75(); }

    static void OnFailureCallback_76(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_76(error);
    }

    static void OnSuccessCallback_76(void * context, uint16_t enum16)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_76(enum16);
    }

    static void OnFailureCallback_77(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_77(error);
    }

    static void OnSuccessCallback_77(void * context) { (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_77(); }

    static void OnFailureCallback_78(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_78(error);
    }

    static void OnSuccessCallback_78(void * context, uint16_t enum16)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_78(enum16);
    }

    static void OnFailureCallback_79(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_79(error);
    }

    static void OnSuccessCallback_79(void * context, uint64_t epochUs)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_79(epochUs);
    }

    static void OnFailureCallback_80(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_80(error);
    }

    static void OnSuccessCallback_80(void * context) { (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_80(); }

    static void OnFailureCallback_81(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_81(error);
    }

    static void OnSuccessCallback_81(void * context, uint64_t epochUs)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_81(epochUs);
    }

    static void OnFailureCallback_82(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_82(error);
    }

    static void OnSuccessCallback_82(void * context) { (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_82(); }

    static void OnFailureCallback_83(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_83(error);
    }

    static void OnSuccessCallback_83(void * context, uint64_t epochUs)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_83(epochUs);
    }

    static void OnFailureCallback_84(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_84(error);
    }

    static void OnSuccessCallback_84(void * context, uint32_t epochS)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_84(epochS);
    }

    static void OnFailureCallback_85(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_85(error);
    }

    static void OnSuccessCallback_85(void * context) { (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_85(); }

    static void OnFailureCallback_86(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_86(error);
    }

    static void OnSuccessCallback_86(void * context, uint32_t epochS)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_86(epochS);
    }

    static void OnFailureCallback_87(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_87(error);
    }

    static void OnSuccessCallback_87(void * context) { (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_87(); }

    static void OnFailureCallback_88(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_88(error);
    }

    static void OnSuccessCallback_88(void * context, uint32_t epochS)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_88(epochS);
    }

    static void OnFailureCallback_89(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_89(error);
    }

    static void OnSuccessCallback_89(void * context, chip::VendorId vendorId)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_89(vendorId);
    }

    static void OnFailureCallback_90(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_90(error);
    }

    static void OnSuccessCallback_90(void * context) { (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_90(); }

    static void OnFailureCallback_91(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_91(error);
    }

    static void OnSuccessCallback_91(void * context, chip::VendorId vendorId)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_91(vendorId);
    }

    static void OnFailureCallback_92(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_92(error);
    }

    static void OnSuccessCallback_92(void * context) { (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_92(); }

    static void OnFailureCallback_93(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_93(error);
    }

    static void OnSuccessCallback_93(void * context, chip::VendorId vendorId)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_93(vendorId);
    }

    static void OnFailureCallback_94(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_94(error);
    }

    static void OnSuccessCallback_94(void * context, chip::CharSpan charString)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_94(charString);
    }

    static void OnFailureCallback_95(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_95(error);
    }

    static void OnSuccessCallback_95(void * context, chip::CharSpan charString)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_95(charString);
    }

    static void OnFailureCallback_96(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_96(error);
    }

    static void OnSuccessCallback_96(void * context) { (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_96(); }

    static void OnFailureCallback_97(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_97(error);
    }

    static void OnSuccessCallback_97(void * context, chip::CharSpan charString)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_97(charString);
    }

    static void OnFailureCallback_98(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_98(error);
    }

    static void OnSuccessCallback_98(void * context, chip::CharSpan charString)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_98(charString);
    }

    static void OnFailureCallback_99(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_99(error);
    }

    static void OnSuccessCallback_99(void * context) { (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_99(); }

    static void OnFailureCallback_100(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_100(error);
    }

    static void OnSuccessCallback_100(void * context, chip::CharSpan charString)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_100(charString);
    }

    static void OnFailureCallback_101(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_101(error);
    }

    static void OnSuccessCallback_101(void * context) { (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_101(); }

    static void OnFailureCallback_102(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_102(error);
    }

    static void OnSuccessCallback_102(void * context, chip::ByteSpan octetString)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_102(octetString);
    }

    static void OnFailureCallback_103(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_103(error);
    }

    static void OnSuccessCallback_103(void * context, chip::ByteSpan octetString)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_103(octetString);
    }

    static void OnFailureCallback_104(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_104(error);
    }

    static void OnSuccessCallback_104(void * context) { (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_104(); }

    static void OnFailureCallback_105(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_105(error);
    }

    static void OnSuccessCallback_105(void * context, chip::ByteSpan octetString)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_105(octetString);
    }

    static void OnFailureCallback_106(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_106(error);
    }

    static void OnSuccessCallback_106(void * context, chip::ByteSpan octetString)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_106(octetString);
    }

    static void OnFailureCallback_107(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_107(error);
    }

    static void OnSuccessCallback_107(void * context) { (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_107(); }

    static void OnFailureCallback_108(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_108(error);
    }

    static void OnSuccessCallback_108(void * context, chip::ByteSpan octetString)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_108(octetString);
    }

    static void OnFailureCallback_109(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_109(error);
    }

    static void OnSuccessCallback_109(void * context) { (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_109(); }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestSendTestAddArgumentsCommand_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::TestAddArguments::Type;

        RequestType request;
        request.arg1 = 3;
        request.arg2 = 17;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_1(data.returnValue);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_1(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1(uint8_t returnValue)
    {
        VerifyOrReturn(CheckValue("returnValue", returnValue, 20));

        TestAddArgumentDefaultValue = returnValue;
        NextTest();
    }

    CHIP_ERROR TestSendTestAddArgumentsCommand_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::TestAddArguments::Type;

        RequestType request;
        request.arg1 = 3;
        request.arg2 = 17;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_2(data.returnValue);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_2(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2(uint8_t returnValue)
    {
        VerifyOrReturn(CheckValue("returnValue", returnValue, TestAddArgumentDefaultValue));

        NextTest();
    }

    CHIP_ERROR TestSendTestAddArgumentsCommand_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::TestAddArguments::Type;

        RequestType request;
        request.arg1 = 3;
        request.arg2 = TestAddArgumentDefaultValue;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestSaveAsSuite *>(context))->OnSuccessResponse_3(data.returnValue);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestSaveAsSuite *>(context))->OnFailureResponse_3(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3(uint8_t returnValue)
    {
        VerifyOrReturn(CheckConstraintNotValue("returnValue", returnValue, TestAddArgumentDefaultValue));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeBooleanDefaultValue_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Boolean::TypeInfo>(
            this, OnSuccessCallback_4, OnFailureCallback_4, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_4(bool boolean)
    {
        VerifyOrReturn(CheckValue("boolean", boolean, 0));

        readAttributeBooleanDefaultValue = boolean;
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeBooleanNotDefaultValue_5()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        bool booleanArgument;
        booleanArgument = 1;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Boolean::TypeInfo>(
            booleanArgument, this, OnSuccessCallback_5, OnFailureCallback_5));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_5() { NextTest(); }

    CHIP_ERROR TestReadAttributeBooleanNotDefaultValue_6()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Boolean::TypeInfo>(
            this, OnSuccessCallback_6, OnFailureCallback_6, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_6(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_6(bool boolean)
    {
        VerifyOrReturn(CheckConstraintNotValue("boolean", boolean, readAttributeBooleanDefaultValue));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeBooleanDefaultValue_7()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        bool booleanArgument;
        booleanArgument = readAttributeBooleanDefaultValue;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Boolean::TypeInfo>(
            booleanArgument, this, OnSuccessCallback_7, OnFailureCallback_7));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_7(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_7() { NextTest(); }

    CHIP_ERROR TestReadAttributeBooleanFalse_8()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Boolean::TypeInfo>(
            this, OnSuccessCallback_8, OnFailureCallback_8, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_8(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_8(bool boolean)
    {
        VerifyOrReturn(CheckValue("boolean", boolean, readAttributeBooleanDefaultValue));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeBitmap8DefaultValue_9()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap8::TypeInfo>(
            this, OnSuccessCallback_9, OnFailureCallback_9, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_9(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_9(uint8_t bitmap8)
    {
        VerifyOrReturn(CheckValue("bitmap8", bitmap8, 0));

        readAttributeBitmap8DefaultValue = bitmap8;
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeBitmap8NotDefaultValue_10()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t bitmap8Argument;
        bitmap8Argument = 1;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap8::TypeInfo>(
            bitmap8Argument, this, OnSuccessCallback_10, OnFailureCallback_10));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_10(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_10() { NextTest(); }

    CHIP_ERROR TestReadAttributeBitmap8NotDefaultValue_11()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap8::TypeInfo>(
            this, OnSuccessCallback_11, OnFailureCallback_11, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_11(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_11(uint8_t bitmap8)
    {
        VerifyOrReturn(CheckConstraintNotValue("bitmap8", bitmap8, readAttributeBitmap8DefaultValue));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeBitmap8DefaultValue_12()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t bitmap8Argument;
        bitmap8Argument = readAttributeBitmap8DefaultValue;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap8::TypeInfo>(
            bitmap8Argument, this, OnSuccessCallback_12, OnFailureCallback_12));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_12(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_12() { NextTest(); }

    CHIP_ERROR TestReadAttributeBitmap8DefaultValue_13()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap8::TypeInfo>(
            this, OnSuccessCallback_13, OnFailureCallback_13, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_13(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_13(uint8_t bitmap8)
    {
        VerifyOrReturn(CheckValue("bitmap8", bitmap8, readAttributeBitmap8DefaultValue));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeBitmap16DefaultValue_14()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap16::TypeInfo>(
            this, OnSuccessCallback_14, OnFailureCallback_14, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_14(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_14(uint16_t bitmap16)
    {
        VerifyOrReturn(CheckValue("bitmap16", bitmap16, 0U));

        readAttributeBitmap16DefaultValue = bitmap16;
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeBitmap16NotDefaultValue_15()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t bitmap16Argument;
        bitmap16Argument = 1U;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap16::TypeInfo>(
            bitmap16Argument, this, OnSuccessCallback_15, OnFailureCallback_15));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_15(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_15() { NextTest(); }

    CHIP_ERROR TestReadAttributeBitmap16NotDefaultValue_16()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap16::TypeInfo>(
            this, OnSuccessCallback_16, OnFailureCallback_16, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_16(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_16(uint16_t bitmap16)
    {
        VerifyOrReturn(CheckConstraintNotValue("bitmap16", bitmap16, readAttributeBitmap16DefaultValue));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeBitmap16DefaultValue_17()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t bitmap16Argument;
        bitmap16Argument = readAttributeBitmap16DefaultValue;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap16::TypeInfo>(
            bitmap16Argument, this, OnSuccessCallback_17, OnFailureCallback_17));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_17(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_17() { NextTest(); }

    CHIP_ERROR TestReadAttributeBitmap16DefaultValue_18()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap16::TypeInfo>(
            this, OnSuccessCallback_18, OnFailureCallback_18, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_18(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_18(uint16_t bitmap16)
    {
        VerifyOrReturn(CheckValue("bitmap16", bitmap16, readAttributeBitmap16DefaultValue));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeBitmap32DefaultValue_19()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap32::TypeInfo>(
            this, OnSuccessCallback_19, OnFailureCallback_19, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_19(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_19(uint32_t bitmap32)
    {
        VerifyOrReturn(CheckValue("bitmap32", bitmap32, 0UL));

        readAttributeBitmap32DefaultValue = bitmap32;
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeBitmap32NotDefaultValue_20()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint32_t bitmap32Argument;
        bitmap32Argument = 1UL;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap32::TypeInfo>(
            bitmap32Argument, this, OnSuccessCallback_20, OnFailureCallback_20));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_20(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_20() { NextTest(); }

    CHIP_ERROR TestReadAttributeBitmap32NotDefaultValue_21()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap32::TypeInfo>(
            this, OnSuccessCallback_21, OnFailureCallback_21, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_21(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_21(uint32_t bitmap32)
    {
        VerifyOrReturn(CheckConstraintNotValue("bitmap32", bitmap32, readAttributeBitmap32DefaultValue));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeBitmap32DefaultValue_22()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint32_t bitmap32Argument;
        bitmap32Argument = readAttributeBitmap32DefaultValue;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap32::TypeInfo>(
            bitmap32Argument, this, OnSuccessCallback_22, OnFailureCallback_22));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_22(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_22() { NextTest(); }

    CHIP_ERROR TestReadAttributeBitmap32DefaultValue_23()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap32::TypeInfo>(
            this, OnSuccessCallback_23, OnFailureCallback_23, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_23(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_23(uint32_t bitmap32)
    {
        VerifyOrReturn(CheckValue("bitmap32", bitmap32, readAttributeBitmap32DefaultValue));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeBitmap64DefaultValue_24()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap64::TypeInfo>(
            this, OnSuccessCallback_24, OnFailureCallback_24, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_24(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_24(uint64_t bitmap64)
    {
        VerifyOrReturn(CheckValue("bitmap64", bitmap64, 0ULL));

        readAttributeBitmap64DefaultValue = bitmap64;
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeBitmap64NotDefaultValue_25()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint64_t bitmap64Argument;
        bitmap64Argument = 1ULL;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap64::TypeInfo>(
            bitmap64Argument, this, OnSuccessCallback_25, OnFailureCallback_25));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_25(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_25() { NextTest(); }

    CHIP_ERROR TestReadAttributeBitmap64DefaultValue_26()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap64::TypeInfo>(
            this, OnSuccessCallback_26, OnFailureCallback_26, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_26(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_26(uint64_t bitmap64)
    {
        VerifyOrReturn(CheckConstraintNotValue("bitmap64", bitmap64, readAttributeBitmap64DefaultValue));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeBitmap64DefaultValue_27()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint64_t bitmap64Argument;
        bitmap64Argument = readAttributeBitmap64DefaultValue;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap64::TypeInfo>(
            bitmap64Argument, this, OnSuccessCallback_27, OnFailureCallback_27));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_27(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_27() { NextTest(); }

    CHIP_ERROR TestReadAttributeBitmap64DefaultValue_28()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap64::TypeInfo>(
            this, OnSuccessCallback_28, OnFailureCallback_28, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_28(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_28(uint64_t bitmap64)
    {
        VerifyOrReturn(CheckValue("bitmap64", bitmap64, readAttributeBitmap64DefaultValue));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeInt8uDefaultValue_29()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int8u::TypeInfo>(
            this, OnSuccessCallback_29, OnFailureCallback_29, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_29(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_29(uint8_t int8u)
    {
        VerifyOrReturn(CheckValue("int8u", int8u, 0));

        readAttributeInt8uDefaultValue = int8u;
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt8uNotDefaultValue_30()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t int8uArgument;
        int8uArgument = 1;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int8u::TypeInfo>(
            int8uArgument, this, OnSuccessCallback_30, OnFailureCallback_30));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_30(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_30() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt8uNotDefaultValue_31()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int8u::TypeInfo>(
            this, OnSuccessCallback_31, OnFailureCallback_31, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_31(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_31(uint8_t int8u)
    {
        VerifyOrReturn(CheckConstraintNotValue("int8u", int8u, readAttributeInt8uDefaultValue));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt8uDefaultValue_32()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t int8uArgument;
        int8uArgument = readAttributeInt8uDefaultValue;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int8u::TypeInfo>(
            int8uArgument, this, OnSuccessCallback_32, OnFailureCallback_32));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_32(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_32() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt8uDefaultValue_33()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int8u::TypeInfo>(
            this, OnSuccessCallback_33, OnFailureCallback_33, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_33(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_33(uint8_t int8u)
    {
        VerifyOrReturn(CheckValue("int8u", int8u, readAttributeInt8uDefaultValue));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeInt16uDefaultValue_34()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int16u::TypeInfo>(
            this, OnSuccessCallback_34, OnFailureCallback_34, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_34(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_34(uint16_t int16u)
    {
        VerifyOrReturn(CheckValue("int16u", int16u, 0U));

        readAttributeInt16uDefaultValue = int16u;
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt16uNotDefaultValue_35()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t int16uArgument;
        int16uArgument = 1U;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int16u::TypeInfo>(
            int16uArgument, this, OnSuccessCallback_35, OnFailureCallback_35));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_35(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_35() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt16uNotDefaultValue_36()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int16u::TypeInfo>(
            this, OnSuccessCallback_36, OnFailureCallback_36, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_36(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_36(uint16_t int16u)
    {
        VerifyOrReturn(CheckConstraintNotValue("int16u", int16u, readAttributeInt16uDefaultValue));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt16uDefaultValue_37()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t int16uArgument;
        int16uArgument = readAttributeInt16uDefaultValue;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int16u::TypeInfo>(
            int16uArgument, this, OnSuccessCallback_37, OnFailureCallback_37));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_37(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_37() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt16uDefaultValue_38()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int16u::TypeInfo>(
            this, OnSuccessCallback_38, OnFailureCallback_38, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_38(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_38(uint16_t int16u)
    {
        VerifyOrReturn(CheckValue("int16u", int16u, readAttributeInt16uDefaultValue));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeInt32uDefaultValue_39()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int32u::TypeInfo>(
            this, OnSuccessCallback_39, OnFailureCallback_39, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_39(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_39(uint32_t int32u)
    {
        VerifyOrReturn(CheckValue("int32u", int32u, 0UL));

        readAttributeInt32uDefaultValue = int32u;
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt32uNotDefaultValue_40()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint32_t int32uArgument;
        int32uArgument = 1UL;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int32u::TypeInfo>(
            int32uArgument, this, OnSuccessCallback_40, OnFailureCallback_40));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_40(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_40() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt32uNotDefaultValue_41()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int32u::TypeInfo>(
            this, OnSuccessCallback_41, OnFailureCallback_41, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_41(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_41(uint32_t int32u)
    {
        VerifyOrReturn(CheckConstraintNotValue("int32u", int32u, readAttributeInt32uDefaultValue));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt32uDefaultValue_42()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint32_t int32uArgument;
        int32uArgument = readAttributeInt32uDefaultValue;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int32u::TypeInfo>(
            int32uArgument, this, OnSuccessCallback_42, OnFailureCallback_42));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_42(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_42() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt32uDefaultValue_43()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int32u::TypeInfo>(
            this, OnSuccessCallback_43, OnFailureCallback_43, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_43(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_43(uint32_t int32u)
    {
        VerifyOrReturn(CheckValue("int32u", int32u, readAttributeInt32uDefaultValue));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeInt64uDefaultValue_44()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int64u::TypeInfo>(
            this, OnSuccessCallback_44, OnFailureCallback_44, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_44(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_44(uint64_t int64u)
    {
        VerifyOrReturn(CheckValue("int64u", int64u, 0ULL));

        readAttributeInt64uDefaultValue = int64u;
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt64uNotDefaultValue_45()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint64_t int64uArgument;
        int64uArgument = 1ULL;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int64u::TypeInfo>(
            int64uArgument, this, OnSuccessCallback_45, OnFailureCallback_45));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_45(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_45() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt64uNotDefaultValue_46()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int64u::TypeInfo>(
            this, OnSuccessCallback_46, OnFailureCallback_46, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_46(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_46(uint64_t int64u)
    {
        VerifyOrReturn(CheckConstraintNotValue("int64u", int64u, readAttributeInt64uDefaultValue));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt64uDefaultValue_47()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint64_t int64uArgument;
        int64uArgument = readAttributeInt64uDefaultValue;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int64u::TypeInfo>(
            int64uArgument, this, OnSuccessCallback_47, OnFailureCallback_47));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_47(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_47() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt64uDefaultValue_48()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int64u::TypeInfo>(
            this, OnSuccessCallback_48, OnFailureCallback_48, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_48(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_48(uint64_t int64u)
    {
        VerifyOrReturn(CheckValue("int64u", int64u, readAttributeInt64uDefaultValue));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeInt8sDefaultValue_49()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int8s::TypeInfo>(
            this, OnSuccessCallback_49, OnFailureCallback_49, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_49(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_49(int8_t int8s)
    {
        VerifyOrReturn(CheckValue("int8s", int8s, 0));

        readAttributeInt8sDefaultValue = int8s;
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt8sNotDefaultValue_50()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int8_t int8sArgument;
        int8sArgument = 1;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int8s::TypeInfo>(
            int8sArgument, this, OnSuccessCallback_50, OnFailureCallback_50));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_50(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_50() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt8sNotDefaultValue_51()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int8s::TypeInfo>(
            this, OnSuccessCallback_51, OnFailureCallback_51, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_51(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_51(int8_t int8s)
    {
        VerifyOrReturn(CheckConstraintNotValue("int8s", int8s, readAttributeInt8sDefaultValue));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt8sDefaultValue_52()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int8_t int8sArgument;
        int8sArgument = readAttributeInt8sDefaultValue;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int8s::TypeInfo>(
            int8sArgument, this, OnSuccessCallback_52, OnFailureCallback_52));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_52(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_52() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt8sDefaultValue_53()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int8s::TypeInfo>(
            this, OnSuccessCallback_53, OnFailureCallback_53, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_53(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_53(int8_t int8s)
    {
        VerifyOrReturn(CheckValue("int8s", int8s, readAttributeInt8sDefaultValue));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeInt16sDefaultValue_54()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int16s::TypeInfo>(
            this, OnSuccessCallback_54, OnFailureCallback_54, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_54(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_54(int16_t int16s)
    {
        VerifyOrReturn(CheckValue("int16s", int16s, 0));

        readAttributeInt16sDefaultValue = int16s;
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt16sNotDefaultValue_55()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t int16sArgument;
        int16sArgument = 1;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int16s::TypeInfo>(
            int16sArgument, this, OnSuccessCallback_55, OnFailureCallback_55));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_55(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_55() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt16sNotDefaultValue_56()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int16s::TypeInfo>(
            this, OnSuccessCallback_56, OnFailureCallback_56, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_56(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_56(int16_t int16s)
    {
        VerifyOrReturn(CheckConstraintNotValue("int16s", int16s, readAttributeInt16sDefaultValue));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt16sDefaultValue_57()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t int16sArgument;
        int16sArgument = readAttributeInt16sDefaultValue;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int16s::TypeInfo>(
            int16sArgument, this, OnSuccessCallback_57, OnFailureCallback_57));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_57(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_57() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt16sDefaultValue_58()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int16s::TypeInfo>(
            this, OnSuccessCallback_58, OnFailureCallback_58, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_58(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_58(int16_t int16s)
    {
        VerifyOrReturn(CheckValue("int16s", int16s, readAttributeInt16sDefaultValue));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeInt32sDefaultValue_59()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int32s::TypeInfo>(
            this, OnSuccessCallback_59, OnFailureCallback_59, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_59(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_59(int32_t int32s)
    {
        VerifyOrReturn(CheckValue("int32s", int32s, 0L));

        readAttributeInt32sDefaultValue = int32s;
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt32sNotDefaultValue_60()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int32_t int32sArgument;
        int32sArgument = 1L;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int32s::TypeInfo>(
            int32sArgument, this, OnSuccessCallback_60, OnFailureCallback_60));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_60(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_60() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt32sNotDefaultValue_61()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int32s::TypeInfo>(
            this, OnSuccessCallback_61, OnFailureCallback_61, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_61(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_61(int32_t int32s)
    {
        VerifyOrReturn(CheckConstraintNotValue("int32s", int32s, readAttributeInt32sDefaultValue));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt32sDefaultValue_62()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int32_t int32sArgument;
        int32sArgument = readAttributeInt32sDefaultValue;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int32s::TypeInfo>(
            int32sArgument, this, OnSuccessCallback_62, OnFailureCallback_62));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_62(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_62() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt32sDefaultValue_63()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int32s::TypeInfo>(
            this, OnSuccessCallback_63, OnFailureCallback_63, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_63(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_63(int32_t int32s)
    {
        VerifyOrReturn(CheckValue("int32s", int32s, readAttributeInt32sDefaultValue));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeInt64sDefaultValue_64()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int64s::TypeInfo>(
            this, OnSuccessCallback_64, OnFailureCallback_64, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_64(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_64(int64_t int64s)
    {
        VerifyOrReturn(CheckValue("int64s", int64s, 0LL));

        readAttributeInt64sDefaultValue = int64s;
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeIntsNotDefaultValue_65()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int64_t int64sArgument;
        int64sArgument = 1LL;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int64s::TypeInfo>(
            int64sArgument, this, OnSuccessCallback_65, OnFailureCallback_65));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_65(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_65() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt64sNotDefaultValue_66()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int64s::TypeInfo>(
            this, OnSuccessCallback_66, OnFailureCallback_66, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_66(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_66(int64_t int64s)
    {
        VerifyOrReturn(CheckConstraintNotValue("int64s", int64s, readAttributeInt64sDefaultValue));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt64sDefaultValue_67()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int64_t int64sArgument;
        int64sArgument = readAttributeInt64sDefaultValue;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int64s::TypeInfo>(
            int64sArgument, this, OnSuccessCallback_67, OnFailureCallback_67));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_67(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_67() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt64sDefaultValue_68()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int64s::TypeInfo>(
            this, OnSuccessCallback_68, OnFailureCallback_68, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_68(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_68(int64_t int64s)
    {
        VerifyOrReturn(CheckValue("int64s", int64s, readAttributeInt64sDefaultValue));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeEnum8DefaultValue_69()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Enum8::TypeInfo>(
            this, OnSuccessCallback_69, OnFailureCallback_69, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_69(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_69(uint8_t enum8)
    {
        VerifyOrReturn(CheckValue("enum8", enum8, 0));

        readAttributeEnum8DefaultValue = enum8;
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeEnum8NotDefaultValue_70()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t enum8Argument;
        enum8Argument = 1;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Enum8::TypeInfo>(
            enum8Argument, this, OnSuccessCallback_70, OnFailureCallback_70));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_70(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_70() { NextTest(); }

    CHIP_ERROR TestReadAttributeEnum8NotDefaultValue_71()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Enum8::TypeInfo>(
            this, OnSuccessCallback_71, OnFailureCallback_71, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_71(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_71(uint8_t enum8)
    {
        VerifyOrReturn(CheckConstraintNotValue("enum8", enum8, readAttributeEnum8DefaultValue));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeEnum8DefaultValue_72()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t enum8Argument;
        enum8Argument = readAttributeEnum8DefaultValue;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Enum8::TypeInfo>(
            enum8Argument, this, OnSuccessCallback_72, OnFailureCallback_72));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_72(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_72() { NextTest(); }

    CHIP_ERROR TestReadAttributeEnum8DefaultValue_73()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Enum8::TypeInfo>(
            this, OnSuccessCallback_73, OnFailureCallback_73, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_73(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_73(uint8_t enum8)
    {
        VerifyOrReturn(CheckValue("enum8", enum8, readAttributeEnum8DefaultValue));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeEnum16DefaultValue_74()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Enum16::TypeInfo>(
            this, OnSuccessCallback_74, OnFailureCallback_74, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_74(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_74(uint16_t enum16)
    {
        VerifyOrReturn(CheckValue("enum16", enum16, 0U));

        readAttributeEnum16DefaultValue = enum16;
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeEnum16NotDefaultValue_75()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t enum16Argument;
        enum16Argument = 1U;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Enum16::TypeInfo>(
            enum16Argument, this, OnSuccessCallback_75, OnFailureCallback_75));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_75(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_75() { NextTest(); }

    CHIP_ERROR TestReadAttributeEnum16NotDefaultValue_76()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Enum16::TypeInfo>(
            this, OnSuccessCallback_76, OnFailureCallback_76, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_76(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_76(uint16_t enum16)
    {
        VerifyOrReturn(CheckConstraintNotValue("enum16", enum16, readAttributeEnum16DefaultValue));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeEnum16DefaultValue_77()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t enum16Argument;
        enum16Argument = readAttributeEnum16DefaultValue;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Enum16::TypeInfo>(
            enum16Argument, this, OnSuccessCallback_77, OnFailureCallback_77));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_77(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_77() { NextTest(); }

    CHIP_ERROR TestReadAttributeEnum16DefaultValue_78()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Enum16::TypeInfo>(
            this, OnSuccessCallback_78, OnFailureCallback_78, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_78(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_78(uint16_t enum16)
    {
        VerifyOrReturn(CheckValue("enum16", enum16, readAttributeEnum16DefaultValue));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeEpochUsDefaultValue_79()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::EpochUs::TypeInfo>(
            this, OnSuccessCallback_79, OnFailureCallback_79, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_79(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_79(uint64_t epochUs)
    {
        VerifyOrReturn(CheckValue("epochUs", epochUs, 0ULL));

        readAttributeEpochUSDefaultValue = epochUs;
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeEpochUsNotDefaultValue_80()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint64_t epochUsArgument;
        epochUsArgument = 1ULL;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::EpochUs::TypeInfo>(
            epochUsArgument, this, OnSuccessCallback_80, OnFailureCallback_80));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_80(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_80() { NextTest(); }

    CHIP_ERROR TestReadAttributeEpochUsNotDefaultValue_81()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::EpochUs::TypeInfo>(
            this, OnSuccessCallback_81, OnFailureCallback_81, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_81(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_81(uint64_t epochUs)
    {
        VerifyOrReturn(CheckConstraintNotValue("epochUs", epochUs, readAttributeEpochUSDefaultValue));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeEpochUsDefaultValue_82()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint64_t epochUsArgument;
        epochUsArgument = readAttributeEpochUSDefaultValue;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::EpochUs::TypeInfo>(
            epochUsArgument, this, OnSuccessCallback_82, OnFailureCallback_82));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_82(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_82() { NextTest(); }

    CHIP_ERROR TestReadAttributeEpochUsDefaultValue_83()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::EpochUs::TypeInfo>(
            this, OnSuccessCallback_83, OnFailureCallback_83, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_83(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_83(uint64_t epochUs)
    {
        VerifyOrReturn(CheckValue("epochUs", epochUs, readAttributeEpochUSDefaultValue));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeEpochSDefaultValue_84()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::EpochS::TypeInfo>(
            this, OnSuccessCallback_84, OnFailureCallback_84, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_84(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_84(uint32_t epochS)
    {
        VerifyOrReturn(CheckValue("epochS", epochS, 0UL));

        readAttributeEpochSDefaultValue = epochS;
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeEpochSNotDefaultValue_85()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint32_t epochSArgument;
        epochSArgument = 1UL;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::EpochS::TypeInfo>(
            epochSArgument, this, OnSuccessCallback_85, OnFailureCallback_85));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_85(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_85() { NextTest(); }

    CHIP_ERROR TestReadAttributeEpochSNotDefaultValue_86()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::EpochS::TypeInfo>(
            this, OnSuccessCallback_86, OnFailureCallback_86, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_86(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_86(uint32_t epochS)
    {
        VerifyOrReturn(CheckConstraintNotValue("epochS", epochS, readAttributeEpochSDefaultValue));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeEpochSDefaultValue_87()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint32_t epochSArgument;
        epochSArgument = readAttributeEpochSDefaultValue;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::EpochS::TypeInfo>(
            epochSArgument, this, OnSuccessCallback_87, OnFailureCallback_87));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_87(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_87() { NextTest(); }

    CHIP_ERROR TestReadAttributeEpochSDefaultValue_88()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::EpochS::TypeInfo>(
            this, OnSuccessCallback_88, OnFailureCallback_88, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_88(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_88(uint32_t epochS)
    {
        VerifyOrReturn(CheckValue("epochS", epochS, readAttributeEpochSDefaultValue));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeVendorIdDefaultValue_89()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::VendorId::TypeInfo>(
            this, OnSuccessCallback_89, OnFailureCallback_89, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_89(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_89(chip::VendorId vendorId)
    {
        VerifyOrReturn(CheckValue("vendorId", vendorId, 0U));

        readAttributeVendorIdDefaultValue = vendorId;
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeVendorIdNotDefaultValue_90()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::VendorId vendorIdArgument;
        vendorIdArgument = static_cast<chip::VendorId>(1);

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::VendorId::TypeInfo>(
            vendorIdArgument, this, OnSuccessCallback_90, OnFailureCallback_90));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_90(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_90() { NextTest(); }

    CHIP_ERROR TestReadAttributeVendorIdNotDefaultValue_91()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::VendorId::TypeInfo>(
            this, OnSuccessCallback_91, OnFailureCallback_91, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_91(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_91(chip::VendorId vendorId)
    {
        VerifyOrReturn(CheckConstraintNotValue("vendorId", vendorId, readAttributeVendorIdDefaultValue));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeVendorIdDefaultValue_92()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::VendorId vendorIdArgument;
        vendorIdArgument = readAttributeVendorIdDefaultValue;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::VendorId::TypeInfo>(
            vendorIdArgument, this, OnSuccessCallback_92, OnFailureCallback_92));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_92(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_92() { NextTest(); }

    CHIP_ERROR TestReadAttributeVendorIdDefaultValue_93()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::VendorId::TypeInfo>(
            this, OnSuccessCallback_93, OnFailureCallback_93, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_93(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_93(chip::VendorId vendorId)
    {
        VerifyOrReturn(CheckValue("vendorId", vendorId, readAttributeVendorIdDefaultValue));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeCharStringDefaultValue_94()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::CharString::TypeInfo>(
            this, OnSuccessCallback_94, OnFailureCallback_94, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_94(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_94(chip::CharSpan charString)
    {
        VerifyOrReturn(CheckValueAsString("charString", charString, chip::CharSpan("", 0)));

        if (readAttributeCharStringDefaultValueBuffer != nullptr)
        {
            chip::Platform::MemoryFree(readAttributeCharStringDefaultValueBuffer);
        }
        readAttributeCharStringDefaultValueBuffer = static_cast<char *>(chip::Platform::MemoryAlloc(charString.size()));
        memcpy(readAttributeCharStringDefaultValueBuffer, charString.data(), charString.size());
        readAttributeCharStringDefaultValue = chip::CharSpan(readAttributeCharStringDefaultValueBuffer, charString.size());
        NextTest();
    }

    CHIP_ERROR TestReadAttributeCharStringDefaultValueAndCompareToSavedValue_95()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::CharString::TypeInfo>(
            this, OnSuccessCallback_95, OnFailureCallback_95, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_95(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_95(chip::CharSpan charString)
    {
        VerifyOrReturn(CheckValueAsString("charString", charString, readAttributeCharStringDefaultValue));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeCharStringNotDefaultValue_96()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::CharSpan charStringArgument;
        charStringArgument = chip::Span<const char>("NotDefaultgarbage: not in length on purpose", 10);

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::CharString::TypeInfo>(
            charStringArgument, this, OnSuccessCallback_96, OnFailureCallback_96));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_96(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_96() { NextTest(); }

    CHIP_ERROR TestReadAttributeCharStringNotDefaultValue_97()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::CharString::TypeInfo>(
            this, OnSuccessCallback_97, OnFailureCallback_97, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_97(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_97(chip::CharSpan charString)
    {
        VerifyOrReturn(CheckValueAsString("charString", charString, chip::CharSpan("NotDefault", 10)));
        VerifyOrReturn(CheckConstraintNotValue("charString", charString, readAttributeCharStringDefaultValue));

        if (readAttributeCharStringNotDefaultValueBuffer != nullptr)
        {
            chip::Platform::MemoryFree(readAttributeCharStringNotDefaultValueBuffer);
        }
        readAttributeCharStringNotDefaultValueBuffer = static_cast<char *>(chip::Platform::MemoryAlloc(charString.size()));
        memcpy(readAttributeCharStringNotDefaultValueBuffer, charString.data(), charString.size());
        readAttributeCharStringNotDefaultValue = chip::CharSpan(readAttributeCharStringNotDefaultValueBuffer, charString.size());
        NextTest();
    }

    CHIP_ERROR TestReadAttributeCharStringNotDefaultValueAndCompareToSavedValue_98()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::CharString::TypeInfo>(
            this, OnSuccessCallback_98, OnFailureCallback_98, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_98(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_98(chip::CharSpan charString)
    {
        VerifyOrReturn(CheckValueAsString("charString", charString, readAttributeCharStringNotDefaultValue));
        VerifyOrReturn(CheckConstraintNotValue("charString", charString, readAttributeCharStringDefaultValue));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeCharStringNotDefaultValueFromSavedValue_99()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::CharSpan charStringArgument;
        charStringArgument = readAttributeCharStringNotDefaultValue;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::CharString::TypeInfo>(
            charStringArgument, this, OnSuccessCallback_99, OnFailureCallback_99));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_99(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_99() { NextTest(); }

    CHIP_ERROR TestReadAttributeCharStringNotDefaultValueAndCompareToExpectedValue_100()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::CharString::TypeInfo>(
            this, OnSuccessCallback_100, OnFailureCallback_100, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_100(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_100(chip::CharSpan charString)
    {
        VerifyOrReturn(CheckValueAsString("charString", charString, chip::CharSpan("NotDefault", 10)));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeCharStringDefaultValue_101()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::CharSpan charStringArgument;
        charStringArgument = readAttributeCharStringDefaultValue;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::CharString::TypeInfo>(
            charStringArgument, this, OnSuccessCallback_101, OnFailureCallback_101));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_101(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_101() { NextTest(); }

    CHIP_ERROR TestReadAttributeOctetStringDefaultValue_102()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::OctetString::TypeInfo>(
            this, OnSuccessCallback_102, OnFailureCallback_102, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_102(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_102(chip::ByteSpan octetString)
    {
        VerifyOrReturn(CheckValueAsString("octetString", octetString, chip::ByteSpan(chip::Uint8::from_const_char(""), 0)));

        if (readAttributeOctetStringDefaultValueBuffer != nullptr)
        {
            chip::Platform::MemoryFree(readAttributeOctetStringDefaultValueBuffer);
        }
        readAttributeOctetStringDefaultValueBuffer = static_cast<uint8_t *>(chip::Platform::MemoryAlloc(octetString.size()));
        memcpy(readAttributeOctetStringDefaultValueBuffer, octetString.data(), octetString.size());
        readAttributeOctetStringDefaultValue = chip::ByteSpan(readAttributeOctetStringDefaultValueBuffer, octetString.size());
        NextTest();
    }

    CHIP_ERROR TestReadAttributeOctetStringDefaultValueAndCompareToSavedValue_103()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::OctetString::TypeInfo>(
            this, OnSuccessCallback_103, OnFailureCallback_103, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_103(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_103(chip::ByteSpan octetString)
    {
        VerifyOrReturn(CheckValueAsString("octetString", octetString, readAttributeOctetStringDefaultValue));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeOctetStringNotDefaultValue_104()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::ByteSpan octetStringArgument;
        octetStringArgument = chip::ByteSpan(chip::Uint8::from_const_char("NotDefaultgarbage: not in length on purpose"), 10);

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::OctetString::TypeInfo>(
            octetStringArgument, this, OnSuccessCallback_104, OnFailureCallback_104));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_104(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_104() { NextTest(); }

    CHIP_ERROR TestReadAttributeOctetStringNotDefaultValue_105()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::OctetString::TypeInfo>(
            this, OnSuccessCallback_105, OnFailureCallback_105, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_105(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_105(chip::ByteSpan octetString)
    {
        VerifyOrReturn(
            CheckValueAsString("octetString", octetString, chip::ByteSpan(chip::Uint8::from_const_char("NotDefault"), 10)));
        VerifyOrReturn(CheckConstraintNotValue("octetString", octetString, readAttributeOctetStringDefaultValue));

        if (readAttributeOctetStringNotDefaultValueBuffer != nullptr)
        {
            chip::Platform::MemoryFree(readAttributeOctetStringNotDefaultValueBuffer);
        }
        readAttributeOctetStringNotDefaultValueBuffer = static_cast<uint8_t *>(chip::Platform::MemoryAlloc(octetString.size()));
        memcpy(readAttributeOctetStringNotDefaultValueBuffer, octetString.data(), octetString.size());
        readAttributeOctetStringNotDefaultValue = chip::ByteSpan(readAttributeOctetStringNotDefaultValueBuffer, octetString.size());
        NextTest();
    }

    CHIP_ERROR TestReadAttributeOctetStringNotDefaultValueAndCompareToSavedValue_106()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::OctetString::TypeInfo>(
            this, OnSuccessCallback_106, OnFailureCallback_106, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_106(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_106(chip::ByteSpan octetString)
    {
        VerifyOrReturn(CheckValueAsString("octetString", octetString, readAttributeOctetStringNotDefaultValue));
        VerifyOrReturn(CheckConstraintNotValue("octetString", octetString, readAttributeOctetStringDefaultValue));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeOctetStringNotDefaultValueFromSavedValue_107()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::ByteSpan octetStringArgument;
        octetStringArgument = readAttributeOctetStringNotDefaultValue;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::OctetString::TypeInfo>(
            octetStringArgument, this, OnSuccessCallback_107, OnFailureCallback_107));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_107(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_107() { NextTest(); }

    CHIP_ERROR TestReadAttributeOctetStringNotDefaultValueAndCompareToExpectedValue_108()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::OctetString::TypeInfo>(
            this, OnSuccessCallback_108, OnFailureCallback_108, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_108(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_108(chip::ByteSpan octetString)
    {
        VerifyOrReturn(
            CheckValueAsString("octetString", octetString, chip::ByteSpan(chip::Uint8::from_const_char("NotDefault"), 10)));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeOctetStringDefaultValue_109()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::ByteSpan octetStringArgument;
        octetStringArgument = readAttributeOctetStringDefaultValue;

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::OctetString::TypeInfo>(
            octetStringArgument, this, OnSuccessCallback_109, OnFailureCallback_109));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_109(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_109() { NextTest(); }
};

class TestConfigVariablesSuite : public TestCommand
{
public:
    TestConfigVariablesSuite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("TestConfigVariables", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("arg1", 0, UINT8_MAX, &mArg1);
        AddArgument("returnValueWithArg1", 0, UINT8_MAX, &mReturnValueWithArg1);
    }

    ~TestConfigVariablesSuite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestConfigVariables\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestConfigVariables\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Send Test Add Arguments Command\n");
            err = TestSendTestAddArgumentsCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Send Test Add Arguments Command\n");
            err = TestSendTestAddArgumentsCommand_2();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 3;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint8_t> mArg1;
    chip::Optional<uint8_t> mReturnValueWithArg1;

    uint8_t TestAddArgumentDefaultValue;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestSendTestAddArgumentsCommand_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::TestAddArguments::Type;

        RequestType request;
        request.arg1 = 3;
        request.arg2 = 17;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestConfigVariablesSuite *>(context))->OnSuccessResponse_1(data.returnValue);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestConfigVariablesSuite *>(context))->OnFailureResponse_1(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1(uint8_t returnValue)
    {
        VerifyOrReturn(CheckValue("returnValue", returnValue, 20));

        TestAddArgumentDefaultValue = returnValue;
        NextTest();
    }

    CHIP_ERROR TestSendTestAddArgumentsCommand_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::TestAddArguments::Type;

        RequestType request;
        request.arg1 = mArg1.HasValue() ? mArg1.Value() : 5;
        request.arg2 = TestAddArgumentDefaultValue;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestConfigVariablesSuite *>(context))->OnSuccessResponse_2(data.returnValue);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestConfigVariablesSuite *>(context))->OnFailureResponse_2(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2(uint8_t returnValue)
    {
        VerifyOrReturn(CheckValue("returnValue", returnValue, mReturnValueWithArg1.HasValue() ? mReturnValueWithArg1.Value() : 25));

        NextTest();
    }
};

class TestDescriptorClusterSuite : public TestCommand
{
public:
    TestDescriptorClusterSuite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("TestDescriptorCluster", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~TestDescriptorClusterSuite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestDescriptorCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestDescriptorCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read attribute Device list\n");
            err = TestReadAttributeDeviceList_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read attribute Server list\n");
            err = TestReadAttributeServerList_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read attribute Client list\n");
            err = TestReadAttributeClientList_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Read attribute Parts list\n");
            err = TestReadAttributePartsList_4();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 5;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_1(void * context, CHIP_ERROR error)
    {
        (static_cast<TestDescriptorClusterSuite *>(context))->OnFailureResponse_1(error);
    }

    static void OnSuccessCallback_1(
        void * context,
        const chip::app::DataModel::DecodableList<chip::app::Clusters::Descriptor::Structs::DeviceType::DecodableType> & deviceList)
    {
        (static_cast<TestDescriptorClusterSuite *>(context))->OnSuccessResponse_1(deviceList);
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<TestDescriptorClusterSuite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context, const chip::app::DataModel::DecodableList<chip::ClusterId> & serverList)
    {
        (static_cast<TestDescriptorClusterSuite *>(context))->OnSuccessResponse_2(serverList);
    }

    static void OnFailureCallback_3(void * context, CHIP_ERROR error)
    {
        (static_cast<TestDescriptorClusterSuite *>(context))->OnFailureResponse_3(error);
    }

    static void OnSuccessCallback_3(void * context, const chip::app::DataModel::DecodableList<chip::ClusterId> & clientList)
    {
        (static_cast<TestDescriptorClusterSuite *>(context))->OnSuccessResponse_3(clientList);
    }

    static void OnFailureCallback_4(void * context, CHIP_ERROR error)
    {
        (static_cast<TestDescriptorClusterSuite *>(context))->OnFailureResponse_4(error);
    }

    static void OnSuccessCallback_4(void * context, const chip::app::DataModel::DecodableList<chip::EndpointId> & partsList)
    {
        (static_cast<TestDescriptorClusterSuite *>(context))->OnSuccessResponse_4(partsList);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestReadAttributeDeviceList_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        chip::Controller::DescriptorClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Descriptor::Attributes::DeviceList::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1(
        const chip::app::DataModel::DecodableList<chip::app::Clusters::Descriptor::Structs::DeviceType::DecodableType> & deviceList)
    {
        {
            auto iter_0 = deviceList.begin();
            VerifyOrReturn(CheckNextListItemDecodes<decltype(deviceList)>("deviceList", iter_0, 0));
            VerifyOrReturn(CheckValue("deviceList[0].type", iter_0.GetValue().type, 22UL));
            VerifyOrReturn(CheckValue("deviceList[0].revision", iter_0.GetValue().revision, 1U));
            VerifyOrReturn(CheckNoMoreListItems<decltype(deviceList)>("deviceList", iter_0, 1));
        }

        NextTest();
    }

    CHIP_ERROR TestReadAttributeServerList_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        chip::Controller::DescriptorClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Descriptor::Attributes::ServerList::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2(const chip::app::DataModel::DecodableList<chip::ClusterId> & serverList)
    {
        {
            auto iter_0 = serverList.begin();
            VerifyOrReturn(CheckNextListItemDecodes<decltype(serverList)>("serverList", iter_0, 0));
            VerifyOrReturn(CheckValue("serverList[0]", iter_0.GetValue(), 3UL));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(serverList)>("serverList", iter_0, 1));
            VerifyOrReturn(CheckValue("serverList[1]", iter_0.GetValue(), 4UL));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(serverList)>("serverList", iter_0, 2));
            VerifyOrReturn(CheckValue("serverList[2]", iter_0.GetValue(), 29UL));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(serverList)>("serverList", iter_0, 3));
            VerifyOrReturn(CheckValue("serverList[3]", iter_0.GetValue(), 30UL));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(serverList)>("serverList", iter_0, 4));
            VerifyOrReturn(CheckValue("serverList[4]", iter_0.GetValue(), 31UL));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(serverList)>("serverList", iter_0, 5));
            VerifyOrReturn(CheckValue("serverList[5]", iter_0.GetValue(), 40UL));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(serverList)>("serverList", iter_0, 6));
            VerifyOrReturn(CheckValue("serverList[6]", iter_0.GetValue(), 42UL));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(serverList)>("serverList", iter_0, 7));
            VerifyOrReturn(CheckValue("serverList[7]", iter_0.GetValue(), 43UL));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(serverList)>("serverList", iter_0, 8));
            VerifyOrReturn(CheckValue("serverList[8]", iter_0.GetValue(), 44UL));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(serverList)>("serverList", iter_0, 9));
            VerifyOrReturn(CheckValue("serverList[9]", iter_0.GetValue(), 45UL));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(serverList)>("serverList", iter_0, 10));
            VerifyOrReturn(CheckValue("serverList[10]", iter_0.GetValue(), 46UL));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(serverList)>("serverList", iter_0, 11));
            VerifyOrReturn(CheckValue("serverList[11]", iter_0.GetValue(), 48UL));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(serverList)>("serverList", iter_0, 12));
            VerifyOrReturn(CheckValue("serverList[12]", iter_0.GetValue(), 49UL));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(serverList)>("serverList", iter_0, 13));
            VerifyOrReturn(CheckValue("serverList[13]", iter_0.GetValue(), 50UL));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(serverList)>("serverList", iter_0, 14));
            VerifyOrReturn(CheckValue("serverList[14]", iter_0.GetValue(), 51UL));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(serverList)>("serverList", iter_0, 15));
            VerifyOrReturn(CheckValue("serverList[15]", iter_0.GetValue(), 52UL));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(serverList)>("serverList", iter_0, 16));
            VerifyOrReturn(CheckValue("serverList[16]", iter_0.GetValue(), 53UL));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(serverList)>("serverList", iter_0, 17));
            VerifyOrReturn(CheckValue("serverList[17]", iter_0.GetValue(), 54UL));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(serverList)>("serverList", iter_0, 18));
            VerifyOrReturn(CheckValue("serverList[18]", iter_0.GetValue(), 55UL));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(serverList)>("serverList", iter_0, 19));
            VerifyOrReturn(CheckValue("serverList[19]", iter_0.GetValue(), 60UL));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(serverList)>("serverList", iter_0, 20));
            VerifyOrReturn(CheckValue("serverList[20]", iter_0.GetValue(), 62UL));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(serverList)>("serverList", iter_0, 21));
            VerifyOrReturn(CheckValue("serverList[21]", iter_0.GetValue(), 63UL));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(serverList)>("serverList", iter_0, 22));
            VerifyOrReturn(CheckValue("serverList[22]", iter_0.GetValue(), 64UL));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(serverList)>("serverList", iter_0, 23));
            VerifyOrReturn(CheckValue("serverList[23]", iter_0.GetValue(), 65UL));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(serverList)>("serverList", iter_0, 24));
            VerifyOrReturn(CheckValue("serverList[24]", iter_0.GetValue(), 1029UL));
            VerifyOrReturn(CheckNoMoreListItems<decltype(serverList)>("serverList", iter_0, 25));
        }

        NextTest();
    }

    CHIP_ERROR TestReadAttributeClientList_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        chip::Controller::DescriptorClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Descriptor::Attributes::ClientList::TypeInfo>(
            this, OnSuccessCallback_3, OnFailureCallback_3, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3(const chip::app::DataModel::DecodableList<chip::ClusterId> & clientList)
    {
        {
            auto iter_0 = clientList.begin();
            VerifyOrReturn(CheckNextListItemDecodes<decltype(clientList)>("clientList", iter_0, 0));
            VerifyOrReturn(CheckValue("clientList[0]", iter_0.GetValue(), 41UL));
            VerifyOrReturn(CheckNoMoreListItems<decltype(clientList)>("clientList", iter_0, 1));
        }

        NextTest();
    }

    CHIP_ERROR TestReadAttributePartsList_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        chip::Controller::DescriptorClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Descriptor::Attributes::PartsList::TypeInfo>(
            this, OnSuccessCallback_4, OnFailureCallback_4, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_4(const chip::app::DataModel::DecodableList<chip::EndpointId> & partsList)
    {
        {
            auto iter_0 = partsList.begin();
            VerifyOrReturn(CheckNextListItemDecodes<decltype(partsList)>("partsList", iter_0, 0));
            VerifyOrReturn(CheckValue("partsList[0]", iter_0.GetValue(), 1U));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(partsList)>("partsList", iter_0, 1));
            VerifyOrReturn(CheckValue("partsList[1]", iter_0.GetValue(), 2U));
            VerifyOrReturn(CheckNoMoreListItems<decltype(partsList)>("partsList", iter_0, 2));
        }

        NextTest();
    }
};

class TestBasicInformationSuite : public TestCommand
{
public:
    TestBasicInformationSuite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("TestBasicInformation", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~TestBasicInformationSuite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestBasicInformation\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestBasicInformation\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read location\n");
            err = TestReadLocation_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Write location\n");
            err = TestWriteLocation_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read back location\n");
            err = TestReadBackLocation_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Restore initial location value\n");
            err = TestRestoreInitialLocationValue_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Read AttributeList value\n");
            err = TestReadAttributeListValue_5();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 6;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_1(void * context, CHIP_ERROR error)
    {
        (static_cast<TestBasicInformationSuite *>(context))->OnFailureResponse_1(error);
    }

    static void OnSuccessCallback_1(void * context, chip::CharSpan location)
    {
        (static_cast<TestBasicInformationSuite *>(context))->OnSuccessResponse_1(location);
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<TestBasicInformationSuite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context) { (static_cast<TestBasicInformationSuite *>(context))->OnSuccessResponse_2(); }

    static void OnFailureCallback_3(void * context, CHIP_ERROR error)
    {
        (static_cast<TestBasicInformationSuite *>(context))->OnFailureResponse_3(error);
    }

    static void OnSuccessCallback_3(void * context, chip::CharSpan location)
    {
        (static_cast<TestBasicInformationSuite *>(context))->OnSuccessResponse_3(location);
    }

    static void OnFailureCallback_4(void * context, CHIP_ERROR error)
    {
        (static_cast<TestBasicInformationSuite *>(context))->OnFailureResponse_4(error);
    }

    static void OnSuccessCallback_4(void * context) { (static_cast<TestBasicInformationSuite *>(context))->OnSuccessResponse_4(); }

    static void OnFailureCallback_5(void * context, CHIP_ERROR error)
    {
        (static_cast<TestBasicInformationSuite *>(context))->OnFailureResponse_5(error);
    }

    static void OnSuccessCallback_5(void * context, const chip::app::DataModel::DecodableList<chip::AttributeId> & attributeList)
    {
        (static_cast<TestBasicInformationSuite *>(context))->OnSuccessResponse_5(attributeList);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestReadLocation_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Basic::Attributes::Location::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1(chip::CharSpan location)
    {
        VerifyOrReturn(CheckValueAsString("location", location, chip::CharSpan("XX", 2)));

        NextTest();
    }

    CHIP_ERROR TestWriteLocation_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::CharSpan locationArgument;
        locationArgument = chip::Span<const char>("USgarbage: not in length on purpose", 2);

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::Basic::Attributes::Location::TypeInfo>(
            locationArgument, this, OnSuccessCallback_2, OnFailureCallback_2));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestReadBackLocation_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Basic::Attributes::Location::TypeInfo>(
            this, OnSuccessCallback_3, OnFailureCallback_3, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3(chip::CharSpan location)
    {
        VerifyOrReturn(CheckValueAsString("location", location, chip::CharSpan("US", 2)));

        NextTest();
    }

    CHIP_ERROR TestRestoreInitialLocationValue_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::CharSpan locationArgument;
        locationArgument = chip::Span<const char>("XXgarbage: not in length on purpose", 2);

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::Basic::Attributes::Location::TypeInfo>(
            locationArgument, this, OnSuccessCallback_4, OnFailureCallback_4));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestReadAttributeListValue_5()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Basic::Attributes::AttributeList::TypeInfo>(
            this, OnSuccessCallback_5, OnFailureCallback_5, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_5(const chip::app::DataModel::DecodableList<chip::AttributeId> & attributeList)
    {
        {
            auto iter_0 = attributeList.begin();
            VerifyOrReturn(CheckNextListItemDecodes<decltype(attributeList)>("attributeList", iter_0, 0));
            VerifyOrReturn(CheckValue("attributeList[0]", iter_0.GetValue(), 0UL));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(attributeList)>("attributeList", iter_0, 1));
            VerifyOrReturn(CheckValue("attributeList[1]", iter_0.GetValue(), 1UL));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(attributeList)>("attributeList", iter_0, 2));
            VerifyOrReturn(CheckValue("attributeList[2]", iter_0.GetValue(), 2UL));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(attributeList)>("attributeList", iter_0, 3));
            VerifyOrReturn(CheckValue("attributeList[3]", iter_0.GetValue(), 3UL));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(attributeList)>("attributeList", iter_0, 4));
            VerifyOrReturn(CheckValue("attributeList[4]", iter_0.GetValue(), 4UL));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(attributeList)>("attributeList", iter_0, 5));
            VerifyOrReturn(CheckValue("attributeList[5]", iter_0.GetValue(), 5UL));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(attributeList)>("attributeList", iter_0, 6));
            VerifyOrReturn(CheckValue("attributeList[6]", iter_0.GetValue(), 6UL));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(attributeList)>("attributeList", iter_0, 7));
            VerifyOrReturn(CheckValue("attributeList[7]", iter_0.GetValue(), 7UL));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(attributeList)>("attributeList", iter_0, 8));
            VerifyOrReturn(CheckValue("attributeList[8]", iter_0.GetValue(), 8UL));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(attributeList)>("attributeList", iter_0, 9));
            VerifyOrReturn(CheckValue("attributeList[9]", iter_0.GetValue(), 9UL));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(attributeList)>("attributeList", iter_0, 10));
            VerifyOrReturn(CheckValue("attributeList[10]", iter_0.GetValue(), 10UL));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(attributeList)>("attributeList", iter_0, 11));
            VerifyOrReturn(CheckValue("attributeList[11]", iter_0.GetValue(), 11UL));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(attributeList)>("attributeList", iter_0, 12));
            VerifyOrReturn(CheckValue("attributeList[12]", iter_0.GetValue(), 12UL));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(attributeList)>("attributeList", iter_0, 13));
            VerifyOrReturn(CheckValue("attributeList[13]", iter_0.GetValue(), 13UL));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(attributeList)>("attributeList", iter_0, 14));
            VerifyOrReturn(CheckValue("attributeList[14]", iter_0.GetValue(), 14UL));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(attributeList)>("attributeList", iter_0, 15));
            VerifyOrReturn(CheckValue("attributeList[15]", iter_0.GetValue(), 15UL));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(attributeList)>("attributeList", iter_0, 16));
            VerifyOrReturn(CheckValue("attributeList[16]", iter_0.GetValue(), 16UL));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(attributeList)>("attributeList", iter_0, 17));
            VerifyOrReturn(CheckValue("attributeList[17]", iter_0.GetValue(), 17UL));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(attributeList)>("attributeList", iter_0, 18));
            VerifyOrReturn(CheckValue("attributeList[18]", iter_0.GetValue(), 18UL));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(attributeList)>("attributeList", iter_0, 19));
            VerifyOrReturn(CheckValue("attributeList[19]", iter_0.GetValue(), 65528UL));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(attributeList)>("attributeList", iter_0, 20));
            VerifyOrReturn(CheckValue("attributeList[20]", iter_0.GetValue(), 65529UL));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(attributeList)>("attributeList", iter_0, 21));
            VerifyOrReturn(CheckValue("attributeList[21]", iter_0.GetValue(), 65531UL));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(attributeList)>("attributeList", iter_0, 22));
            VerifyOrReturn(CheckValue("attributeList[22]", iter_0.GetValue(), 65533UL));
            VerifyOrReturn(CheckNoMoreListItems<decltype(attributeList)>("attributeList", iter_0, 23));
        }

        NextTest();
    }
};

class TestIdentifyClusterSuite : public TestCommand
{
public:
    TestIdentifyClusterSuite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("TestIdentifyCluster", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~TestIdentifyClusterSuite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestIdentifyCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestIdentifyCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Send Identify command and expect success response\n");
            err = TestSendIdentifyCommandAndExpectSuccessResponse_1();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 2;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestSendIdentifyCommandAndExpectSuccessResponse_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        using RequestType               = chip::app::Clusters::Identify::Commands::Identify::Type;

        RequestType request;
        request.identifyTime = 0U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestIdentifyClusterSuite *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestIdentifyClusterSuite *>(context))->OnFailureResponse_1(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1() { NextTest(); }
};

class TestOperationalCredentialsClusterSuite : public TestCommand
{
public:
    TestOperationalCredentialsClusterSuite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("TestOperationalCredentialsCluster", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~TestOperationalCredentialsClusterSuite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestOperationalCredentialsCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestOperationalCredentialsCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read number of supported fabrics\n");
            err = TestReadNumberOfSupportedFabrics_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read number of commissioned fabrics\n");
            err = TestReadNumberOfCommissionedFabrics_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read current fabric index\n");
            err = TestReadCurrentFabricIndex_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Remove nonexistent fabric\n");
            err = TestRemoveNonexistentFabric_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Read fabric list before setting label\n");
            err = TestReadFabricListBeforeSettingLabel_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Set the fabric label\n");
            err = TestSetTheFabricLabel_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Read fabric list after setting label\n");
            err = TestReadFabricListAfterSettingLabel_7();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 8;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::FabricIndex ourFabricIndex;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_1(void * context, CHIP_ERROR error)
    {
        (static_cast<TestOperationalCredentialsClusterSuite *>(context))->OnFailureResponse_1(error);
    }

    static void OnSuccessCallback_1(void * context, uint8_t supportedFabrics)
    {
        (static_cast<TestOperationalCredentialsClusterSuite *>(context))->OnSuccessResponse_1(supportedFabrics);
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<TestOperationalCredentialsClusterSuite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context, uint8_t commissionedFabrics)
    {
        (static_cast<TestOperationalCredentialsClusterSuite *>(context))->OnSuccessResponse_2(commissionedFabrics);
    }

    static void OnFailureCallback_3(void * context, CHIP_ERROR error)
    {
        (static_cast<TestOperationalCredentialsClusterSuite *>(context))->OnFailureResponse_3(error);
    }

    static void OnSuccessCallback_3(void * context, chip::FabricIndex currentFabricIndex)
    {
        (static_cast<TestOperationalCredentialsClusterSuite *>(context))->OnSuccessResponse_3(currentFabricIndex);
    }

    static void OnFailureCallback_5(void * context, CHIP_ERROR error)
    {
        (static_cast<TestOperationalCredentialsClusterSuite *>(context))->OnFailureResponse_5(error);
    }

    static void
    OnSuccessCallback_5(void * context,
                        const chip::app::DataModel::DecodableList<
                            chip::app::Clusters::OperationalCredentials::Structs::FabricDescriptor::DecodableType> & fabrics)
    {
        (static_cast<TestOperationalCredentialsClusterSuite *>(context))->OnSuccessResponse_5(fabrics);
    }

    static void OnFailureCallback_7(void * context, CHIP_ERROR error)
    {
        (static_cast<TestOperationalCredentialsClusterSuite *>(context))->OnFailureResponse_7(error);
    }

    static void
    OnSuccessCallback_7(void * context,
                        const chip::app::DataModel::DecodableList<
                            chip::app::Clusters::OperationalCredentials::Structs::FabricDescriptor::DecodableType> & fabrics)
    {
        (static_cast<TestOperationalCredentialsClusterSuite *>(context))->OnSuccessResponse_7(fabrics);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestReadNumberOfSupportedFabrics_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        chip::Controller::OperationalCredentialsClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::OperationalCredentials::Attributes::SupportedFabrics::TypeInfo>(
                this, OnSuccessCallback_1, OnFailureCallback_1, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1(uint8_t supportedFabrics)
    {
        VerifyOrReturn(CheckConstraintType("supportedFabrics", "", "uint8"));
        VerifyOrReturn(CheckConstraintMinValue<uint8_t>("supportedFabrics", supportedFabrics, 4));
        NextTest();
    }

    CHIP_ERROR TestReadNumberOfCommissionedFabrics_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        chip::Controller::OperationalCredentialsClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::OperationalCredentials::Attributes::CommissionedFabrics::TypeInfo>(
                this, OnSuccessCallback_2, OnFailureCallback_2, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2(uint8_t commissionedFabrics)
    {
        VerifyOrReturn(CheckConstraintType("commissionedFabrics", "", "uint8"));
        VerifyOrReturn(CheckConstraintMinValue<uint8_t>("commissionedFabrics", commissionedFabrics, 1));
        NextTest();
    }

    CHIP_ERROR TestReadCurrentFabricIndex_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        chip::Controller::OperationalCredentialsClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::OperationalCredentials::Attributes::CurrentFabricIndex::TypeInfo>(
                this, OnSuccessCallback_3, OnFailureCallback_3, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3(chip::FabricIndex currentFabricIndex)
    {
        VerifyOrReturn(CheckConstraintType("currentFabricIndex", "", "uint8"));
        VerifyOrReturn(CheckConstraintMinValue<chip::FabricIndex>("currentFabricIndex", currentFabricIndex, 1));
        ourFabricIndex = currentFabricIndex;
        NextTest();
    }

    CHIP_ERROR TestRemoveNonexistentFabric_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        using RequestType               = chip::app::Clusters::OperationalCredentials::Commands::RemoveFabric::Type;

        RequestType request;
        request.fabricIndex = 243;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestOperationalCredentialsClusterSuite *>(context))
                ->OnSuccessResponse_4(data.statusCode, data.fabricIndex, data.debugText);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestOperationalCredentialsClusterSuite *>(context))->OnFailureResponse_4(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_4(chip::app::Clusters::OperationalCredentials::OperationalCertStatus statusCode,
                             const chip::Optional<chip::FabricIndex> & fabricIndex,
                             const chip::Optional<chip::CharSpan> & debugText)
    {
        VerifyOrReturn(CheckValue("statusCode", statusCode, 11));

        NextTest();
    }

    CHIP_ERROR TestReadFabricListBeforeSettingLabel_5()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        chip::Controller::OperationalCredentialsClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OperationalCredentials::Attributes::Fabrics::TypeInfo>(
            this, OnSuccessCallback_5, OnFailureCallback_5, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_5(const chip::app::DataModel::DecodableList<
                             chip::app::Clusters::OperationalCredentials::Structs::FabricDescriptor::DecodableType> & fabrics)
    {
        {
            auto iter_0 = fabrics.begin();
            VerifyOrReturn(CheckNextListItemDecodes<decltype(fabrics)>("fabrics", iter_0, 0));
            VerifyOrReturn(CheckValue("fabrics[0].fabricIndex", iter_0.GetValue().fabricIndex, ourFabricIndex));
            VerifyOrReturn(CheckValueAsString("fabrics[0].label", iter_0.GetValue().label, chip::CharSpan("", 0)));
            VerifyOrReturn(CheckNoMoreListItems<decltype(fabrics)>("fabrics", iter_0, 1));
        }

        NextTest();
    }

    CHIP_ERROR TestSetTheFabricLabel_6()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        using RequestType               = chip::app::Clusters::OperationalCredentials::Commands::UpdateFabricLabel::Type;

        RequestType request;
        request.label = chip::Span<const char>("Batcavegarbage: not in length on purpose", 7);

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestOperationalCredentialsClusterSuite *>(context))
                ->OnSuccessResponse_6(data.statusCode, data.fabricIndex, data.debugText);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestOperationalCredentialsClusterSuite *>(context))->OnFailureResponse_6(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_6(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_6(chip::app::Clusters::OperationalCredentials::OperationalCertStatus statusCode,
                             const chip::Optional<chip::FabricIndex> & fabricIndex,
                             const chip::Optional<chip::CharSpan> & debugText)
    {
        VerifyOrReturn(CheckValue("statusCode", statusCode, 0));

        VerifyOrReturn(CheckValuePresent("fabricIndex", fabricIndex));
        VerifyOrReturn(CheckValue("fabricIndex.Value()", fabricIndex.Value(), ourFabricIndex));

        NextTest();
    }

    CHIP_ERROR TestReadFabricListAfterSettingLabel_7()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        chip::Controller::OperationalCredentialsClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OperationalCredentials::Attributes::Fabrics::TypeInfo>(
            this, OnSuccessCallback_7, OnFailureCallback_7, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_7(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_7(const chip::app::DataModel::DecodableList<
                             chip::app::Clusters::OperationalCredentials::Structs::FabricDescriptor::DecodableType> & fabrics)
    {
        {
            auto iter_0 = fabrics.begin();
            VerifyOrReturn(CheckNextListItemDecodes<decltype(fabrics)>("fabrics", iter_0, 0));
            VerifyOrReturn(CheckValue("fabrics[0].fabricIndex", iter_0.GetValue().fabricIndex, ourFabricIndex));
            VerifyOrReturn(CheckValueAsString("fabrics[0].label", iter_0.GetValue().label, chip::CharSpan("Batcave", 7)));
            VerifyOrReturn(CheckNoMoreListItems<decltype(fabrics)>("fabrics", iter_0, 1));
        }

        NextTest();
    }
};

class TestModeSelectClusterSuite : public TestCommand
{
public:
    TestModeSelectClusterSuite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("TestModeSelectCluster", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~TestModeSelectClusterSuite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestModeSelectCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestModeSelectCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read CurrentMode\n");
            err = TestReadCurrentMode_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read OnMode\n");
            err = TestReadOnMode_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read StartUpMode\n");
            err = TestReadStartUpMode_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Read Description\n");
            err = TestReadDescription_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Read SupportedModes\n");
            err = TestReadSupportedModes_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Change to Supported Mode\n");
            err = TestChangeToSupportedMode_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Verify Current Mode Change\n");
            err = TestVerifyCurrentModeChange_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Change to Unsupported Mode\n");
            err = TestChangeToUnsupportedMode_8();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 9;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_1(void * context, CHIP_ERROR error)
    {
        (static_cast<TestModeSelectClusterSuite *>(context))->OnFailureResponse_1(error);
    }

    static void OnSuccessCallback_1(void * context, uint8_t currentMode)
    {
        (static_cast<TestModeSelectClusterSuite *>(context))->OnSuccessResponse_1(currentMode);
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<TestModeSelectClusterSuite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context, uint8_t onMode)
    {
        (static_cast<TestModeSelectClusterSuite *>(context))->OnSuccessResponse_2(onMode);
    }

    static void OnFailureCallback_3(void * context, CHIP_ERROR error)
    {
        (static_cast<TestModeSelectClusterSuite *>(context))->OnFailureResponse_3(error);
    }

    static void OnSuccessCallback_3(void * context, uint8_t startUpMode)
    {
        (static_cast<TestModeSelectClusterSuite *>(context))->OnSuccessResponse_3(startUpMode);
    }

    static void OnFailureCallback_4(void * context, CHIP_ERROR error)
    {
        (static_cast<TestModeSelectClusterSuite *>(context))->OnFailureResponse_4(error);
    }

    static void OnSuccessCallback_4(void * context, chip::CharSpan description)
    {
        (static_cast<TestModeSelectClusterSuite *>(context))->OnSuccessResponse_4(description);
    }

    static void OnFailureCallback_5(void * context, CHIP_ERROR error)
    {
        (static_cast<TestModeSelectClusterSuite *>(context))->OnFailureResponse_5(error);
    }

    static void OnSuccessCallback_5(
        void * context,
        const chip::app::DataModel::DecodableList<chip::app::Clusters::ModeSelect::Structs::ModeOptionStruct::DecodableType> &
            supportedModes)
    {
        (static_cast<TestModeSelectClusterSuite *>(context))->OnSuccessResponse_5(supportedModes);
    }

    static void OnFailureCallback_7(void * context, CHIP_ERROR error)
    {
        (static_cast<TestModeSelectClusterSuite *>(context))->OnFailureResponse_7(error);
    }

    static void OnSuccessCallback_7(void * context, uint8_t currentMode)
    {
        (static_cast<TestModeSelectClusterSuite *>(context))->OnSuccessResponse_7(currentMode);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestReadCurrentMode_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ModeSelectClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ModeSelect::Attributes::CurrentMode::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1(uint8_t currentMode)
    {
        VerifyOrReturn(CheckValue("currentMode", currentMode, 0));

        NextTest();
    }

    CHIP_ERROR TestReadOnMode_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ModeSelectClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ModeSelect::Attributes::OnMode::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2(uint8_t onMode)
    {
        VerifyOrReturn(CheckValue("onMode", onMode, 0));

        NextTest();
    }

    CHIP_ERROR TestReadStartUpMode_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ModeSelectClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ModeSelect::Attributes::StartUpMode::TypeInfo>(
            this, OnSuccessCallback_3, OnFailureCallback_3, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3(uint8_t startUpMode)
    {
        VerifyOrReturn(CheckValue("startUpMode", startUpMode, 0));

        NextTest();
    }

    CHIP_ERROR TestReadDescription_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ModeSelectClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ModeSelect::Attributes::Description::TypeInfo>(
            this, OnSuccessCallback_4, OnFailureCallback_4, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_4(chip::CharSpan description)
    {
        VerifyOrReturn(CheckValueAsString("description", description, chip::CharSpan("Coffee", 6)));

        NextTest();
    }

    CHIP_ERROR TestReadSupportedModes_5()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ModeSelectClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ModeSelect::Attributes::SupportedModes::TypeInfo>(
            this, OnSuccessCallback_5, OnFailureCallback_5, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_5(
        const chip::app::DataModel::DecodableList<chip::app::Clusters::ModeSelect::Structs::ModeOptionStruct::DecodableType> &
            supportedModes)
    {
        {
            auto iter_0 = supportedModes.begin();
            VerifyOrReturn(CheckNextListItemDecodes<decltype(supportedModes)>("supportedModes", iter_0, 0));
            VerifyOrReturn(CheckValueAsString("supportedModes[0].label", iter_0.GetValue().label, chip::CharSpan("Black", 5)));
            VerifyOrReturn(CheckValue("supportedModes[0].mode", iter_0.GetValue().mode, 0));
            VerifyOrReturn(CheckValue("supportedModes[0].semanticTag", iter_0.GetValue().semanticTag, 0UL));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(supportedModes)>("supportedModes", iter_0, 1));
            VerifyOrReturn(
                CheckValueAsString("supportedModes[1].label", iter_0.GetValue().label, chip::CharSpan("Cappuccino", 10)));
            VerifyOrReturn(CheckValue("supportedModes[1].mode", iter_0.GetValue().mode, 4));
            VerifyOrReturn(CheckValue("supportedModes[1].semanticTag", iter_0.GetValue().semanticTag, 0UL));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(supportedModes)>("supportedModes", iter_0, 2));
            VerifyOrReturn(CheckValueAsString("supportedModes[2].label", iter_0.GetValue().label, chip::CharSpan("Espresso", 8)));
            VerifyOrReturn(CheckValue("supportedModes[2].mode", iter_0.GetValue().mode, 7));
            VerifyOrReturn(CheckValue("supportedModes[2].semanticTag", iter_0.GetValue().semanticTag, 0UL));
            VerifyOrReturn(CheckNoMoreListItems<decltype(supportedModes)>("supportedModes", iter_0, 3));
        }

        NextTest();
    }

    CHIP_ERROR TestChangeToSupportedMode_6()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::ModeSelect::Commands::ChangeToMode::Type;

        RequestType request;
        request.newMode = 4;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestModeSelectClusterSuite *>(context))->OnSuccessResponse_6();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestModeSelectClusterSuite *>(context))->OnFailureResponse_6(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_6(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_6() { NextTest(); }

    CHIP_ERROR TestVerifyCurrentModeChange_7()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::ModeSelectClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::ModeSelect::Attributes::CurrentMode::TypeInfo>(
            this, OnSuccessCallback_7, OnFailureCallback_7, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_7(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_7(uint8_t currentMode)
    {
        VerifyOrReturn(CheckValue("currentMode", currentMode, 4));

        NextTest();
    }

    CHIP_ERROR TestChangeToUnsupportedMode_8()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::ModeSelect::Commands::ChangeToMode::Type;

        RequestType request;
        request.newMode = 2;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestModeSelectClusterSuite *>(context))->OnSuccessResponse_8();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestModeSelectClusterSuite *>(context))->OnFailureResponse_8(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_8(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
        NextTest();
    }

    void OnSuccessResponse_8() { ThrowSuccessResponse(); }
};

class TestSystemCommandsSuite : public TestCommand
{
public:
    TestSystemCommandsSuite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("TestSystemCommands", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~TestSystemCommandsSuite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestSystemCommands\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestSystemCommands\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Stop the accessory\n");
            err = TestStopTheAccessory_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Start the accessory with a given discriminator\n");
            err = TestStartTheAccessoryWithAGivenDiscriminator_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Reboot the accessory with an other given discriminator\n");
            err = TestRebootTheAccessoryWithAnOtherGivenDiscriminator_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Factory Reset the accessory\n");
            err = TestFactoryResetTheAccessory_4();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 5;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestStopTheAccessory_1()
    {
        SetIdentity(kIdentityAlpha);
        return Stop();
    }

    CHIP_ERROR TestStartTheAccessoryWithAGivenDiscriminator_2()
    {
        SetIdentity(kIdentityAlpha);
        return Start(1111);
    }

    CHIP_ERROR TestRebootTheAccessoryWithAnOtherGivenDiscriminator_3()
    {
        SetIdentity(kIdentityAlpha);
        return Reboot(2222);
    }

    CHIP_ERROR TestFactoryResetTheAccessory_4()
    {
        SetIdentity(kIdentityAlpha);
        return FactoryReset();
    }
};

class TestBindingSuite : public TestCommand
{
public:
    TestBindingSuite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("TestBinding", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~TestBindingSuite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestBinding\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestBinding\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Write empty binding table\n");
            err = TestWriteEmptyBindingTable_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read empty binding table\n");
            err = TestReadEmptyBindingTable_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Write invalid binding table\n");
            err = TestWriteInvalidBindingTable_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Write binding table\n");
            err = TestWriteBindingTable_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Read binding table\n");
            err = TestReadBindingTable_5();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 6;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_1(void * context, CHIP_ERROR error)
    {
        (static_cast<TestBindingSuite *>(context))->OnFailureResponse_1(error);
    }

    static void OnSuccessCallback_1(void * context) { (static_cast<TestBindingSuite *>(context))->OnSuccessResponse_1(); }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<TestBindingSuite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(
        void * context,
        const chip::app::DataModel::DecodableList<chip::app::Clusters::Binding::Structs::TargetStruct::DecodableType> & binding)
    {
        (static_cast<TestBindingSuite *>(context))->OnSuccessResponse_2(binding);
    }

    static void OnFailureCallback_3(void * context, CHIP_ERROR error)
    {
        (static_cast<TestBindingSuite *>(context))->OnFailureResponse_3(error);
    }

    static void OnSuccessCallback_3(void * context) { (static_cast<TestBindingSuite *>(context))->OnSuccessResponse_3(); }

    static void OnFailureCallback_4(void * context, CHIP_ERROR error)
    {
        (static_cast<TestBindingSuite *>(context))->OnFailureResponse_4(error);
    }

    static void OnSuccessCallback_4(void * context) { (static_cast<TestBindingSuite *>(context))->OnSuccessResponse_4(); }

    static void OnFailureCallback_5(void * context, CHIP_ERROR error)
    {
        (static_cast<TestBindingSuite *>(context))->OnFailureResponse_5(error);
    }

    static void OnSuccessCallback_5(
        void * context,
        const chip::app::DataModel::DecodableList<chip::app::Clusters::Binding::Structs::TargetStruct::DecodableType> & binding)
    {
        (static_cast<TestBindingSuite *>(context))->OnSuccessResponse_5(binding);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestWriteEmptyBindingTable_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::BindingClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ListFreer listFreer;
        chip::app::DataModel::List<const chip::app::Clusters::Binding::Structs::TargetStruct::Type> bindingArgument;

        bindingArgument = chip::app::DataModel::List<chip::app::Clusters::Binding::Structs::TargetStruct::Type>();

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::Binding::Attributes::Binding::TypeInfo>(
            bindingArgument, this, OnSuccessCallback_1, OnFailureCallback_1));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestReadEmptyBindingTable_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::BindingClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Binding::Attributes::Binding::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2(
        const chip::app::DataModel::DecodableList<chip::app::Clusters::Binding::Structs::TargetStruct::DecodableType> & binding)
    {
        {
            auto iter_0 = binding.begin();
            VerifyOrReturn(CheckNoMoreListItems<decltype(binding)>("binding", iter_0, 0));
        }

        NextTest();
    }

    CHIP_ERROR TestWriteInvalidBindingTable_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::BindingClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ListFreer listFreer;
        chip::app::DataModel::List<const chip::app::Clusters::Binding::Structs::TargetStruct::Type> bindingArgument;

        {
            auto * listHolder_0 = new ListHolder<chip::app::Clusters::Binding::Structs::TargetStruct::Type>(2);
            listFreer.add(listHolder_0);

            listHolder_0->mList[0].fabricIndex = 0;

            listHolder_0->mList[1].fabricIndex = 0;
            listHolder_0->mList[1].node.Emplace();
            listHolder_0->mList[1].node.Value() = 1ULL;
            listHolder_0->mList[1].group.Emplace();
            listHolder_0->mList[1].group.Value() = 1U;
            listHolder_0->mList[1].endpoint.Emplace();
            listHolder_0->mList[1].endpoint.Value() = 1U;
            listHolder_0->mList[1].cluster.Emplace();
            listHolder_0->mList[1].cluster.Value() = 6UL;

            bindingArgument =
                chip::app::DataModel::List<chip::app::Clusters::Binding::Structs::TargetStruct::Type>(listHolder_0->mList, 2);
        }

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::Binding::Attributes::Binding::TypeInfo>(
            bindingArgument, this, OnSuccessCallback_3, OnFailureCallback_3));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
        NextTest();
    }

    void OnSuccessResponse_3() { ThrowSuccessResponse(); }

    CHIP_ERROR TestWriteBindingTable_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::BindingClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ListFreer listFreer;
        chip::app::DataModel::List<const chip::app::Clusters::Binding::Structs::TargetStruct::Type> bindingArgument;

        {
            auto * listHolder_0 = new ListHolder<chip::app::Clusters::Binding::Structs::TargetStruct::Type>(3);
            listFreer.add(listHolder_0);

            listHolder_0->mList[0].fabricIndex = 0;
            listHolder_0->mList[0].group.Emplace();
            listHolder_0->mList[0].group.Value() = 1U;

            listHolder_0->mList[1].fabricIndex = 0;
            listHolder_0->mList[1].node.Emplace();
            listHolder_0->mList[1].node.Value() = 1ULL;
            listHolder_0->mList[1].endpoint.Emplace();
            listHolder_0->mList[1].endpoint.Value() = 1U;
            listHolder_0->mList[1].cluster.Emplace();
            listHolder_0->mList[1].cluster.Value() = 6UL;

            listHolder_0->mList[2].fabricIndex = 0;
            listHolder_0->mList[2].node.Emplace();
            listHolder_0->mList[2].node.Value() = 2ULL;
            listHolder_0->mList[2].endpoint.Emplace();
            listHolder_0->mList[2].endpoint.Value() = 1U;

            bindingArgument =
                chip::app::DataModel::List<chip::app::Clusters::Binding::Structs::TargetStruct::Type>(listHolder_0->mList, 3);
        }

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::Binding::Attributes::Binding::TypeInfo>(
            bindingArgument, this, OnSuccessCallback_4, OnFailureCallback_4));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestReadBindingTable_5()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::BindingClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Binding::Attributes::Binding::TypeInfo>(
            this, OnSuccessCallback_5, OnFailureCallback_5, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_5(
        const chip::app::DataModel::DecodableList<chip::app::Clusters::Binding::Structs::TargetStruct::DecodableType> & binding)
    {
        {
            auto iter_0 = binding.begin();
            VerifyOrReturn(CheckNextListItemDecodes<decltype(binding)>("binding", iter_0, 0));
            VerifyOrReturn(CheckValue("binding[0].fabricIndex", iter_0.GetValue().fabricIndex, 1));
            VerifyOrReturn(CheckValuePresent("binding[0].group", iter_0.GetValue().group));
            VerifyOrReturn(CheckValue("binding[0].group.Value()", iter_0.GetValue().group.Value(), 1U));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(binding)>("binding", iter_0, 1));
            VerifyOrReturn(CheckValue("binding[1].fabricIndex", iter_0.GetValue().fabricIndex, 1));
            VerifyOrReturn(CheckValuePresent("binding[1].node", iter_0.GetValue().node));
            VerifyOrReturn(CheckValue("binding[1].node.Value()", iter_0.GetValue().node.Value(), 1ULL));
            VerifyOrReturn(CheckValuePresent("binding[1].endpoint", iter_0.GetValue().endpoint));
            VerifyOrReturn(CheckValue("binding[1].endpoint.Value()", iter_0.GetValue().endpoint.Value(), 1U));
            VerifyOrReturn(CheckValuePresent("binding[1].cluster", iter_0.GetValue().cluster));
            VerifyOrReturn(CheckValue("binding[1].cluster.Value()", iter_0.GetValue().cluster.Value(), 6UL));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(binding)>("binding", iter_0, 2));
            VerifyOrReturn(CheckValue("binding[2].fabricIndex", iter_0.GetValue().fabricIndex, 1));
            VerifyOrReturn(CheckValuePresent("binding[2].node", iter_0.GetValue().node));
            VerifyOrReturn(CheckValue("binding[2].node.Value()", iter_0.GetValue().node.Value(), 2ULL));
            VerifyOrReturn(CheckValuePresent("binding[2].endpoint", iter_0.GetValue().endpoint));
            VerifyOrReturn(CheckValue("binding[2].endpoint.Value()", iter_0.GetValue().endpoint.Value(), 1U));
            VerifyOrReturn(CheckNoMoreListItems<decltype(binding)>("binding", iter_0, 3));
        }

        NextTest();
    }
};

class Test_TC_SWDIAG_1_1Suite : public TestCommand
{
public:
    Test_TC_SWDIAG_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_SWDIAG_1_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_SWDIAG_1_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_SWDIAG_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_SWDIAG_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Reads a list of ThreadMetrics struct non-global attribute from DUT.\n");
            if (ShouldSkip("A_THREADMETRICS"))
            {
                NextTest();
                return;
            }
            err = TestReadsAListOfThreadMetricsStructNonGlobalAttributeFromDut_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Reads CurrentHeapFree non-global attribute value from DUT\n");
            err = TestReadsCurrentHeapFreeNonGlobalAttributeValueFromDut_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Reads CurrentHeapUsed non-global attribute value from DUT\n");
            if (ShouldSkip("A_CURRENTHEAPUSED"))
            {
                NextTest();
                return;
            }
            err = TestReadsCurrentHeapUsedNonGlobalAttributeValueFromDut_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Reads CurrentHeapHighWaterMark non-global attribute value from DUT\n");
            if (ShouldSkip("A_CURRENTHEAPHIGHWATERMARK"))
            {
                NextTest();
                return;
            }
            err = TestReadsCurrentHeapHighWaterMarkNonGlobalAttributeValueFromDut_4();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 5;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_1(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_SWDIAG_1_1Suite *>(context))->OnFailureResponse_1(error);
    }

    static void OnSuccessCallback_1(
        void * context,
        const chip::app::DataModel::DecodableList<chip::app::Clusters::SoftwareDiagnostics::Structs::ThreadMetrics::DecodableType> &
            threadMetrics)
    {
        (static_cast<Test_TC_SWDIAG_1_1Suite *>(context))->OnSuccessResponse_1(threadMetrics);
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_SWDIAG_1_1Suite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context, uint64_t currentHeapFree)
    {
        (static_cast<Test_TC_SWDIAG_1_1Suite *>(context))->OnSuccessResponse_2(currentHeapFree);
    }

    static void OnFailureCallback_3(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_SWDIAG_1_1Suite *>(context))->OnFailureResponse_3(error);
    }

    static void OnSuccessCallback_3(void * context, uint64_t currentHeapUsed)
    {
        (static_cast<Test_TC_SWDIAG_1_1Suite *>(context))->OnSuccessResponse_3(currentHeapUsed);
    }

    static void OnFailureCallback_4(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_SWDIAG_1_1Suite *>(context))->OnFailureResponse_4(error);
    }

    static void OnSuccessCallback_4(void * context, uint64_t currentHeapHighWatermark)
    {
        (static_cast<Test_TC_SWDIAG_1_1Suite *>(context))->OnSuccessResponse_4(currentHeapHighWatermark);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestReadsAListOfThreadMetricsStructNonGlobalAttributeFromDut_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        chip::Controller::SoftwareDiagnosticsClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::SoftwareDiagnostics::Attributes::ThreadMetrics::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1(
        const chip::app::DataModel::DecodableList<chip::app::Clusters::SoftwareDiagnostics::Structs::ThreadMetrics::DecodableType> &
            threadMetrics)
    {
        NextTest();
    }

    CHIP_ERROR TestReadsCurrentHeapFreeNonGlobalAttributeValueFromDut_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        chip::Controller::SoftwareDiagnosticsClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::SoftwareDiagnostics::Attributes::CurrentHeapFree::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_2(uint64_t currentHeapFree)
    {
        VerifyOrReturn(CheckConstraintType("currentHeapFree", "", "uint64"));
        NextTest();
    }

    CHIP_ERROR TestReadsCurrentHeapUsedNonGlobalAttributeValueFromDut_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        chip::Controller::SoftwareDiagnosticsClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::SoftwareDiagnostics::Attributes::CurrentHeapUsed::TypeInfo>(
            this, OnSuccessCallback_3, OnFailureCallback_3, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_3(uint64_t currentHeapUsed)
    {
        VerifyOrReturn(CheckConstraintType("currentHeapUsed", "", "uint64"));
        NextTest();
    }

    CHIP_ERROR TestReadsCurrentHeapHighWaterMarkNonGlobalAttributeValueFromDut_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        chip::Controller::SoftwareDiagnosticsClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::SoftwareDiagnostics::Attributes::CurrentHeapHighWatermark::TypeInfo>(
                this, OnSuccessCallback_4, OnFailureCallback_4, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_4(uint64_t currentHeapHighWatermark)
    {
        VerifyOrReturn(CheckConstraintType("currentHeapHighWatermark", "", "uint64"));
        NextTest();
    }
};

class Test_TC_SWDIAG_2_1Suite : public TestCommand
{
public:
    Test_TC_SWDIAG_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_SWDIAG_2_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_SWDIAG_2_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_SWDIAG_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_SWDIAG_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_SWDIAG_3_1Suite : public TestCommand
{
public:
    Test_TC_SWDIAG_3_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_SWDIAG_3_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_SWDIAG_3_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_SWDIAG_3_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_SWDIAG_3_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Sends ResetWatermarks to DUT\n");
            if (ShouldSkip("CR_RESETWATERMARKS"))
            {
                NextTest();
                return;
            }
            err = TestSendsResetWatermarksToDut_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Reads CurrentHeapUsed attribute value from DUT\n");
            if (ShouldSkip("A_CURRENTHEAPUSED"))
            {
                NextTest();
                return;
            }
            err = TestReadsCurrentHeapUsedAttributeValueFromDut_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Reads CurrentHeapHighWaterMark attribute value from DUT\n");
            if (ShouldSkip("A_CURRENTHEAPHIGHWATERMARK"))
            {
                NextTest();
                return;
            }
            err = TestReadsCurrentHeapHighWaterMarkAttributeValueFromDut_3();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 4;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_SWDIAG_3_1Suite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context, uint64_t currentHeapUsed)
    {
        (static_cast<Test_TC_SWDIAG_3_1Suite *>(context))->OnSuccessResponse_2(currentHeapUsed);
    }

    static void OnFailureCallback_3(void * context, CHIP_ERROR error)
    {
        (static_cast<Test_TC_SWDIAG_3_1Suite *>(context))->OnFailureResponse_3(error);
    }

    static void OnSuccessCallback_3(void * context, uint64_t currentHeapHighWatermark)
    {
        (static_cast<Test_TC_SWDIAG_3_1Suite *>(context))->OnSuccessResponse_3(currentHeapHighWatermark);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestSendsResetWatermarksToDut_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        using RequestType               = chip::app::Clusters::SoftwareDiagnostics::Commands::ResetWatermarks::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_SWDIAG_3_1Suite *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<Test_TC_SWDIAG_3_1Suite *>(context))->OnFailureResponse_1(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestReadsCurrentHeapUsedAttributeValueFromDut_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        chip::Controller::SoftwareDiagnosticsClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::SoftwareDiagnostics::Attributes::CurrentHeapUsed::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_2(uint64_t currentHeapUsed)
    {
        VerifyOrReturn(CheckConstraintType("currentHeapUsed", "", "uint64"));
        NextTest();
    }

    CHIP_ERROR TestReadsCurrentHeapHighWaterMarkAttributeValueFromDut_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        chip::Controller::SoftwareDiagnosticsClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::SoftwareDiagnostics::Attributes::CurrentHeapHighWatermark::TypeInfo>(
                this, OnSuccessCallback_3, OnFailureCallback_3, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        (status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_3(uint64_t currentHeapHighWatermark)
    {
        VerifyOrReturn(CheckConstraintType("currentHeapHighWatermark", "", "uint64"));
        NextTest();
    }
};

class TestSubscribe_OnOffSuite : public TestCommand
{
public:
    TestSubscribe_OnOffSuite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("TestSubscribe_OnOff", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~TestSubscribe_OnOffSuite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestSubscribe_OnOff\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestSubscribe_OnOff\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Set OnOff Attribute to false\n");
            err = TestSetOnOffAttributeToFalse_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Report: Subscribe OnOff Attribute\n");
            err = TestReportSubscribeOnOffAttribute_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Subscribe OnOff Attribute\n");
            err = TestSubscribeOnOffAttribute_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Turn On the light to see attribute change\n");
            err = TestTurnOnTheLightToSeeAttributeChange_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Check for attribute report\n");
            err = TestCheckForAttributeReport_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Turn Off the light to see attribute change\n");
            err = TestTurnOffTheLightToSeeAttributeChange_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Check for attribute report\n");
            err = TestCheckForAttributeReport_7();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 8;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    typedef void (*Test_TestSubscribe_OnOff_OnOff_ReportCallback)(void * context, bool value);
    Test_TestSubscribe_OnOff_OnOff_ReportCallback mTest_TestSubscribe_OnOff_OnOff_Reported = nullptr;

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSubscribe_OnOffSuite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context, bool onOff)
    {
        (static_cast<TestSubscribe_OnOffSuite *>(context))->OnSuccessResponse_2(onOff);
    }

    bool mReceivedReport_2 = false;

    static void OnFailureCallback_3(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSubscribe_OnOffSuite *>(context))->OnFailureResponse_3(error);
    }

    static void OnSuccessCallback_3(void * context, bool onOff)
    {
        (static_cast<TestSubscribe_OnOffSuite *>(context))->OnSuccessResponse_3(onOff);
    }

    static void OnSubscriptionEstablished_3(void * context)
    {
        (static_cast<TestSubscribe_OnOffSuite *>(context))->OnSubscriptionEstablishedResponse_3();
    }

    static void OnFailureCallback_5(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSubscribe_OnOffSuite *>(context))->OnFailureResponse_5(error);
    }

    static void OnSuccessCallback_5(void * context, bool onOff)
    {
        (static_cast<TestSubscribe_OnOffSuite *>(context))->OnSuccessResponse_5(onOff);
    }

    bool mReceivedReport_5 = false;

    static void OnFailureCallback_7(void * context, CHIP_ERROR error)
    {
        (static_cast<TestSubscribe_OnOffSuite *>(context))->OnFailureResponse_7(error);
    }

    static void OnSuccessCallback_7(void * context, bool onOff)
    {
        (static_cast<TestSubscribe_OnOffSuite *>(context))->OnSuccessResponse_7(onOff);
    }

    bool mReceivedReport_7 = false;

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestSetOnOffAttributeToFalse_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestSubscribe_OnOffSuite *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestSubscribe_OnOffSuite *>(context))->OnFailureResponse_1(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestReportSubscribeOnOffAttribute_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        mTest_TestSubscribe_OnOff_OnOff_Reported = OnSuccessCallback_2;
        return WaitForMs(0);
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2(bool onOff)
    {
        mReceivedReport_2 = true;
        VerifyOrReturn(CheckValue("onOff", onOff, false));
    }

    CHIP_ERROR TestSubscribeOnOffAttribute_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t minIntervalArgument;
        minIntervalArgument = 2U;
        uint16_t maxIntervalArgument;
        maxIntervalArgument = 5U;

        ReturnErrorOnFailure(cluster.SubscribeAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(
            this, OnSuccessCallback_3, OnFailureCallback_3, minIntervalArgument, maxIntervalArgument, OnSubscriptionEstablished_3,
            true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3(bool value)
    {
        if (mTest_TestSubscribe_OnOff_OnOff_Reported)
        {
            auto callback                            = mTest_TestSubscribe_OnOff_OnOff_Reported;
            mTest_TestSubscribe_OnOff_OnOff_Reported = nullptr;
            callback(this, value);
        }
    }

    void OnSubscriptionEstablishedResponse_3()
    {
        VerifyOrReturn(mReceivedReport_2, Exit("Initial report not received!"));
        NextTest();
    }

    CHIP_ERROR TestTurnOnTheLightToSeeAttributeChange_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestSubscribe_OnOffSuite *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestSubscribe_OnOffSuite *>(context))->OnFailureResponse_4(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestCheckForAttributeReport_5()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        mTest_TestSubscribe_OnOff_OnOff_Reported = OnSuccessCallback_5;
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_5(bool onOff)
    {
        mReceivedReport_5 = true;
        VerifyOrReturn(CheckValue("onOff", onOff, true));

        NextTest();
    }

    CHIP_ERROR TestTurnOffTheLightToSeeAttributeChange_6()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestSubscribe_OnOffSuite *>(context))->OnSuccessResponse_6();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestSubscribe_OnOffSuite *>(context))->OnFailureResponse_6(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_6(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_6() { NextTest(); }

    CHIP_ERROR TestCheckForAttributeReport_7()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        mTest_TestSubscribe_OnOff_OnOff_Reported = OnSuccessCallback_7;
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_7(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_7(bool onOff)
    {
        mReceivedReport_7 = true;
        VerifyOrReturn(CheckValue("onOff", onOff, false));

        NextTest();
    }
};

class DL_UsersAndCredentialsSuite : public TestCommand
{
public:
    DL_UsersAndCredentialsSuite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("DL_UsersAndCredentials", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~DL_UsersAndCredentialsSuite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: DL_UsersAndCredentials\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: DL_UsersAndCredentials\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read available user slot and verify response fields\n");
            err = TestReadAvailableUserSlotAndVerifyResponseFields_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Get number of supported users and verify default value\n");
            err = TestGetNumberOfSupportedUsersAndVerifyDefaultValue_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read fails for user with index 0\n");
            err = TestReadFailsForUserWithIndex0_3();
            break;
        case 4:
            ChipLogProgress(chipTool,
                            " ***** Test Step 4 : Read fails for user with index greater than Number Of Users Supported\n");
            err = TestReadFailsForUserWithIndexGreaterThanNumberOfUsersSupported_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Create new user with default parameters\n");
            err = TestCreateNewUserWithDefaultParameters_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Read the user back and verify its fields\n");
            err = TestReadTheUserBackAndVerifyItsFields_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Set user at the occupied index fails with appropriate response\n");
            err = TestSetUserAtTheOccupiedIndexFailsWithAppropriateResponse_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Modify userName for existing user\n");
            err = TestModifyUserNameForExistingUser_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Read the modified user back and verify its fields\n");
            err = TestReadTheModifiedUserBackAndVerifyItsFields_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Modify userUniqueId for existing user\n");
            err = TestModifyUserUniqueIdForExistingUser_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : Read the modified user back and verify its fields\n");
            err = TestReadTheModifiedUserBackAndVerifyItsFields_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : Modify userStatus for existing user\n");
            err = TestModifyUserStatusForExistingUser_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : Read the modified user back and verify its fields\n");
            err = TestReadTheModifiedUserBackAndVerifyItsFields_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : Modify userType for existing user\n");
            err = TestModifyUserTypeForExistingUser_14();
            break;
        case 15:
            ChipLogProgress(chipTool, " ***** Test Step 15 : Read the modified user back and verify its fields\n");
            err = TestReadTheModifiedUserBackAndVerifyItsFields_15();
            break;
        case 16:
            ChipLogProgress(chipTool, " ***** Test Step 16 : Modify credentialRule for existing user\n");
            err = TestModifyCredentialRuleForExistingUser_16();
            break;
        case 17:
            ChipLogProgress(chipTool, " ***** Test Step 17 : Read the modified user back and verify its fields\n");
            err = TestReadTheModifiedUserBackAndVerifyItsFields_17();
            break;
        case 18:
            ChipLogProgress(chipTool, " ***** Test Step 18 : Modify all fields for existing user\n");
            err = TestModifyAllFieldsForExistingUser_18();
            break;
        case 19:
            ChipLogProgress(chipTool, " ***** Test Step 19 : Read the modified user back and verify its fields\n");
            err = TestReadTheModifiedUserBackAndVerifyItsFields_19();
            break;
        case 20:
            ChipLogProgress(chipTool, " ***** Test Step 20 : Add another user with non-default fields\n");
            err = TestAddAnotherUserWithNonDefaultFields_20();
            break;
        case 21:
            ChipLogProgress(chipTool, " ***** Test Step 21 : Read the new user back and verify its fields\n");
            err = TestReadTheNewUserBackAndVerifyItsFields_21();
            break;
        case 22:
            ChipLogProgress(chipTool, " ***** Test Step 22 : Create user in the last slot\n");
            err = TestCreateUserInTheLastSlot_22();
            break;
        case 23:
            ChipLogProgress(chipTool, " ***** Test Step 23 : Read the last user back and verify its fields\n");
            err = TestReadTheLastUserBackAndVerifyItsFields_23();
            break;
        case 24:
            ChipLogProgress(chipTool, " ***** Test Step 24 : User creation in the 0 slot fails\n");
            err = TestUserCreationInThe0SlotFails_24();
            break;
        case 25:
            ChipLogProgress(chipTool, " ***** Test Step 25 : User creation in the out-of-bounds slot fails\n");
            err = TestUserCreationInTheOutOfBoundsSlotFails_25();
            break;
        case 26:
            ChipLogProgress(chipTool, " ***** Test Step 26 : Clear first user\n");
            err = TestClearFirstUser_26();
            break;
        case 27:
            ChipLogProgress(chipTool, " ***** Test Step 27 : Read cleared user and verify it is available\n");
            err = TestReadClearedUserAndVerifyItIsAvailable_27();
            break;
        case 28:
            ChipLogProgress(chipTool, " ***** Test Step 28 : Create new user in the cleared slot\n");
            err = TestCreateNewUserInTheClearedSlot_28();
            break;
        case 29:
            ChipLogProgress(chipTool, " ***** Test Step 29 : Read the user in the previously cleared slot and verify its fields\n");
            err = TestReadTheUserInThePreviouslyClearedSlotAndVerifyItsFields_29();
            break;
        case 30:
            ChipLogProgress(chipTool, " ***** Test Step 30 : Clear user with index 0 fails\n");
            err = TestClearUserWithIndex0Fails_30();
            break;
        case 31:
            ChipLogProgress(chipTool, " ***** Test Step 31 : Clear user with out-of-bounds index fails\n");
            err = TestClearUserWithOutOfBoundsIndexFails_31();
            break;
        case 32:
            ChipLogProgress(chipTool, " ***** Test Step 32 : Clear all users\n");
            err = TestClearAllUsers_32();
            break;
        case 33:
            ChipLogProgress(chipTool, " ***** Test Step 33 : Read first cleared user and verify it is available\n");
            err = TestReadFirstClearedUserAndVerifyItIsAvailable_33();
            break;
        case 34:
            ChipLogProgress(chipTool, " ***** Test Step 34 : Read last cleared user and verify it is available\n");
            err = TestReadLastClearedUserAndVerifyItIsAvailable_34();
            break;
        case 35:
            ChipLogProgress(chipTool, " ***** Test Step 35 : Get number of supported PIN credentials and verify default value\n");
            err = TestGetNumberOfSupportedPinCredentialsAndVerifyDefaultValue_35();
            break;
        case 36:
            ChipLogProgress(chipTool, " ***** Test Step 36 : Check that PIN credential does not exist\n");
            err = TestCheckThatPinCredentialDoesNotExist_36();
            break;
        case 37:
            ChipLogProgress(chipTool, " ***** Test Step 37 : Reading PIN credential with index 0 fails\n");
            err = TestReadingPinCredentialWithIndex0Fails_37();
            break;
        case 38:
            ChipLogProgress(chipTool, " ***** Test Step 38 : Reading PIN credential with out-of-bounds index fails\n");
            err = TestReadingPinCredentialWithOutOfBoundsIndexFails_38();
            break;
        case 39:
            ChipLogProgress(chipTool, " ***** Test Step 39 : Create new PIN credential and user\n");
            err = TestCreateNewPinCredentialAndUser_39();
            break;
        case 40:
            ChipLogProgress(chipTool, " ***** Test Step 40 : Verify created user\n");
            err = TestVerifyCreatedUser_40();
            break;
        case 41:
            ChipLogProgress(chipTool, " ***** Test Step 41 : Verify created PIN credential\n");
            err = TestVerifyCreatedPinCredential_41();
            break;
        case 42:
            ChipLogProgress(chipTool, " ***** Test Step 42 : Create new PIN credential and user with index 0 fails\n");
            err = TestCreateNewPinCredentialAndUserWithIndex0Fails_42();
            break;
        case 43:
            ChipLogProgress(chipTool, " ***** Test Step 43 : Create new PIN credential and user with out-of-bounds index fails\n");
            err = TestCreateNewPinCredentialAndUserWithOutOfBoundsIndexFails_43();
            break;
        case 44:
            ChipLogProgress(chipTool, " ***** Test Step 44 : Get number of supported RFID credentials and verify default value\n");
            err = TestGetNumberOfSupportedRfidCredentialsAndVerifyDefaultValue_44();
            break;
        case 45:
            ChipLogProgress(chipTool, " ***** Test Step 45 : Reading RFID credential with index 0 fails\n");
            err = TestReadingRfidCredentialWithIndex0Fails_45();
            break;
        case 46:
            ChipLogProgress(chipTool, " ***** Test Step 46 : Reading RFID credential with out-of-bounds index fails\n");
            err = TestReadingRfidCredentialWithOutOfBoundsIndexFails_46();
            break;
        case 47:
            ChipLogProgress(chipTool, " ***** Test Step 47 : Check that RFID credential does not exist\n");
            err = TestCheckThatRfidCredentialDoesNotExist_47();
            break;
        case 48:
            ChipLogProgress(chipTool, " ***** Test Step 48 : Create new RFID credential and add it to existing user\n");
            err = TestCreateNewRfidCredentialAndAddItToExistingUser_48();
            break;
        case 49:
            ChipLogProgress(chipTool, " ***** Test Step 49 : Verify modified user\n");
            err = TestVerifyModifiedUser_49();
            break;
        case 50:
            ChipLogProgress(chipTool, " ***** Test Step 50 : Verify created credential\n");
            err = TestVerifyCreatedCredential_50();
            break;
        case 51:
            ChipLogProgress(chipTool, " ***** Test Step 51 : Create new RFID credential and user with index 0 fails\n");
            err = TestCreateNewRfidCredentialAndUserWithIndex0Fails_51();
            break;
        case 52:
            ChipLogProgress(chipTool, " ***** Test Step 52 : Create new RFID credential and user with out-of-bounds index fails\n");
            err = TestCreateNewRfidCredentialAndUserWithOutOfBoundsIndexFails_52();
            break;
        case 53:
            ChipLogProgress(chipTool, " ***** Test Step 53 : Create new PIN credential and try to add it to existing user\n");
            err = TestCreateNewPinCredentialAndTryToAddItToExistingUser_53();
            break;
        case 54:
            ChipLogProgress(chipTool, " ***** Test Step 54 : Create new credential and try to add it to 0 user\n");
            err = TestCreateNewCredentialAndTryToAddItTo0User_54();
            break;
        case 55:
            ChipLogProgress(chipTool, " ***** Test Step 55 : Create new credential and try to add it to out-of-bounds user\n");
            err = TestCreateNewCredentialAndTryToAddItToOutOfBoundsUser_55();
            break;
        case 56:
            ChipLogProgress(chipTool, " ***** Test Step 56 : Create new PIN with too short data\n");
            err = TestCreateNewPinWithTooShortData_56();
            break;
        case 57:
            ChipLogProgress(chipTool, " ***** Test Step 57 : Create new PIN with too long data\n");
            err = TestCreateNewPinWithTooLongData_57();
            break;
        case 58:
            ChipLogProgress(chipTool, " ***** Test Step 58 : Create new RFID with too short data\n");
            err = TestCreateNewRfidWithTooShortData_58();
            break;
        case 59:
            ChipLogProgress(chipTool, " ***** Test Step 59 : Create new PIN with Programming user type fails\n");
            err = TestCreateNewPinWithProgrammingUserTypeFails_59();
            break;
        case 60:
            ChipLogProgress(chipTool, " ***** Test Step 60 : Create new RFID with too short data\n");
            err = TestCreateNewRfidWithTooShortData_60();
            break;
        case 61:
            ChipLogProgress(chipTool, " ***** Test Step 61 : Create new PIN credential with data the would cause duplicate\n");
            err = TestCreateNewPinCredentialWithDataTheWouldCauseDuplicate_61();
            break;
        case 62:
            ChipLogProgress(chipTool, " ***** Test Step 62 : Create new RFID credential with data the would cause duplicate\n");
            err = TestCreateNewRfidCredentialWithDataTheWouldCauseDuplicate_62();
            break;
        case 63:
            ChipLogProgress(chipTool, " ***** Test Step 63 : Modify credentialData of existing PIN credential\n");
            err = TestModifyCredentialDataOfExistingPinCredential_63();
            break;
        case 64:
            ChipLogProgress(chipTool,
                            " ***** Test Step 64 : Verify that credential was changed by creating new credential with old data\n");
            err = TestVerifyThatCredentialWasChangedByCreatingNewCredentialWithOldData_64();
            break;
        case 65:
            ChipLogProgress(chipTool,
                            " ***** Test Step 65 : Verify that credential was changed by creating new credential with new data\n");
            err = TestVerifyThatCredentialWasChangedByCreatingNewCredentialWithNewData_65();
            break;
        case 66:
            ChipLogProgress(chipTool, " ***** Test Step 66 : Clear first PIN credential\n");
            err = TestClearFirstPinCredential_66();
            break;
        case 67:
            ChipLogProgress(chipTool, " ***** Test Step 67 : Read back the credential and make sure it is deleted\n");
            err = TestReadBackTheCredentialAndMakeSureItIsDeleted_67();
            break;
        case 68:
            ChipLogProgress(chipTool, " ***** Test Step 68 : Read the user back and make sure PIN credential is deleted\n");
            err = TestReadTheUserBackAndMakeSurePinCredentialIsDeleted_68();
            break;
        case 69:
            ChipLogProgress(chipTool, " ***** Test Step 69 : Clear the second PIN credential\n");
            err = TestClearTheSecondPinCredential_69();
            break;
        case 70:
            ChipLogProgress(chipTool, " ***** Test Step 70 : Read back the credential and make sure it is deleted\n");
            err = TestReadBackTheCredentialAndMakeSureItIsDeleted_70();
            break;
        case 71:
            ChipLogProgress(chipTool, " ***** Test Step 71 : Read the user back and make sure related user is deleted\n");
            err = TestReadTheUserBackAndMakeSureRelatedUserIsDeleted_71();
            break;
        case 72:
            ChipLogProgress(chipTool, " ***** Test Step 72 : Create new RFID credential with user\n");
            err = TestCreateNewRfidCredentialWithUser_72();
            break;
        case 73:
            ChipLogProgress(chipTool, " ***** Test Step 73 : Clear all the RFID credentials\n");
            err = TestClearAllTheRfidCredentials_73();
            break;
        case 74:
            ChipLogProgress(chipTool, " ***** Test Step 74 : Read back the fist RFID credential and make sure it is deleted\n");
            err = TestReadBackTheFistRfidCredentialAndMakeSureItIsDeleted_74();
            break;
        case 75:
            ChipLogProgress(chipTool, " ***** Test Step 75 : Read back the second RFID credential and make sure it is deleted\n");
            err = TestReadBackTheSecondRfidCredentialAndMakeSureItIsDeleted_75();
            break;
        case 76:
            ChipLogProgress(chipTool,
                            " ***** Test Step 76 : Read the user related with first RFID back and make sure it is deleted\n");
            err = TestReadTheUserRelatedWithFirstRfidBackAndMakeSureItIsDeleted_76();
            break;
        case 77:
            ChipLogProgress(chipTool,
                            " ***** Test Step 77 : Read the user related with second RFID back and make sure it is deleted\n");
            err = TestReadTheUserRelatedWithSecondRfidBackAndMakeSureItIsDeleted_77();
            break;
        case 78:
            ChipLogProgress(chipTool, " ***** Test Step 78 : Create new PIN credential with user\n");
            err = TestCreateNewPinCredentialWithUser_78();
            break;
        case 79:
            ChipLogProgress(chipTool, " ***** Test Step 79 : Create new RFID credential with user\n");
            err = TestCreateNewRfidCredentialWithUser_79();
            break;
        case 80:
            ChipLogProgress(chipTool, " ***** Test Step 80 : Create another RFID credential with user\n");
            err = TestCreateAnotherRfidCredentialWithUser_80();
            break;
        case 81:
            ChipLogProgress(chipTool, " ***** Test Step 81 : Clear all the credentials\n");
            err = TestClearAllTheCredentials_81();
            break;
        case 82:
            ChipLogProgress(chipTool, " ***** Test Step 82 : Read back the first PIN credential and make sure it is deleted\n");
            err = TestReadBackTheFirstPinCredentialAndMakeSureItIsDeleted_82();
            break;
        case 83:
            ChipLogProgress(chipTool, " ***** Test Step 83 : Read back the first RFID credential and make sure it is deleted\n");
            err = TestReadBackTheFirstRfidCredentialAndMakeSureItIsDeleted_83();
            break;
        case 84:
            ChipLogProgress(chipTool, " ***** Test Step 84 : Read back the second PIN credential and make sure it is deleted\n");
            err = TestReadBackTheSecondPinCredentialAndMakeSureItIsDeleted_84();
            break;
        case 85:
            ChipLogProgress(chipTool,
                            " ***** Test Step 85 : Read the user related with first PIN back and make sure it is deleted\n");
            err = TestReadTheUserRelatedWithFirstPinBackAndMakeSureItIsDeleted_85();
            break;
        case 86:
            ChipLogProgress(chipTool,
                            " ***** Test Step 86 : Read the user related with first RFID back and make sure it is deleted\n");
            err = TestReadTheUserRelatedWithFirstRfidBackAndMakeSureItIsDeleted_86();
            break;
        case 87:
            ChipLogProgress(chipTool,
                            " ***** Test Step 87 : Read the user related with second PIN back and make sure it is deleted\n");
            err = TestReadTheUserRelatedWithSecondPinBackAndMakeSureItIsDeleted_87();
            break;
        case 88:
            ChipLogProgress(chipTool, " ***** Test Step 88 : Create new Programming PIN credential with invalid index\n");
            err = TestCreateNewProgrammingPinCredentialWithInvalidIndex_88();
            break;
        case 89:
            ChipLogProgress(chipTool, " ***** Test Step 89 : Create new Programming PIN credential with valid index\n");
            err = TestCreateNewProgrammingPinCredentialWithValidIndex_89();
            break;
        case 90:
            ChipLogProgress(chipTool, " ***** Test Step 90 : Verify created user\n");
            err = TestVerifyCreatedUser_90();
            break;
        case 91:
            ChipLogProgress(chipTool, " ***** Test Step 91 : Verify created programming PIN credential\n");
            err = TestVerifyCreatedProgrammingPinCredential_91();
            break;
        case 92:
            ChipLogProgress(chipTool, " ***** Test Step 92 : Modify the Programming PIN credential\n");
            err = TestModifyTheProgrammingPinCredential_92();
            break;
        case 93:
            ChipLogProgress(chipTool, " ***** Test Step 93 : Clearing Programming PIN fails\n");
            err = TestClearingProgrammingPinFails_93();
            break;
        case 94:
            ChipLogProgress(chipTool, " ***** Test Step 94 : Clearing Programming PIN with invalid index fails\n");
            err = TestClearingProgrammingPinWithInvalidIndexFails_94();
            break;
        case 95:
            ChipLogProgress(chipTool, " ***** Test Step 95 : Clearing PIN credential with zero index fails\n");
            err = TestClearingPinCredentialWithZeroIndexFails_95();
            break;
        case 96:
            ChipLogProgress(chipTool, " ***** Test Step 96 : Clearing PIN credential with out-of-bound index fails\n");
            err = TestClearingPinCredentialWithOutOfBoundIndexFails_96();
            break;
        case 97:
            ChipLogProgress(chipTool, " ***** Test Step 97 : Clearing RFID credential with zero index fails\n");
            err = TestClearingRfidCredentialWithZeroIndexFails_97();
            break;
        case 98:
            ChipLogProgress(chipTool, " ***** Test Step 98 : Clearing RFID credential with out-of-bound index fails\n");
            err = TestClearingRfidCredentialWithOutOfBoundIndexFails_98();
            break;
        case 99:
            ChipLogProgress(chipTool, " ***** Test Step 99 : Clear the Programming PIN user\n");
            err = TestClearTheProgrammingPinUser_99();
            break;
        case 100:
            ChipLogProgress(chipTool, " ***** Test Step 100 : Make sure Programming PIN user is deleted\n");
            err = TestMakeSureProgrammingPinUserIsDeleted_100();
            break;
        case 101:
            ChipLogProgress(chipTool, " ***** Test Step 101 : Make sure programming PIN credential is deleted\n");
            err = TestMakeSureProgrammingPinCredentialIsDeleted_101();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 102;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    uint16_t NumberOfTotalUsersSupported;
    uint16_t NumberOfPINUsersSupported;
    uint16_t NumberOfRFIDUsersSupported;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context, uint16_t numberOfTotalUsersSupported)
    {
        (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnSuccessResponse_2(numberOfTotalUsersSupported);
    }

    static void OnFailureCallback_35(void * context, CHIP_ERROR error)
    {
        (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_35(error);
    }

    static void OnSuccessCallback_35(void * context, uint16_t numberOfPINUsersSupported)
    {
        (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnSuccessResponse_35(numberOfPINUsersSupported);
    }

    static void OnFailureCallback_44(void * context, CHIP_ERROR error)
    {
        (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_44(error);
    }

    static void OnSuccessCallback_44(void * context, uint16_t numberOfRFIDUsersSupported)
    {
        (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnSuccessResponse_44(numberOfRFIDUsersSupported);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestReadAvailableUserSlotAndVerifyResponseFields_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::GetUser::Type;

        RequestType request;
        request.userIndex = 1U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))
                ->OnSuccessResponse_1(data.userIndex, data.userName, data.userUniqueId, data.userStatus, data.userType,
                                      data.credentialRule, data.credentials, data.creatorFabricIndex, data.lastModifiedFabricIndex,
                                      data.nextUserIndex);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_1(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1(
        uint16_t userIndex, const chip::app::DataModel::Nullable<chip::CharSpan> & userName,
        const chip::app::DataModel::Nullable<uint32_t> & userUniqueId,
        const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlUserStatus> & userStatus,
        const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlUserType> & userType,
        const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlCredentialRule> & credentialRule,
        const chip::app::DataModel::Nullable<
            chip::app::DataModel::DecodableList<chip::app::Clusters::DoorLock::Structs::DlCredential::DecodableType>> & credentials,
        const chip::app::DataModel::Nullable<chip::FabricIndex> & creatorFabricIndex,
        const chip::app::DataModel::Nullable<chip::FabricIndex> & lastModifiedFabricIndex,
        const chip::app::DataModel::Nullable<uint16_t> & nextUserIndex)
    {
        VerifyOrReturn(CheckValue("userIndex", userIndex, 1U));

        VerifyOrReturn(CheckValueNull("userName", userName));

        VerifyOrReturn(CheckValueNull("userUniqueId", userUniqueId));

        VerifyOrReturn(CheckValueNull("userStatus", userStatus));

        VerifyOrReturn(CheckValueNull("userType", userType));

        VerifyOrReturn(CheckValueNull("credentialRule", credentialRule));

        VerifyOrReturn(CheckValueNull("credentials", credentials));

        VerifyOrReturn(CheckValueNull("creatorFabricIndex", creatorFabricIndex));

        VerifyOrReturn(CheckValueNull("lastModifiedFabricIndex", lastModifiedFabricIndex));

        VerifyOrReturn(CheckValueNonNull("nextUserIndex", nextUserIndex));
        VerifyOrReturn(CheckValue("nextUserIndex.Value()", nextUserIndex.Value(), 2U));

        NextTest();
    }

    CHIP_ERROR TestGetNumberOfSupportedUsersAndVerifyDefaultValue_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::DoorLockClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::DoorLock::Attributes::NumberOfTotalUsersSupported::TypeInfo>(
                this, OnSuccessCallback_2, OnFailureCallback_2, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2(uint16_t numberOfTotalUsersSupported)
    {
        VerifyOrReturn(CheckValue("numberOfTotalUsersSupported", numberOfTotalUsersSupported, 10U));

        NumberOfTotalUsersSupported = numberOfTotalUsersSupported;
        NextTest();
    }

    CHIP_ERROR TestReadFailsForUserWithIndex0_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::GetUser::Type;

        RequestType request;
        request.userIndex = 0U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))
                ->OnSuccessResponse_3(data.userIndex, data.userName, data.userUniqueId, data.userStatus, data.userType,
                                      data.credentialRule, data.credentials, data.creatorFabricIndex, data.lastModifiedFabricIndex,
                                      data.nextUserIndex);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_3(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_COMMAND));
        NextTest();
    }

    void OnSuccessResponse_3(
        uint16_t userIndex, const chip::app::DataModel::Nullable<chip::CharSpan> & userName,
        const chip::app::DataModel::Nullable<uint32_t> & userUniqueId,
        const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlUserStatus> & userStatus,
        const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlUserType> & userType,
        const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlCredentialRule> & credentialRule,
        const chip::app::DataModel::Nullable<
            chip::app::DataModel::DecodableList<chip::app::Clusters::DoorLock::Structs::DlCredential::DecodableType>> & credentials,
        const chip::app::DataModel::Nullable<chip::FabricIndex> & creatorFabricIndex,
        const chip::app::DataModel::Nullable<chip::FabricIndex> & lastModifiedFabricIndex,
        const chip::app::DataModel::Nullable<uint16_t> & nextUserIndex)
    {
        ThrowSuccessResponse();
    }

    CHIP_ERROR TestReadFailsForUserWithIndexGreaterThanNumberOfUsersSupported_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::GetUser::Type;

        RequestType request;
        request.userIndex = static_cast<uint16_t>(NumberOfTotalUsersSupported + 1);

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))
                ->OnSuccessResponse_4(data.userIndex, data.userName, data.userUniqueId, data.userStatus, data.userType,
                                      data.credentialRule, data.credentials, data.creatorFabricIndex, data.lastModifiedFabricIndex,
                                      data.nextUserIndex);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_4(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_COMMAND));
        NextTest();
    }

    void OnSuccessResponse_4(
        uint16_t userIndex, const chip::app::DataModel::Nullable<chip::CharSpan> & userName,
        const chip::app::DataModel::Nullable<uint32_t> & userUniqueId,
        const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlUserStatus> & userStatus,
        const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlUserType> & userType,
        const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlCredentialRule> & credentialRule,
        const chip::app::DataModel::Nullable<
            chip::app::DataModel::DecodableList<chip::app::Clusters::DoorLock::Structs::DlCredential::DecodableType>> & credentials,
        const chip::app::DataModel::Nullable<chip::FabricIndex> & creatorFabricIndex,
        const chip::app::DataModel::Nullable<chip::FabricIndex> & lastModifiedFabricIndex,
        const chip::app::DataModel::Nullable<uint16_t> & nextUserIndex)
    {
        ThrowSuccessResponse();
    }

    CHIP_ERROR TestCreateNewUserWithDefaultParameters_5()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::SetUser::Type;

        RequestType request;
        request.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);
        request.userIndex     = 1U;
        request.userName.SetNull();
        request.userUniqueId.SetNull();
        request.userStatus.SetNull();
        request.userType.SetNull();
        request.credentialRule.SetNull();

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnSuccessResponse_5();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_5(error);
        };

        ReturnErrorOnFailure(
            chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request, 10000));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_5() { NextTest(); }

    CHIP_ERROR TestReadTheUserBackAndVerifyItsFields_6()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::GetUser::Type;

        RequestType request;
        request.userIndex = 1U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))
                ->OnSuccessResponse_6(data.userIndex, data.userName, data.userUniqueId, data.userStatus, data.userType,
                                      data.credentialRule, data.credentials, data.creatorFabricIndex, data.lastModifiedFabricIndex,
                                      data.nextUserIndex);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_6(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_6(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_6(
        uint16_t userIndex, const chip::app::DataModel::Nullable<chip::CharSpan> & userName,
        const chip::app::DataModel::Nullable<uint32_t> & userUniqueId,
        const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlUserStatus> & userStatus,
        const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlUserType> & userType,
        const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlCredentialRule> & credentialRule,
        const chip::app::DataModel::Nullable<
            chip::app::DataModel::DecodableList<chip::app::Clusters::DoorLock::Structs::DlCredential::DecodableType>> & credentials,
        const chip::app::DataModel::Nullable<chip::FabricIndex> & creatorFabricIndex,
        const chip::app::DataModel::Nullable<chip::FabricIndex> & lastModifiedFabricIndex,
        const chip::app::DataModel::Nullable<uint16_t> & nextUserIndex)
    {
        VerifyOrReturn(CheckValue("userIndex", userIndex, 1U));

        VerifyOrReturn(CheckValueNonNull("userName", userName));
        VerifyOrReturn(CheckValueAsString("userName.Value()", userName.Value(), chip::CharSpan("", 0)));

        VerifyOrReturn(CheckValueNull("userUniqueId", userUniqueId));

        VerifyOrReturn(CheckValueNonNull("userStatus", userStatus));
        VerifyOrReturn(CheckValue("userStatus.Value()", userStatus.Value(), 1));

        VerifyOrReturn(CheckValueNonNull("userType", userType));
        VerifyOrReturn(CheckValue("userType.Value()", userType.Value(), 0));

        VerifyOrReturn(CheckValueNonNull("credentialRule", credentialRule));
        VerifyOrReturn(CheckValue("credentialRule.Value()", credentialRule.Value(), 0));

        VerifyOrReturn(CheckValueNull("credentials", credentials));

        VerifyOrReturn(CheckValueNonNull("creatorFabricIndex", creatorFabricIndex));
        VerifyOrReturn(CheckValue("creatorFabricIndex.Value()", creatorFabricIndex.Value(), 1));

        VerifyOrReturn(CheckValueNonNull("lastModifiedFabricIndex", lastModifiedFabricIndex));
        VerifyOrReturn(CheckValue("lastModifiedFabricIndex.Value()", lastModifiedFabricIndex.Value(), 1));

        VerifyOrReturn(CheckValueNonNull("nextUserIndex", nextUserIndex));
        VerifyOrReturn(CheckValue("nextUserIndex.Value()", nextUserIndex.Value(), 2U));

        NextTest();
    }

    CHIP_ERROR TestSetUserAtTheOccupiedIndexFailsWithAppropriateResponse_7()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::SetUser::Type;

        RequestType request;
        request.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);
        request.userIndex     = 1U;
        request.userName.SetNull();
        request.userUniqueId.SetNull();
        request.userStatus.SetNull();
        request.userType.SetNull();
        request.credentialRule.SetNull();

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnSuccessResponse_7();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_7(error);
        };

        ReturnErrorOnFailure(
            chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request, 10000));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_7(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 1));
        NextTest();
    }

    void OnSuccessResponse_7() { ThrowSuccessResponse(); }

    CHIP_ERROR TestModifyUserNameForExistingUser_8()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::SetUser::Type;

        RequestType request;
        request.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(2);
        request.userIndex     = 1U;
        request.userName.SetNonNull();
        request.userName.Value() = chip::Span<const char>("new_usergarbage: not in length on purpose", 8);
        request.userUniqueId.SetNull();
        request.userStatus.SetNull();
        request.userType.SetNull();
        request.credentialRule.SetNull();

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnSuccessResponse_8();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_8(error);
        };

        ReturnErrorOnFailure(
            chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request, 10000));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_8(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_8() { NextTest(); }

    CHIP_ERROR TestReadTheModifiedUserBackAndVerifyItsFields_9()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::GetUser::Type;

        RequestType request;
        request.userIndex = 1U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))
                ->OnSuccessResponse_9(data.userIndex, data.userName, data.userUniqueId, data.userStatus, data.userType,
                                      data.credentialRule, data.credentials, data.creatorFabricIndex, data.lastModifiedFabricIndex,
                                      data.nextUserIndex);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_9(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_9(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_9(
        uint16_t userIndex, const chip::app::DataModel::Nullable<chip::CharSpan> & userName,
        const chip::app::DataModel::Nullable<uint32_t> & userUniqueId,
        const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlUserStatus> & userStatus,
        const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlUserType> & userType,
        const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlCredentialRule> & credentialRule,
        const chip::app::DataModel::Nullable<
            chip::app::DataModel::DecodableList<chip::app::Clusters::DoorLock::Structs::DlCredential::DecodableType>> & credentials,
        const chip::app::DataModel::Nullable<chip::FabricIndex> & creatorFabricIndex,
        const chip::app::DataModel::Nullable<chip::FabricIndex> & lastModifiedFabricIndex,
        const chip::app::DataModel::Nullable<uint16_t> & nextUserIndex)
    {
        VerifyOrReturn(CheckValue("userIndex", userIndex, 1U));

        VerifyOrReturn(CheckValueNonNull("userName", userName));
        VerifyOrReturn(CheckValueAsString("userName.Value()", userName.Value(), chip::CharSpan("new_user", 8)));

        VerifyOrReturn(CheckValueNull("userUniqueId", userUniqueId));

        VerifyOrReturn(CheckValueNonNull("userStatus", userStatus));
        VerifyOrReturn(CheckValue("userStatus.Value()", userStatus.Value(), 1));

        VerifyOrReturn(CheckValueNonNull("userType", userType));
        VerifyOrReturn(CheckValue("userType.Value()", userType.Value(), 0));

        VerifyOrReturn(CheckValueNonNull("credentialRule", credentialRule));
        VerifyOrReturn(CheckValue("credentialRule.Value()", credentialRule.Value(), 0));

        VerifyOrReturn(CheckValueNull("credentials", credentials));

        VerifyOrReturn(CheckValueNonNull("creatorFabricIndex", creatorFabricIndex));
        VerifyOrReturn(CheckValue("creatorFabricIndex.Value()", creatorFabricIndex.Value(), 1));

        VerifyOrReturn(CheckValueNonNull("lastModifiedFabricIndex", lastModifiedFabricIndex));
        VerifyOrReturn(CheckValue("lastModifiedFabricIndex.Value()", lastModifiedFabricIndex.Value(), 1));

        VerifyOrReturn(CheckValueNonNull("nextUserIndex", nextUserIndex));
        VerifyOrReturn(CheckValue("nextUserIndex.Value()", nextUserIndex.Value(), 2U));

        NextTest();
    }

    CHIP_ERROR TestModifyUserUniqueIdForExistingUser_10()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::SetUser::Type;

        RequestType request;
        request.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(2);
        request.userIndex     = 1U;
        request.userName.SetNull();
        request.userUniqueId.SetNonNull();
        request.userUniqueId.Value() = 305441741UL;
        request.userStatus.SetNull();
        request.userType.SetNull();
        request.credentialRule.SetNull();

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnSuccessResponse_10();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_10(error);
        };

        ReturnErrorOnFailure(
            chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request, 10000));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_10(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_10() { NextTest(); }

    CHIP_ERROR TestReadTheModifiedUserBackAndVerifyItsFields_11()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::GetUser::Type;

        RequestType request;
        request.userIndex = 1U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))
                ->OnSuccessResponse_11(data.userIndex, data.userName, data.userUniqueId, data.userStatus, data.userType,
                                       data.credentialRule, data.credentials, data.creatorFabricIndex, data.lastModifiedFabricIndex,
                                       data.nextUserIndex);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_11(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_11(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_11(
        uint16_t userIndex, const chip::app::DataModel::Nullable<chip::CharSpan> & userName,
        const chip::app::DataModel::Nullable<uint32_t> & userUniqueId,
        const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlUserStatus> & userStatus,
        const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlUserType> & userType,
        const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlCredentialRule> & credentialRule,
        const chip::app::DataModel::Nullable<
            chip::app::DataModel::DecodableList<chip::app::Clusters::DoorLock::Structs::DlCredential::DecodableType>> & credentials,
        const chip::app::DataModel::Nullable<chip::FabricIndex> & creatorFabricIndex,
        const chip::app::DataModel::Nullable<chip::FabricIndex> & lastModifiedFabricIndex,
        const chip::app::DataModel::Nullable<uint16_t> & nextUserIndex)
    {
        VerifyOrReturn(CheckValue("userIndex", userIndex, 1U));

        VerifyOrReturn(CheckValueNonNull("userName", userName));
        VerifyOrReturn(CheckValueAsString("userName.Value()", userName.Value(), chip::CharSpan("new_user", 8)));

        VerifyOrReturn(CheckValueNonNull("userUniqueId", userUniqueId));
        VerifyOrReturn(CheckValue("userUniqueId.Value()", userUniqueId.Value(), 305441741UL));

        VerifyOrReturn(CheckValueNonNull("userStatus", userStatus));
        VerifyOrReturn(CheckValue("userStatus.Value()", userStatus.Value(), 1));

        VerifyOrReturn(CheckValueNonNull("userType", userType));
        VerifyOrReturn(CheckValue("userType.Value()", userType.Value(), 0));

        VerifyOrReturn(CheckValueNonNull("credentialRule", credentialRule));
        VerifyOrReturn(CheckValue("credentialRule.Value()", credentialRule.Value(), 0));

        VerifyOrReturn(CheckValueNull("credentials", credentials));

        VerifyOrReturn(CheckValueNonNull("creatorFabricIndex", creatorFabricIndex));
        VerifyOrReturn(CheckValue("creatorFabricIndex.Value()", creatorFabricIndex.Value(), 1));

        VerifyOrReturn(CheckValueNonNull("lastModifiedFabricIndex", lastModifiedFabricIndex));
        VerifyOrReturn(CheckValue("lastModifiedFabricIndex.Value()", lastModifiedFabricIndex.Value(), 1));

        VerifyOrReturn(CheckValueNonNull("nextUserIndex", nextUserIndex));
        VerifyOrReturn(CheckValue("nextUserIndex.Value()", nextUserIndex.Value(), 2U));

        NextTest();
    }

    CHIP_ERROR TestModifyUserStatusForExistingUser_12()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::SetUser::Type;

        RequestType request;
        request.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(2);
        request.userIndex     = 1U;
        request.userName.SetNull();
        request.userUniqueId.SetNull();
        request.userStatus.SetNonNull();
        request.userStatus.Value() = static_cast<chip::app::Clusters::DoorLock::DlUserStatus>(3);
        request.userType.SetNull();
        request.credentialRule.SetNull();

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnSuccessResponse_12();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_12(error);
        };

        ReturnErrorOnFailure(
            chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request, 10000));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_12(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_12() { NextTest(); }

    CHIP_ERROR TestReadTheModifiedUserBackAndVerifyItsFields_13()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::GetUser::Type;

        RequestType request;
        request.userIndex = 1U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))
                ->OnSuccessResponse_13(data.userIndex, data.userName, data.userUniqueId, data.userStatus, data.userType,
                                       data.credentialRule, data.credentials, data.creatorFabricIndex, data.lastModifiedFabricIndex,
                                       data.nextUserIndex);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_13(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_13(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_13(
        uint16_t userIndex, const chip::app::DataModel::Nullable<chip::CharSpan> & userName,
        const chip::app::DataModel::Nullable<uint32_t> & userUniqueId,
        const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlUserStatus> & userStatus,
        const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlUserType> & userType,
        const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlCredentialRule> & credentialRule,
        const chip::app::DataModel::Nullable<
            chip::app::DataModel::DecodableList<chip::app::Clusters::DoorLock::Structs::DlCredential::DecodableType>> & credentials,
        const chip::app::DataModel::Nullable<chip::FabricIndex> & creatorFabricIndex,
        const chip::app::DataModel::Nullable<chip::FabricIndex> & lastModifiedFabricIndex,
        const chip::app::DataModel::Nullable<uint16_t> & nextUserIndex)
    {
        VerifyOrReturn(CheckValue("userIndex", userIndex, 1U));

        VerifyOrReturn(CheckValueNonNull("userName", userName));
        VerifyOrReturn(CheckValueAsString("userName.Value()", userName.Value(), chip::CharSpan("new_user", 8)));

        VerifyOrReturn(CheckValueNonNull("userUniqueId", userUniqueId));
        VerifyOrReturn(CheckValue("userUniqueId.Value()", userUniqueId.Value(), 305441741UL));

        VerifyOrReturn(CheckValueNonNull("userStatus", userStatus));
        VerifyOrReturn(CheckValue("userStatus.Value()", userStatus.Value(), 3));

        VerifyOrReturn(CheckValueNonNull("userType", userType));
        VerifyOrReturn(CheckValue("userType.Value()", userType.Value(), 0));

        VerifyOrReturn(CheckValueNonNull("credentialRule", credentialRule));
        VerifyOrReturn(CheckValue("credentialRule.Value()", credentialRule.Value(), 0));

        VerifyOrReturn(CheckValueNull("credentials", credentials));

        VerifyOrReturn(CheckValueNonNull("creatorFabricIndex", creatorFabricIndex));
        VerifyOrReturn(CheckValue("creatorFabricIndex.Value()", creatorFabricIndex.Value(), 1));

        VerifyOrReturn(CheckValueNonNull("lastModifiedFabricIndex", lastModifiedFabricIndex));
        VerifyOrReturn(CheckValue("lastModifiedFabricIndex.Value()", lastModifiedFabricIndex.Value(), 1));

        VerifyOrReturn(CheckValueNonNull("nextUserIndex", nextUserIndex));
        VerifyOrReturn(CheckValue("nextUserIndex.Value()", nextUserIndex.Value(), 2U));

        NextTest();
    }

    CHIP_ERROR TestModifyUserTypeForExistingUser_14()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::SetUser::Type;

        RequestType request;
        request.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(2);
        request.userIndex     = 1U;
        request.userName.SetNull();
        request.userUniqueId.SetNull();
        request.userStatus.SetNull();
        request.userType.SetNonNull();
        request.userType.Value() = static_cast<chip::app::Clusters::DoorLock::DlUserType>(6);
        request.credentialRule.SetNull();

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnSuccessResponse_14();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_14(error);
        };

        ReturnErrorOnFailure(
            chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request, 10000));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_14(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_14() { NextTest(); }

    CHIP_ERROR TestReadTheModifiedUserBackAndVerifyItsFields_15()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::GetUser::Type;

        RequestType request;
        request.userIndex = 1U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))
                ->OnSuccessResponse_15(data.userIndex, data.userName, data.userUniqueId, data.userStatus, data.userType,
                                       data.credentialRule, data.credentials, data.creatorFabricIndex, data.lastModifiedFabricIndex,
                                       data.nextUserIndex);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_15(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_15(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_15(
        uint16_t userIndex, const chip::app::DataModel::Nullable<chip::CharSpan> & userName,
        const chip::app::DataModel::Nullable<uint32_t> & userUniqueId,
        const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlUserStatus> & userStatus,
        const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlUserType> & userType,
        const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlCredentialRule> & credentialRule,
        const chip::app::DataModel::Nullable<
            chip::app::DataModel::DecodableList<chip::app::Clusters::DoorLock::Structs::DlCredential::DecodableType>> & credentials,
        const chip::app::DataModel::Nullable<chip::FabricIndex> & creatorFabricIndex,
        const chip::app::DataModel::Nullable<chip::FabricIndex> & lastModifiedFabricIndex,
        const chip::app::DataModel::Nullable<uint16_t> & nextUserIndex)
    {
        VerifyOrReturn(CheckValue("userIndex", userIndex, 1U));

        VerifyOrReturn(CheckValueNonNull("userName", userName));
        VerifyOrReturn(CheckValueAsString("userName.Value()", userName.Value(), chip::CharSpan("new_user", 8)));

        VerifyOrReturn(CheckValueNonNull("userUniqueId", userUniqueId));
        VerifyOrReturn(CheckValue("userUniqueId.Value()", userUniqueId.Value(), 305441741UL));

        VerifyOrReturn(CheckValueNonNull("userStatus", userStatus));
        VerifyOrReturn(CheckValue("userStatus.Value()", userStatus.Value(), 3));

        VerifyOrReturn(CheckValueNonNull("userType", userType));
        VerifyOrReturn(CheckValue("userType.Value()", userType.Value(), 6));

        VerifyOrReturn(CheckValueNonNull("credentialRule", credentialRule));
        VerifyOrReturn(CheckValue("credentialRule.Value()", credentialRule.Value(), 0));

        VerifyOrReturn(CheckValueNull("credentials", credentials));

        VerifyOrReturn(CheckValueNonNull("creatorFabricIndex", creatorFabricIndex));
        VerifyOrReturn(CheckValue("creatorFabricIndex.Value()", creatorFabricIndex.Value(), 1));

        VerifyOrReturn(CheckValueNonNull("lastModifiedFabricIndex", lastModifiedFabricIndex));
        VerifyOrReturn(CheckValue("lastModifiedFabricIndex.Value()", lastModifiedFabricIndex.Value(), 1));

        VerifyOrReturn(CheckValueNonNull("nextUserIndex", nextUserIndex));
        VerifyOrReturn(CheckValue("nextUserIndex.Value()", nextUserIndex.Value(), 2U));

        NextTest();
    }

    CHIP_ERROR TestModifyCredentialRuleForExistingUser_16()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::SetUser::Type;

        RequestType request;
        request.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(2);
        request.userIndex     = 1U;
        request.userName.SetNull();
        request.userUniqueId.SetNull();
        request.userStatus.SetNull();
        request.userType.SetNull();
        request.credentialRule.SetNonNull();
        request.credentialRule.Value() = static_cast<chip::app::Clusters::DoorLock::DlCredentialRule>(2);

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnSuccessResponse_16();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_16(error);
        };

        ReturnErrorOnFailure(
            chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request, 10000));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_16(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_16() { NextTest(); }

    CHIP_ERROR TestReadTheModifiedUserBackAndVerifyItsFields_17()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::GetUser::Type;

        RequestType request;
        request.userIndex = 1U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))
                ->OnSuccessResponse_17(data.userIndex, data.userName, data.userUniqueId, data.userStatus, data.userType,
                                       data.credentialRule, data.credentials, data.creatorFabricIndex, data.lastModifiedFabricIndex,
                                       data.nextUserIndex);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_17(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_17(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_17(
        uint16_t userIndex, const chip::app::DataModel::Nullable<chip::CharSpan> & userName,
        const chip::app::DataModel::Nullable<uint32_t> & userUniqueId,
        const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlUserStatus> & userStatus,
        const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlUserType> & userType,
        const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlCredentialRule> & credentialRule,
        const chip::app::DataModel::Nullable<
            chip::app::DataModel::DecodableList<chip::app::Clusters::DoorLock::Structs::DlCredential::DecodableType>> & credentials,
        const chip::app::DataModel::Nullable<chip::FabricIndex> & creatorFabricIndex,
        const chip::app::DataModel::Nullable<chip::FabricIndex> & lastModifiedFabricIndex,
        const chip::app::DataModel::Nullable<uint16_t> & nextUserIndex)
    {
        VerifyOrReturn(CheckValue("userIndex", userIndex, 1U));

        VerifyOrReturn(CheckValueNonNull("userName", userName));
        VerifyOrReturn(CheckValueAsString("userName.Value()", userName.Value(), chip::CharSpan("new_user", 8)));

        VerifyOrReturn(CheckValueNonNull("userUniqueId", userUniqueId));
        VerifyOrReturn(CheckValue("userUniqueId.Value()", userUniqueId.Value(), 305441741UL));

        VerifyOrReturn(CheckValueNonNull("userStatus", userStatus));
        VerifyOrReturn(CheckValue("userStatus.Value()", userStatus.Value(), 3));

        VerifyOrReturn(CheckValueNonNull("userType", userType));
        VerifyOrReturn(CheckValue("userType.Value()", userType.Value(), 6));

        VerifyOrReturn(CheckValueNonNull("credentialRule", credentialRule));
        VerifyOrReturn(CheckValue("credentialRule.Value()", credentialRule.Value(), 2));

        VerifyOrReturn(CheckValueNull("credentials", credentials));

        VerifyOrReturn(CheckValueNonNull("creatorFabricIndex", creatorFabricIndex));
        VerifyOrReturn(CheckValue("creatorFabricIndex.Value()", creatorFabricIndex.Value(), 1));

        VerifyOrReturn(CheckValueNonNull("lastModifiedFabricIndex", lastModifiedFabricIndex));
        VerifyOrReturn(CheckValue("lastModifiedFabricIndex.Value()", lastModifiedFabricIndex.Value(), 1));

        VerifyOrReturn(CheckValueNonNull("nextUserIndex", nextUserIndex));
        VerifyOrReturn(CheckValue("nextUserIndex.Value()", nextUserIndex.Value(), 2U));

        NextTest();
    }

    CHIP_ERROR TestModifyAllFieldsForExistingUser_18()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::SetUser::Type;

        RequestType request;
        request.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(2);
        request.userIndex     = 1U;
        request.userName.SetNonNull();
        request.userName.Value() = chip::Span<const char>("test_usergarbage: not in length on purpose", 9);
        request.userUniqueId.SetNonNull();
        request.userUniqueId.Value() = 466460832UL;
        request.userStatus.SetNonNull();
        request.userStatus.Value() = static_cast<chip::app::Clusters::DoorLock::DlUserStatus>(1);
        request.userType.SetNonNull();
        request.userType.Value() = static_cast<chip::app::Clusters::DoorLock::DlUserType>(0);
        request.credentialRule.SetNonNull();
        request.credentialRule.Value() = static_cast<chip::app::Clusters::DoorLock::DlCredentialRule>(1);

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnSuccessResponse_18();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_18(error);
        };

        ReturnErrorOnFailure(
            chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request, 10000));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_18(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_18() { NextTest(); }

    CHIP_ERROR TestReadTheModifiedUserBackAndVerifyItsFields_19()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::GetUser::Type;

        RequestType request;
        request.userIndex = 1U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))
                ->OnSuccessResponse_19(data.userIndex, data.userName, data.userUniqueId, data.userStatus, data.userType,
                                       data.credentialRule, data.credentials, data.creatorFabricIndex, data.lastModifiedFabricIndex,
                                       data.nextUserIndex);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_19(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_19(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_19(
        uint16_t userIndex, const chip::app::DataModel::Nullable<chip::CharSpan> & userName,
        const chip::app::DataModel::Nullable<uint32_t> & userUniqueId,
        const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlUserStatus> & userStatus,
        const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlUserType> & userType,
        const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlCredentialRule> & credentialRule,
        const chip::app::DataModel::Nullable<
            chip::app::DataModel::DecodableList<chip::app::Clusters::DoorLock::Structs::DlCredential::DecodableType>> & credentials,
        const chip::app::DataModel::Nullable<chip::FabricIndex> & creatorFabricIndex,
        const chip::app::DataModel::Nullable<chip::FabricIndex> & lastModifiedFabricIndex,
        const chip::app::DataModel::Nullable<uint16_t> & nextUserIndex)
    {
        VerifyOrReturn(CheckValue("userIndex", userIndex, 1U));

        VerifyOrReturn(CheckValueNonNull("userName", userName));
        VerifyOrReturn(CheckValueAsString("userName.Value()", userName.Value(), chip::CharSpan("test_user", 9)));

        VerifyOrReturn(CheckValueNonNull("userUniqueId", userUniqueId));
        VerifyOrReturn(CheckValue("userUniqueId.Value()", userUniqueId.Value(), 466460832UL));

        VerifyOrReturn(CheckValueNonNull("userStatus", userStatus));
        VerifyOrReturn(CheckValue("userStatus.Value()", userStatus.Value(), 1));

        VerifyOrReturn(CheckValueNonNull("userType", userType));
        VerifyOrReturn(CheckValue("userType.Value()", userType.Value(), 0));

        VerifyOrReturn(CheckValueNonNull("credentialRule", credentialRule));
        VerifyOrReturn(CheckValue("credentialRule.Value()", credentialRule.Value(), 1));

        VerifyOrReturn(CheckValueNull("credentials", credentials));

        VerifyOrReturn(CheckValueNonNull("creatorFabricIndex", creatorFabricIndex));
        VerifyOrReturn(CheckValue("creatorFabricIndex.Value()", creatorFabricIndex.Value(), 1));

        VerifyOrReturn(CheckValueNonNull("lastModifiedFabricIndex", lastModifiedFabricIndex));
        VerifyOrReturn(CheckValue("lastModifiedFabricIndex.Value()", lastModifiedFabricIndex.Value(), 1));

        VerifyOrReturn(CheckValueNonNull("nextUserIndex", nextUserIndex));
        VerifyOrReturn(CheckValue("nextUserIndex.Value()", nextUserIndex.Value(), 2U));

        NextTest();
    }

    CHIP_ERROR TestAddAnotherUserWithNonDefaultFields_20()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::SetUser::Type;

        RequestType request;
        request.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);
        request.userIndex     = 2U;
        request.userName.SetNonNull();
        request.userName.Value() = chip::Span<const char>("test_user2garbage: not in length on purpose", 10);
        request.userUniqueId.SetNonNull();
        request.userUniqueId.Value() = 12648430UL;
        request.userStatus.SetNonNull();
        request.userStatus.Value() = static_cast<chip::app::Clusters::DoorLock::DlUserStatus>(1);
        request.userType.SetNonNull();
        request.userType.Value() = static_cast<chip::app::Clusters::DoorLock::DlUserType>(1);
        request.credentialRule.SetNonNull();
        request.credentialRule.Value() = static_cast<chip::app::Clusters::DoorLock::DlCredentialRule>(2);

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnSuccessResponse_20();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_20(error);
        };

        ReturnErrorOnFailure(
            chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request, 10000));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_20(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_20() { NextTest(); }

    CHIP_ERROR TestReadTheNewUserBackAndVerifyItsFields_21()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::GetUser::Type;

        RequestType request;
        request.userIndex = 2U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))
                ->OnSuccessResponse_21(data.userIndex, data.userName, data.userUniqueId, data.userStatus, data.userType,
                                       data.credentialRule, data.credentials, data.creatorFabricIndex, data.lastModifiedFabricIndex,
                                       data.nextUserIndex);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_21(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_21(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_21(
        uint16_t userIndex, const chip::app::DataModel::Nullable<chip::CharSpan> & userName,
        const chip::app::DataModel::Nullable<uint32_t> & userUniqueId,
        const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlUserStatus> & userStatus,
        const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlUserType> & userType,
        const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlCredentialRule> & credentialRule,
        const chip::app::DataModel::Nullable<
            chip::app::DataModel::DecodableList<chip::app::Clusters::DoorLock::Structs::DlCredential::DecodableType>> & credentials,
        const chip::app::DataModel::Nullable<chip::FabricIndex> & creatorFabricIndex,
        const chip::app::DataModel::Nullable<chip::FabricIndex> & lastModifiedFabricIndex,
        const chip::app::DataModel::Nullable<uint16_t> & nextUserIndex)
    {
        VerifyOrReturn(CheckValue("userIndex", userIndex, 2U));

        VerifyOrReturn(CheckValueNonNull("userName", userName));
        VerifyOrReturn(CheckValueAsString("userName.Value()", userName.Value(), chip::CharSpan("test_user2", 10)));

        VerifyOrReturn(CheckValueNonNull("userUniqueId", userUniqueId));
        VerifyOrReturn(CheckValue("userUniqueId.Value()", userUniqueId.Value(), 12648430UL));

        VerifyOrReturn(CheckValueNonNull("userStatus", userStatus));
        VerifyOrReturn(CheckValue("userStatus.Value()", userStatus.Value(), 1));

        VerifyOrReturn(CheckValueNonNull("userType", userType));
        VerifyOrReturn(CheckValue("userType.Value()", userType.Value(), 1));

        VerifyOrReturn(CheckValueNonNull("credentialRule", credentialRule));
        VerifyOrReturn(CheckValue("credentialRule.Value()", credentialRule.Value(), 2));

        VerifyOrReturn(CheckValueNull("credentials", credentials));

        VerifyOrReturn(CheckValueNonNull("creatorFabricIndex", creatorFabricIndex));
        VerifyOrReturn(CheckValue("creatorFabricIndex.Value()", creatorFabricIndex.Value(), 1));

        VerifyOrReturn(CheckValueNonNull("lastModifiedFabricIndex", lastModifiedFabricIndex));
        VerifyOrReturn(CheckValue("lastModifiedFabricIndex.Value()", lastModifiedFabricIndex.Value(), 1));

        VerifyOrReturn(CheckValueNonNull("nextUserIndex", nextUserIndex));
        VerifyOrReturn(CheckValue("nextUserIndex.Value()", nextUserIndex.Value(), 3U));

        NextTest();
    }

    CHIP_ERROR TestCreateUserInTheLastSlot_22()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::SetUser::Type;

        RequestType request;
        request.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);
        request.userIndex     = NumberOfTotalUsersSupported;
        request.userName.SetNonNull();
        request.userName.Value() = chip::Span<const char>("last_usergarbage: not in length on purpose", 9);
        request.userUniqueId.SetNull();
        request.userStatus.SetNull();
        request.userType.SetNull();
        request.credentialRule.SetNull();

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnSuccessResponse_22();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_22(error);
        };

        ReturnErrorOnFailure(
            chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request, 10000));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_22(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_22() { NextTest(); }

    CHIP_ERROR TestReadTheLastUserBackAndVerifyItsFields_23()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::GetUser::Type;

        RequestType request;
        request.userIndex = NumberOfTotalUsersSupported;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))
                ->OnSuccessResponse_23(data.userIndex, data.userName, data.userUniqueId, data.userStatus, data.userType,
                                       data.credentialRule, data.credentials, data.creatorFabricIndex, data.lastModifiedFabricIndex,
                                       data.nextUserIndex);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_23(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_23(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_23(
        uint16_t userIndex, const chip::app::DataModel::Nullable<chip::CharSpan> & userName,
        const chip::app::DataModel::Nullable<uint32_t> & userUniqueId,
        const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlUserStatus> & userStatus,
        const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlUserType> & userType,
        const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlCredentialRule> & credentialRule,
        const chip::app::DataModel::Nullable<
            chip::app::DataModel::DecodableList<chip::app::Clusters::DoorLock::Structs::DlCredential::DecodableType>> & credentials,
        const chip::app::DataModel::Nullable<chip::FabricIndex> & creatorFabricIndex,
        const chip::app::DataModel::Nullable<chip::FabricIndex> & lastModifiedFabricIndex,
        const chip::app::DataModel::Nullable<uint16_t> & nextUserIndex)
    {
        VerifyOrReturn(CheckValue("userIndex", userIndex, NumberOfTotalUsersSupported));

        VerifyOrReturn(CheckValueNonNull("userName", userName));
        VerifyOrReturn(CheckValueAsString("userName.Value()", userName.Value(), chip::CharSpan("last_user", 9)));

        VerifyOrReturn(CheckValueNull("userUniqueId", userUniqueId));

        VerifyOrReturn(CheckValueNonNull("userStatus", userStatus));
        VerifyOrReturn(CheckValue("userStatus.Value()", userStatus.Value(), 1));

        VerifyOrReturn(CheckValueNonNull("userType", userType));
        VerifyOrReturn(CheckValue("userType.Value()", userType.Value(), 0));

        VerifyOrReturn(CheckValueNonNull("credentialRule", credentialRule));
        VerifyOrReturn(CheckValue("credentialRule.Value()", credentialRule.Value(), 0));

        VerifyOrReturn(CheckValueNull("credentials", credentials));

        VerifyOrReturn(CheckValueNonNull("creatorFabricIndex", creatorFabricIndex));
        VerifyOrReturn(CheckValue("creatorFabricIndex.Value()", creatorFabricIndex.Value(), 1));

        VerifyOrReturn(CheckValueNonNull("lastModifiedFabricIndex", lastModifiedFabricIndex));
        VerifyOrReturn(CheckValue("lastModifiedFabricIndex.Value()", lastModifiedFabricIndex.Value(), 1));

        VerifyOrReturn(CheckValueNull("nextUserIndex", nextUserIndex));

        NextTest();
    }

    CHIP_ERROR TestUserCreationInThe0SlotFails_24()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::SetUser::Type;

        RequestType request;
        request.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);
        request.userIndex     = 0U;
        request.userName.SetNull();
        request.userUniqueId.SetNull();
        request.userStatus.SetNull();
        request.userType.SetNull();
        request.credentialRule.SetNull();

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnSuccessResponse_24();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_24(error);
        };

        ReturnErrorOnFailure(
            chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request, 10000));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_24(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_COMMAND));
        NextTest();
    }

    void OnSuccessResponse_24() { ThrowSuccessResponse(); }

    CHIP_ERROR TestUserCreationInTheOutOfBoundsSlotFails_25()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::SetUser::Type;

        RequestType request;
        request.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);
        request.userIndex     = static_cast<uint16_t>(NumberOfTotalUsersSupported + 1);
        request.userName.SetNull();
        request.userUniqueId.SetNull();
        request.userStatus.SetNull();
        request.userType.SetNull();
        request.credentialRule.SetNull();

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnSuccessResponse_25();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_25(error);
        };

        ReturnErrorOnFailure(
            chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request, 10000));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_25(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_COMMAND));
        NextTest();
    }

    void OnSuccessResponse_25() { ThrowSuccessResponse(); }

    CHIP_ERROR TestClearFirstUser_26()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::ClearUser::Type;

        RequestType request;
        request.userIndex = 1U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnSuccessResponse_26();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_26(error);
        };

        ReturnErrorOnFailure(
            chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request, 10000));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_26(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_26() { NextTest(); }

    CHIP_ERROR TestReadClearedUserAndVerifyItIsAvailable_27()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::GetUser::Type;

        RequestType request;
        request.userIndex = 1U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))
                ->OnSuccessResponse_27(data.userIndex, data.userName, data.userUniqueId, data.userStatus, data.userType,
                                       data.credentialRule, data.credentials, data.creatorFabricIndex, data.lastModifiedFabricIndex,
                                       data.nextUserIndex);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_27(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_27(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_27(
        uint16_t userIndex, const chip::app::DataModel::Nullable<chip::CharSpan> & userName,
        const chip::app::DataModel::Nullable<uint32_t> & userUniqueId,
        const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlUserStatus> & userStatus,
        const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlUserType> & userType,
        const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlCredentialRule> & credentialRule,
        const chip::app::DataModel::Nullable<
            chip::app::DataModel::DecodableList<chip::app::Clusters::DoorLock::Structs::DlCredential::DecodableType>> & credentials,
        const chip::app::DataModel::Nullable<chip::FabricIndex> & creatorFabricIndex,
        const chip::app::DataModel::Nullable<chip::FabricIndex> & lastModifiedFabricIndex,
        const chip::app::DataModel::Nullable<uint16_t> & nextUserIndex)
    {
        VerifyOrReturn(CheckValue("userIndex", userIndex, 1U));

        VerifyOrReturn(CheckValueNull("userName", userName));

        VerifyOrReturn(CheckValueNull("userUniqueId", userUniqueId));

        VerifyOrReturn(CheckValueNull("userStatus", userStatus));

        VerifyOrReturn(CheckValueNull("userType", userType));

        VerifyOrReturn(CheckValueNull("credentialRule", credentialRule));

        VerifyOrReturn(CheckValueNull("credentials", credentials));

        VerifyOrReturn(CheckValueNull("creatorFabricIndex", creatorFabricIndex));

        VerifyOrReturn(CheckValueNull("lastModifiedFabricIndex", lastModifiedFabricIndex));

        VerifyOrReturn(CheckValueNonNull("nextUserIndex", nextUserIndex));
        VerifyOrReturn(CheckValue("nextUserIndex.Value()", nextUserIndex.Value(), 3U));

        NextTest();
    }

    CHIP_ERROR TestCreateNewUserInTheClearedSlot_28()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::SetUser::Type;

        RequestType request;
        request.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);
        request.userIndex     = 1U;
        request.userName.SetNull();
        request.userUniqueId.SetNull();
        request.userStatus.SetNull();
        request.userType.SetNull();
        request.credentialRule.SetNull();

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnSuccessResponse_28();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_28(error);
        };

        ReturnErrorOnFailure(
            chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request, 10000));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_28(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_28() { NextTest(); }

    CHIP_ERROR TestReadTheUserInThePreviouslyClearedSlotAndVerifyItsFields_29()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::GetUser::Type;

        RequestType request;
        request.userIndex = 1U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))
                ->OnSuccessResponse_29(data.userIndex, data.userName, data.userUniqueId, data.userStatus, data.userType,
                                       data.credentialRule, data.credentials, data.creatorFabricIndex, data.lastModifiedFabricIndex,
                                       data.nextUserIndex);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_29(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_29(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_29(
        uint16_t userIndex, const chip::app::DataModel::Nullable<chip::CharSpan> & userName,
        const chip::app::DataModel::Nullable<uint32_t> & userUniqueId,
        const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlUserStatus> & userStatus,
        const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlUserType> & userType,
        const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlCredentialRule> & credentialRule,
        const chip::app::DataModel::Nullable<
            chip::app::DataModel::DecodableList<chip::app::Clusters::DoorLock::Structs::DlCredential::DecodableType>> & credentials,
        const chip::app::DataModel::Nullable<chip::FabricIndex> & creatorFabricIndex,
        const chip::app::DataModel::Nullable<chip::FabricIndex> & lastModifiedFabricIndex,
        const chip::app::DataModel::Nullable<uint16_t> & nextUserIndex)
    {
        VerifyOrReturn(CheckValue("userIndex", userIndex, 1U));

        VerifyOrReturn(CheckValueNonNull("userName", userName));
        VerifyOrReturn(CheckValueAsString("userName.Value()", userName.Value(), chip::CharSpan("", 0)));

        VerifyOrReturn(CheckValueNull("userUniqueId", userUniqueId));

        VerifyOrReturn(CheckValueNonNull("userStatus", userStatus));
        VerifyOrReturn(CheckValue("userStatus.Value()", userStatus.Value(), 1));

        VerifyOrReturn(CheckValueNonNull("userType", userType));
        VerifyOrReturn(CheckValue("userType.Value()", userType.Value(), 0));

        VerifyOrReturn(CheckValueNonNull("credentialRule", credentialRule));
        VerifyOrReturn(CheckValue("credentialRule.Value()", credentialRule.Value(), 0));

        VerifyOrReturn(CheckValueNull("credentials", credentials));

        VerifyOrReturn(CheckValueNonNull("creatorFabricIndex", creatorFabricIndex));
        VerifyOrReturn(CheckValue("creatorFabricIndex.Value()", creatorFabricIndex.Value(), 1));

        VerifyOrReturn(CheckValueNonNull("lastModifiedFabricIndex", lastModifiedFabricIndex));
        VerifyOrReturn(CheckValue("lastModifiedFabricIndex.Value()", lastModifiedFabricIndex.Value(), 1));

        VerifyOrReturn(CheckValueNonNull("nextUserIndex", nextUserIndex));
        VerifyOrReturn(CheckValue("nextUserIndex.Value()", nextUserIndex.Value(), 3U));

        NextTest();
    }

    CHIP_ERROR TestClearUserWithIndex0Fails_30()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::ClearUser::Type;

        RequestType request;
        request.userIndex = 0U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnSuccessResponse_30();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_30(error);
        };

        ReturnErrorOnFailure(
            chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request, 10000));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_30(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_COMMAND));
        NextTest();
    }

    void OnSuccessResponse_30() { ThrowSuccessResponse(); }

    CHIP_ERROR TestClearUserWithOutOfBoundsIndexFails_31()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::ClearUser::Type;

        RequestType request;
        request.userIndex = static_cast<uint16_t>(NumberOfTotalUsersSupported + 1);

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnSuccessResponse_31();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_31(error);
        };

        ReturnErrorOnFailure(
            chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request, 10000));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_31(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_COMMAND));
        NextTest();
    }

    void OnSuccessResponse_31() { ThrowSuccessResponse(); }

    CHIP_ERROR TestClearAllUsers_32()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::ClearUser::Type;

        RequestType request;
        request.userIndex = 65534U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnSuccessResponse_32();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_32(error);
        };

        ReturnErrorOnFailure(
            chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request, 10000));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_32(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_32() { NextTest(); }

    CHIP_ERROR TestReadFirstClearedUserAndVerifyItIsAvailable_33()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::GetUser::Type;

        RequestType request;
        request.userIndex = 2U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))
                ->OnSuccessResponse_33(data.userIndex, data.userName, data.userUniqueId, data.userStatus, data.userType,
                                       data.credentialRule, data.credentials, data.creatorFabricIndex, data.lastModifiedFabricIndex,
                                       data.nextUserIndex);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_33(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_33(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_33(
        uint16_t userIndex, const chip::app::DataModel::Nullable<chip::CharSpan> & userName,
        const chip::app::DataModel::Nullable<uint32_t> & userUniqueId,
        const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlUserStatus> & userStatus,
        const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlUserType> & userType,
        const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlCredentialRule> & credentialRule,
        const chip::app::DataModel::Nullable<
            chip::app::DataModel::DecodableList<chip::app::Clusters::DoorLock::Structs::DlCredential::DecodableType>> & credentials,
        const chip::app::DataModel::Nullable<chip::FabricIndex> & creatorFabricIndex,
        const chip::app::DataModel::Nullable<chip::FabricIndex> & lastModifiedFabricIndex,
        const chip::app::DataModel::Nullable<uint16_t> & nextUserIndex)
    {
        VerifyOrReturn(CheckValue("userIndex", userIndex, 2U));

        VerifyOrReturn(CheckValueNull("userName", userName));

        VerifyOrReturn(CheckValueNull("userUniqueId", userUniqueId));

        VerifyOrReturn(CheckValueNull("userStatus", userStatus));

        VerifyOrReturn(CheckValueNull("userType", userType));

        VerifyOrReturn(CheckValueNull("credentialRule", credentialRule));

        VerifyOrReturn(CheckValueNull("credentials", credentials));

        VerifyOrReturn(CheckValueNull("creatorFabricIndex", creatorFabricIndex));

        VerifyOrReturn(CheckValueNull("lastModifiedFabricIndex", lastModifiedFabricIndex));

        VerifyOrReturn(CheckValueNonNull("nextUserIndex", nextUserIndex));
        VerifyOrReturn(CheckValue("nextUserIndex.Value()", nextUserIndex.Value(), 3U));

        NextTest();
    }

    CHIP_ERROR TestReadLastClearedUserAndVerifyItIsAvailable_34()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::GetUser::Type;

        RequestType request;
        request.userIndex = NumberOfTotalUsersSupported;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))
                ->OnSuccessResponse_34(data.userIndex, data.userName, data.userUniqueId, data.userStatus, data.userType,
                                       data.credentialRule, data.credentials, data.creatorFabricIndex, data.lastModifiedFabricIndex,
                                       data.nextUserIndex);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_34(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_34(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_34(
        uint16_t userIndex, const chip::app::DataModel::Nullable<chip::CharSpan> & userName,
        const chip::app::DataModel::Nullable<uint32_t> & userUniqueId,
        const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlUserStatus> & userStatus,
        const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlUserType> & userType,
        const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlCredentialRule> & credentialRule,
        const chip::app::DataModel::Nullable<
            chip::app::DataModel::DecodableList<chip::app::Clusters::DoorLock::Structs::DlCredential::DecodableType>> & credentials,
        const chip::app::DataModel::Nullable<chip::FabricIndex> & creatorFabricIndex,
        const chip::app::DataModel::Nullable<chip::FabricIndex> & lastModifiedFabricIndex,
        const chip::app::DataModel::Nullable<uint16_t> & nextUserIndex)
    {
        VerifyOrReturn(CheckValue("userIndex", userIndex, NumberOfTotalUsersSupported));

        VerifyOrReturn(CheckValueNull("userName", userName));

        VerifyOrReturn(CheckValueNull("userUniqueId", userUniqueId));

        VerifyOrReturn(CheckValueNull("userStatus", userStatus));

        VerifyOrReturn(CheckValueNull("userType", userType));

        VerifyOrReturn(CheckValueNull("credentialRule", credentialRule));

        VerifyOrReturn(CheckValueNull("credentials", credentials));

        VerifyOrReturn(CheckValueNull("creatorFabricIndex", creatorFabricIndex));

        VerifyOrReturn(CheckValueNull("lastModifiedFabricIndex", lastModifiedFabricIndex));

        VerifyOrReturn(CheckValueNull("nextUserIndex", nextUserIndex));

        NextTest();
    }

    CHIP_ERROR TestGetNumberOfSupportedPinCredentialsAndVerifyDefaultValue_35()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::DoorLockClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::DoorLock::Attributes::NumberOfPINUsersSupported::TypeInfo>(
            this, OnSuccessCallback_35, OnFailureCallback_35, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_35(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_35(uint16_t numberOfPINUsersSupported)
    {
        VerifyOrReturn(CheckValue("numberOfPINUsersSupported", numberOfPINUsersSupported, 10U));

        NumberOfPINUsersSupported = numberOfPINUsersSupported;
        NextTest();
    }

    CHIP_ERROR TestCheckThatPinCredentialDoesNotExist_36()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::GetCredentialStatus::Type;

        RequestType request;

        request.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
        request.credential.credentialIndex = 1U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))
                ->OnSuccessResponse_36(data.credentialExists, data.userIndex, data.nextCredentialIndex);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_36(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_36(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_36(bool credentialExists, const chip::app::DataModel::Nullable<uint16_t> & userIndex,
                              const chip::app::DataModel::Nullable<uint16_t> & nextCredentialIndex)
    {
        VerifyOrReturn(CheckValue("credentialExists", credentialExists, false));

        VerifyOrReturn(CheckValueNull("userIndex", userIndex));

        VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", nextCredentialIndex));
        VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", nextCredentialIndex.Value(), 2U));

        NextTest();
    }

    CHIP_ERROR TestReadingPinCredentialWithIndex0Fails_37()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::GetCredentialStatus::Type;

        RequestType request;

        request.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
        request.credential.credentialIndex = 0U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))
                ->OnSuccessResponse_37(data.credentialExists, data.userIndex, data.nextCredentialIndex);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_37(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_37(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_COMMAND));
        NextTest();
    }

    void OnSuccessResponse_37(bool credentialExists, const chip::app::DataModel::Nullable<uint16_t> & userIndex,
                              const chip::app::DataModel::Nullable<uint16_t> & nextCredentialIndex)
    {
        ThrowSuccessResponse();
    }

    CHIP_ERROR TestReadingPinCredentialWithOutOfBoundsIndexFails_38()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::GetCredentialStatus::Type;

        RequestType request;

        request.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
        request.credential.credentialIndex = static_cast<uint16_t>(NumberOfPINUsersSupported + 1);

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))
                ->OnSuccessResponse_38(data.credentialExists, data.userIndex, data.nextCredentialIndex);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_38(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_38(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_COMMAND));
        NextTest();
    }

    void OnSuccessResponse_38(bool credentialExists, const chip::app::DataModel::Nullable<uint16_t> & userIndex,
                              const chip::app::DataModel::Nullable<uint16_t> & nextCredentialIndex)
    {
        ThrowSuccessResponse();
    }

    CHIP_ERROR TestCreateNewPinCredentialAndUser_39()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::SetCredential::Type;

        RequestType request;
        request.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);

        request.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
        request.credential.credentialIndex = 1U;

        request.credentialData = chip::ByteSpan(chip::Uint8::from_const_char("000000garbage: not in length on purpose"), 6);
        request.userIndex.SetNull();
        request.userStatus.SetNull();
        request.userType.SetNull();

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))
                ->OnSuccessResponse_39(data.status, data.userIndex, data.nextCredentialIndex);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_39(error);
        };

        ReturnErrorOnFailure(
            chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request, 10000));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_39(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_39(chip::app::Clusters::DoorLock::DlStatus status,
                              const chip::app::DataModel::Nullable<uint16_t> & userIndex,
                              const chip::app::DataModel::Nullable<uint16_t> & nextCredentialIndex)
    {
        VerifyOrReturn(CheckValue("status", status, 0));

        VerifyOrReturn(CheckValueNonNull("userIndex", userIndex));
        VerifyOrReturn(CheckValue("userIndex.Value()", userIndex.Value(), 1U));

        VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", nextCredentialIndex));
        VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", nextCredentialIndex.Value(), 2U));

        NextTest();
    }

    CHIP_ERROR TestVerifyCreatedUser_40()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::GetUser::Type;

        RequestType request;
        request.userIndex = 1U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))
                ->OnSuccessResponse_40(data.userIndex, data.userName, data.userUniqueId, data.userStatus, data.userType,
                                       data.credentialRule, data.credentials, data.creatorFabricIndex, data.lastModifiedFabricIndex,
                                       data.nextUserIndex);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_40(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_40(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_40(
        uint16_t userIndex, const chip::app::DataModel::Nullable<chip::CharSpan> & userName,
        const chip::app::DataModel::Nullable<uint32_t> & userUniqueId,
        const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlUserStatus> & userStatus,
        const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlUserType> & userType,
        const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlCredentialRule> & credentialRule,
        const chip::app::DataModel::Nullable<
            chip::app::DataModel::DecodableList<chip::app::Clusters::DoorLock::Structs::DlCredential::DecodableType>> & credentials,
        const chip::app::DataModel::Nullable<chip::FabricIndex> & creatorFabricIndex,
        const chip::app::DataModel::Nullable<chip::FabricIndex> & lastModifiedFabricIndex,
        const chip::app::DataModel::Nullable<uint16_t> & nextUserIndex)
    {
        VerifyOrReturn(CheckValue("userIndex", userIndex, 1U));

        VerifyOrReturn(CheckValueNonNull("userName", userName));
        VerifyOrReturn(CheckValueAsString("userName.Value()", userName.Value(), chip::CharSpan("", 0)));

        VerifyOrReturn(CheckValueNull("userUniqueId", userUniqueId));

        VerifyOrReturn(CheckValueNonNull("userStatus", userStatus));
        VerifyOrReturn(CheckValue("userStatus.Value()", userStatus.Value(), 1));

        VerifyOrReturn(CheckValueNonNull("userType", userType));
        VerifyOrReturn(CheckValue("userType.Value()", userType.Value(), 0));

        VerifyOrReturn(CheckValueNonNull("credentialRule", credentialRule));
        VerifyOrReturn(CheckValue("credentialRule.Value()", credentialRule.Value(), 0));

        VerifyOrReturn(CheckValueNonNull("credentials", credentials));
        {
            auto iter_1 = credentials.Value().begin();
            VerifyOrReturn(CheckNextListItemDecodes<decltype(credentials.Value())>("credentials.Value()", iter_1, 0));
            VerifyOrReturn(CheckValue("credentials.Value()[0].credentialType", iter_1.GetValue().credentialType, 1));
            VerifyOrReturn(CheckValue("credentials.Value()[0].credentialIndex", iter_1.GetValue().credentialIndex, 1U));
            VerifyOrReturn(CheckNoMoreListItems<decltype(credentials.Value())>("credentials.Value()", iter_1, 1));
        }

        VerifyOrReturn(CheckValueNonNull("creatorFabricIndex", creatorFabricIndex));
        VerifyOrReturn(CheckValue("creatorFabricIndex.Value()", creatorFabricIndex.Value(), 1));

        VerifyOrReturn(CheckValueNonNull("lastModifiedFabricIndex", lastModifiedFabricIndex));
        VerifyOrReturn(CheckValue("lastModifiedFabricIndex.Value()", lastModifiedFabricIndex.Value(), 1));

        VerifyOrReturn(CheckValueNonNull("nextUserIndex", nextUserIndex));
        VerifyOrReturn(CheckValue("nextUserIndex.Value()", nextUserIndex.Value(), 2U));

        NextTest();
    }

    CHIP_ERROR TestVerifyCreatedPinCredential_41()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::GetCredentialStatus::Type;

        RequestType request;

        request.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
        request.credential.credentialIndex = 1U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))
                ->OnSuccessResponse_41(data.credentialExists, data.userIndex, data.nextCredentialIndex);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_41(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_41(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_41(bool credentialExists, const chip::app::DataModel::Nullable<uint16_t> & userIndex,
                              const chip::app::DataModel::Nullable<uint16_t> & nextCredentialIndex)
    {
        VerifyOrReturn(CheckValue("credentialExists", credentialExists, true));

        VerifyOrReturn(CheckValueNonNull("userIndex", userIndex));
        VerifyOrReturn(CheckValue("userIndex.Value()", userIndex.Value(), 1U));

        VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", nextCredentialIndex));
        VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", nextCredentialIndex.Value(), 2U));

        NextTest();
    }

    CHIP_ERROR TestCreateNewPinCredentialAndUserWithIndex0Fails_42()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::SetCredential::Type;

        RequestType request;
        request.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);

        request.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
        request.credential.credentialIndex = 0U;

        request.credentialData = chip::ByteSpan(chip::Uint8::from_const_char("123456garbage: not in length on purpose"), 6);
        request.userIndex.SetNull();
        request.userStatus.SetNull();
        request.userType.SetNull();

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))
                ->OnSuccessResponse_42(data.status, data.userIndex, data.nextCredentialIndex);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_42(error);
        };

        ReturnErrorOnFailure(
            chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request, 10000));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_42(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_42(chip::app::Clusters::DoorLock::DlStatus status,
                              const chip::app::DataModel::Nullable<uint16_t> & userIndex,
                              const chip::app::DataModel::Nullable<uint16_t> & nextCredentialIndex)
    {
        VerifyOrReturn(CheckValue("status", status, 133));

        VerifyOrReturn(CheckValueNull("userIndex", userIndex));

        VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", nextCredentialIndex));
        VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", nextCredentialIndex.Value(), 2U));

        NextTest();
    }

    CHIP_ERROR TestCreateNewPinCredentialAndUserWithOutOfBoundsIndexFails_43()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::SetCredential::Type;

        RequestType request;
        request.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);

        request.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
        request.credential.credentialIndex = static_cast<uint16_t>(NumberOfPINUsersSupported + 1);

        request.credentialData = chip::ByteSpan(chip::Uint8::from_const_char("123456garbage: not in length on purpose"), 6);
        request.userIndex.SetNull();
        request.userStatus.SetNull();
        request.userType.SetNull();

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))
                ->OnSuccessResponse_43(data.status, data.userIndex, data.nextCredentialIndex);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_43(error);
        };

        ReturnErrorOnFailure(
            chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request, 10000));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_43(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_43(chip::app::Clusters::DoorLock::DlStatus status,
                              const chip::app::DataModel::Nullable<uint16_t> & userIndex,
                              const chip::app::DataModel::Nullable<uint16_t> & nextCredentialIndex)
    {
        VerifyOrReturn(CheckValue("status", status, 133));

        VerifyOrReturn(CheckValueNull("userIndex", userIndex));

        VerifyOrReturn(CheckValueNull("nextCredentialIndex", nextCredentialIndex));

        NextTest();
    }

    CHIP_ERROR TestGetNumberOfSupportedRfidCredentialsAndVerifyDefaultValue_44()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::DoorLockClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::DoorLock::Attributes::NumberOfRFIDUsersSupported::TypeInfo>(
            this, OnSuccessCallback_44, OnFailureCallback_44, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_44(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_44(uint16_t numberOfRFIDUsersSupported)
    {
        VerifyOrReturn(CheckValue("numberOfRFIDUsersSupported", numberOfRFIDUsersSupported, 10U));

        NumberOfRFIDUsersSupported = numberOfRFIDUsersSupported;
        NextTest();
    }

    CHIP_ERROR TestReadingRfidCredentialWithIndex0Fails_45()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::GetCredentialStatus::Type;

        RequestType request;

        request.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(2);
        request.credential.credentialIndex = 0U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))
                ->OnSuccessResponse_45(data.credentialExists, data.userIndex, data.nextCredentialIndex);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_45(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_45(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_COMMAND));
        NextTest();
    }

    void OnSuccessResponse_45(bool credentialExists, const chip::app::DataModel::Nullable<uint16_t> & userIndex,
                              const chip::app::DataModel::Nullable<uint16_t> & nextCredentialIndex)
    {
        ThrowSuccessResponse();
    }

    CHIP_ERROR TestReadingRfidCredentialWithOutOfBoundsIndexFails_46()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::GetCredentialStatus::Type;

        RequestType request;

        request.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(2);
        request.credential.credentialIndex = static_cast<uint16_t>(NumberOfRFIDUsersSupported + 1);

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))
                ->OnSuccessResponse_46(data.credentialExists, data.userIndex, data.nextCredentialIndex);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_46(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_46(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_COMMAND));
        NextTest();
    }

    void OnSuccessResponse_46(bool credentialExists, const chip::app::DataModel::Nullable<uint16_t> & userIndex,
                              const chip::app::DataModel::Nullable<uint16_t> & nextCredentialIndex)
    {
        ThrowSuccessResponse();
    }

    CHIP_ERROR TestCheckThatRfidCredentialDoesNotExist_47()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::GetCredentialStatus::Type;

        RequestType request;

        request.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(2);
        request.credential.credentialIndex = 2U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))
                ->OnSuccessResponse_47(data.credentialExists, data.userIndex, data.nextCredentialIndex);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_47(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_47(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_47(bool credentialExists, const chip::app::DataModel::Nullable<uint16_t> & userIndex,
                              const chip::app::DataModel::Nullable<uint16_t> & nextCredentialIndex)
    {
        VerifyOrReturn(CheckValue("credentialExists", credentialExists, false));

        VerifyOrReturn(CheckValueNull("userIndex", userIndex));

        VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", nextCredentialIndex));
        VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", nextCredentialIndex.Value(), 3U));

        NextTest();
    }

    CHIP_ERROR TestCreateNewRfidCredentialAndAddItToExistingUser_48()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::SetCredential::Type;

        RequestType request;
        request.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);

        request.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(2);
        request.credential.credentialIndex = 2U;

        request.credentialData =
            chip::ByteSpan(chip::Uint8::from_const_char("rfid_data_123456garbage: not in length on purpose"), 16);
        request.userIndex.SetNonNull();
        request.userIndex.Value() = 1U;
        request.userStatus.SetNull();
        request.userType.SetNull();

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))
                ->OnSuccessResponse_48(data.status, data.userIndex, data.nextCredentialIndex);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_48(error);
        };

        ReturnErrorOnFailure(
            chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request, 10000));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_48(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_48(chip::app::Clusters::DoorLock::DlStatus status,
                              const chip::app::DataModel::Nullable<uint16_t> & userIndex,
                              const chip::app::DataModel::Nullable<uint16_t> & nextCredentialIndex)
    {
        VerifyOrReturn(CheckValue("status", status, 0));

        VerifyOrReturn(CheckValueNull("userIndex", userIndex));

        VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", nextCredentialIndex));
        VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", nextCredentialIndex.Value(), 3U));

        NextTest();
    }

    CHIP_ERROR TestVerifyModifiedUser_49()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::GetUser::Type;

        RequestType request;
        request.userIndex = 1U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))
                ->OnSuccessResponse_49(data.userIndex, data.userName, data.userUniqueId, data.userStatus, data.userType,
                                       data.credentialRule, data.credentials, data.creatorFabricIndex, data.lastModifiedFabricIndex,
                                       data.nextUserIndex);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_49(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_49(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_49(
        uint16_t userIndex, const chip::app::DataModel::Nullable<chip::CharSpan> & userName,
        const chip::app::DataModel::Nullable<uint32_t> & userUniqueId,
        const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlUserStatus> & userStatus,
        const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlUserType> & userType,
        const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlCredentialRule> & credentialRule,
        const chip::app::DataModel::Nullable<
            chip::app::DataModel::DecodableList<chip::app::Clusters::DoorLock::Structs::DlCredential::DecodableType>> & credentials,
        const chip::app::DataModel::Nullable<chip::FabricIndex> & creatorFabricIndex,
        const chip::app::DataModel::Nullable<chip::FabricIndex> & lastModifiedFabricIndex,
        const chip::app::DataModel::Nullable<uint16_t> & nextUserIndex)
    {
        VerifyOrReturn(CheckValue("userIndex", userIndex, 1U));

        VerifyOrReturn(CheckValueNonNull("userName", userName));
        VerifyOrReturn(CheckValueAsString("userName.Value()", userName.Value(), chip::CharSpan("", 0)));

        VerifyOrReturn(CheckValueNull("userUniqueId", userUniqueId));

        VerifyOrReturn(CheckValueNonNull("userStatus", userStatus));
        VerifyOrReturn(CheckValue("userStatus.Value()", userStatus.Value(), 1));

        VerifyOrReturn(CheckValueNonNull("userType", userType));
        VerifyOrReturn(CheckValue("userType.Value()", userType.Value(), 0));

        VerifyOrReturn(CheckValueNonNull("credentialRule", credentialRule));
        VerifyOrReturn(CheckValue("credentialRule.Value()", credentialRule.Value(), 0));

        VerifyOrReturn(CheckValueNonNull("credentials", credentials));
        {
            auto iter_1 = credentials.Value().begin();
            VerifyOrReturn(CheckNextListItemDecodes<decltype(credentials.Value())>("credentials.Value()", iter_1, 0));
            VerifyOrReturn(CheckValue("credentials.Value()[0].credentialType", iter_1.GetValue().credentialType, 1));
            VerifyOrReturn(CheckValue("credentials.Value()[0].credentialIndex", iter_1.GetValue().credentialIndex, 1U));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(credentials.Value())>("credentials.Value()", iter_1, 1));
            VerifyOrReturn(CheckValue("credentials.Value()[1].credentialType", iter_1.GetValue().credentialType, 2));
            VerifyOrReturn(CheckValue("credentials.Value()[1].credentialIndex", iter_1.GetValue().credentialIndex, 2U));
            VerifyOrReturn(CheckNoMoreListItems<decltype(credentials.Value())>("credentials.Value()", iter_1, 2));
        }

        VerifyOrReturn(CheckValueNonNull("creatorFabricIndex", creatorFabricIndex));
        VerifyOrReturn(CheckValue("creatorFabricIndex.Value()", creatorFabricIndex.Value(), 1));

        VerifyOrReturn(CheckValueNonNull("lastModifiedFabricIndex", lastModifiedFabricIndex));
        VerifyOrReturn(CheckValue("lastModifiedFabricIndex.Value()", lastModifiedFabricIndex.Value(), 1));

        VerifyOrReturn(CheckValueNonNull("nextUserIndex", nextUserIndex));
        VerifyOrReturn(CheckValue("nextUserIndex.Value()", nextUserIndex.Value(), 2U));

        NextTest();
    }

    CHIP_ERROR TestVerifyCreatedCredential_50()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::GetCredentialStatus::Type;

        RequestType request;

        request.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(2);
        request.credential.credentialIndex = 2U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))
                ->OnSuccessResponse_50(data.credentialExists, data.userIndex, data.nextCredentialIndex);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_50(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_50(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_50(bool credentialExists, const chip::app::DataModel::Nullable<uint16_t> & userIndex,
                              const chip::app::DataModel::Nullable<uint16_t> & nextCredentialIndex)
    {
        VerifyOrReturn(CheckValue("credentialExists", credentialExists, true));

        VerifyOrReturn(CheckValueNonNull("userIndex", userIndex));
        VerifyOrReturn(CheckValue("userIndex.Value()", userIndex.Value(), 1U));

        VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", nextCredentialIndex));
        VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", nextCredentialIndex.Value(), 3U));

        NextTest();
    }

    CHIP_ERROR TestCreateNewRfidCredentialAndUserWithIndex0Fails_51()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::SetCredential::Type;

        RequestType request;
        request.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);

        request.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(2);
        request.credential.credentialIndex = 0U;

        request.credentialData =
            chip::ByteSpan(chip::Uint8::from_const_char("new_rfid_data_fieldgarbage: not in length on purpose"), 19);
        request.userIndex.SetNull();
        request.userStatus.SetNull();
        request.userType.SetNull();

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))
                ->OnSuccessResponse_51(data.status, data.userIndex, data.nextCredentialIndex);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_51(error);
        };

        ReturnErrorOnFailure(
            chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request, 10000));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_51(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_51(chip::app::Clusters::DoorLock::DlStatus status,
                              const chip::app::DataModel::Nullable<uint16_t> & userIndex,
                              const chip::app::DataModel::Nullable<uint16_t> & nextCredentialIndex)
    {
        VerifyOrReturn(CheckValue("status", status, 133));

        VerifyOrReturn(CheckValueNull("userIndex", userIndex));

        VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", nextCredentialIndex));
        VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", nextCredentialIndex.Value(), 3U));

        NextTest();
    }

    CHIP_ERROR TestCreateNewRfidCredentialAndUserWithOutOfBoundsIndexFails_52()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::SetCredential::Type;

        RequestType request;
        request.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);

        request.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(2);
        request.credential.credentialIndex = static_cast<uint16_t>(NumberOfRFIDUsersSupported + 1);

        request.credentialData =
            chip::ByteSpan(chip::Uint8::from_const_char("new_rfid_data_fieldgarbage: not in length on purpose"), 19);
        request.userIndex.SetNull();
        request.userStatus.SetNull();
        request.userType.SetNull();

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))
                ->OnSuccessResponse_52(data.status, data.userIndex, data.nextCredentialIndex);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_52(error);
        };

        ReturnErrorOnFailure(
            chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request, 10000));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_52(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_52(chip::app::Clusters::DoorLock::DlStatus status,
                              const chip::app::DataModel::Nullable<uint16_t> & userIndex,
                              const chip::app::DataModel::Nullable<uint16_t> & nextCredentialIndex)
    {
        VerifyOrReturn(CheckValue("status", status, 133));

        VerifyOrReturn(CheckValueNull("userIndex", userIndex));

        VerifyOrReturn(CheckValueNull("nextCredentialIndex", nextCredentialIndex));

        NextTest();
    }

    CHIP_ERROR TestCreateNewPinCredentialAndTryToAddItToExistingUser_53()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::SetCredential::Type;

        RequestType request;
        request.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);

        request.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
        request.credential.credentialIndex = 3U;

        request.credentialData = chip::ByteSpan(chip::Uint8::from_const_char("123465garbage: not in length on purpose"), 6);
        request.userIndex.SetNonNull();
        request.userIndex.Value() = 1U;
        request.userStatus.SetNull();
        request.userType.SetNull();

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))
                ->OnSuccessResponse_53(data.status, data.userIndex, data.nextCredentialIndex);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_53(error);
        };

        ReturnErrorOnFailure(
            chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request, 10000));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_53(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_53(chip::app::Clusters::DoorLock::DlStatus status,
                              const chip::app::DataModel::Nullable<uint16_t> & userIndex,
                              const chip::app::DataModel::Nullable<uint16_t> & nextCredentialIndex)
    {
        VerifyOrReturn(CheckValue("status", status, 3));

        VerifyOrReturn(CheckValueNull("userIndex", userIndex));

        VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", nextCredentialIndex));
        VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", nextCredentialIndex.Value(), 4U));

        NextTest();
    }

    CHIP_ERROR TestCreateNewCredentialAndTryToAddItTo0User_54()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::SetCredential::Type;

        RequestType request;
        request.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);

        request.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
        request.credential.credentialIndex = 3U;

        request.credentialData = chip::ByteSpan(chip::Uint8::from_const_char("123465garbage: not in length on purpose"), 6);
        request.userIndex.SetNonNull();
        request.userIndex.Value() = 0U;
        request.userStatus.SetNull();
        request.userType.SetNull();

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))
                ->OnSuccessResponse_54(data.status, data.userIndex, data.nextCredentialIndex);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_54(error);
        };

        ReturnErrorOnFailure(
            chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request, 10000));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_54(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_54(chip::app::Clusters::DoorLock::DlStatus status,
                              const chip::app::DataModel::Nullable<uint16_t> & userIndex,
                              const chip::app::DataModel::Nullable<uint16_t> & nextCredentialIndex)
    {
        VerifyOrReturn(CheckValue("status", status, 133));

        VerifyOrReturn(CheckValueNull("userIndex", userIndex));

        VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", nextCredentialIndex));
        VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", nextCredentialIndex.Value(), 4U));

        NextTest();
    }

    CHIP_ERROR TestCreateNewCredentialAndTryToAddItToOutOfBoundsUser_55()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::SetCredential::Type;

        RequestType request;
        request.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);

        request.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
        request.credential.credentialIndex = 3U;

        request.credentialData = chip::ByteSpan(chip::Uint8::from_const_char("123465garbage: not in length on purpose"), 6);
        request.userIndex.SetNonNull();
        request.userIndex.Value() = static_cast<uint16_t>(NumberOfTotalUsersSupported + 1);
        request.userStatus.SetNull();
        request.userType.SetNull();

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))
                ->OnSuccessResponse_55(data.status, data.userIndex, data.nextCredentialIndex);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_55(error);
        };

        ReturnErrorOnFailure(
            chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request, 10000));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_55(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_55(chip::app::Clusters::DoorLock::DlStatus status,
                              const chip::app::DataModel::Nullable<uint16_t> & userIndex,
                              const chip::app::DataModel::Nullable<uint16_t> & nextCredentialIndex)
    {
        VerifyOrReturn(CheckValue("status", status, 133));

        VerifyOrReturn(CheckValueNull("userIndex", userIndex));

        VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", nextCredentialIndex));
        VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", nextCredentialIndex.Value(), 4U));

        NextTest();
    }

    CHIP_ERROR TestCreateNewPinWithTooShortData_56()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::SetCredential::Type;

        RequestType request;
        request.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);

        request.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
        request.credential.credentialIndex = 3U;

        request.credentialData = chip::ByteSpan(chip::Uint8::from_const_char("12345garbage: not in length on purpose"), 5);
        request.userIndex.SetNonNull();
        request.userIndex.Value() = 0U;
        request.userStatus.SetNull();
        request.userType.SetNull();

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))
                ->OnSuccessResponse_56(data.status, data.userIndex, data.nextCredentialIndex);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_56(error);
        };

        ReturnErrorOnFailure(
            chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request, 10000));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_56(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_56(chip::app::Clusters::DoorLock::DlStatus status,
                              const chip::app::DataModel::Nullable<uint16_t> & userIndex,
                              const chip::app::DataModel::Nullable<uint16_t> & nextCredentialIndex)
    {
        VerifyOrReturn(CheckValue("status", status, 133));

        VerifyOrReturn(CheckValueNull("userIndex", userIndex));

        VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", nextCredentialIndex));
        VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", nextCredentialIndex.Value(), 4U));

        NextTest();
    }

    CHIP_ERROR TestCreateNewPinWithTooLongData_57()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::SetCredential::Type;

        RequestType request;
        request.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);

        request.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
        request.credential.credentialIndex = 3U;

        request.credentialData = chip::ByteSpan(chip::Uint8::from_const_char("123456789garbage: not in length on purpose"), 9);
        request.userIndex.SetNonNull();
        request.userIndex.Value() = 0U;
        request.userStatus.SetNull();
        request.userType.SetNull();

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))
                ->OnSuccessResponse_57(data.status, data.userIndex, data.nextCredentialIndex);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_57(error);
        };

        ReturnErrorOnFailure(
            chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request, 10000));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_57(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_57(chip::app::Clusters::DoorLock::DlStatus status,
                              const chip::app::DataModel::Nullable<uint16_t> & userIndex,
                              const chip::app::DataModel::Nullable<uint16_t> & nextCredentialIndex)
    {
        VerifyOrReturn(CheckValue("status", status, 133));

        VerifyOrReturn(CheckValueNull("userIndex", userIndex));

        VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", nextCredentialIndex));
        VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", nextCredentialIndex.Value(), 4U));

        NextTest();
    }

    CHIP_ERROR TestCreateNewRfidWithTooShortData_58()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::SetCredential::Type;

        RequestType request;
        request.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);

        request.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(2);
        request.credential.credentialIndex = 3U;

        request.credentialData = chip::ByteSpan(chip::Uint8::from_const_char("rfid_datagarbage: not in length on purpose"), 9);
        request.userIndex.SetNonNull();
        request.userIndex.Value() = 0U;
        request.userStatus.SetNull();
        request.userType.SetNull();

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))
                ->OnSuccessResponse_58(data.status, data.userIndex, data.nextCredentialIndex);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_58(error);
        };

        ReturnErrorOnFailure(
            chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request, 10000));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_58(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_58(chip::app::Clusters::DoorLock::DlStatus status,
                              const chip::app::DataModel::Nullable<uint16_t> & userIndex,
                              const chip::app::DataModel::Nullable<uint16_t> & nextCredentialIndex)
    {
        VerifyOrReturn(CheckValue("status", status, 133));

        VerifyOrReturn(CheckValueNull("userIndex", userIndex));

        VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", nextCredentialIndex));
        VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", nextCredentialIndex.Value(), 4U));

        NextTest();
    }

    CHIP_ERROR TestCreateNewPinWithProgrammingUserTypeFails_59()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::SetCredential::Type;

        RequestType request;
        request.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);

        request.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
        request.credential.credentialIndex = 3U;

        request.credentialData = chip::ByteSpan(chip::Uint8::from_const_char("123456garbage: not in length on purpose"), 6);
        request.userIndex.SetNonNull();
        request.userIndex.Value() = 0U;
        request.userStatus.SetNull();
        request.userType.SetNonNull();
        request.userType.Value() = static_cast<chip::app::Clusters::DoorLock::DlUserType>(3);

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))
                ->OnSuccessResponse_59(data.status, data.userIndex, data.nextCredentialIndex);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_59(error);
        };

        ReturnErrorOnFailure(
            chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request, 10000));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_59(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_59(chip::app::Clusters::DoorLock::DlStatus status,
                              const chip::app::DataModel::Nullable<uint16_t> & userIndex,
                              const chip::app::DataModel::Nullable<uint16_t> & nextCredentialIndex)
    {
        VerifyOrReturn(CheckValue("status", status, 133));

        VerifyOrReturn(CheckValueNull("userIndex", userIndex));

        VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", nextCredentialIndex));
        VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", nextCredentialIndex.Value(), 4U));

        NextTest();
    }

    CHIP_ERROR TestCreateNewRfidWithTooShortData_60()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::SetCredential::Type;

        RequestType request;
        request.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);

        request.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(2);
        request.credential.credentialIndex = 3U;

        request.credentialData = chip::ByteSpan(
            chip::Uint8::from_const_char("very_long_rfid_data_to_test_boundariesgarbage: not in length on purpose"), 38);
        request.userIndex.SetNonNull();
        request.userIndex.Value() = 0U;
        request.userStatus.SetNull();
        request.userType.SetNull();

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))
                ->OnSuccessResponse_60(data.status, data.userIndex, data.nextCredentialIndex);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_60(error);
        };

        ReturnErrorOnFailure(
            chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request, 10000));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_60(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_60(chip::app::Clusters::DoorLock::DlStatus status,
                              const chip::app::DataModel::Nullable<uint16_t> & userIndex,
                              const chip::app::DataModel::Nullable<uint16_t> & nextCredentialIndex)
    {
        VerifyOrReturn(CheckValue("status", status, 133));

        VerifyOrReturn(CheckValueNull("userIndex", userIndex));

        VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", nextCredentialIndex));
        VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", nextCredentialIndex.Value(), 4U));

        NextTest();
    }

    CHIP_ERROR TestCreateNewPinCredentialWithDataTheWouldCauseDuplicate_61()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::SetCredential::Type;

        RequestType request;
        request.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);

        request.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
        request.credential.credentialIndex = 4U;

        request.credentialData = chip::ByteSpan(chip::Uint8::from_const_char("000000garbage: not in length on purpose"), 6);
        request.userIndex.SetNull();
        request.userStatus.SetNull();
        request.userType.SetNull();

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))
                ->OnSuccessResponse_61(data.status, data.userIndex, data.nextCredentialIndex);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_61(error);
        };

        ReturnErrorOnFailure(
            chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request, 10000));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_61(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_61(chip::app::Clusters::DoorLock::DlStatus status,
                              const chip::app::DataModel::Nullable<uint16_t> & userIndex,
                              const chip::app::DataModel::Nullable<uint16_t> & nextCredentialIndex)
    {
        VerifyOrReturn(CheckValue("status", status, 2));

        VerifyOrReturn(CheckValueNull("userIndex", userIndex));

        VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", nextCredentialIndex));
        VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", nextCredentialIndex.Value(), 5U));

        NextTest();
    }

    CHIP_ERROR TestCreateNewRfidCredentialWithDataTheWouldCauseDuplicate_62()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::SetCredential::Type;

        RequestType request;
        request.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);

        request.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(2);
        request.credential.credentialIndex = 4U;

        request.credentialData =
            chip::ByteSpan(chip::Uint8::from_const_char("rfid_data_123456garbage: not in length on purpose"), 16);
        request.userIndex.SetNull();
        request.userStatus.SetNull();
        request.userType.SetNull();

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))
                ->OnSuccessResponse_62(data.status, data.userIndex, data.nextCredentialIndex);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_62(error);
        };

        ReturnErrorOnFailure(
            chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request, 10000));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_62(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_62(chip::app::Clusters::DoorLock::DlStatus status,
                              const chip::app::DataModel::Nullable<uint16_t> & userIndex,
                              const chip::app::DataModel::Nullable<uint16_t> & nextCredentialIndex)
    {
        VerifyOrReturn(CheckValue("status", status, 2));

        VerifyOrReturn(CheckValueNull("userIndex", userIndex));

        VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", nextCredentialIndex));
        VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", nextCredentialIndex.Value(), 5U));

        NextTest();
    }

    CHIP_ERROR TestModifyCredentialDataOfExistingPinCredential_63()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::SetCredential::Type;

        RequestType request;
        request.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(2);

        request.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
        request.credential.credentialIndex = 1U;

        request.credentialData = chip::ByteSpan(chip::Uint8::from_const_char("123456garbage: not in length on purpose"), 6);
        request.userIndex.SetNonNull();
        request.userIndex.Value() = 1U;
        request.userStatus.SetNull();
        request.userType.SetNull();

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))
                ->OnSuccessResponse_63(data.status, data.userIndex, data.nextCredentialIndex);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_63(error);
        };

        ReturnErrorOnFailure(
            chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request, 10000));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_63(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_63(chip::app::Clusters::DoorLock::DlStatus status,
                              const chip::app::DataModel::Nullable<uint16_t> & userIndex,
                              const chip::app::DataModel::Nullable<uint16_t> & nextCredentialIndex)
    {
        VerifyOrReturn(CheckValue("status", status, 0));

        VerifyOrReturn(CheckValueNull("userIndex", userIndex));

        VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", nextCredentialIndex));
        VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", nextCredentialIndex.Value(), 3U));

        NextTest();
    }

    CHIP_ERROR TestVerifyThatCredentialWasChangedByCreatingNewCredentialWithOldData_64()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::SetCredential::Type;

        RequestType request;
        request.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);

        request.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
        request.credential.credentialIndex = 3U;

        request.credentialData = chip::ByteSpan(chip::Uint8::from_const_char("000000garbage: not in length on purpose"), 6);
        request.userIndex.SetNull();
        request.userStatus.SetNull();
        request.userType.SetNull();

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))
                ->OnSuccessResponse_64(data.status, data.userIndex, data.nextCredentialIndex);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_64(error);
        };

        ReturnErrorOnFailure(
            chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request, 10000));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_64(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_64(chip::app::Clusters::DoorLock::DlStatus status,
                              const chip::app::DataModel::Nullable<uint16_t> & userIndex,
                              const chip::app::DataModel::Nullable<uint16_t> & nextCredentialIndex)
    {
        VerifyOrReturn(CheckValue("status", status, 0));

        VerifyOrReturn(CheckValueNonNull("userIndex", userIndex));
        VerifyOrReturn(CheckValue("userIndex.Value()", userIndex.Value(), 2U));

        VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", nextCredentialIndex));
        VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", nextCredentialIndex.Value(), 4U));

        NextTest();
    }

    CHIP_ERROR TestVerifyThatCredentialWasChangedByCreatingNewCredentialWithNewData_65()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::SetCredential::Type;

        RequestType request;
        request.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);

        request.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
        request.credential.credentialIndex = 4U;

        request.credentialData = chip::ByteSpan(chip::Uint8::from_const_char("123456garbage: not in length on purpose"), 6);
        request.userIndex.SetNull();
        request.userStatus.SetNull();
        request.userType.SetNull();

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))
                ->OnSuccessResponse_65(data.status, data.userIndex, data.nextCredentialIndex);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_65(error);
        };

        ReturnErrorOnFailure(
            chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request, 10000));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_65(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_65(chip::app::Clusters::DoorLock::DlStatus status,
                              const chip::app::DataModel::Nullable<uint16_t> & userIndex,
                              const chip::app::DataModel::Nullable<uint16_t> & nextCredentialIndex)
    {
        VerifyOrReturn(CheckValue("status", status, 2));

        VerifyOrReturn(CheckValueNull("userIndex", userIndex));

        VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", nextCredentialIndex));
        VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", nextCredentialIndex.Value(), 5U));

        NextTest();
    }

    CHIP_ERROR TestClearFirstPinCredential_66()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::ClearCredential::Type;

        RequestType request;
        request.credential.SetNonNull();

        request.credential.Value().credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
        request.credential.Value().credentialIndex = 1U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnSuccessResponse_66();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_66(error);
        };

        ReturnErrorOnFailure(
            chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request, 10000));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_66(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_66() { NextTest(); }

    CHIP_ERROR TestReadBackTheCredentialAndMakeSureItIsDeleted_67()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::GetCredentialStatus::Type;

        RequestType request;

        request.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
        request.credential.credentialIndex = 1U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))
                ->OnSuccessResponse_67(data.credentialExists, data.userIndex, data.nextCredentialIndex);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_67(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_67(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_67(bool credentialExists, const chip::app::DataModel::Nullable<uint16_t> & userIndex,
                              const chip::app::DataModel::Nullable<uint16_t> & nextCredentialIndex)
    {
        VerifyOrReturn(CheckValue("credentialExists", credentialExists, false));

        VerifyOrReturn(CheckValueNull("userIndex", userIndex));

        VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", nextCredentialIndex));
        VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", nextCredentialIndex.Value(), 4U));

        NextTest();
    }

    CHIP_ERROR TestReadTheUserBackAndMakeSurePinCredentialIsDeleted_68()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::GetUser::Type;

        RequestType request;
        request.userIndex = 1U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))
                ->OnSuccessResponse_68(data.userIndex, data.userName, data.userUniqueId, data.userStatus, data.userType,
                                       data.credentialRule, data.credentials, data.creatorFabricIndex, data.lastModifiedFabricIndex,
                                       data.nextUserIndex);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_68(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_68(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_68(
        uint16_t userIndex, const chip::app::DataModel::Nullable<chip::CharSpan> & userName,
        const chip::app::DataModel::Nullable<uint32_t> & userUniqueId,
        const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlUserStatus> & userStatus,
        const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlUserType> & userType,
        const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlCredentialRule> & credentialRule,
        const chip::app::DataModel::Nullable<
            chip::app::DataModel::DecodableList<chip::app::Clusters::DoorLock::Structs::DlCredential::DecodableType>> & credentials,
        const chip::app::DataModel::Nullable<chip::FabricIndex> & creatorFabricIndex,
        const chip::app::DataModel::Nullable<chip::FabricIndex> & lastModifiedFabricIndex,
        const chip::app::DataModel::Nullable<uint16_t> & nextUserIndex)
    {
        VerifyOrReturn(CheckValue("userIndex", userIndex, 1U));

        VerifyOrReturn(CheckValueNonNull("userName", userName));
        VerifyOrReturn(CheckValueAsString("userName.Value()", userName.Value(), chip::CharSpan("", 0)));

        VerifyOrReturn(CheckValueNull("userUniqueId", userUniqueId));

        VerifyOrReturn(CheckValueNonNull("userStatus", userStatus));
        VerifyOrReturn(CheckValue("userStatus.Value()", userStatus.Value(), 1));

        VerifyOrReturn(CheckValueNonNull("userType", userType));
        VerifyOrReturn(CheckValue("userType.Value()", userType.Value(), 0));

        VerifyOrReturn(CheckValueNonNull("credentialRule", credentialRule));
        VerifyOrReturn(CheckValue("credentialRule.Value()", credentialRule.Value(), 0));

        VerifyOrReturn(CheckValueNonNull("credentials", credentials));
        {
            auto iter_1 = credentials.Value().begin();
            VerifyOrReturn(CheckNextListItemDecodes<decltype(credentials.Value())>("credentials.Value()", iter_1, 0));
            VerifyOrReturn(CheckValue("credentials.Value()[0].credentialType", iter_1.GetValue().credentialType, 2));
            VerifyOrReturn(CheckValue("credentials.Value()[0].credentialIndex", iter_1.GetValue().credentialIndex, 2U));
            VerifyOrReturn(CheckNoMoreListItems<decltype(credentials.Value())>("credentials.Value()", iter_1, 1));
        }

        VerifyOrReturn(CheckValueNonNull("creatorFabricIndex", creatorFabricIndex));
        VerifyOrReturn(CheckValue("creatorFabricIndex.Value()", creatorFabricIndex.Value(), 1));

        VerifyOrReturn(CheckValueNonNull("lastModifiedFabricIndex", lastModifiedFabricIndex));
        VerifyOrReturn(CheckValue("lastModifiedFabricIndex.Value()", lastModifiedFabricIndex.Value(), 1));

        VerifyOrReturn(CheckValueNonNull("nextUserIndex", nextUserIndex));
        VerifyOrReturn(CheckValue("nextUserIndex.Value()", nextUserIndex.Value(), 3U));

        NextTest();
    }

    CHIP_ERROR TestClearTheSecondPinCredential_69()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::ClearCredential::Type;

        RequestType request;
        request.credential.SetNonNull();

        request.credential.Value().credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
        request.credential.Value().credentialIndex = 3U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnSuccessResponse_69();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_69(error);
        };

        ReturnErrorOnFailure(
            chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request, 10000));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_69(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_69() { NextTest(); }

    CHIP_ERROR TestReadBackTheCredentialAndMakeSureItIsDeleted_70()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::GetCredentialStatus::Type;

        RequestType request;

        request.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
        request.credential.credentialIndex = 3U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))
                ->OnSuccessResponse_70(data.credentialExists, data.userIndex, data.nextCredentialIndex);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_70(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_70(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_70(bool credentialExists, const chip::app::DataModel::Nullable<uint16_t> & userIndex,
                              const chip::app::DataModel::Nullable<uint16_t> & nextCredentialIndex)
    {
        VerifyOrReturn(CheckValue("credentialExists", credentialExists, false));

        VerifyOrReturn(CheckValueNull("userIndex", userIndex));

        VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", nextCredentialIndex));
        VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", nextCredentialIndex.Value(), 4U));

        NextTest();
    }

    CHIP_ERROR TestReadTheUserBackAndMakeSureRelatedUserIsDeleted_71()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::GetUser::Type;

        RequestType request;
        request.userIndex = 2U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))
                ->OnSuccessResponse_71(data.userIndex, data.userName, data.userUniqueId, data.userStatus, data.userType,
                                       data.credentialRule, data.credentials, data.creatorFabricIndex, data.lastModifiedFabricIndex,
                                       data.nextUserIndex);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_71(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_71(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_71(
        uint16_t userIndex, const chip::app::DataModel::Nullable<chip::CharSpan> & userName,
        const chip::app::DataModel::Nullable<uint32_t> & userUniqueId,
        const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlUserStatus> & userStatus,
        const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlUserType> & userType,
        const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlCredentialRule> & credentialRule,
        const chip::app::DataModel::Nullable<
            chip::app::DataModel::DecodableList<chip::app::Clusters::DoorLock::Structs::DlCredential::DecodableType>> & credentials,
        const chip::app::DataModel::Nullable<chip::FabricIndex> & creatorFabricIndex,
        const chip::app::DataModel::Nullable<chip::FabricIndex> & lastModifiedFabricIndex,
        const chip::app::DataModel::Nullable<uint16_t> & nextUserIndex)
    {
        VerifyOrReturn(CheckValue("userIndex", userIndex, 2U));

        VerifyOrReturn(CheckValueNull("userName", userName));

        VerifyOrReturn(CheckValueNull("userUniqueId", userUniqueId));

        VerifyOrReturn(CheckValueNull("userStatus", userStatus));

        VerifyOrReturn(CheckValueNull("userType", userType));

        VerifyOrReturn(CheckValueNull("credentialRule", credentialRule));

        VerifyOrReturn(CheckValueNull("credentials", credentials));

        VerifyOrReturn(CheckValueNull("creatorFabricIndex", creatorFabricIndex));

        VerifyOrReturn(CheckValueNull("lastModifiedFabricIndex", lastModifiedFabricIndex));

        VerifyOrReturn(CheckValueNonNull("nextUserIndex", nextUserIndex));
        VerifyOrReturn(CheckValue("nextUserIndex.Value()", nextUserIndex.Value(), 3U));

        NextTest();
    }

    CHIP_ERROR TestCreateNewRfidCredentialWithUser_72()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::SetCredential::Type;

        RequestType request;
        request.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);

        request.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(2);
        request.credential.credentialIndex = 1U;

        request.credentialData =
            chip::ByteSpan(chip::Uint8::from_const_char("rfid_data_12345garbage: not in length on purpose"), 15);
        request.userIndex.SetNull();
        request.userStatus.SetNull();
        request.userType.SetNull();

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))
                ->OnSuccessResponse_72(data.status, data.userIndex, data.nextCredentialIndex);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_72(error);
        };

        ReturnErrorOnFailure(
            chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request, 10000));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_72(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_72(chip::app::Clusters::DoorLock::DlStatus status,
                              const chip::app::DataModel::Nullable<uint16_t> & userIndex,
                              const chip::app::DataModel::Nullable<uint16_t> & nextCredentialIndex)
    {
        VerifyOrReturn(CheckValue("status", status, 0));

        VerifyOrReturn(CheckValueNonNull("userIndex", userIndex));
        VerifyOrReturn(CheckValue("userIndex.Value()", userIndex.Value(), 2U));

        VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", nextCredentialIndex));
        VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", nextCredentialIndex.Value(), 3U));

        NextTest();
    }

    CHIP_ERROR TestClearAllTheRfidCredentials_73()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::ClearCredential::Type;

        RequestType request;
        request.credential.SetNonNull();

        request.credential.Value().credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(2);
        request.credential.Value().credentialIndex = 65534U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnSuccessResponse_73();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_73(error);
        };

        ReturnErrorOnFailure(
            chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request, 10000));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_73(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_73() { NextTest(); }

    CHIP_ERROR TestReadBackTheFistRfidCredentialAndMakeSureItIsDeleted_74()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::GetCredentialStatus::Type;

        RequestType request;

        request.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(2);
        request.credential.credentialIndex = 1U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))
                ->OnSuccessResponse_74(data.credentialExists, data.userIndex, data.nextCredentialIndex);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_74(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_74(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_74(bool credentialExists, const chip::app::DataModel::Nullable<uint16_t> & userIndex,
                              const chip::app::DataModel::Nullable<uint16_t> & nextCredentialIndex)
    {
        VerifyOrReturn(CheckValue("credentialExists", credentialExists, false));

        VerifyOrReturn(CheckValueNull("userIndex", userIndex));

        VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", nextCredentialIndex));
        VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", nextCredentialIndex.Value(), 2U));

        NextTest();
    }

    CHIP_ERROR TestReadBackTheSecondRfidCredentialAndMakeSureItIsDeleted_75()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::GetCredentialStatus::Type;

        RequestType request;

        request.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(2);
        request.credential.credentialIndex = 2U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))
                ->OnSuccessResponse_75(data.credentialExists, data.userIndex, data.nextCredentialIndex);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_75(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_75(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_75(bool credentialExists, const chip::app::DataModel::Nullable<uint16_t> & userIndex,
                              const chip::app::DataModel::Nullable<uint16_t> & nextCredentialIndex)
    {
        VerifyOrReturn(CheckValue("credentialExists", credentialExists, false));

        VerifyOrReturn(CheckValueNull("userIndex", userIndex));

        VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", nextCredentialIndex));
        VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", nextCredentialIndex.Value(), 3U));

        NextTest();
    }

    CHIP_ERROR TestReadTheUserRelatedWithFirstRfidBackAndMakeSureItIsDeleted_76()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::GetUser::Type;

        RequestType request;
        request.userIndex = 1U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))
                ->OnSuccessResponse_76(data.userIndex, data.userName, data.userUniqueId, data.userStatus, data.userType,
                                       data.credentialRule, data.credentials, data.creatorFabricIndex, data.lastModifiedFabricIndex,
                                       data.nextUserIndex);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_76(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_76(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_76(
        uint16_t userIndex, const chip::app::DataModel::Nullable<chip::CharSpan> & userName,
        const chip::app::DataModel::Nullable<uint32_t> & userUniqueId,
        const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlUserStatus> & userStatus,
        const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlUserType> & userType,
        const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlCredentialRule> & credentialRule,
        const chip::app::DataModel::Nullable<
            chip::app::DataModel::DecodableList<chip::app::Clusters::DoorLock::Structs::DlCredential::DecodableType>> & credentials,
        const chip::app::DataModel::Nullable<chip::FabricIndex> & creatorFabricIndex,
        const chip::app::DataModel::Nullable<chip::FabricIndex> & lastModifiedFabricIndex,
        const chip::app::DataModel::Nullable<uint16_t> & nextUserIndex)
    {
        VerifyOrReturn(CheckValue("userIndex", userIndex, 1U));

        VerifyOrReturn(CheckValueNull("userName", userName));

        VerifyOrReturn(CheckValueNull("userUniqueId", userUniqueId));

        VerifyOrReturn(CheckValueNull("userStatus", userStatus));

        VerifyOrReturn(CheckValueNull("userType", userType));

        VerifyOrReturn(CheckValueNull("credentialRule", credentialRule));

        VerifyOrReturn(CheckValueNull("credentials", credentials));

        VerifyOrReturn(CheckValueNull("creatorFabricIndex", creatorFabricIndex));

        VerifyOrReturn(CheckValueNull("lastModifiedFabricIndex", lastModifiedFabricIndex));

        VerifyOrReturn(CheckValueNonNull("nextUserIndex", nextUserIndex));
        VerifyOrReturn(CheckValue("nextUserIndex.Value()", nextUserIndex.Value(), 2U));

        NextTest();
    }

    CHIP_ERROR TestReadTheUserRelatedWithSecondRfidBackAndMakeSureItIsDeleted_77()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::GetUser::Type;

        RequestType request;
        request.userIndex = 2U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))
                ->OnSuccessResponse_77(data.userIndex, data.userName, data.userUniqueId, data.userStatus, data.userType,
                                       data.credentialRule, data.credentials, data.creatorFabricIndex, data.lastModifiedFabricIndex,
                                       data.nextUserIndex);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_77(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_77(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_77(
        uint16_t userIndex, const chip::app::DataModel::Nullable<chip::CharSpan> & userName,
        const chip::app::DataModel::Nullable<uint32_t> & userUniqueId,
        const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlUserStatus> & userStatus,
        const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlUserType> & userType,
        const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlCredentialRule> & credentialRule,
        const chip::app::DataModel::Nullable<
            chip::app::DataModel::DecodableList<chip::app::Clusters::DoorLock::Structs::DlCredential::DecodableType>> & credentials,
        const chip::app::DataModel::Nullable<chip::FabricIndex> & creatorFabricIndex,
        const chip::app::DataModel::Nullable<chip::FabricIndex> & lastModifiedFabricIndex,
        const chip::app::DataModel::Nullable<uint16_t> & nextUserIndex)
    {
        VerifyOrReturn(CheckValue("userIndex", userIndex, 2U));

        VerifyOrReturn(CheckValueNull("userName", userName));

        VerifyOrReturn(CheckValueNull("userUniqueId", userUniqueId));

        VerifyOrReturn(CheckValueNull("userStatus", userStatus));

        VerifyOrReturn(CheckValueNull("userType", userType));

        VerifyOrReturn(CheckValueNull("credentialRule", credentialRule));

        VerifyOrReturn(CheckValueNull("credentials", credentials));

        VerifyOrReturn(CheckValueNull("creatorFabricIndex", creatorFabricIndex));

        VerifyOrReturn(CheckValueNull("lastModifiedFabricIndex", lastModifiedFabricIndex));

        VerifyOrReturn(CheckValueNonNull("nextUserIndex", nextUserIndex));
        VerifyOrReturn(CheckValue("nextUserIndex.Value()", nextUserIndex.Value(), 3U));

        NextTest();
    }

    CHIP_ERROR TestCreateNewPinCredentialWithUser_78()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::SetCredential::Type;

        RequestType request;
        request.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);

        request.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
        request.credential.credentialIndex = 1U;

        request.credentialData = chip::ByteSpan(chip::Uint8::from_const_char("123456garbage: not in length on purpose"), 6);
        request.userIndex.SetNull();
        request.userStatus.SetNull();
        request.userType.SetNull();

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))
                ->OnSuccessResponse_78(data.status, data.userIndex, data.nextCredentialIndex);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_78(error);
        };

        ReturnErrorOnFailure(
            chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request, 10000));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_78(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_78(chip::app::Clusters::DoorLock::DlStatus status,
                              const chip::app::DataModel::Nullable<uint16_t> & userIndex,
                              const chip::app::DataModel::Nullable<uint16_t> & nextCredentialIndex)
    {
        VerifyOrReturn(CheckValue("status", status, 0));

        VerifyOrReturn(CheckValueNonNull("userIndex", userIndex));
        VerifyOrReturn(CheckValue("userIndex.Value()", userIndex.Value(), 1U));

        VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", nextCredentialIndex));
        VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", nextCredentialIndex.Value(), 2U));

        NextTest();
    }

    CHIP_ERROR TestCreateNewRfidCredentialWithUser_79()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::SetCredential::Type;

        RequestType request;
        request.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);

        request.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(2);
        request.credential.credentialIndex = 2U;

        request.credentialData =
            chip::ByteSpan(chip::Uint8::from_const_char("rfid_data_1234garbage: not in length on purpose"), 14);
        request.userIndex.SetNull();
        request.userStatus.SetNull();
        request.userType.SetNull();

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))
                ->OnSuccessResponse_79(data.status, data.userIndex, data.nextCredentialIndex);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_79(error);
        };

        ReturnErrorOnFailure(
            chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request, 10000));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_79(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_79(chip::app::Clusters::DoorLock::DlStatus status,
                              const chip::app::DataModel::Nullable<uint16_t> & userIndex,
                              const chip::app::DataModel::Nullable<uint16_t> & nextCredentialIndex)
    {
        VerifyOrReturn(CheckValue("status", status, 0));

        VerifyOrReturn(CheckValueNonNull("userIndex", userIndex));
        VerifyOrReturn(CheckValue("userIndex.Value()", userIndex.Value(), 2U));

        VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", nextCredentialIndex));
        VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", nextCredentialIndex.Value(), 3U));

        NextTest();
    }

    CHIP_ERROR TestCreateAnotherRfidCredentialWithUser_80()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::SetCredential::Type;

        RequestType request;
        request.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);

        request.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(2);
        request.credential.credentialIndex = 6U;

        request.credentialData =
            chip::ByteSpan(chip::Uint8::from_const_char("rfid_data_9876garbage: not in length on purpose"), 14);
        request.userIndex.SetNull();
        request.userStatus.SetNull();
        request.userType.SetNull();

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))
                ->OnSuccessResponse_80(data.status, data.userIndex, data.nextCredentialIndex);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_80(error);
        };

        ReturnErrorOnFailure(
            chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request, 10000));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_80(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_80(chip::app::Clusters::DoorLock::DlStatus status,
                              const chip::app::DataModel::Nullable<uint16_t> & userIndex,
                              const chip::app::DataModel::Nullable<uint16_t> & nextCredentialIndex)
    {
        VerifyOrReturn(CheckValue("status", status, 0));

        VerifyOrReturn(CheckValueNonNull("userIndex", userIndex));
        VerifyOrReturn(CheckValue("userIndex.Value()", userIndex.Value(), 3U));

        VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", nextCredentialIndex));
        VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", nextCredentialIndex.Value(), 7U));

        NextTest();
    }

    CHIP_ERROR TestClearAllTheCredentials_81()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::ClearCredential::Type;

        RequestType request;
        request.credential.SetNull();

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnSuccessResponse_81();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_81(error);
        };

        ReturnErrorOnFailure(
            chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request, 10000));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_81(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_81() { NextTest(); }

    CHIP_ERROR TestReadBackTheFirstPinCredentialAndMakeSureItIsDeleted_82()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::GetCredentialStatus::Type;

        RequestType request;

        request.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
        request.credential.credentialIndex = 1U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))
                ->OnSuccessResponse_82(data.credentialExists, data.userIndex, data.nextCredentialIndex);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_82(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_82(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_82(bool credentialExists, const chip::app::DataModel::Nullable<uint16_t> & userIndex,
                              const chip::app::DataModel::Nullable<uint16_t> & nextCredentialIndex)
    {
        VerifyOrReturn(CheckValue("credentialExists", credentialExists, false));

        VerifyOrReturn(CheckValueNull("userIndex", userIndex));

        VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", nextCredentialIndex));
        VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", nextCredentialIndex.Value(), 2U));

        NextTest();
    }

    CHIP_ERROR TestReadBackTheFirstRfidCredentialAndMakeSureItIsDeleted_83()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::GetCredentialStatus::Type;

        RequestType request;

        request.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(2);
        request.credential.credentialIndex = 2U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))
                ->OnSuccessResponse_83(data.credentialExists, data.userIndex, data.nextCredentialIndex);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_83(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_83(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_83(bool credentialExists, const chip::app::DataModel::Nullable<uint16_t> & userIndex,
                              const chip::app::DataModel::Nullable<uint16_t> & nextCredentialIndex)
    {
        VerifyOrReturn(CheckValue("credentialExists", credentialExists, false));

        VerifyOrReturn(CheckValueNull("userIndex", userIndex));

        VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", nextCredentialIndex));
        VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", nextCredentialIndex.Value(), 3U));

        NextTest();
    }

    CHIP_ERROR TestReadBackTheSecondPinCredentialAndMakeSureItIsDeleted_84()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::GetCredentialStatus::Type;

        RequestType request;

        request.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
        request.credential.credentialIndex = 6U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))
                ->OnSuccessResponse_84(data.credentialExists, data.userIndex, data.nextCredentialIndex);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_84(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_84(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_84(bool credentialExists, const chip::app::DataModel::Nullable<uint16_t> & userIndex,
                              const chip::app::DataModel::Nullable<uint16_t> & nextCredentialIndex)
    {
        VerifyOrReturn(CheckValue("credentialExists", credentialExists, false));

        VerifyOrReturn(CheckValueNull("userIndex", userIndex));

        VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", nextCredentialIndex));
        VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", nextCredentialIndex.Value(), 7U));

        NextTest();
    }

    CHIP_ERROR TestReadTheUserRelatedWithFirstPinBackAndMakeSureItIsDeleted_85()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::GetUser::Type;

        RequestType request;
        request.userIndex = 1U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))
                ->OnSuccessResponse_85(data.userIndex, data.userName, data.userUniqueId, data.userStatus, data.userType,
                                       data.credentialRule, data.credentials, data.creatorFabricIndex, data.lastModifiedFabricIndex,
                                       data.nextUserIndex);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_85(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_85(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_85(
        uint16_t userIndex, const chip::app::DataModel::Nullable<chip::CharSpan> & userName,
        const chip::app::DataModel::Nullable<uint32_t> & userUniqueId,
        const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlUserStatus> & userStatus,
        const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlUserType> & userType,
        const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlCredentialRule> & credentialRule,
        const chip::app::DataModel::Nullable<
            chip::app::DataModel::DecodableList<chip::app::Clusters::DoorLock::Structs::DlCredential::DecodableType>> & credentials,
        const chip::app::DataModel::Nullable<chip::FabricIndex> & creatorFabricIndex,
        const chip::app::DataModel::Nullable<chip::FabricIndex> & lastModifiedFabricIndex,
        const chip::app::DataModel::Nullable<uint16_t> & nextUserIndex)
    {
        VerifyOrReturn(CheckValue("userIndex", userIndex, 1U));

        VerifyOrReturn(CheckValueNull("userName", userName));

        VerifyOrReturn(CheckValueNull("userUniqueId", userUniqueId));

        VerifyOrReturn(CheckValueNull("userStatus", userStatus));

        VerifyOrReturn(CheckValueNull("userType", userType));

        VerifyOrReturn(CheckValueNull("credentialRule", credentialRule));

        VerifyOrReturn(CheckValueNull("credentials", credentials));

        VerifyOrReturn(CheckValueNull("creatorFabricIndex", creatorFabricIndex));

        VerifyOrReturn(CheckValueNull("lastModifiedFabricIndex", lastModifiedFabricIndex));

        VerifyOrReturn(CheckValueNonNull("nextUserIndex", nextUserIndex));
        VerifyOrReturn(CheckValue("nextUserIndex.Value()", nextUserIndex.Value(), 2U));

        NextTest();
    }

    CHIP_ERROR TestReadTheUserRelatedWithFirstRfidBackAndMakeSureItIsDeleted_86()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::GetUser::Type;

        RequestType request;
        request.userIndex = 2U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))
                ->OnSuccessResponse_86(data.userIndex, data.userName, data.userUniqueId, data.userStatus, data.userType,
                                       data.credentialRule, data.credentials, data.creatorFabricIndex, data.lastModifiedFabricIndex,
                                       data.nextUserIndex);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_86(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_86(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_86(
        uint16_t userIndex, const chip::app::DataModel::Nullable<chip::CharSpan> & userName,
        const chip::app::DataModel::Nullable<uint32_t> & userUniqueId,
        const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlUserStatus> & userStatus,
        const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlUserType> & userType,
        const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlCredentialRule> & credentialRule,
        const chip::app::DataModel::Nullable<
            chip::app::DataModel::DecodableList<chip::app::Clusters::DoorLock::Structs::DlCredential::DecodableType>> & credentials,
        const chip::app::DataModel::Nullable<chip::FabricIndex> & creatorFabricIndex,
        const chip::app::DataModel::Nullable<chip::FabricIndex> & lastModifiedFabricIndex,
        const chip::app::DataModel::Nullable<uint16_t> & nextUserIndex)
    {
        VerifyOrReturn(CheckValue("userIndex", userIndex, 2U));

        VerifyOrReturn(CheckValueNull("userName", userName));

        VerifyOrReturn(CheckValueNull("userUniqueId", userUniqueId));

        VerifyOrReturn(CheckValueNull("userStatus", userStatus));

        VerifyOrReturn(CheckValueNull("userType", userType));

        VerifyOrReturn(CheckValueNull("credentialRule", credentialRule));

        VerifyOrReturn(CheckValueNull("credentials", credentials));

        VerifyOrReturn(CheckValueNull("creatorFabricIndex", creatorFabricIndex));

        VerifyOrReturn(CheckValueNull("lastModifiedFabricIndex", lastModifiedFabricIndex));

        VerifyOrReturn(CheckValueNonNull("nextUserIndex", nextUserIndex));
        VerifyOrReturn(CheckValue("nextUserIndex.Value()", nextUserIndex.Value(), 3U));

        NextTest();
    }

    CHIP_ERROR TestReadTheUserRelatedWithSecondPinBackAndMakeSureItIsDeleted_87()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::GetUser::Type;

        RequestType request;
        request.userIndex = 3U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))
                ->OnSuccessResponse_87(data.userIndex, data.userName, data.userUniqueId, data.userStatus, data.userType,
                                       data.credentialRule, data.credentials, data.creatorFabricIndex, data.lastModifiedFabricIndex,
                                       data.nextUserIndex);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_87(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_87(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_87(
        uint16_t userIndex, const chip::app::DataModel::Nullable<chip::CharSpan> & userName,
        const chip::app::DataModel::Nullable<uint32_t> & userUniqueId,
        const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlUserStatus> & userStatus,
        const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlUserType> & userType,
        const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlCredentialRule> & credentialRule,
        const chip::app::DataModel::Nullable<
            chip::app::DataModel::DecodableList<chip::app::Clusters::DoorLock::Structs::DlCredential::DecodableType>> & credentials,
        const chip::app::DataModel::Nullable<chip::FabricIndex> & creatorFabricIndex,
        const chip::app::DataModel::Nullable<chip::FabricIndex> & lastModifiedFabricIndex,
        const chip::app::DataModel::Nullable<uint16_t> & nextUserIndex)
    {
        VerifyOrReturn(CheckValue("userIndex", userIndex, 3U));

        VerifyOrReturn(CheckValueNull("userName", userName));

        VerifyOrReturn(CheckValueNull("userUniqueId", userUniqueId));

        VerifyOrReturn(CheckValueNull("userStatus", userStatus));

        VerifyOrReturn(CheckValueNull("userType", userType));

        VerifyOrReturn(CheckValueNull("credentialRule", credentialRule));

        VerifyOrReturn(CheckValueNull("credentials", credentials));

        VerifyOrReturn(CheckValueNull("creatorFabricIndex", creatorFabricIndex));

        VerifyOrReturn(CheckValueNull("lastModifiedFabricIndex", lastModifiedFabricIndex));

        VerifyOrReturn(CheckValueNonNull("nextUserIndex", nextUserIndex));
        VerifyOrReturn(CheckValue("nextUserIndex.Value()", nextUserIndex.Value(), 4U));

        NextTest();
    }

    CHIP_ERROR TestCreateNewProgrammingPinCredentialWithInvalidIndex_88()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::SetCredential::Type;

        RequestType request;
        request.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);

        request.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(0);
        request.credential.credentialIndex = 1U;

        request.credentialData = chip::ByteSpan(chip::Uint8::from_const_char("123456garbage: not in length on purpose"), 6);
        request.userIndex.SetNull();
        request.userStatus.SetNull();
        request.userType.SetNull();

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))
                ->OnSuccessResponse_88(data.status, data.userIndex, data.nextCredentialIndex);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_88(error);
        };

        ReturnErrorOnFailure(
            chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request, 10000));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_88(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_88(chip::app::Clusters::DoorLock::DlStatus status,
                              const chip::app::DataModel::Nullable<uint16_t> & userIndex,
                              const chip::app::DataModel::Nullable<uint16_t> & nextCredentialIndex)
    {
        VerifyOrReturn(CheckValue("status", status, 133));

        VerifyOrReturn(CheckValueNull("userIndex", userIndex));

        VerifyOrReturn(CheckValueNull("nextCredentialIndex", nextCredentialIndex));

        NextTest();
    }

    CHIP_ERROR TestCreateNewProgrammingPinCredentialWithValidIndex_89()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::SetCredential::Type;

        RequestType request;
        request.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);

        request.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(0);
        request.credential.credentialIndex = 0U;

        request.credentialData = chip::ByteSpan(chip::Uint8::from_const_char("123456garbage: not in length on purpose"), 6);
        request.userIndex.SetNull();
        request.userStatus.SetNull();
        request.userType.SetNull();

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))
                ->OnSuccessResponse_89(data.status, data.userIndex, data.nextCredentialIndex);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_89(error);
        };

        ReturnErrorOnFailure(
            chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request, 10000));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_89(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_89(chip::app::Clusters::DoorLock::DlStatus status,
                              const chip::app::DataModel::Nullable<uint16_t> & userIndex,
                              const chip::app::DataModel::Nullable<uint16_t> & nextCredentialIndex)
    {
        VerifyOrReturn(CheckValue("status", status, 0));

        VerifyOrReturn(CheckValueNonNull("userIndex", userIndex));
        VerifyOrReturn(CheckValue("userIndex.Value()", userIndex.Value(), 1U));

        VerifyOrReturn(CheckValueNull("nextCredentialIndex", nextCredentialIndex));

        NextTest();
    }

    CHIP_ERROR TestVerifyCreatedUser_90()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::GetUser::Type;

        RequestType request;
        request.userIndex = 1U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))
                ->OnSuccessResponse_90(data.userIndex, data.userName, data.userUniqueId, data.userStatus, data.userType,
                                       data.credentialRule, data.credentials, data.creatorFabricIndex, data.lastModifiedFabricIndex,
                                       data.nextUserIndex);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_90(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_90(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_90(
        uint16_t userIndex, const chip::app::DataModel::Nullable<chip::CharSpan> & userName,
        const chip::app::DataModel::Nullable<uint32_t> & userUniqueId,
        const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlUserStatus> & userStatus,
        const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlUserType> & userType,
        const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlCredentialRule> & credentialRule,
        const chip::app::DataModel::Nullable<
            chip::app::DataModel::DecodableList<chip::app::Clusters::DoorLock::Structs::DlCredential::DecodableType>> & credentials,
        const chip::app::DataModel::Nullable<chip::FabricIndex> & creatorFabricIndex,
        const chip::app::DataModel::Nullable<chip::FabricIndex> & lastModifiedFabricIndex,
        const chip::app::DataModel::Nullable<uint16_t> & nextUserIndex)
    {
        VerifyOrReturn(CheckValue("userIndex", userIndex, 1U));

        VerifyOrReturn(CheckValueNonNull("userName", userName));
        VerifyOrReturn(CheckValueAsString("userName.Value()", userName.Value(), chip::CharSpan("", 0)));

        VerifyOrReturn(CheckValueNull("userUniqueId", userUniqueId));

        VerifyOrReturn(CheckValueNonNull("userStatus", userStatus));
        VerifyOrReturn(CheckValue("userStatus.Value()", userStatus.Value(), 1));

        VerifyOrReturn(CheckValueNonNull("userType", userType));
        VerifyOrReturn(CheckValue("userType.Value()", userType.Value(), 0));

        VerifyOrReturn(CheckValueNonNull("credentialRule", credentialRule));
        VerifyOrReturn(CheckValue("credentialRule.Value()", credentialRule.Value(), 0));

        VerifyOrReturn(CheckValueNonNull("credentials", credentials));
        {
            auto iter_1 = credentials.Value().begin();
            VerifyOrReturn(CheckNextListItemDecodes<decltype(credentials.Value())>("credentials.Value()", iter_1, 0));
            VerifyOrReturn(CheckValue("credentials.Value()[0].credentialType", iter_1.GetValue().credentialType, 0));
            VerifyOrReturn(CheckValue("credentials.Value()[0].credentialIndex", iter_1.GetValue().credentialIndex, 0U));
            VerifyOrReturn(CheckNoMoreListItems<decltype(credentials.Value())>("credentials.Value()", iter_1, 1));
        }

        VerifyOrReturn(CheckValueNonNull("creatorFabricIndex", creatorFabricIndex));
        VerifyOrReturn(CheckValue("creatorFabricIndex.Value()", creatorFabricIndex.Value(), 1));

        VerifyOrReturn(CheckValueNonNull("lastModifiedFabricIndex", lastModifiedFabricIndex));
        VerifyOrReturn(CheckValue("lastModifiedFabricIndex.Value()", lastModifiedFabricIndex.Value(), 1));

        VerifyOrReturn(CheckValueNonNull("nextUserIndex", nextUserIndex));
        VerifyOrReturn(CheckValue("nextUserIndex.Value()", nextUserIndex.Value(), 2U));

        NextTest();
    }

    CHIP_ERROR TestVerifyCreatedProgrammingPinCredential_91()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::GetCredentialStatus::Type;

        RequestType request;

        request.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(0);
        request.credential.credentialIndex = 0U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))
                ->OnSuccessResponse_91(data.credentialExists, data.userIndex, data.nextCredentialIndex);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_91(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_91(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_91(bool credentialExists, const chip::app::DataModel::Nullable<uint16_t> & userIndex,
                              const chip::app::DataModel::Nullable<uint16_t> & nextCredentialIndex)
    {
        VerifyOrReturn(CheckValue("credentialExists", credentialExists, true));

        VerifyOrReturn(CheckValueNonNull("userIndex", userIndex));
        VerifyOrReturn(CheckValue("userIndex.Value()", userIndex.Value(), 1U));

        VerifyOrReturn(CheckValueNull("nextCredentialIndex", nextCredentialIndex));

        NextTest();
    }

    CHIP_ERROR TestModifyTheProgrammingPinCredential_92()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::SetCredential::Type;

        RequestType request;
        request.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(2);

        request.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(0);
        request.credential.credentialIndex = 0U;

        request.credentialData = chip::ByteSpan(chip::Uint8::from_const_char("654321garbage: not in length on purpose"), 6);
        request.userIndex.SetNull();
        request.userStatus.SetNull();
        request.userType.SetNull();

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))
                ->OnSuccessResponse_92(data.status, data.userIndex, data.nextCredentialIndex);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_92(error);
        };

        ReturnErrorOnFailure(
            chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request, 10000));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_92(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_92(chip::app::Clusters::DoorLock::DlStatus status,
                              const chip::app::DataModel::Nullable<uint16_t> & userIndex,
                              const chip::app::DataModel::Nullable<uint16_t> & nextCredentialIndex)
    {
        VerifyOrReturn(CheckValue("status", status, 0));

        VerifyOrReturn(CheckValueNull("userIndex", userIndex));

        VerifyOrReturn(CheckValueNull("nextCredentialIndex", nextCredentialIndex));

        NextTest();
    }

    CHIP_ERROR TestClearingProgrammingPinFails_93()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::ClearCredential::Type;

        RequestType request;
        request.credential.SetNonNull();

        request.credential.Value().credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(0);
        request.credential.Value().credentialIndex = 0U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnSuccessResponse_93();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_93(error);
        };

        ReturnErrorOnFailure(
            chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request, 10000));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_93(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_COMMAND));
        NextTest();
    }

    void OnSuccessResponse_93() { ThrowSuccessResponse(); }

    CHIP_ERROR TestClearingProgrammingPinWithInvalidIndexFails_94()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::ClearCredential::Type;

        RequestType request;
        request.credential.SetNonNull();

        request.credential.Value().credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(0);
        request.credential.Value().credentialIndex = 1U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnSuccessResponse_94();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_94(error);
        };

        ReturnErrorOnFailure(
            chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request, 10000));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_94(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_COMMAND));
        NextTest();
    }

    void OnSuccessResponse_94() { ThrowSuccessResponse(); }

    CHIP_ERROR TestClearingPinCredentialWithZeroIndexFails_95()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::ClearCredential::Type;

        RequestType request;
        request.credential.SetNonNull();

        request.credential.Value().credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
        request.credential.Value().credentialIndex = 0U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnSuccessResponse_95();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_95(error);
        };

        ReturnErrorOnFailure(
            chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request, 10000));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_95(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_COMMAND));
        NextTest();
    }

    void OnSuccessResponse_95() { ThrowSuccessResponse(); }

    CHIP_ERROR TestClearingPinCredentialWithOutOfBoundIndexFails_96()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::ClearCredential::Type;

        RequestType request;
        request.credential.SetNonNull();

        request.credential.Value().credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
        request.credential.Value().credentialIndex = static_cast<uint16_t>(NumberOfPINUsersSupported + 1);

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnSuccessResponse_96();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_96(error);
        };

        ReturnErrorOnFailure(
            chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request, 10000));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_96(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_COMMAND));
        NextTest();
    }

    void OnSuccessResponse_96() { ThrowSuccessResponse(); }

    CHIP_ERROR TestClearingRfidCredentialWithZeroIndexFails_97()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::ClearCredential::Type;

        RequestType request;
        request.credential.SetNonNull();

        request.credential.Value().credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(2);
        request.credential.Value().credentialIndex = 0U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnSuccessResponse_97();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_97(error);
        };

        ReturnErrorOnFailure(
            chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request, 10000));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_97(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_COMMAND));
        NextTest();
    }

    void OnSuccessResponse_97() { ThrowSuccessResponse(); }

    CHIP_ERROR TestClearingRfidCredentialWithOutOfBoundIndexFails_98()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::ClearCredential::Type;

        RequestType request;
        request.credential.SetNonNull();

        request.credential.Value().credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(2);
        request.credential.Value().credentialIndex = static_cast<uint16_t>(NumberOfRFIDUsersSupported + 1);

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnSuccessResponse_98();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_98(error);
        };

        ReturnErrorOnFailure(
            chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request, 10000));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_98(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_COMMAND));
        NextTest();
    }

    void OnSuccessResponse_98() { ThrowSuccessResponse(); }

    CHIP_ERROR TestClearTheProgrammingPinUser_99()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::ClearUser::Type;

        RequestType request;
        request.userIndex = 1U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnSuccessResponse_99();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_99(error);
        };

        ReturnErrorOnFailure(
            chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request, 10000));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_99(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_99() { NextTest(); }

    CHIP_ERROR TestMakeSureProgrammingPinUserIsDeleted_100()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::GetUser::Type;

        RequestType request;
        request.userIndex = 1U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))
                ->OnSuccessResponse_100(data.userIndex, data.userName, data.userUniqueId, data.userStatus, data.userType,
                                        data.credentialRule, data.credentials, data.creatorFabricIndex,
                                        data.lastModifiedFabricIndex, data.nextUserIndex);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_100(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_100(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_100(
        uint16_t userIndex, const chip::app::DataModel::Nullable<chip::CharSpan> & userName,
        const chip::app::DataModel::Nullable<uint32_t> & userUniqueId,
        const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlUserStatus> & userStatus,
        const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlUserType> & userType,
        const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlCredentialRule> & credentialRule,
        const chip::app::DataModel::Nullable<
            chip::app::DataModel::DecodableList<chip::app::Clusters::DoorLock::Structs::DlCredential::DecodableType>> & credentials,
        const chip::app::DataModel::Nullable<chip::FabricIndex> & creatorFabricIndex,
        const chip::app::DataModel::Nullable<chip::FabricIndex> & lastModifiedFabricIndex,
        const chip::app::DataModel::Nullable<uint16_t> & nextUserIndex)
    {
        VerifyOrReturn(CheckValue("userIndex", userIndex, 1U));

        VerifyOrReturn(CheckValueNull("userName", userName));

        VerifyOrReturn(CheckValueNull("userUniqueId", userUniqueId));

        VerifyOrReturn(CheckValueNull("userStatus", userStatus));

        VerifyOrReturn(CheckValueNull("userType", userType));

        VerifyOrReturn(CheckValueNull("credentialRule", credentialRule));

        VerifyOrReturn(CheckValueNull("credentials", credentials));

        VerifyOrReturn(CheckValueNull("creatorFabricIndex", creatorFabricIndex));

        VerifyOrReturn(CheckValueNull("lastModifiedFabricIndex", lastModifiedFabricIndex));

        VerifyOrReturn(CheckValueNonNull("nextUserIndex", nextUserIndex));
        VerifyOrReturn(CheckValue("nextUserIndex.Value()", nextUserIndex.Value(), 2U));

        NextTest();
    }

    CHIP_ERROR TestMakeSureProgrammingPinCredentialIsDeleted_101()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::GetCredentialStatus::Type;

        RequestType request;

        request.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(0);
        request.credential.credentialIndex = 0U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))
                ->OnSuccessResponse_101(data.credentialExists, data.userIndex, data.nextCredentialIndex);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_UsersAndCredentialsSuite *>(context))->OnFailureResponse_101(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_101(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_101(bool credentialExists, const chip::app::DataModel::Nullable<uint16_t> & userIndex,
                               const chip::app::DataModel::Nullable<uint16_t> & nextCredentialIndex)
    {
        VerifyOrReturn(CheckValue("credentialExists", credentialExists, false));

        VerifyOrReturn(CheckValueNull("userIndex", userIndex));

        VerifyOrReturn(CheckValueNull("nextCredentialIndex", nextCredentialIndex));

        NextTest();
    }
};

class DL_LockUnlockSuite : public TestCommand
{
public:
    DL_LockUnlockSuite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("DL_LockUnlock", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~DL_LockUnlockSuite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: DL_LockUnlock\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: DL_LockUnlock\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Create new PIN credential and lock/unlock user\n");
            err = TestCreateNewPinCredentialAndLockUnlockUser_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Try to unlock the door with invalid PIN\n");
            err = TestTryToUnlockTheDoorWithInvalidPin_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Verify that lock state attribute value is set to Locked\n");
            err = TestVerifyThatLockStateAttributeValueIsSetToLocked_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Try to unlock the door with valid PIN\n");
            err = TestTryToUnlockTheDoorWithValidPin_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Verify that lock state attribute value is set to Unlocked\n");
            err = TestVerifyThatLockStateAttributeValueIsSetToUnlocked_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Try to lock the door with invalid PIN\n");
            err = TestTryToLockTheDoorWithInvalidPin_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Verify that lock state attribute value is set to Unlocked\n");
            err = TestVerifyThatLockStateAttributeValueIsSetToUnlocked_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Try to unlock the door with valid PIN\n");
            err = TestTryToUnlockTheDoorWithValidPin_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Verify that lock state attribute value is set to Locked\n");
            err = TestVerifyThatLockStateAttributeValueIsSetToLocked_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Clean the created credential\n");
            err = TestCleanTheCreatedCredential_10();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 11;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_3(void * context, CHIP_ERROR error)
    {
        (static_cast<DL_LockUnlockSuite *>(context))->OnFailureResponse_3(error);
    }

    static void OnSuccessCallback_3(void * context,
                                    const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlLockState> & lockState)
    {
        (static_cast<DL_LockUnlockSuite *>(context))->OnSuccessResponse_3(lockState);
    }

    static void OnFailureCallback_5(void * context, CHIP_ERROR error)
    {
        (static_cast<DL_LockUnlockSuite *>(context))->OnFailureResponse_5(error);
    }

    static void OnSuccessCallback_5(void * context,
                                    const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlLockState> & lockState)
    {
        (static_cast<DL_LockUnlockSuite *>(context))->OnSuccessResponse_5(lockState);
    }

    static void OnFailureCallback_7(void * context, CHIP_ERROR error)
    {
        (static_cast<DL_LockUnlockSuite *>(context))->OnFailureResponse_7(error);
    }

    static void OnSuccessCallback_7(void * context,
                                    const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlLockState> & lockState)
    {
        (static_cast<DL_LockUnlockSuite *>(context))->OnSuccessResponse_7(lockState);
    }

    static void OnFailureCallback_9(void * context, CHIP_ERROR error)
    {
        (static_cast<DL_LockUnlockSuite *>(context))->OnFailureResponse_9(error);
    }

    static void OnSuccessCallback_9(void * context,
                                    const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlLockState> & lockState)
    {
        (static_cast<DL_LockUnlockSuite *>(context))->OnSuccessResponse_9(lockState);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestCreateNewPinCredentialAndLockUnlockUser_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::SetCredential::Type;

        RequestType request;
        request.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);

        request.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
        request.credential.credentialIndex = 1U;

        request.credentialData = chip::ByteSpan(chip::Uint8::from_const_char("123456garbage: not in length on purpose"), 6);
        request.userIndex.SetNull();
        request.userStatus.SetNull();
        request.userType.SetNull();

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_LockUnlockSuite *>(context))
                ->OnSuccessResponse_1(data.status, data.userIndex, data.nextCredentialIndex);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_LockUnlockSuite *>(context))->OnFailureResponse_1(error);
        };

        ReturnErrorOnFailure(
            chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request, 10000));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1(chip::app::Clusters::DoorLock::DlStatus status,
                             const chip::app::DataModel::Nullable<uint16_t> & userIndex,
                             const chip::app::DataModel::Nullable<uint16_t> & nextCredentialIndex)
    {
        VerifyOrReturn(CheckValue("status", status, 0));

        VerifyOrReturn(CheckValueNonNull("userIndex", userIndex));
        VerifyOrReturn(CheckValue("userIndex.Value()", userIndex.Value(), 1U));

        VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", nextCredentialIndex));
        VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", nextCredentialIndex.Value(), 2U));

        NextTest();
    }

    CHIP_ERROR TestTryToUnlockTheDoorWithInvalidPin_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::UnlockDoor::Type;

        RequestType request;
        request.pinCode.Emplace();
        request.pinCode.Value() = chip::ByteSpan(chip::Uint8::from_const_char("000000garbage: not in length on purpose"), 6);

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_LockUnlockSuite *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_LockUnlockSuite *>(context))->OnFailureResponse_2(error);
        };

        ReturnErrorOnFailure(
            chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request, 10000));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_FAILURE));
        NextTest();
    }

    void OnSuccessResponse_2() { ThrowSuccessResponse(); }

    CHIP_ERROR TestVerifyThatLockStateAttributeValueIsSetToLocked_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::DoorLockClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::DoorLock::Attributes::LockState::TypeInfo>(
            this, OnSuccessCallback_3, OnFailureCallback_3, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3(const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlLockState> & lockState)
    {
        VerifyOrReturn(CheckValueNonNull("lockState", lockState));
        VerifyOrReturn(CheckValue("lockState.Value()", lockState.Value(), 1));

        NextTest();
    }

    CHIP_ERROR TestTryToUnlockTheDoorWithValidPin_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::UnlockDoor::Type;

        RequestType request;
        request.pinCode.Emplace();
        request.pinCode.Value() = chip::ByteSpan(chip::Uint8::from_const_char("123456garbage: not in length on purpose"), 6);

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_LockUnlockSuite *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_LockUnlockSuite *>(context))->OnFailureResponse_4(error);
        };

        ReturnErrorOnFailure(
            chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request, 10000));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestVerifyThatLockStateAttributeValueIsSetToUnlocked_5()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::DoorLockClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::DoorLock::Attributes::LockState::TypeInfo>(
            this, OnSuccessCallback_5, OnFailureCallback_5, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_5(const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlLockState> & lockState)
    {
        VerifyOrReturn(CheckValueNonNull("lockState", lockState));
        VerifyOrReturn(CheckValue("lockState.Value()", lockState.Value(), 2));

        NextTest();
    }

    CHIP_ERROR TestTryToLockTheDoorWithInvalidPin_6()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::LockDoor::Type;

        RequestType request;
        request.pinCode.Emplace();
        request.pinCode.Value() = chip::ByteSpan(chip::Uint8::from_const_char("000000garbage: not in length on purpose"), 6);

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_LockUnlockSuite *>(context))->OnSuccessResponse_6();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_LockUnlockSuite *>(context))->OnFailureResponse_6(error);
        };

        ReturnErrorOnFailure(
            chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request, 10000));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_6(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_FAILURE));
        NextTest();
    }

    void OnSuccessResponse_6() { ThrowSuccessResponse(); }

    CHIP_ERROR TestVerifyThatLockStateAttributeValueIsSetToUnlocked_7()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::DoorLockClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::DoorLock::Attributes::LockState::TypeInfo>(
            this, OnSuccessCallback_7, OnFailureCallback_7, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_7(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_7(const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlLockState> & lockState)
    {
        VerifyOrReturn(CheckValueNonNull("lockState", lockState));
        VerifyOrReturn(CheckValue("lockState.Value()", lockState.Value(), 2));

        NextTest();
    }

    CHIP_ERROR TestTryToUnlockTheDoorWithValidPin_8()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::LockDoor::Type;

        RequestType request;
        request.pinCode.Emplace();
        request.pinCode.Value() = chip::ByteSpan(chip::Uint8::from_const_char("123456garbage: not in length on purpose"), 6);

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_LockUnlockSuite *>(context))->OnSuccessResponse_8();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_LockUnlockSuite *>(context))->OnFailureResponse_8(error);
        };

        ReturnErrorOnFailure(
            chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request, 10000));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_8(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_8() { NextTest(); }

    CHIP_ERROR TestVerifyThatLockStateAttributeValueIsSetToLocked_9()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::DoorLockClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::DoorLock::Attributes::LockState::TypeInfo>(
            this, OnSuccessCallback_9, OnFailureCallback_9, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_9(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_9(const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlLockState> & lockState)
    {
        VerifyOrReturn(CheckValueNonNull("lockState", lockState));
        VerifyOrReturn(CheckValue("lockState.Value()", lockState.Value(), 1));

        NextTest();
    }

    CHIP_ERROR TestCleanTheCreatedCredential_10()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::ClearCredential::Type;

        RequestType request;
        request.credential.SetNonNull();

        request.credential.Value().credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
        request.credential.Value().credentialIndex = 1U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_LockUnlockSuite *>(context))->OnSuccessResponse_10();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_LockUnlockSuite *>(context))->OnFailureResponse_10(error);
        };

        ReturnErrorOnFailure(
            chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request, 10000));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_10(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_10() { NextTest(); }
};

class DL_SchedulesSuite : public TestCommand
{
public:
    DL_SchedulesSuite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("DL_Schedules", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~DL_SchedulesSuite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: DL_Schedules\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: DL_Schedules\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Create new PIN credential and schedule user\n");
            err = TestCreateNewPinCredentialAndScheduleUser_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Get number of supported users\n");
            err = TestGetNumberOfSupportedUsers_2();
            break;
        case 3:
            ChipLogProgress(chipTool,
                            " ***** Test Step 3 : Get Max number of Week Day schedules for user and verify default value\n");
            err = TestGetMaxNumberOfWeekDaySchedulesForUserAndVerifyDefaultValue_3();
            break;
        case 4:
            ChipLogProgress(chipTool,
                            " ***** Test Step 4 : Get Max number of Year Day schedules for user and verify default value\n");
            err = TestGetMaxNumberOfYearDaySchedulesForUserAndVerifyDefaultValue_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Create Week Day schedule with 0 index\n");
            err = TestCreateWeekDayScheduleWith0Index_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Create Week Day schedule with out-of-bounds index\n");
            err = TestCreateWeekDayScheduleWithOutOfBoundsIndex_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Create Week Day schedule with 0 user index\n");
            err = TestCreateWeekDayScheduleWith0UserIndex_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Create Week Day schedule with out-of-bounds user index\n");
            err = TestCreateWeekDayScheduleWithOutOfBoundsUserIndex_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Create Week Day schedule for non-existing user\n");
            err = TestCreateWeekDayScheduleForNonExistingUser_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Create Week Day schedule with 0 days mask\n");
            err = TestCreateWeekDayScheduleWith0DaysMask_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : Create Week Day schedule for Sunday and Monday\n");
            err = TestCreateWeekDayScheduleForSundayAndMonday_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : Create Week Day schedule for Sunday Wednesday and Saturday\n");
            err = TestCreateWeekDayScheduleForSundayWednesdayAndSaturday_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : Create Week Day schedule with invalid start hour\n");
            err = TestCreateWeekDayScheduleWithInvalidStartHour_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : Create Week Day schedule with invalid start minute\n");
            err = TestCreateWeekDayScheduleWithInvalidStartMinute_14();
            break;
        case 15:
            ChipLogProgress(chipTool, " ***** Test Step 15 : Create Week Day schedule with invalid end hour\n");
            err = TestCreateWeekDayScheduleWithInvalidEndHour_15();
            break;
        case 16:
            ChipLogProgress(chipTool, " ***** Test Step 16 : Create Week Day schedule with invalid end minute\n");
            err = TestCreateWeekDayScheduleWithInvalidEndMinute_16();
            break;
        case 17:
            ChipLogProgress(chipTool, " ***** Test Step 17 : Create Week Day schedule with start hour later that end hour\n");
            err = TestCreateWeekDayScheduleWithStartHourLaterThatEndHour_17();
            break;
        case 18:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 18 : Create Week Day schedule with start minute later that end minute when hours are equal\n");
            err = TestCreateWeekDayScheduleWithStartMinuteLaterThatEndMinuteWhenHoursAreEqual_18();
            break;
        case 19:
            ChipLogProgress(chipTool, " ***** Test Step 19 : Make sure that previous operations did not create a schedule\n");
            err = TestMakeSureThatPreviousOperationsDidNotCreateASchedule_19();
            break;
        case 20:
            ChipLogProgress(chipTool, " ***** Test Step 20 : Get Week Day schedule with 0 index\n");
            err = TestGetWeekDayScheduleWith0Index_20();
            break;
        case 21:
            ChipLogProgress(chipTool, " ***** Test Step 21 : Get Week Day schedule with out-of-bounds index\n");
            err = TestGetWeekDayScheduleWithOutOfBoundsIndex_21();
            break;
        case 22:
            ChipLogProgress(chipTool, " ***** Test Step 22 : Get Week Day schedule with 0 user index\n");
            err = TestGetWeekDayScheduleWith0UserIndex_22();
            break;
        case 23:
            ChipLogProgress(chipTool, " ***** Test Step 23 : Get Week Day schedule with out-of-bounds user index\n");
            err = TestGetWeekDayScheduleWithOutOfBoundsUserIndex_23();
            break;
        case 24:
            ChipLogProgress(chipTool, " ***** Test Step 24 : Get Week Day schedule with non-existing user index\n");
            err = TestGetWeekDayScheduleWithNonExistingUserIndex_24();
            break;
        case 25:
            ChipLogProgress(chipTool, " ***** Test Step 25 : Create Year Day schedule with 0 index\n");
            err = TestCreateYearDayScheduleWith0Index_25();
            break;
        case 26:
            ChipLogProgress(chipTool, " ***** Test Step 26 : Create Year Day schedule with out-of-bounds index\n");
            err = TestCreateYearDayScheduleWithOutOfBoundsIndex_26();
            break;
        case 27:
            ChipLogProgress(chipTool, " ***** Test Step 27 : Create Year Day schedule with 0 user index\n");
            err = TestCreateYearDayScheduleWith0UserIndex_27();
            break;
        case 28:
            ChipLogProgress(chipTool, " ***** Test Step 28 : Create Year Day schedule with out-of-bounds user index\n");
            err = TestCreateYearDayScheduleWithOutOfBoundsUserIndex_28();
            break;
        case 29:
            ChipLogProgress(chipTool, " ***** Test Step 29 : Create Year Day schedule for non-existing user\n");
            err = TestCreateYearDayScheduleForNonExistingUser_29();
            break;
        case 30:
            ChipLogProgress(chipTool, " ***** Test Step 30 : Create Year Day schedule with start hour later that end hour\n");
            err = TestCreateYearDayScheduleWithStartHourLaterThatEndHour_30();
            break;
        case 31:
            ChipLogProgress(chipTool, " ***** Test Step 31 : Make sure that previous operations did not create a schedule\n");
            err = TestMakeSureThatPreviousOperationsDidNotCreateASchedule_31();
            break;
        case 32:
            ChipLogProgress(chipTool, " ***** Test Step 32 : Get Year Day schedule with 0 index\n");
            err = TestGetYearDayScheduleWith0Index_32();
            break;
        case 33:
            ChipLogProgress(chipTool, " ***** Test Step 33 : Get Year Day schedule with out-of-bounds index\n");
            err = TestGetYearDayScheduleWithOutOfBoundsIndex_33();
            break;
        case 34:
            ChipLogProgress(chipTool, " ***** Test Step 34 : Get Year Day schedule with 0 user index\n");
            err = TestGetYearDayScheduleWith0UserIndex_34();
            break;
        case 35:
            ChipLogProgress(chipTool, " ***** Test Step 35 : Get Year Day schedule with out-of-bounds user index\n");
            err = TestGetYearDayScheduleWithOutOfBoundsUserIndex_35();
            break;
        case 36:
            ChipLogProgress(chipTool, " ***** Test Step 36 : Get Year Day schedule with non-existing user index\n");
            err = TestGetYearDayScheduleWithNonExistingUserIndex_36();
            break;
        case 37:
            ChipLogProgress(chipTool, " ***** Test Step 37 : Create Week Day schedule with valid parameters\n");
            err = TestCreateWeekDayScheduleWithValidParameters_37();
            break;
        case 38:
            ChipLogProgress(chipTool, " ***** Test Step 38 : Verify created schedule\n");
            err = TestVerifyCreatedSchedule_38();
            break;
        case 39:
            ChipLogProgress(chipTool, " ***** Test Step 39 : Create Year Day schedule with valid parameters\n");
            err = TestCreateYearDayScheduleWithValidParameters_39();
            break;
        case 40:
            ChipLogProgress(chipTool, " ***** Test Step 40 : Verify created schedule\n");
            err = TestVerifyCreatedSchedule_40();
            break;
        case 41:
            ChipLogProgress(chipTool, " ***** Test Step 41 : Clear Week Day schedule with 0 index\n");
            err = TestClearWeekDayScheduleWith0Index_41();
            break;
        case 42:
            ChipLogProgress(chipTool, " ***** Test Step 42 : Clear Week Day schedule with out-of-bounds index\n");
            err = TestClearWeekDayScheduleWithOutOfBoundsIndex_42();
            break;
        case 43:
            ChipLogProgress(chipTool, " ***** Test Step 43 : Clear Week Day schedule with 0 user index\n");
            err = TestClearWeekDayScheduleWith0UserIndex_43();
            break;
        case 44:
            ChipLogProgress(chipTool, " ***** Test Step 44 : Clear Week Day schedule with out-of-bounds user index\n");
            err = TestClearWeekDayScheduleWithOutOfBoundsUserIndex_44();
            break;
        case 45:
            ChipLogProgress(chipTool, " ***** Test Step 45 : Clear Week Day schedule with non-existing user\n");
            err = TestClearWeekDayScheduleWithNonExistingUser_45();
            break;
        case 46:
            ChipLogProgress(chipTool, " ***** Test Step 46 : Clear Year Day schedule with 0 index\n");
            err = TestClearYearDayScheduleWith0Index_46();
            break;
        case 47:
            ChipLogProgress(chipTool, " ***** Test Step 47 : Clear Year Day schedule with out-of-bounds index\n");
            err = TestClearYearDayScheduleWithOutOfBoundsIndex_47();
            break;
        case 48:
            ChipLogProgress(chipTool, " ***** Test Step 48 : Clear Year Day schedule with 0 user index\n");
            err = TestClearYearDayScheduleWith0UserIndex_48();
            break;
        case 49:
            ChipLogProgress(chipTool, " ***** Test Step 49 : Clear Year Day schedule with out-of-bounds user index\n");
            err = TestClearYearDayScheduleWithOutOfBoundsUserIndex_49();
            break;
        case 50:
            ChipLogProgress(chipTool, " ***** Test Step 50 : Clear Year Day schedule with non-existing user\n");
            err = TestClearYearDayScheduleWithNonExistingUser_50();
            break;
        case 51:
            ChipLogProgress(chipTool, " ***** Test Step 51 : Make sure that week day schedule was not deleted\n");
            err = TestMakeSureThatWeekDayScheduleWasNotDeleted_51();
            break;
        case 52:
            ChipLogProgress(chipTool, " ***** Test Step 52 : Make sure that year day schedule was not deleted\n");
            err = TestMakeSureThatYearDayScheduleWasNotDeleted_52();
            break;
        case 53:
            ChipLogProgress(chipTool, " ***** Test Step 53 : Create another Week Day schedule with valid parameters\n");
            err = TestCreateAnotherWeekDayScheduleWithValidParameters_53();
            break;
        case 54:
            ChipLogProgress(chipTool, " ***** Test Step 54 : Verify created week day schedule\n");
            err = TestVerifyCreatedWeekDaySchedule_54();
            break;
        case 55:
            ChipLogProgress(chipTool, " ***** Test Step 55 : Create another Year Day schedule with valid parameters\n");
            err = TestCreateAnotherYearDayScheduleWithValidParameters_55();
            break;
        case 56:
            ChipLogProgress(chipTool, " ***** Test Step 56 : Verify created year day schedule\n");
            err = TestVerifyCreatedYearDaySchedule_56();
            break;
        case 57:
            ChipLogProgress(chipTool, " ***** Test Step 57 : Clear a single week day schedule for the first user\n");
            err = TestClearASingleWeekDayScheduleForTheFirstUser_57();
            break;
        case 58:
            ChipLogProgress(chipTool, " ***** Test Step 58 : Verify cleared week day schedule\n");
            err = TestVerifyClearedWeekDaySchedule_58();
            break;
        case 59:
            ChipLogProgress(chipTool, " ***** Test Step 59 : Clear all remaining week day schedules for the first user\n");
            err = TestClearAllRemainingWeekDaySchedulesForTheFirstUser_59();
            break;
        case 60:
            ChipLogProgress(chipTool, " ***** Test Step 60 : Verify cleared week schedule\n");
            err = TestVerifyClearedWeekSchedule_60();
            break;
        case 61:
            ChipLogProgress(chipTool, " ***** Test Step 61 : Make sure that first year day schedule was not deleted\n");
            err = TestMakeSureThatFirstYearDayScheduleWasNotDeleted_61();
            break;
        case 62:
            ChipLogProgress(chipTool, " ***** Test Step 62 : Make sure that second year day schedule was not deleted\n");
            err = TestMakeSureThatSecondYearDayScheduleWasNotDeleted_62();
            break;
        case 63:
            ChipLogProgress(chipTool, " ***** Test Step 63 : Create another Week Day schedule with valid parameters\n");
            err = TestCreateAnotherWeekDayScheduleWithValidParameters_63();
            break;
        case 64:
            ChipLogProgress(chipTool, " ***** Test Step 64 : Clear a single year day schedule for the first user\n");
            err = TestClearASingleYearDayScheduleForTheFirstUser_64();
            break;
        case 65:
            ChipLogProgress(chipTool, " ***** Test Step 65 : Verify cleared year day schedule\n");
            err = TestVerifyClearedYearDaySchedule_65();
            break;
        case 66:
            ChipLogProgress(chipTool, " ***** Test Step 66 : Clear all remaining year schedules for the first user\n");
            err = TestClearAllRemainingYearSchedulesForTheFirstUser_66();
            break;
        case 67:
            ChipLogProgress(chipTool, " ***** Test Step 67 : Verify that second year day schedule was cleared\n");
            err = TestVerifyThatSecondYearDayScheduleWasCleared_67();
            break;
        case 68:
            ChipLogProgress(chipTool, " ***** Test Step 68 : Verify created week day schedule\n");
            err = TestVerifyCreatedWeekDaySchedule_68();
            break;
        case 69:
            ChipLogProgress(chipTool, " ***** Test Step 69 : Clear all remaining week day schedules for the first user\n");
            err = TestClearAllRemainingWeekDaySchedulesForTheFirstUser_69();
            break;
        case 70:
            ChipLogProgress(chipTool,
                            " ***** Test Step 70 : Create new user without credential so we can add more schedules to it\n");
            err = TestCreateNewUserWithoutCredentialSoWeCanAddMoreSchedulesToIt_70();
            break;
        case 71:
            ChipLogProgress(chipTool, " ***** Test Step 71 : Create Week Day schedule with valid parameters for first user\n");
            err = TestCreateWeekDayScheduleWithValidParametersForFirstUser_71();
            break;
        case 72:
            ChipLogProgress(chipTool, " ***** Test Step 72 : Verify created week day schedule for first user\n");
            err = TestVerifyCreatedWeekDayScheduleForFirstUser_72();
            break;
        case 73:
            ChipLogProgress(chipTool, " ***** Test Step 73 : Create Year Day schedule for first user\n");
            err = TestCreateYearDayScheduleForFirstUser_73();
            break;
        case 74:
            ChipLogProgress(chipTool, " ***** Test Step 74 : Verify created year day schedule for first\n");
            err = TestVerifyCreatedYearDayScheduleForFirst_74();
            break;
        case 75:
            ChipLogProgress(chipTool, " ***** Test Step 75 : Create Week Day schedule with valid parameters for second user\n");
            err = TestCreateWeekDayScheduleWithValidParametersForSecondUser_75();
            break;
        case 76:
            ChipLogProgress(chipTool, " ***** Test Step 76 : Verify created week day schedule for first user\n");
            err = TestVerifyCreatedWeekDayScheduleForFirstUser_76();
            break;
        case 77:
            ChipLogProgress(chipTool, " ***** Test Step 77 : Create Year Day schedule for second user\n");
            err = TestCreateYearDayScheduleForSecondUser_77();
            break;
        case 78:
            ChipLogProgress(chipTool, " ***** Test Step 78 : Verify created year day schedule for first\n");
            err = TestVerifyCreatedYearDayScheduleForFirst_78();
            break;
        case 79:
            ChipLogProgress(chipTool, " ***** Test Step 79 : Cleanup\n");
            err = TestCleanup_79();
            break;
        case 80:
            ChipLogProgress(chipTool, " ***** Test Step 80 : Make sure clearing first user also cleared week day schedules\n");
            err = TestMakeSureClearingFirstUserAlsoClearedWeekDaySchedules_80();
            break;
        case 81:
            ChipLogProgress(chipTool, " ***** Test Step 81 : Make sure clearing first user also cleared year day schedules\n");
            err = TestMakeSureClearingFirstUserAlsoClearedYearDaySchedules_81();
            break;
        case 82:
            ChipLogProgress(chipTool, " ***** Test Step 82 : Make sure clearing second user also cleared week day schedules\n");
            err = TestMakeSureClearingSecondUserAlsoClearedWeekDaySchedules_82();
            break;
        case 83:
            ChipLogProgress(chipTool, " ***** Test Step 83 : Make sure clearing second user also cleared year day schedules\n");
            err = TestMakeSureClearingSecondUserAlsoClearedYearDaySchedules_83();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 84;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    uint16_t NumberOfTotalUsersSupported;
    uint8_t NumberOfWeekDaySchedulesSupportedPerUser;
    uint8_t NumberOfYearDaySchedulesSupportedPerUser;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<DL_SchedulesSuite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context, uint16_t numberOfTotalUsersSupported)
    {
        (static_cast<DL_SchedulesSuite *>(context))->OnSuccessResponse_2(numberOfTotalUsersSupported);
    }

    static void OnFailureCallback_3(void * context, CHIP_ERROR error)
    {
        (static_cast<DL_SchedulesSuite *>(context))->OnFailureResponse_3(error);
    }

    static void OnSuccessCallback_3(void * context, uint8_t numberOfWeekDaySchedulesSupportedPerUser)
    {
        (static_cast<DL_SchedulesSuite *>(context))->OnSuccessResponse_3(numberOfWeekDaySchedulesSupportedPerUser);
    }

    static void OnFailureCallback_4(void * context, CHIP_ERROR error)
    {
        (static_cast<DL_SchedulesSuite *>(context))->OnFailureResponse_4(error);
    }

    static void OnSuccessCallback_4(void * context, uint8_t numberOfYearDaySchedulesSupportedPerUser)
    {
        (static_cast<DL_SchedulesSuite *>(context))->OnSuccessResponse_4(numberOfYearDaySchedulesSupportedPerUser);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestCreateNewPinCredentialAndScheduleUser_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::SetCredential::Type;

        RequestType request;
        request.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);

        request.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
        request.credential.credentialIndex = 1U;

        request.credentialData = chip::ByteSpan(chip::Uint8::from_const_char("123456garbage: not in length on purpose"), 6);
        request.userIndex.SetNull();
        request.userStatus.SetNull();
        request.userType.SetNull();

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_SchedulesSuite *>(context))->OnSuccessResponse_1(data.status, data.userIndex, data.nextCredentialIndex);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_SchedulesSuite *>(context))->OnFailureResponse_1(error);
        };

        ReturnErrorOnFailure(
            chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request, 10000));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1(chip::app::Clusters::DoorLock::DlStatus status,
                             const chip::app::DataModel::Nullable<uint16_t> & userIndex,
                             const chip::app::DataModel::Nullable<uint16_t> & nextCredentialIndex)
    {
        VerifyOrReturn(CheckValue("status", status, 0));

        VerifyOrReturn(CheckValueNonNull("userIndex", userIndex));
        VerifyOrReturn(CheckValue("userIndex.Value()", userIndex.Value(), 1U));

        VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", nextCredentialIndex));
        VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", nextCredentialIndex.Value(), 2U));

        NextTest();
    }

    CHIP_ERROR TestGetNumberOfSupportedUsers_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::DoorLockClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::DoorLock::Attributes::NumberOfTotalUsersSupported::TypeInfo>(
                this, OnSuccessCallback_2, OnFailureCallback_2, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2(uint16_t numberOfTotalUsersSupported)
    {
        VerifyOrReturn(CheckValue("numberOfTotalUsersSupported", numberOfTotalUsersSupported, 10U));

        NumberOfTotalUsersSupported = numberOfTotalUsersSupported;
        NextTest();
    }

    CHIP_ERROR TestGetMaxNumberOfWeekDaySchedulesForUserAndVerifyDefaultValue_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::DoorLockClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::DoorLock::Attributes::NumberOfWeekDaySchedulesSupportedPerUser::TypeInfo>(
                this, OnSuccessCallback_3, OnFailureCallback_3, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3(uint8_t numberOfWeekDaySchedulesSupportedPerUser)
    {
        VerifyOrReturn(CheckValue("numberOfWeekDaySchedulesSupportedPerUser", numberOfWeekDaySchedulesSupportedPerUser, 10));

        NumberOfWeekDaySchedulesSupportedPerUser = numberOfWeekDaySchedulesSupportedPerUser;
        NextTest();
    }

    CHIP_ERROR TestGetMaxNumberOfYearDaySchedulesForUserAndVerifyDefaultValue_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::DoorLockClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::DoorLock::Attributes::NumberOfYearDaySchedulesSupportedPerUser::TypeInfo>(
                this, OnSuccessCallback_4, OnFailureCallback_4, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_4(uint8_t numberOfYearDaySchedulesSupportedPerUser)
    {
        VerifyOrReturn(CheckValue("numberOfYearDaySchedulesSupportedPerUser", numberOfYearDaySchedulesSupportedPerUser, 10));

        NumberOfYearDaySchedulesSupportedPerUser = numberOfYearDaySchedulesSupportedPerUser;
        NextTest();
    }

    CHIP_ERROR TestCreateWeekDayScheduleWith0Index_5()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::SetWeekDaySchedule::Type;

        RequestType request;
        request.weekDayIndex = 0;
        request.userIndex    = 1U;
        request.daysMask     = static_cast<chip::BitFlags<chip::app::Clusters::DoorLock::DlDaysMaskMap>>(1);
        request.startHour    = 15;
        request.startMinute  = 16;
        request.endHour      = 18;
        request.endMinute    = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_SchedulesSuite *>(context))->OnSuccessResponse_5();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_SchedulesSuite *>(context))->OnFailureResponse_5(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_FIELD));
        NextTest();
    }

    void OnSuccessResponse_5() { ThrowSuccessResponse(); }

    CHIP_ERROR TestCreateWeekDayScheduleWithOutOfBoundsIndex_6()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::SetWeekDaySchedule::Type;

        RequestType request;
        request.weekDayIndex = static_cast<uint8_t>(NumberOfWeekDaySchedulesSupportedPerUser + 1);
        request.userIndex    = 1U;
        request.daysMask     = static_cast<chip::BitFlags<chip::app::Clusters::DoorLock::DlDaysMaskMap>>(1);
        request.startHour    = 15;
        request.startMinute  = 16;
        request.endHour      = 18;
        request.endMinute    = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_SchedulesSuite *>(context))->OnSuccessResponse_6();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_SchedulesSuite *>(context))->OnFailureResponse_6(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_6(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_FIELD));
        NextTest();
    }

    void OnSuccessResponse_6() { ThrowSuccessResponse(); }

    CHIP_ERROR TestCreateWeekDayScheduleWith0UserIndex_7()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::SetWeekDaySchedule::Type;

        RequestType request;
        request.weekDayIndex = 1;
        request.userIndex    = 0U;
        request.daysMask     = static_cast<chip::BitFlags<chip::app::Clusters::DoorLock::DlDaysMaskMap>>(1);
        request.startHour    = 15;
        request.startMinute  = 16;
        request.endHour      = 18;
        request.endMinute    = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_SchedulesSuite *>(context))->OnSuccessResponse_7();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_SchedulesSuite *>(context))->OnFailureResponse_7(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_7(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_FIELD));
        NextTest();
    }

    void OnSuccessResponse_7() { ThrowSuccessResponse(); }

    CHIP_ERROR TestCreateWeekDayScheduleWithOutOfBoundsUserIndex_8()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::SetWeekDaySchedule::Type;

        RequestType request;
        request.weekDayIndex = 1;
        request.userIndex    = static_cast<uint8_t>(NumberOfTotalUsersSupported + 1);
        request.daysMask     = static_cast<chip::BitFlags<chip::app::Clusters::DoorLock::DlDaysMaskMap>>(1);
        request.startHour    = 15;
        request.startMinute  = 16;
        request.endHour      = 18;
        request.endMinute    = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_SchedulesSuite *>(context))->OnSuccessResponse_8();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_SchedulesSuite *>(context))->OnFailureResponse_8(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_8(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_FIELD));
        NextTest();
    }

    void OnSuccessResponse_8() { ThrowSuccessResponse(); }

    CHIP_ERROR TestCreateWeekDayScheduleForNonExistingUser_9()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::SetWeekDaySchedule::Type;

        RequestType request;
        request.weekDayIndex = 1;
        request.userIndex    = 2U;
        request.daysMask     = static_cast<chip::BitFlags<chip::app::Clusters::DoorLock::DlDaysMaskMap>>(1);
        request.startHour    = 15;
        request.startMinute  = 16;
        request.endHour      = 18;
        request.endMinute    = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_SchedulesSuite *>(context))->OnSuccessResponse_9();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_SchedulesSuite *>(context))->OnFailureResponse_9(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_9(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_NOT_FOUND));
        NextTest();
    }

    void OnSuccessResponse_9() { ThrowSuccessResponse(); }

    CHIP_ERROR TestCreateWeekDayScheduleWith0DaysMask_10()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::SetWeekDaySchedule::Type;

        RequestType request;
        request.weekDayIndex = 1;
        request.userIndex    = 1U;
        request.daysMask     = static_cast<chip::BitFlags<chip::app::Clusters::DoorLock::DlDaysMaskMap>>(0);
        request.startHour    = 15;
        request.startMinute  = 16;
        request.endHour      = 18;
        request.endMinute    = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_SchedulesSuite *>(context))->OnSuccessResponse_10();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_SchedulesSuite *>(context))->OnFailureResponse_10(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_10(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_FIELD));
        NextTest();
    }

    void OnSuccessResponse_10() { ThrowSuccessResponse(); }

    CHIP_ERROR TestCreateWeekDayScheduleForSundayAndMonday_11()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::SetWeekDaySchedule::Type;

        RequestType request;
        request.weekDayIndex = 1;
        request.userIndex    = 1U;
        request.daysMask     = static_cast<chip::BitFlags<chip::app::Clusters::DoorLock::DlDaysMaskMap>>(3);
        request.startHour    = 15;
        request.startMinute  = 16;
        request.endHour      = 18;
        request.endMinute    = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_SchedulesSuite *>(context))->OnSuccessResponse_11();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_SchedulesSuite *>(context))->OnFailureResponse_11(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_11(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_FIELD));
        NextTest();
    }

    void OnSuccessResponse_11() { ThrowSuccessResponse(); }

    CHIP_ERROR TestCreateWeekDayScheduleForSundayWednesdayAndSaturday_12()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::SetWeekDaySchedule::Type;

        RequestType request;
        request.weekDayIndex = 1;
        request.userIndex    = 1U;
        request.daysMask     = static_cast<chip::BitFlags<chip::app::Clusters::DoorLock::DlDaysMaskMap>>(73);
        request.startHour    = 15;
        request.startMinute  = 16;
        request.endHour      = 18;
        request.endMinute    = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_SchedulesSuite *>(context))->OnSuccessResponse_12();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_SchedulesSuite *>(context))->OnFailureResponse_12(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_12(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_FIELD));
        NextTest();
    }

    void OnSuccessResponse_12() { ThrowSuccessResponse(); }

    CHIP_ERROR TestCreateWeekDayScheduleWithInvalidStartHour_13()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::SetWeekDaySchedule::Type;

        RequestType request;
        request.weekDayIndex = 1;
        request.userIndex    = 1U;
        request.daysMask     = static_cast<chip::BitFlags<chip::app::Clusters::DoorLock::DlDaysMaskMap>>(1);
        request.startHour    = 24;
        request.startMinute  = 16;
        request.endHour      = 18;
        request.endMinute    = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_SchedulesSuite *>(context))->OnSuccessResponse_13();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_SchedulesSuite *>(context))->OnFailureResponse_13(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_13(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_FIELD));
        NextTest();
    }

    void OnSuccessResponse_13() { ThrowSuccessResponse(); }

    CHIP_ERROR TestCreateWeekDayScheduleWithInvalidStartMinute_14()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::SetWeekDaySchedule::Type;

        RequestType request;
        request.weekDayIndex = 1;
        request.userIndex    = 1U;
        request.daysMask     = static_cast<chip::BitFlags<chip::app::Clusters::DoorLock::DlDaysMaskMap>>(1);
        request.startHour    = 15;
        request.startMinute  = 60;
        request.endHour      = 18;
        request.endMinute    = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_SchedulesSuite *>(context))->OnSuccessResponse_14();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_SchedulesSuite *>(context))->OnFailureResponse_14(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_14(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_FIELD));
        NextTest();
    }

    void OnSuccessResponse_14() { ThrowSuccessResponse(); }

    CHIP_ERROR TestCreateWeekDayScheduleWithInvalidEndHour_15()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::SetWeekDaySchedule::Type;

        RequestType request;
        request.weekDayIndex = 1;
        request.userIndex    = 1U;
        request.daysMask     = static_cast<chip::BitFlags<chip::app::Clusters::DoorLock::DlDaysMaskMap>>(1);
        request.startHour    = 15;
        request.startMinute  = 16;
        request.endHour      = 24;
        request.endMinute    = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_SchedulesSuite *>(context))->OnSuccessResponse_15();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_SchedulesSuite *>(context))->OnFailureResponse_15(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_15(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_FIELD));
        NextTest();
    }

    void OnSuccessResponse_15() { ThrowSuccessResponse(); }

    CHIP_ERROR TestCreateWeekDayScheduleWithInvalidEndMinute_16()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::SetWeekDaySchedule::Type;

        RequestType request;
        request.weekDayIndex = 1;
        request.userIndex    = 1U;
        request.daysMask     = static_cast<chip::BitFlags<chip::app::Clusters::DoorLock::DlDaysMaskMap>>(1);
        request.startHour    = 15;
        request.startMinute  = 16;
        request.endHour      = 18;
        request.endMinute    = 60;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_SchedulesSuite *>(context))->OnSuccessResponse_16();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_SchedulesSuite *>(context))->OnFailureResponse_16(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_16(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_FIELD));
        NextTest();
    }

    void OnSuccessResponse_16() { ThrowSuccessResponse(); }

    CHIP_ERROR TestCreateWeekDayScheduleWithStartHourLaterThatEndHour_17()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::SetWeekDaySchedule::Type;

        RequestType request;
        request.weekDayIndex = 1;
        request.userIndex    = 1U;
        request.daysMask     = static_cast<chip::BitFlags<chip::app::Clusters::DoorLock::DlDaysMaskMap>>(1);
        request.startHour    = 19;
        request.startMinute  = 16;
        request.endHour      = 18;
        request.endMinute    = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_SchedulesSuite *>(context))->OnSuccessResponse_17();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_SchedulesSuite *>(context))->OnFailureResponse_17(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_17(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_FIELD));
        NextTest();
    }

    void OnSuccessResponse_17() { ThrowSuccessResponse(); }

    CHIP_ERROR TestCreateWeekDayScheduleWithStartMinuteLaterThatEndMinuteWhenHoursAreEqual_18()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::SetWeekDaySchedule::Type;

        RequestType request;
        request.weekDayIndex = 1;
        request.userIndex    = 1U;
        request.daysMask     = static_cast<chip::BitFlags<chip::app::Clusters::DoorLock::DlDaysMaskMap>>(1);
        request.startHour    = 15;
        request.startMinute  = 50;
        request.endHour      = 15;
        request.endMinute    = 49;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_SchedulesSuite *>(context))->OnSuccessResponse_18();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_SchedulesSuite *>(context))->OnFailureResponse_18(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_18(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_FIELD));
        NextTest();
    }

    void OnSuccessResponse_18() { ThrowSuccessResponse(); }

    CHIP_ERROR TestMakeSureThatPreviousOperationsDidNotCreateASchedule_19()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::GetWeekDaySchedule::Type;

        RequestType request;
        request.weekDayIndex = 1;
        request.userIndex    = 1U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_SchedulesSuite *>(context))
                ->OnSuccessResponse_19(data.weekDayIndex, data.userIndex, data.status, data.daysMask, data.startHour,
                                       data.startMinute, data.endHour, data.endMinute);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_SchedulesSuite *>(context))->OnFailureResponse_19(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_19(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_19(uint8_t weekDayIndex, uint16_t userIndex, chip::app::Clusters::DoorLock::DlStatus status,
                              const chip::Optional<chip::BitFlags<chip::app::Clusters::DoorLock::DlDaysMaskMap>> & daysMask,
                              const chip::Optional<uint8_t> & startHour, const chip::Optional<uint8_t> & startMinute,
                              const chip::Optional<uint8_t> & endHour, const chip::Optional<uint8_t> & endMinute)
    {
        VerifyOrReturn(CheckValue("weekDayIndex", weekDayIndex, 1));

        VerifyOrReturn(CheckValue("userIndex", userIndex, 1U));

        VerifyOrReturn(CheckValue("status", status, 139));

        NextTest();
    }

    CHIP_ERROR TestGetWeekDayScheduleWith0Index_20()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::GetWeekDaySchedule::Type;

        RequestType request;
        request.weekDayIndex = 0;
        request.userIndex    = 1U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_SchedulesSuite *>(context))
                ->OnSuccessResponse_20(data.weekDayIndex, data.userIndex, data.status, data.daysMask, data.startHour,
                                       data.startMinute, data.endHour, data.endMinute);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_SchedulesSuite *>(context))->OnFailureResponse_20(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_20(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_20(uint8_t weekDayIndex, uint16_t userIndex, chip::app::Clusters::DoorLock::DlStatus status,
                              const chip::Optional<chip::BitFlags<chip::app::Clusters::DoorLock::DlDaysMaskMap>> & daysMask,
                              const chip::Optional<uint8_t> & startHour, const chip::Optional<uint8_t> & startMinute,
                              const chip::Optional<uint8_t> & endHour, const chip::Optional<uint8_t> & endMinute)
    {
        VerifyOrReturn(CheckValue("weekDayIndex", weekDayIndex, 0));

        VerifyOrReturn(CheckValue("userIndex", userIndex, 1U));

        VerifyOrReturn(CheckValue("status", status, 133));

        NextTest();
    }

    CHIP_ERROR TestGetWeekDayScheduleWithOutOfBoundsIndex_21()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::GetWeekDaySchedule::Type;

        RequestType request;
        request.weekDayIndex = static_cast<uint8_t>(NumberOfWeekDaySchedulesSupportedPerUser + 1);
        request.userIndex    = 1U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_SchedulesSuite *>(context))
                ->OnSuccessResponse_21(data.weekDayIndex, data.userIndex, data.status, data.daysMask, data.startHour,
                                       data.startMinute, data.endHour, data.endMinute);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_SchedulesSuite *>(context))->OnFailureResponse_21(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_21(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_21(uint8_t weekDayIndex, uint16_t userIndex, chip::app::Clusters::DoorLock::DlStatus status,
                              const chip::Optional<chip::BitFlags<chip::app::Clusters::DoorLock::DlDaysMaskMap>> & daysMask,
                              const chip::Optional<uint8_t> & startHour, const chip::Optional<uint8_t> & startMinute,
                              const chip::Optional<uint8_t> & endHour, const chip::Optional<uint8_t> & endMinute)
    {
        VerifyOrReturn(
            CheckValue("weekDayIndex", weekDayIndex, static_cast<uint8_t>(NumberOfWeekDaySchedulesSupportedPerUser + 1)));

        VerifyOrReturn(CheckValue("userIndex", userIndex, 1U));

        VerifyOrReturn(CheckValue("status", status, 133));

        NextTest();
    }

    CHIP_ERROR TestGetWeekDayScheduleWith0UserIndex_22()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::GetWeekDaySchedule::Type;

        RequestType request;
        request.weekDayIndex = 1;
        request.userIndex    = 0U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_SchedulesSuite *>(context))
                ->OnSuccessResponse_22(data.weekDayIndex, data.userIndex, data.status, data.daysMask, data.startHour,
                                       data.startMinute, data.endHour, data.endMinute);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_SchedulesSuite *>(context))->OnFailureResponse_22(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_22(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_22(uint8_t weekDayIndex, uint16_t userIndex, chip::app::Clusters::DoorLock::DlStatus status,
                              const chip::Optional<chip::BitFlags<chip::app::Clusters::DoorLock::DlDaysMaskMap>> & daysMask,
                              const chip::Optional<uint8_t> & startHour, const chip::Optional<uint8_t> & startMinute,
                              const chip::Optional<uint8_t> & endHour, const chip::Optional<uint8_t> & endMinute)
    {
        VerifyOrReturn(CheckValue("weekDayIndex", weekDayIndex, 1));

        VerifyOrReturn(CheckValue("userIndex", userIndex, 0U));

        VerifyOrReturn(CheckValue("status", status, 133));

        NextTest();
    }

    CHIP_ERROR TestGetWeekDayScheduleWithOutOfBoundsUserIndex_23()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::GetWeekDaySchedule::Type;

        RequestType request;
        request.weekDayIndex = 1;
        request.userIndex    = static_cast<uint8_t>(NumberOfTotalUsersSupported + 1);

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_SchedulesSuite *>(context))
                ->OnSuccessResponse_23(data.weekDayIndex, data.userIndex, data.status, data.daysMask, data.startHour,
                                       data.startMinute, data.endHour, data.endMinute);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_SchedulesSuite *>(context))->OnFailureResponse_23(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_23(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_23(uint8_t weekDayIndex, uint16_t userIndex, chip::app::Clusters::DoorLock::DlStatus status,
                              const chip::Optional<chip::BitFlags<chip::app::Clusters::DoorLock::DlDaysMaskMap>> & daysMask,
                              const chip::Optional<uint8_t> & startHour, const chip::Optional<uint8_t> & startMinute,
                              const chip::Optional<uint8_t> & endHour, const chip::Optional<uint8_t> & endMinute)
    {
        VerifyOrReturn(CheckValue("weekDayIndex", weekDayIndex, 1));

        VerifyOrReturn(CheckValue("userIndex", userIndex, static_cast<uint8_t>(NumberOfTotalUsersSupported + 1)));

        VerifyOrReturn(CheckValue("status", status, 133));

        NextTest();
    }

    CHIP_ERROR TestGetWeekDayScheduleWithNonExistingUserIndex_24()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::GetWeekDaySchedule::Type;

        RequestType request;
        request.weekDayIndex = 1;
        request.userIndex    = 2U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_SchedulesSuite *>(context))
                ->OnSuccessResponse_24(data.weekDayIndex, data.userIndex, data.status, data.daysMask, data.startHour,
                                       data.startMinute, data.endHour, data.endMinute);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_SchedulesSuite *>(context))->OnFailureResponse_24(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_24(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_24(uint8_t weekDayIndex, uint16_t userIndex, chip::app::Clusters::DoorLock::DlStatus status,
                              const chip::Optional<chip::BitFlags<chip::app::Clusters::DoorLock::DlDaysMaskMap>> & daysMask,
                              const chip::Optional<uint8_t> & startHour, const chip::Optional<uint8_t> & startMinute,
                              const chip::Optional<uint8_t> & endHour, const chip::Optional<uint8_t> & endMinute)
    {
        VerifyOrReturn(CheckValue("weekDayIndex", weekDayIndex, 1));

        VerifyOrReturn(CheckValue("userIndex", userIndex, 2U));

        VerifyOrReturn(CheckValue("status", status, 139));

        NextTest();
    }

    CHIP_ERROR TestCreateYearDayScheduleWith0Index_25()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::SetYearDaySchedule::Type;

        RequestType request;
        request.yearDayIndex   = 0;
        request.userIndex      = 1U;
        request.localStartTime = 12345UL;
        request.localEndTime   = 12345689UL;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_SchedulesSuite *>(context))->OnSuccessResponse_25();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_SchedulesSuite *>(context))->OnFailureResponse_25(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_25(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_FIELD));
        NextTest();
    }

    void OnSuccessResponse_25() { ThrowSuccessResponse(); }

    CHIP_ERROR TestCreateYearDayScheduleWithOutOfBoundsIndex_26()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::SetYearDaySchedule::Type;

        RequestType request;
        request.yearDayIndex   = static_cast<uint8_t>(NumberOfYearDaySchedulesSupportedPerUser + 1);
        request.userIndex      = 1U;
        request.localStartTime = 12345UL;
        request.localEndTime   = 12345689UL;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_SchedulesSuite *>(context))->OnSuccessResponse_26();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_SchedulesSuite *>(context))->OnFailureResponse_26(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_26(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_FIELD));
        NextTest();
    }

    void OnSuccessResponse_26() { ThrowSuccessResponse(); }

    CHIP_ERROR TestCreateYearDayScheduleWith0UserIndex_27()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::SetYearDaySchedule::Type;

        RequestType request;
        request.yearDayIndex   = 1;
        request.userIndex      = 0U;
        request.localStartTime = 12345UL;
        request.localEndTime   = 12345689UL;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_SchedulesSuite *>(context))->OnSuccessResponse_27();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_SchedulesSuite *>(context))->OnFailureResponse_27(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_27(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_FIELD));
        NextTest();
    }

    void OnSuccessResponse_27() { ThrowSuccessResponse(); }

    CHIP_ERROR TestCreateYearDayScheduleWithOutOfBoundsUserIndex_28()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::SetYearDaySchedule::Type;

        RequestType request;
        request.yearDayIndex   = 1;
        request.userIndex      = static_cast<uint8_t>(NumberOfTotalUsersSupported + 1);
        request.localStartTime = 12345UL;
        request.localEndTime   = 12345689UL;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_SchedulesSuite *>(context))->OnSuccessResponse_28();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_SchedulesSuite *>(context))->OnFailureResponse_28(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_28(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_FIELD));
        NextTest();
    }

    void OnSuccessResponse_28() { ThrowSuccessResponse(); }

    CHIP_ERROR TestCreateYearDayScheduleForNonExistingUser_29()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::SetYearDaySchedule::Type;

        RequestType request;
        request.yearDayIndex   = 1;
        request.userIndex      = 2U;
        request.localStartTime = 12345UL;
        request.localEndTime   = 12345689UL;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_SchedulesSuite *>(context))->OnSuccessResponse_29();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_SchedulesSuite *>(context))->OnFailureResponse_29(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_29(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_NOT_FOUND));
        NextTest();
    }

    void OnSuccessResponse_29() { ThrowSuccessResponse(); }

    CHIP_ERROR TestCreateYearDayScheduleWithStartHourLaterThatEndHour_30()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::SetYearDaySchedule::Type;

        RequestType request;
        request.yearDayIndex   = 1;
        request.userIndex      = 1U;
        request.localStartTime = 12345689UL;
        request.localEndTime   = 12345688UL;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_SchedulesSuite *>(context))->OnSuccessResponse_30();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_SchedulesSuite *>(context))->OnFailureResponse_30(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_30(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_FIELD));
        NextTest();
    }

    void OnSuccessResponse_30() { ThrowSuccessResponse(); }

    CHIP_ERROR TestMakeSureThatPreviousOperationsDidNotCreateASchedule_31()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::GetYearDaySchedule::Type;

        RequestType request;
        request.yearDayIndex = 1;
        request.userIndex    = 1U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_SchedulesSuite *>(context))
                ->OnSuccessResponse_31(data.yearDayIndex, data.userIndex, data.status, data.localStartTime, data.localEndTime);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_SchedulesSuite *>(context))->OnFailureResponse_31(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_31(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_31(uint8_t yearDayIndex, uint16_t userIndex, chip::app::Clusters::DoorLock::DlStatus status,
                              const chip::Optional<uint32_t> & localStartTime, const chip::Optional<uint32_t> & localEndTime)
    {
        VerifyOrReturn(CheckValue("yearDayIndex", yearDayIndex, 1));

        VerifyOrReturn(CheckValue("userIndex", userIndex, 1U));

        VerifyOrReturn(CheckValue("status", status, 139));

        NextTest();
    }

    CHIP_ERROR TestGetYearDayScheduleWith0Index_32()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::GetYearDaySchedule::Type;

        RequestType request;
        request.yearDayIndex = 0;
        request.userIndex    = 1U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_SchedulesSuite *>(context))
                ->OnSuccessResponse_32(data.yearDayIndex, data.userIndex, data.status, data.localStartTime, data.localEndTime);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_SchedulesSuite *>(context))->OnFailureResponse_32(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_32(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_32(uint8_t yearDayIndex, uint16_t userIndex, chip::app::Clusters::DoorLock::DlStatus status,
                              const chip::Optional<uint32_t> & localStartTime, const chip::Optional<uint32_t> & localEndTime)
    {
        VerifyOrReturn(CheckValue("yearDayIndex", yearDayIndex, 0));

        VerifyOrReturn(CheckValue("userIndex", userIndex, 1U));

        VerifyOrReturn(CheckValue("status", status, 133));

        NextTest();
    }

    CHIP_ERROR TestGetYearDayScheduleWithOutOfBoundsIndex_33()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::GetYearDaySchedule::Type;

        RequestType request;
        request.yearDayIndex = static_cast<uint8_t>(NumberOfYearDaySchedulesSupportedPerUser + 1);
        request.userIndex    = 1U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_SchedulesSuite *>(context))
                ->OnSuccessResponse_33(data.yearDayIndex, data.userIndex, data.status, data.localStartTime, data.localEndTime);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_SchedulesSuite *>(context))->OnFailureResponse_33(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_33(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_33(uint8_t yearDayIndex, uint16_t userIndex, chip::app::Clusters::DoorLock::DlStatus status,
                              const chip::Optional<uint32_t> & localStartTime, const chip::Optional<uint32_t> & localEndTime)
    {
        VerifyOrReturn(
            CheckValue("yearDayIndex", yearDayIndex, static_cast<uint8_t>(NumberOfYearDaySchedulesSupportedPerUser + 1)));

        VerifyOrReturn(CheckValue("userIndex", userIndex, 1U));

        VerifyOrReturn(CheckValue("status", status, 133));

        NextTest();
    }

    CHIP_ERROR TestGetYearDayScheduleWith0UserIndex_34()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::GetYearDaySchedule::Type;

        RequestType request;
        request.yearDayIndex = 1;
        request.userIndex    = 0U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_SchedulesSuite *>(context))
                ->OnSuccessResponse_34(data.yearDayIndex, data.userIndex, data.status, data.localStartTime, data.localEndTime);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_SchedulesSuite *>(context))->OnFailureResponse_34(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_34(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_34(uint8_t yearDayIndex, uint16_t userIndex, chip::app::Clusters::DoorLock::DlStatus status,
                              const chip::Optional<uint32_t> & localStartTime, const chip::Optional<uint32_t> & localEndTime)
    {
        VerifyOrReturn(CheckValue("yearDayIndex", yearDayIndex, 1));

        VerifyOrReturn(CheckValue("userIndex", userIndex, 0U));

        VerifyOrReturn(CheckValue("status", status, 133));

        NextTest();
    }

    CHIP_ERROR TestGetYearDayScheduleWithOutOfBoundsUserIndex_35()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::GetYearDaySchedule::Type;

        RequestType request;
        request.yearDayIndex = 1;
        request.userIndex    = static_cast<uint8_t>(NumberOfTotalUsersSupported + 1);

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_SchedulesSuite *>(context))
                ->OnSuccessResponse_35(data.yearDayIndex, data.userIndex, data.status, data.localStartTime, data.localEndTime);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_SchedulesSuite *>(context))->OnFailureResponse_35(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_35(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_35(uint8_t yearDayIndex, uint16_t userIndex, chip::app::Clusters::DoorLock::DlStatus status,
                              const chip::Optional<uint32_t> & localStartTime, const chip::Optional<uint32_t> & localEndTime)
    {
        VerifyOrReturn(CheckValue("yearDayIndex", yearDayIndex, 1));

        VerifyOrReturn(CheckValue("userIndex", userIndex, static_cast<uint8_t>(NumberOfTotalUsersSupported + 1)));

        VerifyOrReturn(CheckValue("status", status, 133));

        NextTest();
    }

    CHIP_ERROR TestGetYearDayScheduleWithNonExistingUserIndex_36()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::GetYearDaySchedule::Type;

        RequestType request;
        request.yearDayIndex = 1;
        request.userIndex    = 2U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_SchedulesSuite *>(context))
                ->OnSuccessResponse_36(data.yearDayIndex, data.userIndex, data.status, data.localStartTime, data.localEndTime);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_SchedulesSuite *>(context))->OnFailureResponse_36(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_36(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_36(uint8_t yearDayIndex, uint16_t userIndex, chip::app::Clusters::DoorLock::DlStatus status,
                              const chip::Optional<uint32_t> & localStartTime, const chip::Optional<uint32_t> & localEndTime)
    {
        VerifyOrReturn(CheckValue("yearDayIndex", yearDayIndex, 1));

        VerifyOrReturn(CheckValue("userIndex", userIndex, 2U));

        VerifyOrReturn(CheckValue("status", status, 139));

        NextTest();
    }

    CHIP_ERROR TestCreateWeekDayScheduleWithValidParameters_37()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::SetWeekDaySchedule::Type;

        RequestType request;
        request.weekDayIndex = 1;
        request.userIndex    = 1U;
        request.daysMask     = static_cast<chip::BitFlags<chip::app::Clusters::DoorLock::DlDaysMaskMap>>(1);
        request.startHour    = 15;
        request.startMinute  = 16;
        request.endHour      = 18;
        request.endMinute    = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_SchedulesSuite *>(context))->OnSuccessResponse_37();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_SchedulesSuite *>(context))->OnFailureResponse_37(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_37(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_37() { NextTest(); }

    CHIP_ERROR TestVerifyCreatedSchedule_38()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::GetWeekDaySchedule::Type;

        RequestType request;
        request.weekDayIndex = 1;
        request.userIndex    = 1U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_SchedulesSuite *>(context))
                ->OnSuccessResponse_38(data.weekDayIndex, data.userIndex, data.status, data.daysMask, data.startHour,
                                       data.startMinute, data.endHour, data.endMinute);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_SchedulesSuite *>(context))->OnFailureResponse_38(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_38(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_38(uint8_t weekDayIndex, uint16_t userIndex, chip::app::Clusters::DoorLock::DlStatus status,
                              const chip::Optional<chip::BitFlags<chip::app::Clusters::DoorLock::DlDaysMaskMap>> & daysMask,
                              const chip::Optional<uint8_t> & startHour, const chip::Optional<uint8_t> & startMinute,
                              const chip::Optional<uint8_t> & endHour, const chip::Optional<uint8_t> & endMinute)
    {
        VerifyOrReturn(CheckValue("weekDayIndex", weekDayIndex, 1));

        VerifyOrReturn(CheckValue("userIndex", userIndex, 1U));

        VerifyOrReturn(CheckValue("status", status, 0));

        VerifyOrReturn(CheckValuePresent("daysMask", daysMask));
        VerifyOrReturn(CheckValue("daysMask.Value()", daysMask.Value(), 1));

        VerifyOrReturn(CheckValuePresent("startHour", startHour));
        VerifyOrReturn(CheckValue("startHour.Value()", startHour.Value(), 15));

        VerifyOrReturn(CheckValuePresent("startMinute", startMinute));
        VerifyOrReturn(CheckValue("startMinute.Value()", startMinute.Value(), 16));

        VerifyOrReturn(CheckValuePresent("endHour", endHour));
        VerifyOrReturn(CheckValue("endHour.Value()", endHour.Value(), 18));

        VerifyOrReturn(CheckValuePresent("endMinute", endMinute));
        VerifyOrReturn(CheckValue("endMinute.Value()", endMinute.Value(), 0));

        NextTest();
    }

    CHIP_ERROR TestCreateYearDayScheduleWithValidParameters_39()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::SetYearDaySchedule::Type;

        RequestType request;
        request.yearDayIndex   = 1;
        request.userIndex      = 1U;
        request.localStartTime = 12345UL;
        request.localEndTime   = 12345689UL;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_SchedulesSuite *>(context))->OnSuccessResponse_39();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_SchedulesSuite *>(context))->OnFailureResponse_39(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_39(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_39() { NextTest(); }

    CHIP_ERROR TestVerifyCreatedSchedule_40()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::GetYearDaySchedule::Type;

        RequestType request;
        request.yearDayIndex = 1;
        request.userIndex    = 1U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_SchedulesSuite *>(context))
                ->OnSuccessResponse_40(data.yearDayIndex, data.userIndex, data.status, data.localStartTime, data.localEndTime);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_SchedulesSuite *>(context))->OnFailureResponse_40(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_40(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_40(uint8_t yearDayIndex, uint16_t userIndex, chip::app::Clusters::DoorLock::DlStatus status,
                              const chip::Optional<uint32_t> & localStartTime, const chip::Optional<uint32_t> & localEndTime)
    {
        VerifyOrReturn(CheckValue("yearDayIndex", yearDayIndex, 1));

        VerifyOrReturn(CheckValue("userIndex", userIndex, 1U));

        VerifyOrReturn(CheckValue("status", status, 0));

        VerifyOrReturn(CheckValuePresent("localStartTime", localStartTime));
        VerifyOrReturn(CheckValue("localStartTime.Value()", localStartTime.Value(), 12345UL));

        VerifyOrReturn(CheckValuePresent("localEndTime", localEndTime));
        VerifyOrReturn(CheckValue("localEndTime.Value()", localEndTime.Value(), 12345689UL));

        NextTest();
    }

    CHIP_ERROR TestClearWeekDayScheduleWith0Index_41()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::ClearWeekDaySchedule::Type;

        RequestType request;
        request.weekDayIndex = 0;
        request.userIndex    = 1U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_SchedulesSuite *>(context))->OnSuccessResponse_41();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_SchedulesSuite *>(context))->OnFailureResponse_41(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_41(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_FIELD));
        NextTest();
    }

    void OnSuccessResponse_41() { ThrowSuccessResponse(); }

    CHIP_ERROR TestClearWeekDayScheduleWithOutOfBoundsIndex_42()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::ClearWeekDaySchedule::Type;

        RequestType request;
        request.weekDayIndex = static_cast<uint8_t>(NumberOfWeekDaySchedulesSupportedPerUser + 1);
        request.userIndex    = 1U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_SchedulesSuite *>(context))->OnSuccessResponse_42();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_SchedulesSuite *>(context))->OnFailureResponse_42(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_42(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_FIELD));
        NextTest();
    }

    void OnSuccessResponse_42() { ThrowSuccessResponse(); }

    CHIP_ERROR TestClearWeekDayScheduleWith0UserIndex_43()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::ClearWeekDaySchedule::Type;

        RequestType request;
        request.weekDayIndex = 1;
        request.userIndex    = 0U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_SchedulesSuite *>(context))->OnSuccessResponse_43();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_SchedulesSuite *>(context))->OnFailureResponse_43(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_43(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_FIELD));
        NextTest();
    }

    void OnSuccessResponse_43() { ThrowSuccessResponse(); }

    CHIP_ERROR TestClearWeekDayScheduleWithOutOfBoundsUserIndex_44()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::ClearWeekDaySchedule::Type;

        RequestType request;
        request.weekDayIndex = 1;
        request.userIndex    = static_cast<uint8_t>(NumberOfTotalUsersSupported + 1);

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_SchedulesSuite *>(context))->OnSuccessResponse_44();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_SchedulesSuite *>(context))->OnFailureResponse_44(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_44(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_FIELD));
        NextTest();
    }

    void OnSuccessResponse_44() { ThrowSuccessResponse(); }

    CHIP_ERROR TestClearWeekDayScheduleWithNonExistingUser_45()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::ClearWeekDaySchedule::Type;

        RequestType request;
        request.weekDayIndex = 1;
        request.userIndex    = 2U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_SchedulesSuite *>(context))->OnSuccessResponse_45();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_SchedulesSuite *>(context))->OnFailureResponse_45(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_45(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_NOT_FOUND));
        NextTest();
    }

    void OnSuccessResponse_45() { ThrowSuccessResponse(); }

    CHIP_ERROR TestClearYearDayScheduleWith0Index_46()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::ClearYearDaySchedule::Type;

        RequestType request;
        request.yearDayIndex = 0;
        request.userIndex    = 1U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_SchedulesSuite *>(context))->OnSuccessResponse_46();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_SchedulesSuite *>(context))->OnFailureResponse_46(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_46(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_FIELD));
        NextTest();
    }

    void OnSuccessResponse_46() { ThrowSuccessResponse(); }

    CHIP_ERROR TestClearYearDayScheduleWithOutOfBoundsIndex_47()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::ClearYearDaySchedule::Type;

        RequestType request;
        request.yearDayIndex = static_cast<uint8_t>(NumberOfYearDaySchedulesSupportedPerUser + 1);
        request.userIndex    = 1U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_SchedulesSuite *>(context))->OnSuccessResponse_47();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_SchedulesSuite *>(context))->OnFailureResponse_47(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_47(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_FIELD));
        NextTest();
    }

    void OnSuccessResponse_47() { ThrowSuccessResponse(); }

    CHIP_ERROR TestClearYearDayScheduleWith0UserIndex_48()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::ClearYearDaySchedule::Type;

        RequestType request;
        request.yearDayIndex = 1;
        request.userIndex    = 0U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_SchedulesSuite *>(context))->OnSuccessResponse_48();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_SchedulesSuite *>(context))->OnFailureResponse_48(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_48(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_FIELD));
        NextTest();
    }

    void OnSuccessResponse_48() { ThrowSuccessResponse(); }

    CHIP_ERROR TestClearYearDayScheduleWithOutOfBoundsUserIndex_49()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::ClearYearDaySchedule::Type;

        RequestType request;
        request.yearDayIndex = 1;
        request.userIndex    = static_cast<uint8_t>(NumberOfTotalUsersSupported + 1);

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_SchedulesSuite *>(context))->OnSuccessResponse_49();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_SchedulesSuite *>(context))->OnFailureResponse_49(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_49(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_FIELD));
        NextTest();
    }

    void OnSuccessResponse_49() { ThrowSuccessResponse(); }

    CHIP_ERROR TestClearYearDayScheduleWithNonExistingUser_50()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::ClearYearDaySchedule::Type;

        RequestType request;
        request.yearDayIndex = 1;
        request.userIndex    = 2U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_SchedulesSuite *>(context))->OnSuccessResponse_50();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_SchedulesSuite *>(context))->OnFailureResponse_50(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_50(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_NOT_FOUND));
        NextTest();
    }

    void OnSuccessResponse_50() { ThrowSuccessResponse(); }

    CHIP_ERROR TestMakeSureThatWeekDayScheduleWasNotDeleted_51()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::GetWeekDaySchedule::Type;

        RequestType request;
        request.weekDayIndex = 1;
        request.userIndex    = 1U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_SchedulesSuite *>(context))
                ->OnSuccessResponse_51(data.weekDayIndex, data.userIndex, data.status, data.daysMask, data.startHour,
                                       data.startMinute, data.endHour, data.endMinute);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_SchedulesSuite *>(context))->OnFailureResponse_51(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_51(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_51(uint8_t weekDayIndex, uint16_t userIndex, chip::app::Clusters::DoorLock::DlStatus status,
                              const chip::Optional<chip::BitFlags<chip::app::Clusters::DoorLock::DlDaysMaskMap>> & daysMask,
                              const chip::Optional<uint8_t> & startHour, const chip::Optional<uint8_t> & startMinute,
                              const chip::Optional<uint8_t> & endHour, const chip::Optional<uint8_t> & endMinute)
    {
        VerifyOrReturn(CheckValue("weekDayIndex", weekDayIndex, 1));

        VerifyOrReturn(CheckValue("userIndex", userIndex, 1U));

        VerifyOrReturn(CheckValue("status", status, 0));

        VerifyOrReturn(CheckValuePresent("daysMask", daysMask));
        VerifyOrReturn(CheckValue("daysMask.Value()", daysMask.Value(), 1));

        VerifyOrReturn(CheckValuePresent("startHour", startHour));
        VerifyOrReturn(CheckValue("startHour.Value()", startHour.Value(), 15));

        VerifyOrReturn(CheckValuePresent("startMinute", startMinute));
        VerifyOrReturn(CheckValue("startMinute.Value()", startMinute.Value(), 16));

        VerifyOrReturn(CheckValuePresent("endHour", endHour));
        VerifyOrReturn(CheckValue("endHour.Value()", endHour.Value(), 18));

        VerifyOrReturn(CheckValuePresent("endMinute", endMinute));
        VerifyOrReturn(CheckValue("endMinute.Value()", endMinute.Value(), 0));

        NextTest();
    }

    CHIP_ERROR TestMakeSureThatYearDayScheduleWasNotDeleted_52()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::GetYearDaySchedule::Type;

        RequestType request;
        request.yearDayIndex = 1;
        request.userIndex    = 1U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_SchedulesSuite *>(context))
                ->OnSuccessResponse_52(data.yearDayIndex, data.userIndex, data.status, data.localStartTime, data.localEndTime);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_SchedulesSuite *>(context))->OnFailureResponse_52(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_52(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_52(uint8_t yearDayIndex, uint16_t userIndex, chip::app::Clusters::DoorLock::DlStatus status,
                              const chip::Optional<uint32_t> & localStartTime, const chip::Optional<uint32_t> & localEndTime)
    {
        VerifyOrReturn(CheckValue("yearDayIndex", yearDayIndex, 1));

        VerifyOrReturn(CheckValue("userIndex", userIndex, 1U));

        VerifyOrReturn(CheckValue("status", status, 0));

        VerifyOrReturn(CheckValuePresent("localStartTime", localStartTime));
        VerifyOrReturn(CheckValue("localStartTime.Value()", localStartTime.Value(), 12345UL));

        VerifyOrReturn(CheckValuePresent("localEndTime", localEndTime));
        VerifyOrReturn(CheckValue("localEndTime.Value()", localEndTime.Value(), 12345689UL));

        NextTest();
    }

    CHIP_ERROR TestCreateAnotherWeekDayScheduleWithValidParameters_53()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::SetWeekDaySchedule::Type;

        RequestType request;
        request.weekDayIndex = 2;
        request.userIndex    = 1U;
        request.daysMask     = static_cast<chip::BitFlags<chip::app::Clusters::DoorLock::DlDaysMaskMap>>(2);
        request.startHour    = 0;
        request.startMinute  = 0;
        request.endHour      = 23;
        request.endMinute    = 59;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_SchedulesSuite *>(context))->OnSuccessResponse_53();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_SchedulesSuite *>(context))->OnFailureResponse_53(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_53(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_53() { NextTest(); }

    CHIP_ERROR TestVerifyCreatedWeekDaySchedule_54()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::GetWeekDaySchedule::Type;

        RequestType request;
        request.weekDayIndex = 2;
        request.userIndex    = 1U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_SchedulesSuite *>(context))
                ->OnSuccessResponse_54(data.weekDayIndex, data.userIndex, data.status, data.daysMask, data.startHour,
                                       data.startMinute, data.endHour, data.endMinute);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_SchedulesSuite *>(context))->OnFailureResponse_54(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_54(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_54(uint8_t weekDayIndex, uint16_t userIndex, chip::app::Clusters::DoorLock::DlStatus status,
                              const chip::Optional<chip::BitFlags<chip::app::Clusters::DoorLock::DlDaysMaskMap>> & daysMask,
                              const chip::Optional<uint8_t> & startHour, const chip::Optional<uint8_t> & startMinute,
                              const chip::Optional<uint8_t> & endHour, const chip::Optional<uint8_t> & endMinute)
    {
        VerifyOrReturn(CheckValue("weekDayIndex", weekDayIndex, 2));

        VerifyOrReturn(CheckValue("userIndex", userIndex, 1U));

        VerifyOrReturn(CheckValue("status", status, 0));

        VerifyOrReturn(CheckValuePresent("daysMask", daysMask));
        VerifyOrReturn(CheckValue("daysMask.Value()", daysMask.Value(), 2));

        VerifyOrReturn(CheckValuePresent("startHour", startHour));
        VerifyOrReturn(CheckValue("startHour.Value()", startHour.Value(), 0));

        VerifyOrReturn(CheckValuePresent("startMinute", startMinute));
        VerifyOrReturn(CheckValue("startMinute.Value()", startMinute.Value(), 0));

        VerifyOrReturn(CheckValuePresent("endHour", endHour));
        VerifyOrReturn(CheckValue("endHour.Value()", endHour.Value(), 23));

        VerifyOrReturn(CheckValuePresent("endMinute", endMinute));
        VerifyOrReturn(CheckValue("endMinute.Value()", endMinute.Value(), 59));

        NextTest();
    }

    CHIP_ERROR TestCreateAnotherYearDayScheduleWithValidParameters_55()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::SetYearDaySchedule::Type;

        RequestType request;
        request.yearDayIndex   = 2;
        request.userIndex      = 1U;
        request.localStartTime = 9000UL;
        request.localEndTime   = 888888888UL;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_SchedulesSuite *>(context))->OnSuccessResponse_55();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_SchedulesSuite *>(context))->OnFailureResponse_55(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_55(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_55() { NextTest(); }

    CHIP_ERROR TestVerifyCreatedYearDaySchedule_56()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::GetYearDaySchedule::Type;

        RequestType request;
        request.yearDayIndex = 2;
        request.userIndex    = 1U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_SchedulesSuite *>(context))
                ->OnSuccessResponse_56(data.yearDayIndex, data.userIndex, data.status, data.localStartTime, data.localEndTime);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_SchedulesSuite *>(context))->OnFailureResponse_56(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_56(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_56(uint8_t yearDayIndex, uint16_t userIndex, chip::app::Clusters::DoorLock::DlStatus status,
                              const chip::Optional<uint32_t> & localStartTime, const chip::Optional<uint32_t> & localEndTime)
    {
        VerifyOrReturn(CheckValue("yearDayIndex", yearDayIndex, 2));

        VerifyOrReturn(CheckValue("userIndex", userIndex, 1U));

        VerifyOrReturn(CheckValue("status", status, 0));

        VerifyOrReturn(CheckValuePresent("localStartTime", localStartTime));
        VerifyOrReturn(CheckValue("localStartTime.Value()", localStartTime.Value(), 9000UL));

        VerifyOrReturn(CheckValuePresent("localEndTime", localEndTime));
        VerifyOrReturn(CheckValue("localEndTime.Value()", localEndTime.Value(), 888888888UL));

        NextTest();
    }

    CHIP_ERROR TestClearASingleWeekDayScheduleForTheFirstUser_57()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::ClearWeekDaySchedule::Type;

        RequestType request;
        request.weekDayIndex = 1;
        request.userIndex    = 1U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_SchedulesSuite *>(context))->OnSuccessResponse_57();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_SchedulesSuite *>(context))->OnFailureResponse_57(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_57(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_57() { NextTest(); }

    CHIP_ERROR TestVerifyClearedWeekDaySchedule_58()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::GetWeekDaySchedule::Type;

        RequestType request;
        request.weekDayIndex = 1;
        request.userIndex    = 1U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_SchedulesSuite *>(context))
                ->OnSuccessResponse_58(data.weekDayIndex, data.userIndex, data.status, data.daysMask, data.startHour,
                                       data.startMinute, data.endHour, data.endMinute);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_SchedulesSuite *>(context))->OnFailureResponse_58(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_58(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_58(uint8_t weekDayIndex, uint16_t userIndex, chip::app::Clusters::DoorLock::DlStatus status,
                              const chip::Optional<chip::BitFlags<chip::app::Clusters::DoorLock::DlDaysMaskMap>> & daysMask,
                              const chip::Optional<uint8_t> & startHour, const chip::Optional<uint8_t> & startMinute,
                              const chip::Optional<uint8_t> & endHour, const chip::Optional<uint8_t> & endMinute)
    {
        VerifyOrReturn(CheckValue("weekDayIndex", weekDayIndex, 1));

        VerifyOrReturn(CheckValue("userIndex", userIndex, 1U));

        VerifyOrReturn(CheckValue("status", status, 139));

        NextTest();
    }

    CHIP_ERROR TestClearAllRemainingWeekDaySchedulesForTheFirstUser_59()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::ClearWeekDaySchedule::Type;

        RequestType request;
        request.weekDayIndex = 254;
        request.userIndex    = 1U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_SchedulesSuite *>(context))->OnSuccessResponse_59();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_SchedulesSuite *>(context))->OnFailureResponse_59(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_59(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_59() { NextTest(); }

    CHIP_ERROR TestVerifyClearedWeekSchedule_60()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::GetWeekDaySchedule::Type;

        RequestType request;
        request.weekDayIndex = 2;
        request.userIndex    = 1U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_SchedulesSuite *>(context))
                ->OnSuccessResponse_60(data.weekDayIndex, data.userIndex, data.status, data.daysMask, data.startHour,
                                       data.startMinute, data.endHour, data.endMinute);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_SchedulesSuite *>(context))->OnFailureResponse_60(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_60(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_60(uint8_t weekDayIndex, uint16_t userIndex, chip::app::Clusters::DoorLock::DlStatus status,
                              const chip::Optional<chip::BitFlags<chip::app::Clusters::DoorLock::DlDaysMaskMap>> & daysMask,
                              const chip::Optional<uint8_t> & startHour, const chip::Optional<uint8_t> & startMinute,
                              const chip::Optional<uint8_t> & endHour, const chip::Optional<uint8_t> & endMinute)
    {
        VerifyOrReturn(CheckValue("weekDayIndex", weekDayIndex, 2));

        VerifyOrReturn(CheckValue("userIndex", userIndex, 1U));

        VerifyOrReturn(CheckValue("status", status, 139));

        NextTest();
    }

    CHIP_ERROR TestMakeSureThatFirstYearDayScheduleWasNotDeleted_61()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::GetYearDaySchedule::Type;

        RequestType request;
        request.yearDayIndex = 1;
        request.userIndex    = 1U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_SchedulesSuite *>(context))
                ->OnSuccessResponse_61(data.yearDayIndex, data.userIndex, data.status, data.localStartTime, data.localEndTime);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_SchedulesSuite *>(context))->OnFailureResponse_61(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_61(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_61(uint8_t yearDayIndex, uint16_t userIndex, chip::app::Clusters::DoorLock::DlStatus status,
                              const chip::Optional<uint32_t> & localStartTime, const chip::Optional<uint32_t> & localEndTime)
    {
        VerifyOrReturn(CheckValue("yearDayIndex", yearDayIndex, 1));

        VerifyOrReturn(CheckValue("userIndex", userIndex, 1U));

        VerifyOrReturn(CheckValue("status", status, 0));

        VerifyOrReturn(CheckValuePresent("localStartTime", localStartTime));
        VerifyOrReturn(CheckValue("localStartTime.Value()", localStartTime.Value(), 12345UL));

        VerifyOrReturn(CheckValuePresent("localEndTime", localEndTime));
        VerifyOrReturn(CheckValue("localEndTime.Value()", localEndTime.Value(), 12345689UL));

        NextTest();
    }

    CHIP_ERROR TestMakeSureThatSecondYearDayScheduleWasNotDeleted_62()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::GetYearDaySchedule::Type;

        RequestType request;
        request.yearDayIndex = 2;
        request.userIndex    = 1U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_SchedulesSuite *>(context))
                ->OnSuccessResponse_62(data.yearDayIndex, data.userIndex, data.status, data.localStartTime, data.localEndTime);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_SchedulesSuite *>(context))->OnFailureResponse_62(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_62(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_62(uint8_t yearDayIndex, uint16_t userIndex, chip::app::Clusters::DoorLock::DlStatus status,
                              const chip::Optional<uint32_t> & localStartTime, const chip::Optional<uint32_t> & localEndTime)
    {
        VerifyOrReturn(CheckValue("yearDayIndex", yearDayIndex, 2));

        VerifyOrReturn(CheckValue("userIndex", userIndex, 1U));

        VerifyOrReturn(CheckValue("status", status, 0));

        VerifyOrReturn(CheckValuePresent("localStartTime", localStartTime));
        VerifyOrReturn(CheckValue("localStartTime.Value()", localStartTime.Value(), 9000UL));

        VerifyOrReturn(CheckValuePresent("localEndTime", localEndTime));
        VerifyOrReturn(CheckValue("localEndTime.Value()", localEndTime.Value(), 888888888UL));

        NextTest();
    }

    CHIP_ERROR TestCreateAnotherWeekDayScheduleWithValidParameters_63()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::SetWeekDaySchedule::Type;

        RequestType request;
        request.weekDayIndex = 1;
        request.userIndex    = 1U;
        request.daysMask     = static_cast<chip::BitFlags<chip::app::Clusters::DoorLock::DlDaysMaskMap>>(2);
        request.startHour    = 0;
        request.startMinute  = 0;
        request.endHour      = 23;
        request.endMinute    = 59;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_SchedulesSuite *>(context))->OnSuccessResponse_63();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_SchedulesSuite *>(context))->OnFailureResponse_63(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_63(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_63() { NextTest(); }

    CHIP_ERROR TestClearASingleYearDayScheduleForTheFirstUser_64()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::ClearYearDaySchedule::Type;

        RequestType request;
        request.yearDayIndex = 1;
        request.userIndex    = 1U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_SchedulesSuite *>(context))->OnSuccessResponse_64();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_SchedulesSuite *>(context))->OnFailureResponse_64(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_64(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_64() { NextTest(); }

    CHIP_ERROR TestVerifyClearedYearDaySchedule_65()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::GetYearDaySchedule::Type;

        RequestType request;
        request.yearDayIndex = 1;
        request.userIndex    = 1U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_SchedulesSuite *>(context))
                ->OnSuccessResponse_65(data.yearDayIndex, data.userIndex, data.status, data.localStartTime, data.localEndTime);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_SchedulesSuite *>(context))->OnFailureResponse_65(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_65(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_65(uint8_t yearDayIndex, uint16_t userIndex, chip::app::Clusters::DoorLock::DlStatus status,
                              const chip::Optional<uint32_t> & localStartTime, const chip::Optional<uint32_t> & localEndTime)
    {
        VerifyOrReturn(CheckValue("yearDayIndex", yearDayIndex, 1));

        VerifyOrReturn(CheckValue("userIndex", userIndex, 1U));

        VerifyOrReturn(CheckValue("status", status, 139));

        NextTest();
    }

    CHIP_ERROR TestClearAllRemainingYearSchedulesForTheFirstUser_66()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::ClearYearDaySchedule::Type;

        RequestType request;
        request.yearDayIndex = 254;
        request.userIndex    = 1U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_SchedulesSuite *>(context))->OnSuccessResponse_66();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_SchedulesSuite *>(context))->OnFailureResponse_66(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_66(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_66() { NextTest(); }

    CHIP_ERROR TestVerifyThatSecondYearDayScheduleWasCleared_67()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::GetYearDaySchedule::Type;

        RequestType request;
        request.yearDayIndex = 2;
        request.userIndex    = 1U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_SchedulesSuite *>(context))
                ->OnSuccessResponse_67(data.yearDayIndex, data.userIndex, data.status, data.localStartTime, data.localEndTime);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_SchedulesSuite *>(context))->OnFailureResponse_67(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_67(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_67(uint8_t yearDayIndex, uint16_t userIndex, chip::app::Clusters::DoorLock::DlStatus status,
                              const chip::Optional<uint32_t> & localStartTime, const chip::Optional<uint32_t> & localEndTime)
    {
        VerifyOrReturn(CheckValue("yearDayIndex", yearDayIndex, 2));

        VerifyOrReturn(CheckValue("userIndex", userIndex, 1U));

        VerifyOrReturn(CheckValue("status", status, 139));

        NextTest();
    }

    CHIP_ERROR TestVerifyCreatedWeekDaySchedule_68()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::GetWeekDaySchedule::Type;

        RequestType request;
        request.weekDayIndex = 1;
        request.userIndex    = 1U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_SchedulesSuite *>(context))
                ->OnSuccessResponse_68(data.weekDayIndex, data.userIndex, data.status, data.daysMask, data.startHour,
                                       data.startMinute, data.endHour, data.endMinute);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_SchedulesSuite *>(context))->OnFailureResponse_68(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_68(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_68(uint8_t weekDayIndex, uint16_t userIndex, chip::app::Clusters::DoorLock::DlStatus status,
                              const chip::Optional<chip::BitFlags<chip::app::Clusters::DoorLock::DlDaysMaskMap>> & daysMask,
                              const chip::Optional<uint8_t> & startHour, const chip::Optional<uint8_t> & startMinute,
                              const chip::Optional<uint8_t> & endHour, const chip::Optional<uint8_t> & endMinute)
    {
        VerifyOrReturn(CheckValue("weekDayIndex", weekDayIndex, 1));

        VerifyOrReturn(CheckValue("userIndex", userIndex, 1U));

        VerifyOrReturn(CheckValue("status", status, 0));

        VerifyOrReturn(CheckValuePresent("daysMask", daysMask));
        VerifyOrReturn(CheckValue("daysMask.Value()", daysMask.Value(), 2));

        VerifyOrReturn(CheckValuePresent("startHour", startHour));
        VerifyOrReturn(CheckValue("startHour.Value()", startHour.Value(), 0));

        VerifyOrReturn(CheckValuePresent("startMinute", startMinute));
        VerifyOrReturn(CheckValue("startMinute.Value()", startMinute.Value(), 0));

        VerifyOrReturn(CheckValuePresent("endHour", endHour));
        VerifyOrReturn(CheckValue("endHour.Value()", endHour.Value(), 23));

        VerifyOrReturn(CheckValuePresent("endMinute", endMinute));
        VerifyOrReturn(CheckValue("endMinute.Value()", endMinute.Value(), 59));

        NextTest();
    }

    CHIP_ERROR TestClearAllRemainingWeekDaySchedulesForTheFirstUser_69()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::ClearWeekDaySchedule::Type;

        RequestType request;
        request.weekDayIndex = 254;
        request.userIndex    = 1U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_SchedulesSuite *>(context))->OnSuccessResponse_69();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_SchedulesSuite *>(context))->OnFailureResponse_69(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_69(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_69() { NextTest(); }

    CHIP_ERROR TestCreateNewUserWithoutCredentialSoWeCanAddMoreSchedulesToIt_70()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::SetUser::Type;

        RequestType request;
        request.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);
        request.userIndex     = 2U;
        request.userName.SetNull();
        request.userUniqueId.SetNull();
        request.userStatus.SetNull();
        request.userType.SetNull();
        request.credentialRule.SetNull();

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_SchedulesSuite *>(context))->OnSuccessResponse_70();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_SchedulesSuite *>(context))->OnFailureResponse_70(error);
        };

        ReturnErrorOnFailure(
            chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request, 10000));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_70(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_70() { NextTest(); }

    CHIP_ERROR TestCreateWeekDayScheduleWithValidParametersForFirstUser_71()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::SetWeekDaySchedule::Type;

        RequestType request;
        request.weekDayIndex = 1;
        request.userIndex    = 1U;
        request.daysMask     = static_cast<chip::BitFlags<chip::app::Clusters::DoorLock::DlDaysMaskMap>>(1);
        request.startHour    = 0;
        request.startMinute  = 0;
        request.endHour      = 23;
        request.endMinute    = 59;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_SchedulesSuite *>(context))->OnSuccessResponse_71();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_SchedulesSuite *>(context))->OnFailureResponse_71(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_71(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_71() { NextTest(); }

    CHIP_ERROR TestVerifyCreatedWeekDayScheduleForFirstUser_72()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::GetWeekDaySchedule::Type;

        RequestType request;
        request.weekDayIndex = 1;
        request.userIndex    = 1U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_SchedulesSuite *>(context))
                ->OnSuccessResponse_72(data.weekDayIndex, data.userIndex, data.status, data.daysMask, data.startHour,
                                       data.startMinute, data.endHour, data.endMinute);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_SchedulesSuite *>(context))->OnFailureResponse_72(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_72(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_72(uint8_t weekDayIndex, uint16_t userIndex, chip::app::Clusters::DoorLock::DlStatus status,
                              const chip::Optional<chip::BitFlags<chip::app::Clusters::DoorLock::DlDaysMaskMap>> & daysMask,
                              const chip::Optional<uint8_t> & startHour, const chip::Optional<uint8_t> & startMinute,
                              const chip::Optional<uint8_t> & endHour, const chip::Optional<uint8_t> & endMinute)
    {
        VerifyOrReturn(CheckValue("weekDayIndex", weekDayIndex, 1));

        VerifyOrReturn(CheckValue("userIndex", userIndex, 1U));

        VerifyOrReturn(CheckValue("status", status, 0));

        VerifyOrReturn(CheckValuePresent("daysMask", daysMask));
        VerifyOrReturn(CheckValue("daysMask.Value()", daysMask.Value(), 1));

        VerifyOrReturn(CheckValuePresent("startHour", startHour));
        VerifyOrReturn(CheckValue("startHour.Value()", startHour.Value(), 0));

        VerifyOrReturn(CheckValuePresent("startMinute", startMinute));
        VerifyOrReturn(CheckValue("startMinute.Value()", startMinute.Value(), 0));

        VerifyOrReturn(CheckValuePresent("endHour", endHour));
        VerifyOrReturn(CheckValue("endHour.Value()", endHour.Value(), 23));

        VerifyOrReturn(CheckValuePresent("endMinute", endMinute));
        VerifyOrReturn(CheckValue("endMinute.Value()", endMinute.Value(), 59));

        NextTest();
    }

    CHIP_ERROR TestCreateYearDayScheduleForFirstUser_73()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::SetYearDaySchedule::Type;

        RequestType request;
        request.yearDayIndex   = 4;
        request.userIndex      = 1U;
        request.localStartTime = 9000UL;
        request.localEndTime   = 888888888UL;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_SchedulesSuite *>(context))->OnSuccessResponse_73();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_SchedulesSuite *>(context))->OnFailureResponse_73(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_73(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_73() { NextTest(); }

    CHIP_ERROR TestVerifyCreatedYearDayScheduleForFirst_74()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::GetYearDaySchedule::Type;

        RequestType request;
        request.yearDayIndex = 4;
        request.userIndex    = 1U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_SchedulesSuite *>(context))
                ->OnSuccessResponse_74(data.yearDayIndex, data.userIndex, data.status, data.localStartTime, data.localEndTime);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_SchedulesSuite *>(context))->OnFailureResponse_74(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_74(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_74(uint8_t yearDayIndex, uint16_t userIndex, chip::app::Clusters::DoorLock::DlStatus status,
                              const chip::Optional<uint32_t> & localStartTime, const chip::Optional<uint32_t> & localEndTime)
    {
        VerifyOrReturn(CheckValue("yearDayIndex", yearDayIndex, 4));

        VerifyOrReturn(CheckValue("userIndex", userIndex, 1U));

        VerifyOrReturn(CheckValue("status", status, 0));

        VerifyOrReturn(CheckValuePresent("localStartTime", localStartTime));
        VerifyOrReturn(CheckValue("localStartTime.Value()", localStartTime.Value(), 9000UL));

        VerifyOrReturn(CheckValuePresent("localEndTime", localEndTime));
        VerifyOrReturn(CheckValue("localEndTime.Value()", localEndTime.Value(), 888888888UL));

        NextTest();
    }

    CHIP_ERROR TestCreateWeekDayScheduleWithValidParametersForSecondUser_75()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::SetWeekDaySchedule::Type;

        RequestType request;
        request.weekDayIndex = 4;
        request.userIndex    = 2U;
        request.daysMask     = static_cast<chip::BitFlags<chip::app::Clusters::DoorLock::DlDaysMaskMap>>(64);
        request.startHour    = 23;
        request.startMinute  = 0;
        request.endHour      = 23;
        request.endMinute    = 59;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_SchedulesSuite *>(context))->OnSuccessResponse_75();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_SchedulesSuite *>(context))->OnFailureResponse_75(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_75(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_75() { NextTest(); }

    CHIP_ERROR TestVerifyCreatedWeekDayScheduleForFirstUser_76()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::GetWeekDaySchedule::Type;

        RequestType request;
        request.weekDayIndex = 4;
        request.userIndex    = 2U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_SchedulesSuite *>(context))
                ->OnSuccessResponse_76(data.weekDayIndex, data.userIndex, data.status, data.daysMask, data.startHour,
                                       data.startMinute, data.endHour, data.endMinute);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_SchedulesSuite *>(context))->OnFailureResponse_76(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_76(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_76(uint8_t weekDayIndex, uint16_t userIndex, chip::app::Clusters::DoorLock::DlStatus status,
                              const chip::Optional<chip::BitFlags<chip::app::Clusters::DoorLock::DlDaysMaskMap>> & daysMask,
                              const chip::Optional<uint8_t> & startHour, const chip::Optional<uint8_t> & startMinute,
                              const chip::Optional<uint8_t> & endHour, const chip::Optional<uint8_t> & endMinute)
    {
        VerifyOrReturn(CheckValue("weekDayIndex", weekDayIndex, 4));

        VerifyOrReturn(CheckValue("userIndex", userIndex, 2U));

        VerifyOrReturn(CheckValue("status", status, 0));

        VerifyOrReturn(CheckValuePresent("daysMask", daysMask));
        VerifyOrReturn(CheckValue("daysMask.Value()", daysMask.Value(), 64));

        VerifyOrReturn(CheckValuePresent("startHour", startHour));
        VerifyOrReturn(CheckValue("startHour.Value()", startHour.Value(), 23));

        VerifyOrReturn(CheckValuePresent("startMinute", startMinute));
        VerifyOrReturn(CheckValue("startMinute.Value()", startMinute.Value(), 0));

        VerifyOrReturn(CheckValuePresent("endHour", endHour));
        VerifyOrReturn(CheckValue("endHour.Value()", endHour.Value(), 23));

        VerifyOrReturn(CheckValuePresent("endMinute", endMinute));
        VerifyOrReturn(CheckValue("endMinute.Value()", endMinute.Value(), 59));

        NextTest();
    }

    CHIP_ERROR TestCreateYearDayScheduleForSecondUser_77()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::SetYearDaySchedule::Type;

        RequestType request;
        request.yearDayIndex   = 1;
        request.userIndex      = 1U;
        request.localStartTime = 55555UL;
        request.localEndTime   = 7777777UL;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_SchedulesSuite *>(context))->OnSuccessResponse_77();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_SchedulesSuite *>(context))->OnFailureResponse_77(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_77(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_77() { NextTest(); }

    CHIP_ERROR TestVerifyCreatedYearDayScheduleForFirst_78()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::GetYearDaySchedule::Type;

        RequestType request;
        request.yearDayIndex = 1;
        request.userIndex    = 1U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_SchedulesSuite *>(context))
                ->OnSuccessResponse_78(data.yearDayIndex, data.userIndex, data.status, data.localStartTime, data.localEndTime);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_SchedulesSuite *>(context))->OnFailureResponse_78(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_78(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_78(uint8_t yearDayIndex, uint16_t userIndex, chip::app::Clusters::DoorLock::DlStatus status,
                              const chip::Optional<uint32_t> & localStartTime, const chip::Optional<uint32_t> & localEndTime)
    {
        VerifyOrReturn(CheckValue("yearDayIndex", yearDayIndex, 1));

        VerifyOrReturn(CheckValue("userIndex", userIndex, 1U));

        VerifyOrReturn(CheckValue("status", status, 0));

        VerifyOrReturn(CheckValuePresent("localStartTime", localStartTime));
        VerifyOrReturn(CheckValue("localStartTime.Value()", localStartTime.Value(), 55555UL));

        VerifyOrReturn(CheckValuePresent("localEndTime", localEndTime));
        VerifyOrReturn(CheckValue("localEndTime.Value()", localEndTime.Value(), 7777777UL));

        NextTest();
    }

    CHIP_ERROR TestCleanup_79()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::ClearUser::Type;

        RequestType request;
        request.userIndex = 65534U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_SchedulesSuite *>(context))->OnSuccessResponse_79();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_SchedulesSuite *>(context))->OnFailureResponse_79(error);
        };

        ReturnErrorOnFailure(
            chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request, 10000));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_79(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_79() { NextTest(); }

    CHIP_ERROR TestMakeSureClearingFirstUserAlsoClearedWeekDaySchedules_80()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::GetWeekDaySchedule::Type;

        RequestType request;
        request.weekDayIndex = 1;
        request.userIndex    = 1U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_SchedulesSuite *>(context))
                ->OnSuccessResponse_80(data.weekDayIndex, data.userIndex, data.status, data.daysMask, data.startHour,
                                       data.startMinute, data.endHour, data.endMinute);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_SchedulesSuite *>(context))->OnFailureResponse_80(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_80(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_80(uint8_t weekDayIndex, uint16_t userIndex, chip::app::Clusters::DoorLock::DlStatus status,
                              const chip::Optional<chip::BitFlags<chip::app::Clusters::DoorLock::DlDaysMaskMap>> & daysMask,
                              const chip::Optional<uint8_t> & startHour, const chip::Optional<uint8_t> & startMinute,
                              const chip::Optional<uint8_t> & endHour, const chip::Optional<uint8_t> & endMinute)
    {
        VerifyOrReturn(CheckValue("weekDayIndex", weekDayIndex, 1));

        VerifyOrReturn(CheckValue("userIndex", userIndex, 1U));

        VerifyOrReturn(CheckValue("status", status, 139));

        NextTest();
    }

    CHIP_ERROR TestMakeSureClearingFirstUserAlsoClearedYearDaySchedules_81()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::GetYearDaySchedule::Type;

        RequestType request;
        request.yearDayIndex = 4;
        request.userIndex    = 1U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_SchedulesSuite *>(context))
                ->OnSuccessResponse_81(data.yearDayIndex, data.userIndex, data.status, data.localStartTime, data.localEndTime);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_SchedulesSuite *>(context))->OnFailureResponse_81(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_81(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_81(uint8_t yearDayIndex, uint16_t userIndex, chip::app::Clusters::DoorLock::DlStatus status,
                              const chip::Optional<uint32_t> & localStartTime, const chip::Optional<uint32_t> & localEndTime)
    {
        VerifyOrReturn(CheckValue("yearDayIndex", yearDayIndex, 4));

        VerifyOrReturn(CheckValue("userIndex", userIndex, 1U));

        VerifyOrReturn(CheckValue("status", status, 139));

        NextTest();
    }

    CHIP_ERROR TestMakeSureClearingSecondUserAlsoClearedWeekDaySchedules_82()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::GetWeekDaySchedule::Type;

        RequestType request;
        request.weekDayIndex = 4;
        request.userIndex    = 2U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_SchedulesSuite *>(context))
                ->OnSuccessResponse_82(data.weekDayIndex, data.userIndex, data.status, data.daysMask, data.startHour,
                                       data.startMinute, data.endHour, data.endMinute);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_SchedulesSuite *>(context))->OnFailureResponse_82(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_82(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_82(uint8_t weekDayIndex, uint16_t userIndex, chip::app::Clusters::DoorLock::DlStatus status,
                              const chip::Optional<chip::BitFlags<chip::app::Clusters::DoorLock::DlDaysMaskMap>> & daysMask,
                              const chip::Optional<uint8_t> & startHour, const chip::Optional<uint8_t> & startMinute,
                              const chip::Optional<uint8_t> & endHour, const chip::Optional<uint8_t> & endMinute)
    {
        VerifyOrReturn(CheckValue("weekDayIndex", weekDayIndex, 4));

        VerifyOrReturn(CheckValue("userIndex", userIndex, 2U));

        VerifyOrReturn(CheckValue("status", status, 139));

        NextTest();
    }

    CHIP_ERROR TestMakeSureClearingSecondUserAlsoClearedYearDaySchedules_83()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::DoorLock::Commands::GetYearDaySchedule::Type;

        RequestType request;
        request.yearDayIndex = 1;
        request.userIndex    = 2U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<DL_SchedulesSuite *>(context))
                ->OnSuccessResponse_83(data.yearDayIndex, data.userIndex, data.status, data.localStartTime, data.localEndTime);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<DL_SchedulesSuite *>(context))->OnFailureResponse_83(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_83(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_83(uint8_t yearDayIndex, uint16_t userIndex, chip::app::Clusters::DoorLock::DlStatus status,
                              const chip::Optional<uint32_t> & localStartTime, const chip::Optional<uint32_t> & localEndTime)
    {
        VerifyOrReturn(CheckValue("yearDayIndex", yearDayIndex, 1));

        VerifyOrReturn(CheckValue("userIndex", userIndex, 2U));

        VerifyOrReturn(CheckValue("status", status, 139));

        NextTest();
    }
};

class TestGroupMessagingSuite : public TestCommand
{
public:
    TestGroupMessagingSuite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("TestGroupMessaging", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~TestGroupMessagingSuite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestGroupMessaging\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestGroupMessaging\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Add Group 1 (endpoint 1)\n");
            err = TestAddGroup1Endpoint1_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Add Group 2 (endpoint 0)\n");
            err = TestAddGroup2Endpoint0_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : KeySet Write 1\n");
            err = TestKeySetWrite1_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : KeySet Write 2\n");
            err = TestKeySetWrite2_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Write Group Keys\n");
            err = TestWriteGroupKeys_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Install ACLs\n");
            err = TestInstallACLs_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Group Write Attribute\n");
            err = TestGroupWriteAttribute_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Read back Attribute\n");
            err = TestReadBackAttribute_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Restore initial location value\n");
            err = TestRestoreInitialLocationValue_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Read back Attribute\n");
            err = TestReadBackAttribute_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : Turn On the light to see attribute change\n");
            err = TestTurnOnTheLightToSeeAttributeChange_11();
            break;
        case 12:
            ChipLogProgress(chipTool,
                            " ***** Test Step 12 : Check on/off attribute value is true after on command for endpoint 1\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommandForEndpoint1_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : Cleanup ACLs\n");
            err = TestCleanupACLs_13();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 14;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_5(void * context, CHIP_ERROR error)
    {
        (static_cast<TestGroupMessagingSuite *>(context))->OnFailureResponse_5(error);
    }

    static void OnSuccessCallback_5(void * context) { (static_cast<TestGroupMessagingSuite *>(context))->OnSuccessResponse_5(); }

    static void OnFailureCallback_6(void * context, CHIP_ERROR error)
    {
        (static_cast<TestGroupMessagingSuite *>(context))->OnFailureResponse_6(error);
    }

    static void OnSuccessCallback_6(void * context) { (static_cast<TestGroupMessagingSuite *>(context))->OnSuccessResponse_6(); }

    static void OnDoneCallback_7(void * context) { (static_cast<TestGroupMessagingSuite *>(context))->OnDoneResponse_7(); }

    static void OnFailureCallback_7(void * context, CHIP_ERROR error)
    {
        (static_cast<TestGroupMessagingSuite *>(context))->OnFailureResponse_7(error);
    }

    static void OnSuccessCallback_7(void * context) { (static_cast<TestGroupMessagingSuite *>(context))->OnSuccessResponse_7(); }

    static void OnFailureCallback_8(void * context, CHIP_ERROR error)
    {
        (static_cast<TestGroupMessagingSuite *>(context))->OnFailureResponse_8(error);
    }

    static void OnSuccessCallback_8(void * context, chip::CharSpan location)
    {
        (static_cast<TestGroupMessagingSuite *>(context))->OnSuccessResponse_8(location);
    }

    static void OnDoneCallback_9(void * context) { (static_cast<TestGroupMessagingSuite *>(context))->OnDoneResponse_9(); }

    static void OnFailureCallback_9(void * context, CHIP_ERROR error)
    {
        (static_cast<TestGroupMessagingSuite *>(context))->OnFailureResponse_9(error);
    }

    static void OnSuccessCallback_9(void * context) { (static_cast<TestGroupMessagingSuite *>(context))->OnSuccessResponse_9(); }

    static void OnFailureCallback_10(void * context, CHIP_ERROR error)
    {
        (static_cast<TestGroupMessagingSuite *>(context))->OnFailureResponse_10(error);
    }

    static void OnSuccessCallback_10(void * context, chip::CharSpan location)
    {
        (static_cast<TestGroupMessagingSuite *>(context))->OnSuccessResponse_10(location);
    }

    static void OnFailureCallback_12(void * context, CHIP_ERROR error)
    {
        (static_cast<TestGroupMessagingSuite *>(context))->OnFailureResponse_12(error);
    }

    static void OnSuccessCallback_12(void * context, bool onOff)
    {
        (static_cast<TestGroupMessagingSuite *>(context))->OnSuccessResponse_12(onOff);
    }

    static void OnFailureCallback_13(void * context, CHIP_ERROR error)
    {
        (static_cast<TestGroupMessagingSuite *>(context))->OnFailureResponse_13(error);
    }

    static void OnSuccessCallback_13(void * context) { (static_cast<TestGroupMessagingSuite *>(context))->OnSuccessResponse_13(); }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestAddGroup1Endpoint1_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::Groups::Commands::AddGroup::Type;

        RequestType request;
        request.groupId   = 257U;
        request.groupName = chip::Span<const char>("Group #1garbage: not in length on purpose", 8);

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupMessagingSuite *>(context))->OnSuccessResponse_1(data.status, data.groupId);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestGroupMessagingSuite *>(context))->OnFailureResponse_1(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1(uint8_t status, chip::GroupId groupId)
    {
        VerifyOrReturn(CheckValue("status", status, 0));

        VerifyOrReturn(CheckValue("groupId", groupId, 257U));

        NextTest();
    }

    CHIP_ERROR TestAddGroup2Endpoint0_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        using RequestType               = chip::app::Clusters::Groups::Commands::AddGroup::Type;

        RequestType request;
        request.groupId   = 258U;
        request.groupName = chip::Span<const char>("Group #2garbage: not in length on purpose", 8);

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupMessagingSuite *>(context))->OnSuccessResponse_2(data.status, data.groupId);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestGroupMessagingSuite *>(context))->OnFailureResponse_2(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2(uint8_t status, chip::GroupId groupId)
    {
        VerifyOrReturn(CheckValue("status", status, 0));

        VerifyOrReturn(CheckValue("groupId", groupId, 258U));

        NextTest();
    }

    CHIP_ERROR TestKeySetWrite1_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        using RequestType               = chip::app::Clusters::GroupKeyManagement::Commands::KeySetWrite::Type;

        RequestType request;

        request.groupKeySet.groupKeySetID = 417U;
        request.groupKeySet.groupKeySecurityPolicy =
            static_cast<chip::app::Clusters::GroupKeyManagement::GroupKeySecurityPolicy>(1);
        request.groupKeySet.epochKey0.SetNonNull();
        request.groupKeySet.epochKey0.Value() =
            chip::ByteSpan(chip::Uint8::from_const_char(
                               "\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xafgarbage: not in length on purpose"),
                           16);
        request.groupKeySet.epochStartTime0.SetNonNull();
        request.groupKeySet.epochStartTime0.Value() = 1110000ULL;
        request.groupKeySet.epochKey1.SetNonNull();
        request.groupKeySet.epochKey1.Value() =
            chip::ByteSpan(chip::Uint8::from_const_char(
                               "\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbfgarbage: not in length on purpose"),
                           16);
        request.groupKeySet.epochStartTime1.SetNonNull();
        request.groupKeySet.epochStartTime1.Value() = 1110001ULL;
        request.groupKeySet.epochKey2.SetNonNull();
        request.groupKeySet.epochKey2.Value() =
            chip::ByteSpan(chip::Uint8::from_const_char(
                               "\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcfgarbage: not in length on purpose"),
                           16);
        request.groupKeySet.epochStartTime2.SetNonNull();
        request.groupKeySet.epochStartTime2.Value() = 1110002ULL;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupMessagingSuite *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestGroupMessagingSuite *>(context))->OnFailureResponse_3(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestKeySetWrite2_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        using RequestType               = chip::app::Clusters::GroupKeyManagement::Commands::KeySetWrite::Type;

        RequestType request;

        request.groupKeySet.groupKeySetID = 418U;
        request.groupKeySet.groupKeySecurityPolicy =
            static_cast<chip::app::Clusters::GroupKeyManagement::GroupKeySecurityPolicy>(1);
        request.groupKeySet.epochKey0.SetNonNull();
        request.groupKeySet.epochKey0.Value() =
            chip::ByteSpan(chip::Uint8::from_const_char(
                               "\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdfgarbage: not in length on purpose"),
                           16);
        request.groupKeySet.epochStartTime0.SetNonNull();
        request.groupKeySet.epochStartTime0.Value() = 2220000ULL;
        request.groupKeySet.epochKey1.SetNonNull();
        request.groupKeySet.epochKey1.Value() =
            chip::ByteSpan(chip::Uint8::from_const_char(
                               "\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xefgarbage: not in length on purpose"),
                           16);
        request.groupKeySet.epochStartTime1.SetNonNull();
        request.groupKeySet.epochStartTime1.Value() = 2220001ULL;
        request.groupKeySet.epochKey2.SetNonNull();
        request.groupKeySet.epochKey2.Value() =
            chip::ByteSpan(chip::Uint8::from_const_char(
                               "\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xffgarbage: not in length on purpose"),
                           16);
        request.groupKeySet.epochStartTime2.SetNonNull();
        request.groupKeySet.epochStartTime2.Value() = 2220002ULL;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupMessagingSuite *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestGroupMessagingSuite *>(context))->OnFailureResponse_4(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestWriteGroupKeys_5()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        chip::Controller::GroupKeyManagementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ListFreer listFreer;
        chip::app::DataModel::List<const chip::app::Clusters::GroupKeyManagement::Structs::GroupKeyMapStruct::Type>
            groupKeyMapArgument;

        {
            auto * listHolder_0 = new ListHolder<chip::app::Clusters::GroupKeyManagement::Structs::GroupKeyMapStruct::Type>(2);
            listFreer.add(listHolder_0);

            listHolder_0->mList[0].fabricIndex   = 1;
            listHolder_0->mList[0].groupId       = 257U;
            listHolder_0->mList[0].groupKeySetID = 417U;

            listHolder_0->mList[1].fabricIndex   = 1;
            listHolder_0->mList[1].groupId       = 258U;
            listHolder_0->mList[1].groupKeySetID = 418U;

            groupKeyMapArgument =
                chip::app::DataModel::List<chip::app::Clusters::GroupKeyManagement::Structs::GroupKeyMapStruct::Type>(
                    listHolder_0->mList, 2);
        }

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::GroupKeyManagement::Attributes::GroupKeyMap::TypeInfo>(
            groupKeyMapArgument, this, OnSuccessCallback_5, OnFailureCallback_5));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_5() { NextTest(); }

    CHIP_ERROR TestInstallACLs_6()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        chip::Controller::AccessControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ListFreer listFreer;
        chip::app::DataModel::List<const chip::app::Clusters::AccessControl::Structs::AccessControlEntry::Type> aclArgument;

        {
            auto * listHolder_0 = new ListHolder<chip::app::Clusters::AccessControl::Structs::AccessControlEntry::Type>(2);
            listFreer.add(listHolder_0);

            listHolder_0->mList[0].fabricIndex = 0;
            listHolder_0->mList[0].privilege   = static_cast<chip::app::Clusters::AccessControl::Privilege>(5);
            listHolder_0->mList[0].authMode    = static_cast<chip::app::Clusters::AccessControl::AuthMode>(2);
            listHolder_0->mList[0].subjects.SetNull();
            listHolder_0->mList[0].targets.SetNull();

            listHolder_0->mList[1].fabricIndex = 0;
            listHolder_0->mList[1].privilege   = static_cast<chip::app::Clusters::AccessControl::Privilege>(3);
            listHolder_0->mList[1].authMode    = static_cast<chip::app::Clusters::AccessControl::AuthMode>(3);
            listHolder_0->mList[1].subjects.SetNull();
            listHolder_0->mList[1].targets.SetNull();

            aclArgument = chip::app::DataModel::List<chip::app::Clusters::AccessControl::Structs::AccessControlEntry::Type>(
                listHolder_0->mList, 2);
        }

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::AccessControl::Attributes::Acl::TypeInfo>(
            aclArgument, this, OnSuccessCallback_6, OnFailureCallback_6));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_6(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_6() { NextTest(); }

    CHIP_ERROR TestGroupWriteAttribute_7()
    {
        const chip::GroupId groupId = 258;
        chip::Controller::BasicClusterTest cluster;
        cluster.AssociateWithGroup(mDevices[kIdentityAlpha], groupId);

        chip::CharSpan locationArgument;
        locationArgument = chip::Span<const char>("USgarbage: not in length on purpose", 2);

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::Basic::Attributes::Location::TypeInfo>(
            locationArgument, this, OnSuccessCallback_7, OnFailureCallback_7, OnDoneCallback_7));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_7(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_7() { NextTest(); }

    void OnDoneResponse_7() { NextTest(); }

    CHIP_ERROR TestReadBackAttribute_8()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Basic::Attributes::Location::TypeInfo>(
            this, OnSuccessCallback_8, OnFailureCallback_8, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_8(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_8(chip::CharSpan location)
    {
        VerifyOrReturn(CheckValueAsString("location", location, chip::CharSpan("US", 2)));

        NextTest();
    }

    CHIP_ERROR TestRestoreInitialLocationValue_9()
    {
        const chip::GroupId groupId = 258;
        chip::Controller::BasicClusterTest cluster;
        cluster.AssociateWithGroup(mDevices[kIdentityAlpha], groupId);

        chip::CharSpan locationArgument;
        locationArgument = chip::Span<const char>("XXgarbage: not in length on purpose", 2);

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::Basic::Attributes::Location::TypeInfo>(
            locationArgument, this, OnSuccessCallback_9, OnFailureCallback_9, OnDoneCallback_9));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_9(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_9() { NextTest(); }

    void OnDoneResponse_9() { NextTest(); }

    CHIP_ERROR TestReadBackAttribute_10()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::Basic::Attributes::Location::TypeInfo>(
            this, OnSuccessCallback_10, OnFailureCallback_10, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_10(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_10(chip::CharSpan location)
    {
        VerifyOrReturn(CheckValueAsString("location", location, chip::CharSpan("XX", 2)));

        NextTest();
    }

    CHIP_ERROR TestTurnOnTheLightToSeeAttributeChange_11()
    {
        const chip::GroupId groupId = 257;
        using RequestType           = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupMessagingSuite *>(context))->OnSuccessResponse_11();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestGroupMessagingSuite *>(context))->OnFailureResponse_11(error);
        };

        auto done = [](void * context) { (static_cast<TestGroupMessagingSuite *>(context))->OnDoneResponse_11(); };

        ReturnErrorOnFailure(
            chip::Controller::InvokeGroupCommand(mDevices[kIdentityAlpha], this, success, failure, done, groupId, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_11(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_11() { NextTest(); }

    void OnDoneResponse_11() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommandForEndpoint1_12()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(
            this, OnSuccessCallback_12, OnFailureCallback_12, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_12(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_12(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 1));

        NextTest();
    }

    CHIP_ERROR TestCleanupACLs_13()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        chip::Controller::AccessControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ListFreer listFreer;
        chip::app::DataModel::List<const chip::app::Clusters::AccessControl::Structs::AccessControlEntry::Type> aclArgument;

        {
            auto * listHolder_0 = new ListHolder<chip::app::Clusters::AccessControl::Structs::AccessControlEntry::Type>(1);
            listFreer.add(listHolder_0);

            listHolder_0->mList[0].fabricIndex = 0;
            listHolder_0->mList[0].privilege   = static_cast<chip::app::Clusters::AccessControl::Privilege>(5);
            listHolder_0->mList[0].authMode    = static_cast<chip::app::Clusters::AccessControl::AuthMode>(2);
            listHolder_0->mList[0].subjects.SetNull();
            listHolder_0->mList[0].targets.SetNull();

            aclArgument = chip::app::DataModel::List<chip::app::Clusters::AccessControl::Structs::AccessControlEntry::Type>(
                listHolder_0->mList, 1);
        }

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::AccessControl::Attributes::Acl::TypeInfo>(
            aclArgument, this, OnSuccessCallback_13, OnFailureCallback_13));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_13(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_13() { NextTest(); }
};

class TestGroupsClusterSuite : public TestCommand
{
public:
    TestGroupsClusterSuite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("TestGroupsCluster", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~TestGroupsClusterSuite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestGroupsCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestGroupsCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : View Group 0 (invalid)\n");
            err = TestViewGroup0Invalid_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : View Group 1 (not found)\n");
            err = TestViewGroup1NotFound_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Add Group 1 (new)\n");
            err = TestAddGroup1New_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : View Group 1 (new)\n");
            err = TestViewGroup1New_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : View Group 2 (not found)\n");
            err = TestViewGroup2NotFound_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Get Group Membership 1 (all)\n");
            err = TestGetGroupMembership1All_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : View Group 3 (not found)\n");
            err = TestViewGroup3NotFound_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : View Group 1 (existing)\n");
            err = TestViewGroup1Existing_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Remove Group 0 (invalid)\n");
            err = TestRemoveGroup0Invalid_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Remove Group 4 (not found)\n");
            err = TestRemoveGroup4NotFound_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : View Group 1 (not removed)\n");
            err = TestViewGroup1NotRemoved_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : View Group 2 (removed)\n");
            err = TestViewGroup2Removed_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : Get Group Membership 3\n");
            err = TestGetGroupMembership3_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : Remove All\n");
            err = TestRemoveAll_14();
            break;
        case 15:
            ChipLogProgress(chipTool, " ***** Test Step 15 : View Group 1 (removed)\n");
            err = TestViewGroup1Removed_15();
            break;
        case 16:
            ChipLogProgress(chipTool, " ***** Test Step 16 : View Group 2 (still removed)\n");
            err = TestViewGroup2StillRemoved_16();
            break;
        case 17:
            ChipLogProgress(chipTool, " ***** Test Step 17 : View Group 3 (removed)\n");
            err = TestViewGroup3Removed_17();
            break;
        case 18:
            ChipLogProgress(chipTool, " ***** Test Step 18 : Get Group Membership 4\n");
            err = TestGetGroupMembership4_18();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 19;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestViewGroup0Invalid_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::Groups::Commands::ViewGroup::Type;

        RequestType request;
        request.groupId = 0U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupsClusterSuite *>(context))->OnSuccessResponse_1(data.status, data.groupId, data.groupName);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestGroupsClusterSuite *>(context))->OnFailureResponse_1(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1(uint8_t status, chip::GroupId groupId, chip::CharSpan groupName)
    {
        VerifyOrReturn(CheckValue("status", status, 135));

        VerifyOrReturn(CheckValue("groupId", groupId, 0U));

        NextTest();
    }

    CHIP_ERROR TestViewGroup1NotFound_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::Groups::Commands::ViewGroup::Type;

        RequestType request;
        request.groupId = 1U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupsClusterSuite *>(context))->OnSuccessResponse_2(data.status, data.groupId, data.groupName);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestGroupsClusterSuite *>(context))->OnFailureResponse_2(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2(uint8_t status, chip::GroupId groupId, chip::CharSpan groupName)
    {
        VerifyOrReturn(CheckValue("status", status, 139));

        VerifyOrReturn(CheckValue("groupId", groupId, 1U));

        NextTest();
    }

    CHIP_ERROR TestAddGroup1New_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::Groups::Commands::AddGroup::Type;

        RequestType request;
        request.groupId   = 1U;
        request.groupName = chip::Span<const char>("Group #1garbage: not in length on purpose", 8);

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupsClusterSuite *>(context))->OnSuccessResponse_3(data.status, data.groupId);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestGroupsClusterSuite *>(context))->OnFailureResponse_3(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3(uint8_t status, chip::GroupId groupId)
    {
        VerifyOrReturn(CheckValue("status", status, 0));

        VerifyOrReturn(CheckValue("groupId", groupId, 1U));

        NextTest();
    }

    CHIP_ERROR TestViewGroup1New_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::Groups::Commands::ViewGroup::Type;

        RequestType request;
        request.groupId = 1U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupsClusterSuite *>(context))->OnSuccessResponse_4(data.status, data.groupId, data.groupName);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestGroupsClusterSuite *>(context))->OnFailureResponse_4(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_4(uint8_t status, chip::GroupId groupId, chip::CharSpan groupName)
    {
        VerifyOrReturn(CheckValue("status", status, 0));

        VerifyOrReturn(CheckValue("groupId", groupId, 1U));

        VerifyOrReturn(CheckValueAsString("groupName", groupName, chip::CharSpan("Group #1", 8)));

        NextTest();
    }

    CHIP_ERROR TestViewGroup2NotFound_5()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::Groups::Commands::ViewGroup::Type;

        RequestType request;
        request.groupId = 4369U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupsClusterSuite *>(context))->OnSuccessResponse_5(data.status, data.groupId, data.groupName);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestGroupsClusterSuite *>(context))->OnFailureResponse_5(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_5(uint8_t status, chip::GroupId groupId, chip::CharSpan groupName)
    {
        VerifyOrReturn(CheckValue("status", status, 139));

        VerifyOrReturn(CheckValue("groupId", groupId, 4369U));

        NextTest();
    }

    CHIP_ERROR TestGetGroupMembership1All_6()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::Groups::Commands::GetGroupMembership::Type;

        ListFreer listFreer;
        RequestType request;

        request.groupList = chip::app::DataModel::List<chip::GroupId>();

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupsClusterSuite *>(context))->OnSuccessResponse_6(data.capacity, data.groupList);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestGroupsClusterSuite *>(context))->OnFailureResponse_6(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_6(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_6(const chip::app::DataModel::Nullable<uint8_t> & capacity,
                             const chip::app::DataModel::DecodableList<chip::GroupId> & groupList)
    {
        VerifyOrReturn(CheckValueNull("capacity", capacity));

        {
            auto iter_0 = groupList.begin();
            VerifyOrReturn(CheckNextListItemDecodes<decltype(groupList)>("groupList", iter_0, 0));
            VerifyOrReturn(CheckValue("groupList[0]", iter_0.GetValue(), 1U));
            VerifyOrReturn(CheckNoMoreListItems<decltype(groupList)>("groupList", iter_0, 1));
        }

        NextTest();
    }

    CHIP_ERROR TestViewGroup3NotFound_7()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::Groups::Commands::ViewGroup::Type;

        RequestType request;
        request.groupId = 32767U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupsClusterSuite *>(context))->OnSuccessResponse_7(data.status, data.groupId, data.groupName);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestGroupsClusterSuite *>(context))->OnFailureResponse_7(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_7(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_7(uint8_t status, chip::GroupId groupId, chip::CharSpan groupName)
    {
        VerifyOrReturn(CheckValue("status", status, 139));

        VerifyOrReturn(CheckValue("groupId", groupId, 32767U));

        NextTest();
    }

    CHIP_ERROR TestViewGroup1Existing_8()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::Groups::Commands::ViewGroup::Type;

        RequestType request;
        request.groupId = 1U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupsClusterSuite *>(context))->OnSuccessResponse_8(data.status, data.groupId, data.groupName);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestGroupsClusterSuite *>(context))->OnFailureResponse_8(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_8(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_8(uint8_t status, chip::GroupId groupId, chip::CharSpan groupName)
    {
        VerifyOrReturn(CheckValue("status", status, 0));

        VerifyOrReturn(CheckValue("groupId", groupId, 1U));

        VerifyOrReturn(CheckValueAsString("groupName", groupName, chip::CharSpan("Group #1", 8)));

        NextTest();
    }

    CHIP_ERROR TestRemoveGroup0Invalid_9()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::Groups::Commands::RemoveGroup::Type;

        RequestType request;
        request.groupId = 0U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupsClusterSuite *>(context))->OnSuccessResponse_9(data.status, data.groupId);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestGroupsClusterSuite *>(context))->OnFailureResponse_9(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_9(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_9(uint8_t status, chip::GroupId groupId)
    {
        VerifyOrReturn(CheckValue("status", status, 135));

        VerifyOrReturn(CheckValue("groupId", groupId, 0U));

        NextTest();
    }

    CHIP_ERROR TestRemoveGroup4NotFound_10()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::Groups::Commands::RemoveGroup::Type;

        RequestType request;
        request.groupId = 4U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupsClusterSuite *>(context))->OnSuccessResponse_10(data.status, data.groupId);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestGroupsClusterSuite *>(context))->OnFailureResponse_10(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_10(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_10(uint8_t status, chip::GroupId groupId)
    {
        VerifyOrReturn(CheckValue("status", status, 139));

        VerifyOrReturn(CheckValue("groupId", groupId, 4U));

        NextTest();
    }

    CHIP_ERROR TestViewGroup1NotRemoved_11()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::Groups::Commands::ViewGroup::Type;

        RequestType request;
        request.groupId = 1U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupsClusterSuite *>(context))->OnSuccessResponse_11(data.status, data.groupId, data.groupName);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestGroupsClusterSuite *>(context))->OnFailureResponse_11(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_11(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_11(uint8_t status, chip::GroupId groupId, chip::CharSpan groupName)
    {
        VerifyOrReturn(CheckValue("status", status, 0));

        VerifyOrReturn(CheckValue("groupId", groupId, 1U));

        VerifyOrReturn(CheckValueAsString("groupName", groupName, chip::CharSpan("Group #1", 8)));

        NextTest();
    }

    CHIP_ERROR TestViewGroup2Removed_12()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::Groups::Commands::ViewGroup::Type;

        RequestType request;
        request.groupId = 4369U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupsClusterSuite *>(context))->OnSuccessResponse_12(data.status, data.groupId, data.groupName);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestGroupsClusterSuite *>(context))->OnFailureResponse_12(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_12(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_12(uint8_t status, chip::GroupId groupId, chip::CharSpan groupName)
    {
        VerifyOrReturn(CheckValue("status", status, 139));

        VerifyOrReturn(CheckValue("groupId", groupId, 4369U));

        NextTest();
    }

    CHIP_ERROR TestGetGroupMembership3_13()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::Groups::Commands::GetGroupMembership::Type;

        ListFreer listFreer;
        RequestType request;

        {
            auto * listHolder_0 = new ListHolder<chip::GroupId>(4);
            listFreer.add(listHolder_0);
            listHolder_0->mList[0] = 1U;
            listHolder_0->mList[1] = 2U;
            listHolder_0->mList[2] = 4369U;
            listHolder_0->mList[3] = 3U;
            request.groupList      = chip::app::DataModel::List<chip::GroupId>(listHolder_0->mList, 4);
        }

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupsClusterSuite *>(context))->OnSuccessResponse_13(data.capacity, data.groupList);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestGroupsClusterSuite *>(context))->OnFailureResponse_13(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_13(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_13(const chip::app::DataModel::Nullable<uint8_t> & capacity,
                              const chip::app::DataModel::DecodableList<chip::GroupId> & groupList)
    {
        VerifyOrReturn(CheckValueNull("capacity", capacity));

        {
            auto iter_0 = groupList.begin();
            VerifyOrReturn(CheckNextListItemDecodes<decltype(groupList)>("groupList", iter_0, 0));
            VerifyOrReturn(CheckValue("groupList[0]", iter_0.GetValue(), 1U));
            VerifyOrReturn(CheckNoMoreListItems<decltype(groupList)>("groupList", iter_0, 1));
        }

        NextTest();
    }

    CHIP_ERROR TestRemoveAll_14()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::Groups::Commands::RemoveAllGroups::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupsClusterSuite *>(context))->OnSuccessResponse_14();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestGroupsClusterSuite *>(context))->OnFailureResponse_14(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_14(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_14() { NextTest(); }

    CHIP_ERROR TestViewGroup1Removed_15()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::Groups::Commands::ViewGroup::Type;

        RequestType request;
        request.groupId = 1U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupsClusterSuite *>(context))->OnSuccessResponse_15(data.status, data.groupId, data.groupName);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestGroupsClusterSuite *>(context))->OnFailureResponse_15(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_15(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_15(uint8_t status, chip::GroupId groupId, chip::CharSpan groupName)
    {
        VerifyOrReturn(CheckValue("status", status, 139));

        VerifyOrReturn(CheckValue("groupId", groupId, 1U));

        NextTest();
    }

    CHIP_ERROR TestViewGroup2StillRemoved_16()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::Groups::Commands::ViewGroup::Type;

        RequestType request;
        request.groupId = 4369U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupsClusterSuite *>(context))->OnSuccessResponse_16(data.status, data.groupId, data.groupName);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestGroupsClusterSuite *>(context))->OnFailureResponse_16(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_16(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_16(uint8_t status, chip::GroupId groupId, chip::CharSpan groupName)
    {
        VerifyOrReturn(CheckValue("status", status, 139));

        VerifyOrReturn(CheckValue("groupId", groupId, 4369U));

        NextTest();
    }

    CHIP_ERROR TestViewGroup3Removed_17()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::Groups::Commands::ViewGroup::Type;

        RequestType request;
        request.groupId = 32767U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupsClusterSuite *>(context))->OnSuccessResponse_17(data.status, data.groupId, data.groupName);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestGroupsClusterSuite *>(context))->OnFailureResponse_17(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_17(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_17(uint8_t status, chip::GroupId groupId, chip::CharSpan groupName)
    {
        VerifyOrReturn(CheckValue("status", status, 139));

        VerifyOrReturn(CheckValue("groupId", groupId, 32767U));

        NextTest();
    }

    CHIP_ERROR TestGetGroupMembership4_18()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::Groups::Commands::GetGroupMembership::Type;

        ListFreer listFreer;
        RequestType request;

        {
            auto * listHolder_0 = new ListHolder<chip::GroupId>(5);
            listFreer.add(listHolder_0);
            listHolder_0->mList[0] = 1U;
            listHolder_0->mList[1] = 2U;
            listHolder_0->mList[2] = 4369U;
            listHolder_0->mList[3] = 3U;
            listHolder_0->mList[4] = 32767U;
            request.groupList      = chip::app::DataModel::List<chip::GroupId>(listHolder_0->mList, 5);
        }

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupsClusterSuite *>(context))->OnSuccessResponse_18(data.capacity, data.groupList);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestGroupsClusterSuite *>(context))->OnFailureResponse_18(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_18(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_18(const chip::app::DataModel::Nullable<uint8_t> & capacity,
                              const chip::app::DataModel::DecodableList<chip::GroupId> & groupList)
    {
        VerifyOrReturn(CheckValueNull("capacity", capacity));

        {
            auto iter_0 = groupList.begin();
            VerifyOrReturn(CheckNoMoreListItems<decltype(groupList)>("groupList", iter_0, 0));
        }

        NextTest();
    }
};

class TestGroupKeyManagementClusterSuite : public TestCommand
{
public:
    TestGroupKeyManagementClusterSuite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("TestGroupKeyManagementCluster", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~TestGroupKeyManagementClusterSuite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestGroupKeyManagementCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestGroupKeyManagementCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read maxGroupsPerFabric\n");
            err = TestReadMaxGroupsPerFabric_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read maxGroupKeysPerFabric\n");
            err = TestReadMaxGroupKeysPerFabric_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Add Group 1\n");
            err = TestAddGroup1_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Add Group 2\n");
            err = TestAddGroup2_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : KeySet Write 1\n");
            err = TestKeySetWrite1_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : KeySet Write 2\n");
            err = TestKeySetWrite2_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : KeySet Read\n");
            err = TestKeySetRead_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Write Group Keys\n");
            err = TestWriteGroupKeys_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Read Group Keys\n");
            err = TestReadGroupKeys_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Read GroupTable\n");
            err = TestReadGroupTable_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : KeySet Remove 1\n");
            err = TestKeySetRemove1_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : KeySet Read (removed)\n");
            err = TestKeySetReadRemoved_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : KeySet Read (not removed)\n");
            err = TestKeySetReadNotRemoved_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : Remove All\n");
            err = TestRemoveAll_14();
            break;
        case 15:
            ChipLogProgress(chipTool, " ***** Test Step 15 : KeySet Remove 2\n");
            err = TestKeySetRemove2_15();
            break;
        case 16:
            ChipLogProgress(chipTool, " ***** Test Step 16 : KeySet Read (also removed)\n");
            err = TestKeySetReadAlsoRemoved_16();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 17;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_1(void * context, CHIP_ERROR error)
    {
        (static_cast<TestGroupKeyManagementClusterSuite *>(context))->OnFailureResponse_1(error);
    }

    static void OnSuccessCallback_1(void * context, uint16_t maxGroupsPerFabric)
    {
        (static_cast<TestGroupKeyManagementClusterSuite *>(context))->OnSuccessResponse_1(maxGroupsPerFabric);
    }

    static void OnFailureCallback_2(void * context, CHIP_ERROR error)
    {
        (static_cast<TestGroupKeyManagementClusterSuite *>(context))->OnFailureResponse_2(error);
    }

    static void OnSuccessCallback_2(void * context, uint16_t maxGroupKeysPerFabric)
    {
        (static_cast<TestGroupKeyManagementClusterSuite *>(context))->OnSuccessResponse_2(maxGroupKeysPerFabric);
    }

    static void OnFailureCallback_8(void * context, CHIP_ERROR error)
    {
        (static_cast<TestGroupKeyManagementClusterSuite *>(context))->OnFailureResponse_8(error);
    }

    static void OnSuccessCallback_8(void * context)
    {
        (static_cast<TestGroupKeyManagementClusterSuite *>(context))->OnSuccessResponse_8();
    }

    static void OnFailureCallback_9(void * context, CHIP_ERROR error)
    {
        (static_cast<TestGroupKeyManagementClusterSuite *>(context))->OnFailureResponse_9(error);
    }

    static void
    OnSuccessCallback_9(void * context,
                        const chip::app::DataModel::DecodableList<
                            chip::app::Clusters::GroupKeyManagement::Structs::GroupKeyMapStruct::DecodableType> & groupKeyMap)
    {
        (static_cast<TestGroupKeyManagementClusterSuite *>(context))->OnSuccessResponse_9(groupKeyMap);
    }

    static void OnFailureCallback_10(void * context, CHIP_ERROR error)
    {
        (static_cast<TestGroupKeyManagementClusterSuite *>(context))->OnFailureResponse_10(error);
    }

    static void
    OnSuccessCallback_10(void * context,
                         const chip::app::DataModel::DecodableList<
                             chip::app::Clusters::GroupKeyManagement::Structs::GroupInfoMapStruct::DecodableType> & groupTable)
    {
        (static_cast<TestGroupKeyManagementClusterSuite *>(context))->OnSuccessResponse_10(groupTable);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestReadMaxGroupsPerFabric_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        chip::Controller::GroupKeyManagementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::GroupKeyManagement::Attributes::MaxGroupsPerFabric::TypeInfo>(
                this, OnSuccessCallback_1, OnFailureCallback_1, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1(uint16_t maxGroupsPerFabric)
    {
        VerifyOrReturn(CheckConstraintMinValue<uint16_t>("maxGroupsPerFabric", maxGroupsPerFabric, 2U));
        NextTest();
    }

    CHIP_ERROR TestReadMaxGroupKeysPerFabric_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        chip::Controller::GroupKeyManagementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(
            cluster.ReadAttribute<chip::app::Clusters::GroupKeyManagement::Attributes::MaxGroupKeysPerFabric::TypeInfo>(
                this, OnSuccessCallback_2, OnFailureCallback_2, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2(uint16_t maxGroupKeysPerFabric)
    {
        VerifyOrReturn(CheckValue("maxGroupKeysPerFabric", maxGroupKeysPerFabric, 2U));

        NextTest();
    }

    CHIP_ERROR TestAddGroup1_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::Groups::Commands::AddGroup::Type;

        RequestType request;
        request.groupId   = 257U;
        request.groupName = chip::Span<const char>("Group #1garbage: not in length on purpose", 8);

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupKeyManagementClusterSuite *>(context))->OnSuccessResponse_3(data.status, data.groupId);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestGroupKeyManagementClusterSuite *>(context))->OnFailureResponse_3(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3(uint8_t status, chip::GroupId groupId)
    {
        VerifyOrReturn(CheckValue("status", status, 0));

        VerifyOrReturn(CheckValue("groupId", groupId, 257U));

        NextTest();
    }

    CHIP_ERROR TestAddGroup2_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::Groups::Commands::AddGroup::Type;

        RequestType request;
        request.groupId   = 258U;
        request.groupName = chip::Span<const char>("Group #2garbage: not in length on purpose", 8);

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupKeyManagementClusterSuite *>(context))->OnSuccessResponse_4(data.status, data.groupId);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestGroupKeyManagementClusterSuite *>(context))->OnFailureResponse_4(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_4(uint8_t status, chip::GroupId groupId)
    {
        VerifyOrReturn(CheckValue("status", status, 0));

        VerifyOrReturn(CheckValue("groupId", groupId, 258U));

        NextTest();
    }

    CHIP_ERROR TestKeySetWrite1_5()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        using RequestType               = chip::app::Clusters::GroupKeyManagement::Commands::KeySetWrite::Type;

        RequestType request;

        request.groupKeySet.groupKeySetID = 417U;
        request.groupKeySet.groupKeySecurityPolicy =
            static_cast<chip::app::Clusters::GroupKeyManagement::GroupKeySecurityPolicy>(0);
        request.groupKeySet.epochKey0.SetNonNull();
        request.groupKeySet.epochKey0.Value() =
            chip::ByteSpan(chip::Uint8::from_const_char(
                               "\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xafgarbage: not in length on purpose"),
                           16);
        request.groupKeySet.epochStartTime0.SetNonNull();
        request.groupKeySet.epochStartTime0.Value() = 1110000ULL;
        request.groupKeySet.epochKey1.SetNonNull();
        request.groupKeySet.epochKey1.Value() =
            chip::ByteSpan(chip::Uint8::from_const_char(
                               "\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbfgarbage: not in length on purpose"),
                           16);
        request.groupKeySet.epochStartTime1.SetNonNull();
        request.groupKeySet.epochStartTime1.Value() = 1110001ULL;
        request.groupKeySet.epochKey2.SetNonNull();
        request.groupKeySet.epochKey2.Value() =
            chip::ByteSpan(chip::Uint8::from_const_char(
                               "\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcfgarbage: not in length on purpose"),
                           16);
        request.groupKeySet.epochStartTime2.SetNonNull();
        request.groupKeySet.epochStartTime2.Value() = 1110002ULL;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupKeyManagementClusterSuite *>(context))->OnSuccessResponse_5();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestGroupKeyManagementClusterSuite *>(context))->OnFailureResponse_5(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_5() { NextTest(); }

    CHIP_ERROR TestKeySetWrite2_6()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        using RequestType               = chip::app::Clusters::GroupKeyManagement::Commands::KeySetWrite::Type;

        RequestType request;

        request.groupKeySet.groupKeySetID = 418U;
        request.groupKeySet.groupKeySecurityPolicy =
            static_cast<chip::app::Clusters::GroupKeyManagement::GroupKeySecurityPolicy>(1);
        request.groupKeySet.epochKey0.SetNonNull();
        request.groupKeySet.epochKey0.Value() =
            chip::ByteSpan(chip::Uint8::from_const_char(
                               "\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdfgarbage: not in length on purpose"),
                           16);
        request.groupKeySet.epochStartTime0.SetNonNull();
        request.groupKeySet.epochStartTime0.Value() = 2110000ULL;
        request.groupKeySet.epochKey1.SetNonNull();
        request.groupKeySet.epochKey1.Value() =
            chip::ByteSpan(chip::Uint8::from_const_char(
                               "\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xefgarbage: not in length on purpose"),
                           16);
        request.groupKeySet.epochStartTime1.SetNonNull();
        request.groupKeySet.epochStartTime1.Value() = 2110001ULL;
        request.groupKeySet.epochKey2.SetNonNull();
        request.groupKeySet.epochKey2.Value() =
            chip::ByteSpan(chip::Uint8::from_const_char(
                               "\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xffgarbage: not in length on purpose"),
                           16);
        request.groupKeySet.epochStartTime2.SetNonNull();
        request.groupKeySet.epochStartTime2.Value() = 2110002ULL;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupKeyManagementClusterSuite *>(context))->OnSuccessResponse_6();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestGroupKeyManagementClusterSuite *>(context))->OnFailureResponse_6(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_6(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_6() { NextTest(); }

    CHIP_ERROR TestKeySetRead_7()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        using RequestType               = chip::app::Clusters::GroupKeyManagement::Commands::KeySetRead::Type;

        RequestType request;
        request.groupKeySetID = 417U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupKeyManagementClusterSuite *>(context))->OnSuccessResponse_7(data.groupKeySet);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestGroupKeyManagementClusterSuite *>(context))->OnFailureResponse_7(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_7(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_7(const chip::app::Clusters::GroupKeyManagement::Structs::GroupKeySetStruct::DecodableType & groupKeySet)
    {
        VerifyOrReturn(CheckValue("groupKeySet.groupKeySetID", groupKeySet.groupKeySetID, 417U));
        VerifyOrReturn(CheckValue("groupKeySet.groupKeySecurityPolicy", groupKeySet.groupKeySecurityPolicy, 0));
        VerifyOrReturn(CheckValueNull("groupKeySet.epochKey0", groupKeySet.epochKey0));
        VerifyOrReturn(CheckValueNonNull("groupKeySet.epochStartTime0", groupKeySet.epochStartTime0));
        VerifyOrReturn(CheckValue("groupKeySet.epochStartTime0.Value()", groupKeySet.epochStartTime0.Value(), 1110000ULL));
        VerifyOrReturn(CheckValueNull("groupKeySet.epochKey1", groupKeySet.epochKey1));
        VerifyOrReturn(CheckValueNonNull("groupKeySet.epochStartTime1", groupKeySet.epochStartTime1));
        VerifyOrReturn(CheckValue("groupKeySet.epochStartTime1.Value()", groupKeySet.epochStartTime1.Value(), 1110001ULL));
        VerifyOrReturn(CheckValueNull("groupKeySet.epochKey2", groupKeySet.epochKey2));
        VerifyOrReturn(CheckValueNonNull("groupKeySet.epochStartTime2", groupKeySet.epochStartTime2));
        VerifyOrReturn(CheckValue("groupKeySet.epochStartTime2.Value()", groupKeySet.epochStartTime2.Value(), 1110002ULL));

        NextTest();
    }

    CHIP_ERROR TestWriteGroupKeys_8()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        chip::Controller::GroupKeyManagementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ListFreer listFreer;
        chip::app::DataModel::List<const chip::app::Clusters::GroupKeyManagement::Structs::GroupKeyMapStruct::Type>
            groupKeyMapArgument;

        {
            auto * listHolder_0 = new ListHolder<chip::app::Clusters::GroupKeyManagement::Structs::GroupKeyMapStruct::Type>(2);
            listFreer.add(listHolder_0);

            listHolder_0->mList[0].fabricIndex   = 1;
            listHolder_0->mList[0].groupId       = 257U;
            listHolder_0->mList[0].groupKeySetID = 417U;

            listHolder_0->mList[1].fabricIndex   = 1;
            listHolder_0->mList[1].groupId       = 258U;
            listHolder_0->mList[1].groupKeySetID = 418U;

            groupKeyMapArgument =
                chip::app::DataModel::List<chip::app::Clusters::GroupKeyManagement::Structs::GroupKeyMapStruct::Type>(
                    listHolder_0->mList, 2);
        }

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::GroupKeyManagement::Attributes::GroupKeyMap::TypeInfo>(
            groupKeyMapArgument, this, OnSuccessCallback_8, OnFailureCallback_8));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_8(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_8() { NextTest(); }

    CHIP_ERROR TestReadGroupKeys_9()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        chip::Controller::GroupKeyManagementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::GroupKeyManagement::Attributes::GroupKeyMap::TypeInfo>(
            this, OnSuccessCallback_9, OnFailureCallback_9, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_9(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_9(const chip::app::DataModel::DecodableList<
                             chip::app::Clusters::GroupKeyManagement::Structs::GroupKeyMapStruct::DecodableType> & groupKeyMap)
    {
        {
            auto iter_0 = groupKeyMap.begin();
            VerifyOrReturn(CheckNextListItemDecodes<decltype(groupKeyMap)>("groupKeyMap", iter_0, 0));
            VerifyOrReturn(CheckValue("groupKeyMap[0].fabricIndex", iter_0.GetValue().fabricIndex, 1));
            VerifyOrReturn(CheckValue("groupKeyMap[0].groupId", iter_0.GetValue().groupId, 257U));
            VerifyOrReturn(CheckValue("groupKeyMap[0].groupKeySetID", iter_0.GetValue().groupKeySetID, 417U));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(groupKeyMap)>("groupKeyMap", iter_0, 1));
            VerifyOrReturn(CheckValue("groupKeyMap[1].fabricIndex", iter_0.GetValue().fabricIndex, 1));
            VerifyOrReturn(CheckValue("groupKeyMap[1].groupId", iter_0.GetValue().groupId, 258U));
            VerifyOrReturn(CheckValue("groupKeyMap[1].groupKeySetID", iter_0.GetValue().groupKeySetID, 418U));
            VerifyOrReturn(CheckNoMoreListItems<decltype(groupKeyMap)>("groupKeyMap", iter_0, 2));
        }

        NextTest();
    }

    CHIP_ERROR TestReadGroupTable_10()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        chip::Controller::GroupKeyManagementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::GroupKeyManagement::Attributes::GroupTable::TypeInfo>(
            this, OnSuccessCallback_10, OnFailureCallback_10, true));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_10(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_10(const chip::app::DataModel::DecodableList<
                              chip::app::Clusters::GroupKeyManagement::Structs::GroupInfoMapStruct::DecodableType> & groupTable)
    {
        {
            auto iter_0 = groupTable.begin();
            VerifyOrReturn(CheckNextListItemDecodes<decltype(groupTable)>("groupTable", iter_0, 0));
            VerifyOrReturn(CheckValue("groupTable[0].fabricIndex", iter_0.GetValue().fabricIndex, 1));
            VerifyOrReturn(CheckValue("groupTable[0].groupId", iter_0.GetValue().groupId, 257U));
            VerifyOrReturn(CheckValuePresent("groupTable[0].groupName", iter_0.GetValue().groupName));
            VerifyOrReturn(CheckValueAsString("groupTable[0].groupName.Value()", iter_0.GetValue().groupName.Value(),
                                              chip::CharSpan("Group #1", 8)));
            VerifyOrReturn(CheckNextListItemDecodes<decltype(groupTable)>("groupTable", iter_0, 1));
            VerifyOrReturn(CheckValue("groupTable[1].fabricIndex", iter_0.GetValue().fabricIndex, 1));
            VerifyOrReturn(CheckValue("groupTable[1].groupId", iter_0.GetValue().groupId, 258U));
            VerifyOrReturn(CheckValuePresent("groupTable[1].groupName", iter_0.GetValue().groupName));
            VerifyOrReturn(CheckValueAsString("groupTable[1].groupName.Value()", iter_0.GetValue().groupName.Value(),
                                              chip::CharSpan("Group #2", 8)));
            VerifyOrReturn(CheckNoMoreListItems<decltype(groupTable)>("groupTable", iter_0, 2));
        }

        NextTest();
    }

    CHIP_ERROR TestKeySetRemove1_11()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        using RequestType               = chip::app::Clusters::GroupKeyManagement::Commands::KeySetRemove::Type;

        RequestType request;
        request.groupKeySetID = 417U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupKeyManagementClusterSuite *>(context))->OnSuccessResponse_11();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestGroupKeyManagementClusterSuite *>(context))->OnFailureResponse_11(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_11(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_11() { NextTest(); }

    CHIP_ERROR TestKeySetReadRemoved_12()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        using RequestType               = chip::app::Clusters::GroupKeyManagement::Commands::KeySetRead::Type;

        RequestType request;
        request.groupKeySetID = 417U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupKeyManagementClusterSuite *>(context))->OnSuccessResponse_12(data.groupKeySet);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestGroupKeyManagementClusterSuite *>(context))->OnFailureResponse_12(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_12(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_NOT_FOUND));
        NextTest();
    }

    void
    OnSuccessResponse_12(const chip::app::Clusters::GroupKeyManagement::Structs::GroupKeySetStruct::DecodableType & groupKeySet)
    {
        ThrowSuccessResponse();
    }

    CHIP_ERROR TestKeySetReadNotRemoved_13()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        using RequestType               = chip::app::Clusters::GroupKeyManagement::Commands::KeySetRead::Type;

        RequestType request;
        request.groupKeySetID = 418U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupKeyManagementClusterSuite *>(context))->OnSuccessResponse_13(data.groupKeySet);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestGroupKeyManagementClusterSuite *>(context))->OnFailureResponse_13(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_13(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void
    OnSuccessResponse_13(const chip::app::Clusters::GroupKeyManagement::Structs::GroupKeySetStruct::DecodableType & groupKeySet)
    {
        VerifyOrReturn(CheckValue("groupKeySet.groupKeySetID", groupKeySet.groupKeySetID, 418U));
        VerifyOrReturn(CheckValue("groupKeySet.groupKeySecurityPolicy", groupKeySet.groupKeySecurityPolicy, 1));
        VerifyOrReturn(CheckValueNull("groupKeySet.epochKey0", groupKeySet.epochKey0));
        VerifyOrReturn(CheckValueNonNull("groupKeySet.epochStartTime0", groupKeySet.epochStartTime0));
        VerifyOrReturn(CheckValue("groupKeySet.epochStartTime0.Value()", groupKeySet.epochStartTime0.Value(), 2110000ULL));
        VerifyOrReturn(CheckValueNull("groupKeySet.epochKey1", groupKeySet.epochKey1));
        VerifyOrReturn(CheckValueNonNull("groupKeySet.epochStartTime1", groupKeySet.epochStartTime1));
        VerifyOrReturn(CheckValue("groupKeySet.epochStartTime1.Value()", groupKeySet.epochStartTime1.Value(), 2110001ULL));
        VerifyOrReturn(CheckValueNull("groupKeySet.epochKey2", groupKeySet.epochKey2));
        VerifyOrReturn(CheckValueNonNull("groupKeySet.epochStartTime2", groupKeySet.epochStartTime2));
        VerifyOrReturn(CheckValue("groupKeySet.epochStartTime2.Value()", groupKeySet.epochStartTime2.Value(), 2110002ULL));

        NextTest();
    }

    CHIP_ERROR TestRemoveAll_14()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::Groups::Commands::RemoveAllGroups::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupKeyManagementClusterSuite *>(context))->OnSuccessResponse_14();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestGroupKeyManagementClusterSuite *>(context))->OnFailureResponse_14(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_14(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_14() { NextTest(); }

    CHIP_ERROR TestKeySetRemove2_15()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        using RequestType               = chip::app::Clusters::GroupKeyManagement::Commands::KeySetRemove::Type;

        RequestType request;
        request.groupKeySetID = 418U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupKeyManagementClusterSuite *>(context))->OnSuccessResponse_15();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestGroupKeyManagementClusterSuite *>(context))->OnFailureResponse_15(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_15(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_15() { NextTest(); }

    CHIP_ERROR TestKeySetReadAlsoRemoved_16()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        using RequestType               = chip::app::Clusters::GroupKeyManagement::Commands::KeySetRead::Type;

        RequestType request;
        request.groupKeySetID = 418U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupKeyManagementClusterSuite *>(context))->OnSuccessResponse_16(data.groupKeySet);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestGroupKeyManagementClusterSuite *>(context))->OnFailureResponse_16(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_16(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_NOT_FOUND));
        NextTest();
    }

    void
    OnSuccessResponse_16(const chip::app::Clusters::GroupKeyManagement::Structs::GroupKeySetStruct::DecodableType & groupKeySet)
    {
        ThrowSuccessResponse();
    }
};

class Test_TC_DD_1_5Suite : public TestCommand
{
public:
    Test_TC_DD_1_5Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_DD_1_5", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_DD_1_5Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_DD_1_5\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_DD_1_5\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Step 1\n");
            err = TestStep1_0();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestStep1_0()
    {
        SetIdentity(kIdentityAlpha);
        return Log("Verify that the onboarding payload for NFC tags SHALL use NDEF URI Record Type Definition as defined by NFC "
                   "Forum in URI Record Type Definition RTD URI");
    }
};

class Test_TC_DD_1_6Suite : public TestCommand
{
public:
    Test_TC_DD_1_6Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_DD_1_6", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_DD_1_6Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_DD_1_6\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_DD_1_6\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Step 1\n");
            err = TestStep1_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Step 1 verification\n");
            err = TestStep1Verification_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Step 2 verificaiton\n");
            err = TestStep2Verificaiton_2();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 3;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestStep1_0()
    {
        SetIdentity(kIdentityAlpha);
        return Log("Scan the DUTs QR code using a QR code reader");
    }

    CHIP_ERROR TestStep1Verification_1()
    {
        SetIdentity(kIdentityAlpha);
        return Log(
            "Verify the QR code gets scanned successfully and the QR code must be of sufficient size and contrast respective to "
            "surface material as to be readable with standard readers such as smartphones in normal lighting conditions");
    }

    CHIP_ERROR TestStep2Verificaiton_2()
    {
        SetIdentity(kIdentityAlpha);
        return Log("Verify QR code version is 1 or higher");
    }
};

class Test_TC_DD_1_7Suite : public TestCommand
{
public:
    Test_TC_DD_1_7Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_DD_1_7", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_DD_1_7Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_DD_1_7\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_DD_1_7\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Precondition\n");
            err = TestPrecondition_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Step 1\n");
            err = TestStep1_1();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 2;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestPrecondition_0()
    {
        SetIdentity(kIdentityAlpha);
        return Log("Verify manual pairing code is printed on the device or in additional provided materials");
    }

    CHIP_ERROR TestStep1_1()
    {
        SetIdentity(kIdentityAlpha);
        return Log("Verify that the Manual Pairing Code should be printed using a minimum font size of 6 points typically "
                   "producing a typeface height of 2.1 mm");
    }
};

class Test_TC_DD_1_8Suite : public TestCommand
{
public:
    Test_TC_DD_1_8Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_DD_1_8", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_DD_1_8Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_DD_1_8\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_DD_1_8\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Step 1\n");
            err = TestStep1_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Step 1 verification\n");
            err = TestStep1Verification_1();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 2;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestStep1_0()
    {
        SetIdentity(kIdentityAlpha);
        return Log("Scan the device QR code using DUT");
    }

    CHIP_ERROR TestStep1Verification_1()
    {
        SetIdentity(kIdentityAlpha);
        return Log("Verify the DUT is able to scan and parse the QR code successfully to onboard the device onto the CHIP network");
    }
};

class Test_TC_DD_1_9Suite : public TestCommand
{
public:
    Test_TC_DD_1_9Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_DD_1_9", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_DD_1_9Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_DD_1_9\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_DD_1_9\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Precondition\n");
            err = TestPrecondition_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Step 1\n");
            err = TestStep1_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Step 1 verification\n");
            err = TestStep1Verification_2();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 3;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestPrecondition_0()
    {
        SetIdentity(kIdentityAlpha);
        return Log("Verify that the manual pairing code is printed on the device or in additional provided materials");
    }

    CHIP_ERROR TestStep1_1()
    {
        SetIdentity(kIdentityAlpha);
        return Log("Provide the 11 digit or 21 digit pairing code from the Device in text speech or any format supported by DUT");
    }

    CHIP_ERROR TestStep1Verification_2()
    {
        SetIdentity(kIdentityAlpha);
        return Log(
            "Verify that the manual pairing code can be provided to DUT and parsed to onboard the device onto the CHIP network");
    }
};

class Test_TC_DD_1_10Suite : public TestCommand
{
public:
    Test_TC_DD_1_10Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_DD_1_10", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_DD_1_10Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_DD_1_10\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_DD_1_10\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_DD_2_1Suite : public TestCommand
{
public:
    Test_TC_DD_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_DD_2_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_DD_2_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_DD_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_DD_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_DD_2_2Suite : public TestCommand
{
public:
    Test_TC_DD_2_2Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_DD_2_2", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_DD_2_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_DD_2_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_DD_2_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_DD_3_1Suite : public TestCommand
{
public:
    Test_TC_DD_3_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_DD_3_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_DD_3_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_DD_3_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_DD_3_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_DD_3_2Suite : public TestCommand
{
public:
    Test_TC_DD_3_2Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_DD_3_2", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_DD_3_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_DD_3_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_DD_3_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_DD_3_5Suite : public TestCommand
{
public:
    Test_TC_DD_3_5Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_DD_3_5", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_DD_3_5Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_DD_3_5\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_DD_3_5\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_DD_3_6Suite : public TestCommand
{
public:
    Test_TC_DD_3_6Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_DD_3_6", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_DD_3_6Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_DD_3_6\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_DD_3_6\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_DD_3_9Suite : public TestCommand
{
public:
    Test_TC_DD_3_9Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_DD_3_9", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_DD_3_9Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_DD_3_9\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_DD_3_9\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_DD_3_10Suite : public TestCommand
{
public:
    Test_TC_DD_3_10Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_DD_3_10", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_DD_3_10Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_DD_3_10\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_DD_3_10\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_DD_4_1Suite : public TestCommand
{
public:
    Test_TC_DD_4_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_DD_4_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_DD_4_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_DD_4_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_DD_4_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class TestGroupDemoCommandSuite : public TestCommand
{
public:
    TestGroupDemoCommandSuite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("TestGroupDemoCommand", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~TestGroupDemoCommandSuite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestGroupDemoCommand\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestGroupDemoCommand\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Turn On the light to see attribute change\n");
            err = TestTurnOnTheLightToSeeAttributeChange_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Wait 100ms\n");
            err = TestWait100ms_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Turn Off the light to see attribute change\n");
            err = TestTurnOffTheLightToSeeAttributeChange_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Wait 100ms\n");
            err = TestWait100ms_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Turn On the light to see attribute change\n");
            err = TestTurnOnTheLightToSeeAttributeChange_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Wait 100ms\n");
            err = TestWait100ms_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Turn Off the light to see attribute change\n");
            err = TestTurnOffTheLightToSeeAttributeChange_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Wait 100ms\n");
            err = TestWait100ms_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Turn On the light to see attribute change\n");
            err = TestTurnOnTheLightToSeeAttributeChange_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Wait 100ms\n");
            err = TestWait100ms_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : Turn Off the light to see attribute change\n");
            err = TestTurnOffTheLightToSeeAttributeChange_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : Wait 100ms\n");
            err = TestWait100ms_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : Turn On the light to see attribute change\n");
            err = TestTurnOnTheLightToSeeAttributeChange_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : Wait 100ms\n");
            err = TestWait100ms_14();
            break;
        case 15:
            ChipLogProgress(chipTool, " ***** Test Step 15 : Turn Off the light to see attribute change\n");
            err = TestTurnOffTheLightToSeeAttributeChange_15();
            break;
        case 16:
            ChipLogProgress(chipTool, " ***** Test Step 16 : Wait 100ms\n");
            err = TestWait100ms_16();
            break;
        case 17:
            ChipLogProgress(chipTool, " ***** Test Step 17 : Turn On the light to see attribute change\n");
            err = TestTurnOnTheLightToSeeAttributeChange_17();
            break;
        case 18:
            ChipLogProgress(chipTool, " ***** Test Step 18 : Wait 100ms\n");
            err = TestWait100ms_18();
            break;
        case 19:
            ChipLogProgress(chipTool, " ***** Test Step 19 : Turn Off the light to see attribute change\n");
            err = TestTurnOffTheLightToSeeAttributeChange_19();
            break;
        case 20:
            ChipLogProgress(chipTool, " ***** Test Step 20 : Wait 100ms\n");
            err = TestWait100ms_20();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 21;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestTurnOnTheLightToSeeAttributeChange_1()
    {
        const chip::GroupId groupId = 257;
        using RequestType           = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupDemoCommandSuite *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestGroupDemoCommandSuite *>(context))->OnFailureResponse_1(error);
        };

        auto done = [](void * context) { (static_cast<TestGroupDemoCommandSuite *>(context))->OnDoneResponse_1(); };

        ReturnErrorOnFailure(
            chip::Controller::InvokeGroupCommand(mDevices[kIdentityAlpha], this, success, failure, done, groupId, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1() { NextTest(); }

    void OnDoneResponse_1() { NextTest(); }

    CHIP_ERROR TestWait100ms_2()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForMs(1000);
    }

    CHIP_ERROR TestTurnOffTheLightToSeeAttributeChange_3()
    {
        const chip::GroupId groupId = 257;
        using RequestType           = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupDemoCommandSuite *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestGroupDemoCommandSuite *>(context))->OnFailureResponse_3(error);
        };

        auto done = [](void * context) { (static_cast<TestGroupDemoCommandSuite *>(context))->OnDoneResponse_3(); };

        ReturnErrorOnFailure(
            chip::Controller::InvokeGroupCommand(mDevices[kIdentityAlpha], this, success, failure, done, groupId, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3() { NextTest(); }

    void OnDoneResponse_3() { NextTest(); }

    CHIP_ERROR TestWait100ms_4()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForMs(1000);
    }

    CHIP_ERROR TestTurnOnTheLightToSeeAttributeChange_5()
    {
        const chip::GroupId groupId = 257;
        using RequestType           = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupDemoCommandSuite *>(context))->OnSuccessResponse_5();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestGroupDemoCommandSuite *>(context))->OnFailureResponse_5(error);
        };

        auto done = [](void * context) { (static_cast<TestGroupDemoCommandSuite *>(context))->OnDoneResponse_5(); };

        ReturnErrorOnFailure(
            chip::Controller::InvokeGroupCommand(mDevices[kIdentityAlpha], this, success, failure, done, groupId, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_5() { NextTest(); }

    void OnDoneResponse_5() { NextTest(); }

    CHIP_ERROR TestWait100ms_6()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForMs(1000);
    }

    CHIP_ERROR TestTurnOffTheLightToSeeAttributeChange_7()
    {
        const chip::GroupId groupId = 257;
        using RequestType           = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupDemoCommandSuite *>(context))->OnSuccessResponse_7();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestGroupDemoCommandSuite *>(context))->OnFailureResponse_7(error);
        };

        auto done = [](void * context) { (static_cast<TestGroupDemoCommandSuite *>(context))->OnDoneResponse_7(); };

        ReturnErrorOnFailure(
            chip::Controller::InvokeGroupCommand(mDevices[kIdentityAlpha], this, success, failure, done, groupId, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_7(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_7() { NextTest(); }

    void OnDoneResponse_7() { NextTest(); }

    CHIP_ERROR TestWait100ms_8()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForMs(1000);
    }

    CHIP_ERROR TestTurnOnTheLightToSeeAttributeChange_9()
    {
        const chip::GroupId groupId = 257;
        using RequestType           = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupDemoCommandSuite *>(context))->OnSuccessResponse_9();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestGroupDemoCommandSuite *>(context))->OnFailureResponse_9(error);
        };

        auto done = [](void * context) { (static_cast<TestGroupDemoCommandSuite *>(context))->OnDoneResponse_9(); };

        ReturnErrorOnFailure(
            chip::Controller::InvokeGroupCommand(mDevices[kIdentityAlpha], this, success, failure, done, groupId, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_9(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_9() { NextTest(); }

    void OnDoneResponse_9() { NextTest(); }

    CHIP_ERROR TestWait100ms_10()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForMs(1000);
    }

    CHIP_ERROR TestTurnOffTheLightToSeeAttributeChange_11()
    {
        const chip::GroupId groupId = 257;
        using RequestType           = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupDemoCommandSuite *>(context))->OnSuccessResponse_11();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestGroupDemoCommandSuite *>(context))->OnFailureResponse_11(error);
        };

        auto done = [](void * context) { (static_cast<TestGroupDemoCommandSuite *>(context))->OnDoneResponse_11(); };

        ReturnErrorOnFailure(
            chip::Controller::InvokeGroupCommand(mDevices[kIdentityAlpha], this, success, failure, done, groupId, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_11(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_11() { NextTest(); }

    void OnDoneResponse_11() { NextTest(); }

    CHIP_ERROR TestWait100ms_12()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForMs(1000);
    }

    CHIP_ERROR TestTurnOnTheLightToSeeAttributeChange_13()
    {
        const chip::GroupId groupId = 257;
        using RequestType           = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupDemoCommandSuite *>(context))->OnSuccessResponse_13();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestGroupDemoCommandSuite *>(context))->OnFailureResponse_13(error);
        };

        auto done = [](void * context) { (static_cast<TestGroupDemoCommandSuite *>(context))->OnDoneResponse_13(); };

        ReturnErrorOnFailure(
            chip::Controller::InvokeGroupCommand(mDevices[kIdentityAlpha], this, success, failure, done, groupId, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_13(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_13() { NextTest(); }

    void OnDoneResponse_13() { NextTest(); }

    CHIP_ERROR TestWait100ms_14()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForMs(1000);
    }

    CHIP_ERROR TestTurnOffTheLightToSeeAttributeChange_15()
    {
        const chip::GroupId groupId = 257;
        using RequestType           = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupDemoCommandSuite *>(context))->OnSuccessResponse_15();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestGroupDemoCommandSuite *>(context))->OnFailureResponse_15(error);
        };

        auto done = [](void * context) { (static_cast<TestGroupDemoCommandSuite *>(context))->OnDoneResponse_15(); };

        ReturnErrorOnFailure(
            chip::Controller::InvokeGroupCommand(mDevices[kIdentityAlpha], this, success, failure, done, groupId, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_15(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_15() { NextTest(); }

    void OnDoneResponse_15() { NextTest(); }

    CHIP_ERROR TestWait100ms_16()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForMs(1000);
    }

    CHIP_ERROR TestTurnOnTheLightToSeeAttributeChange_17()
    {
        const chip::GroupId groupId = 257;
        using RequestType           = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupDemoCommandSuite *>(context))->OnSuccessResponse_17();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestGroupDemoCommandSuite *>(context))->OnFailureResponse_17(error);
        };

        auto done = [](void * context) { (static_cast<TestGroupDemoCommandSuite *>(context))->OnDoneResponse_17(); };

        ReturnErrorOnFailure(
            chip::Controller::InvokeGroupCommand(mDevices[kIdentityAlpha], this, success, failure, done, groupId, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_17(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_17() { NextTest(); }

    void OnDoneResponse_17() { NextTest(); }

    CHIP_ERROR TestWait100ms_18()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForMs(1000);
    }

    CHIP_ERROR TestTurnOffTheLightToSeeAttributeChange_19()
    {
        const chip::GroupId groupId = 257;
        using RequestType           = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupDemoCommandSuite *>(context))->OnSuccessResponse_19();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestGroupDemoCommandSuite *>(context))->OnFailureResponse_19(error);
        };

        auto done = [](void * context) { (static_cast<TestGroupDemoCommandSuite *>(context))->OnDoneResponse_19(); };

        ReturnErrorOnFailure(
            chip::Controller::InvokeGroupCommand(mDevices[kIdentityAlpha], this, success, failure, done, groupId, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_19(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_19() { NextTest(); }

    void OnDoneResponse_19() { NextTest(); }

    CHIP_ERROR TestWait100ms_20()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForMs(1000);
    }
};

class TestGroupDemoConfigSuite : public TestCommand
{
public:
    TestGroupDemoConfigSuite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("TestGroupDemoConfig", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~TestGroupDemoConfigSuite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestGroupDemoConfig\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestGroupDemoConfig\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Add Group 1 - endpoint 1\n");
            err = TestAddGroup1Endpoint1_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : KeySet Write 1\n");
            err = TestKeySetWrite1_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Map Group Key Set to group ID on a given fabric\n");
            err = TestMapGroupKeySetToGroupIdOnAGivenFabric_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Install ACLs for test\n");
            err = TestInstallACLsForTest_4();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 5;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    static void OnFailureCallback_3(void * context, CHIP_ERROR error)
    {
        (static_cast<TestGroupDemoConfigSuite *>(context))->OnFailureResponse_3(error);
    }

    static void OnSuccessCallback_3(void * context) { (static_cast<TestGroupDemoConfigSuite *>(context))->OnSuccessResponse_3(); }

    static void OnFailureCallback_4(void * context, CHIP_ERROR error)
    {
        (static_cast<TestGroupDemoConfigSuite *>(context))->OnFailureResponse_4(error);
    }

    static void OnSuccessCallback_4(void * context) { (static_cast<TestGroupDemoConfigSuite *>(context))->OnSuccessResponse_4(); }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
    }

    CHIP_ERROR TestAddGroup1Endpoint1_1()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 1;
        using RequestType               = chip::app::Clusters::Groups::Commands::AddGroup::Type;

        RequestType request;
        request.groupId   = 257U;
        request.groupName = chip::Span<const char>("Group #1garbage: not in length on purpose", 8);

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupDemoConfigSuite *>(context))->OnSuccessResponse_1(data.status, data.groupId);
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestGroupDemoConfigSuite *>(context))->OnFailureResponse_1(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_1(uint8_t status, chip::GroupId groupId)
    {
        VerifyOrReturn(CheckValue("status", status, 0));

        VerifyOrReturn(CheckValue("groupId", groupId, 257U));

        NextTest();
    }

    CHIP_ERROR TestKeySetWrite1_2()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        using RequestType               = chip::app::Clusters::GroupKeyManagement::Commands::KeySetWrite::Type;

        RequestType request;

        request.groupKeySet.groupKeySetID = 417U;
        request.groupKeySet.groupKeySecurityPolicy =
            static_cast<chip::app::Clusters::GroupKeyManagement::GroupKeySecurityPolicy>(1);
        request.groupKeySet.epochKey0.SetNonNull();
        request.groupKeySet.epochKey0.Value() =
            chip::ByteSpan(chip::Uint8::from_const_char(
                               "\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xafgarbage: not in length on purpose"),
                           16);
        request.groupKeySet.epochStartTime0.SetNonNull();
        request.groupKeySet.epochStartTime0.Value() = 1110000ULL;
        request.groupKeySet.epochKey1.SetNonNull();
        request.groupKeySet.epochKey1.Value() =
            chip::ByteSpan(chip::Uint8::from_const_char(
                               "\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbfgarbage: not in length on purpose"),
                           16);
        request.groupKeySet.epochStartTime1.SetNonNull();
        request.groupKeySet.epochStartTime1.Value() = 1110001ULL;
        request.groupKeySet.epochKey2.SetNonNull();
        request.groupKeySet.epochKey2.Value() =
            chip::ByteSpan(chip::Uint8::from_const_char(
                               "\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcfgarbage: not in length on purpose"),
                           16);
        request.groupKeySet.epochStartTime2.SetNonNull();
        request.groupKeySet.epochStartTime2.Value() = 1110002ULL;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupDemoConfigSuite *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<TestGroupDemoConfigSuite *>(context))->OnFailureResponse_2(error);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestMapGroupKeySetToGroupIdOnAGivenFabric_3()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        chip::Controller::GroupKeyManagementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ListFreer listFreer;
        chip::app::DataModel::List<const chip::app::Clusters::GroupKeyManagement::Structs::GroupKeyMapStruct::Type>
            groupKeyMapArgument;

        {
            auto * listHolder_0 = new ListHolder<chip::app::Clusters::GroupKeyManagement::Structs::GroupKeyMapStruct::Type>(1);
            listFreer.add(listHolder_0);

            listHolder_0->mList[0].fabricIndex   = 1;
            listHolder_0->mList[0].groupId       = 257U;
            listHolder_0->mList[0].groupKeySetID = 417U;

            groupKeyMapArgument =
                chip::app::DataModel::List<chip::app::Clusters::GroupKeyManagement::Structs::GroupKeyMapStruct::Type>(
                    listHolder_0->mList, 1);
        }

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::GroupKeyManagement::Attributes::GroupKeyMap::TypeInfo>(
            groupKeyMapArgument, this, OnSuccessCallback_3, OnFailureCallback_3));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestInstallACLsForTest_4()
    {
        const chip::EndpointId endpoint = mEndpoint.HasValue() ? mEndpoint.Value() : 0;
        chip::Controller::AccessControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ListFreer listFreer;
        chip::app::DataModel::List<const chip::app::Clusters::AccessControl::Structs::AccessControlEntry::Type> aclArgument;

        {
            auto * listHolder_0 = new ListHolder<chip::app::Clusters::AccessControl::Structs::AccessControlEntry::Type>(2);
            listFreer.add(listHolder_0);

            listHolder_0->mList[0].fabricIndex = 1;
            listHolder_0->mList[0].privilege   = static_cast<chip::app::Clusters::AccessControl::Privilege>(5);
            listHolder_0->mList[0].authMode    = static_cast<chip::app::Clusters::AccessControl::AuthMode>(2);
            listHolder_0->mList[0].subjects.SetNull();
            listHolder_0->mList[0].targets.SetNull();

            listHolder_0->mList[1].fabricIndex = 1;
            listHolder_0->mList[1].privilege   = static_cast<chip::app::Clusters::AccessControl::Privilege>(3);
            listHolder_0->mList[1].authMode    = static_cast<chip::app::Clusters::AccessControl::AuthMode>(3);
            listHolder_0->mList[1].subjects.SetNonNull();

            {
                auto * listHolder_3 = new ListHolder<uint64_t>(1);
                listFreer.add(listHolder_3);
                listHolder_3->mList[0]                  = 257ULL;
                listHolder_0->mList[1].subjects.Value() = chip::app::DataModel::List<uint64_t>(listHolder_3->mList, 1);
            }
            listHolder_0->mList[1].targets.SetNull();

            aclArgument = chip::app::DataModel::List<chip::app::Clusters::AccessControl::Structs::AccessControlEntry::Type>(
                listHolder_0->mList, 2);
        }

        ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::AccessControl::Attributes::Acl::TypeInfo>(
            aclArgument, this, OnSuccessCallback_4, OnFailureCallback_4));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(CHIP_ERROR error)
    {
        chip::app::StatusIB status(error);
        ThrowFailureResponse();
    }

    void OnSuccessResponse_4() { NextTest(); }
};

class Test_TC_BDX_1_1Suite : public TestCommand
{
public:
    Test_TC_BDX_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_BDX_1_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_BDX_1_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_BDX_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_BDX_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_BDX_1_2Suite : public TestCommand
{
public:
    Test_TC_BDX_1_2Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_BDX_1_2", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_BDX_1_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_BDX_1_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_BDX_1_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_BDX_1_3Suite : public TestCommand
{
public:
    Test_TC_BDX_1_3Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_BDX_1_3", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_BDX_1_3Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_BDX_1_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_BDX_1_3\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_BDX_1_5Suite : public TestCommand
{
public:
    Test_TC_BDX_1_5Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_BDX_1_5", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_BDX_1_5Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_BDX_1_5\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_BDX_1_5\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_BDX_1_6Suite : public TestCommand
{
public:
    Test_TC_BDX_1_6Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_BDX_1_6", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_BDX_1_6Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_BDX_1_6\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_BDX_1_6\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_BDX_2_1Suite : public TestCommand
{
public:
    Test_TC_BDX_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_BDX_2_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_BDX_2_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_BDX_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_BDX_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_BDX_2_2Suite : public TestCommand
{
public:
    Test_TC_BDX_2_2Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_BDX_2_2", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_BDX_2_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_BDX_2_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_BDX_2_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_BDX_2_3Suite : public TestCommand
{
public:
    Test_TC_BDX_2_3Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_BDX_2_3", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_BDX_2_3Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_BDX_2_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_BDX_2_3\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_BDX_2_4Suite : public TestCommand
{
public:
    Test_TC_BDX_2_4Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_BDX_2_4", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_BDX_2_4Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_BDX_2_4\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_BDX_2_4\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_BDX_2_5Suite : public TestCommand
{
public:
    Test_TC_BDX_2_5Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_BDX_2_5", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_BDX_2_5Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_BDX_2_5\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_BDX_2_5\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_BR_1Suite : public TestCommand
{
public:
    Test_TC_BR_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_BR_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_BR_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_BR_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_BR_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_BR_2Suite : public TestCommand
{
public:
    Test_TC_BR_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_BR_2", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_BR_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_BR_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_BR_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_BR_3Suite : public TestCommand
{
public:
    Test_TC_BR_3Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_BR_3", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_BR_3Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_BR_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_BR_3\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_BRAC_2_1Suite : public TestCommand
{
public:
    Test_TC_BRAC_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_BRAC_2_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_BRAC_2_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_BRAC_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_BRAC_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_BRAC_2_2Suite : public TestCommand
{
public:
    Test_TC_BRAC_2_2Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_BRAC_2_2", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_BRAC_2_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_BRAC_2_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_BRAC_2_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_DM_1_2Suite : public TestCommand
{
public:
    Test_TC_DM_1_2Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_DM_1_2", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_DM_1_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_DM_1_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_DM_1_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_DM_2_3Suite : public TestCommand
{
public:
    Test_TC_DM_2_3Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_DM_2_3", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_DM_2_3Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_DM_2_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_DM_2_3\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_DM_3_2Suite : public TestCommand
{
public:
    Test_TC_DM_3_2Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_DM_3_2", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_DM_3_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_DM_3_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_DM_3_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_DIAG_LOG_1_1Suite : public TestCommand
{
public:
    Test_TC_DIAG_LOG_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_DIAG_LOG_1_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_DIAG_LOG_1_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_DIAG_LOG_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_DIAG_LOG_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_DIAG_LOG_1_2Suite : public TestCommand
{
public:
    Test_TC_DIAG_LOG_1_2Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_DIAG_LOG_1_2", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_DIAG_LOG_1_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_DIAG_LOG_1_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_DIAG_LOG_1_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_DIAG_LOG_1_3Suite : public TestCommand
{
public:
    Test_TC_DIAG_LOG_1_3Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_DIAG_LOG_1_3", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_DIAG_LOG_1_3Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_DIAG_LOG_1_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_DIAG_LOG_1_3\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_DESC_1_1Suite : public TestCommand
{
public:
    Test_TC_DESC_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_DESC_1_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_DESC_1_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_DESC_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_DESC_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_ETHDIAG_1_2Suite : public TestCommand
{
public:
    Test_TC_ETHDIAG_1_2Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_ETHDIAG_1_2", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_ETHDIAG_1_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_ETHDIAG_1_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_ETHDIAG_1_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_GC_1_1Suite : public TestCommand
{
public:
    Test_TC_GC_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_GC_1_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_GC_1_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_GC_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_GC_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_GC_1_2Suite : public TestCommand
{
public:
    Test_TC_GC_1_2Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_GC_1_2", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_GC_1_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_GC_1_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_GC_1_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_GC_1_3Suite : public TestCommand
{
public:
    Test_TC_GC_1_3Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_GC_1_3", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_GC_1_3Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_GC_1_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_GC_1_3\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_GENDIAG_1_1Suite : public TestCommand
{
public:
    Test_TC_GENDIAG_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_GENDIAG_1_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_GENDIAG_1_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_GENDIAG_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_GENDIAG_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_GENDIAG_1_2Suite : public TestCommand
{
public:
    Test_TC_GENDIAG_1_2Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_GENDIAG_1_2", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_GENDIAG_1_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_GENDIAG_1_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_GENDIAG_1_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_I_1_1Suite : public TestCommand
{
public:
    Test_TC_I_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_I_1_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_I_1_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_I_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_I_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_I_2_1Suite : public TestCommand
{
public:
    Test_TC_I_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_I_2_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_I_2_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_I_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_I_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_I_2_2Suite : public TestCommand
{
public:
    Test_TC_I_2_2Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_I_2_2", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_I_2_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_I_2_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_I_2_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_I_2_3Suite : public TestCommand
{
public:
    Test_TC_I_2_3Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_I_2_3", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_I_2_3Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_I_2_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_I_2_3\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_ILL_2_1Suite : public TestCommand
{
public:
    Test_TC_ILL_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_ILL_2_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_ILL_2_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_ILL_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_ILL_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_IDM_1_1Suite : public TestCommand
{
public:
    Test_TC_IDM_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_IDM_1_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_IDM_1_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_IDM_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_IDM_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_IDM_1_2Suite : public TestCommand
{
public:
    Test_TC_IDM_1_2Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_IDM_1_2", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_IDM_1_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_IDM_1_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_IDM_1_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_IDM_2_1Suite : public TestCommand
{
public:
    Test_TC_IDM_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_IDM_2_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_IDM_2_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_IDM_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_IDM_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_IDM_2_2Suite : public TestCommand
{
public:
    Test_TC_IDM_2_2Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_IDM_2_2", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_IDM_2_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_IDM_2_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_IDM_2_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_IDM_3_1Suite : public TestCommand
{
public:
    Test_TC_IDM_3_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_IDM_3_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_IDM_3_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_IDM_3_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_IDM_3_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_IDM_3_2Suite : public TestCommand
{
public:
    Test_TC_IDM_3_2Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_IDM_3_2", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_IDM_3_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_IDM_3_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_IDM_3_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_IDM_4_1Suite : public TestCommand
{
public:
    Test_TC_IDM_4_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_IDM_4_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_IDM_4_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_IDM_4_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_IDM_4_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_IDM_4_2Suite : public TestCommand
{
public:
    Test_TC_IDM_4_2Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_IDM_4_2", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_IDM_4_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_IDM_4_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_IDM_4_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_IDM_5_1Suite : public TestCommand
{
public:
    Test_TC_IDM_5_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_IDM_5_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_IDM_5_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_IDM_5_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_IDM_5_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_IDM_5_2Suite : public TestCommand
{
public:
    Test_TC_IDM_5_2Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_IDM_5_2", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_IDM_5_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_IDM_5_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_IDM_5_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_IDM_6_1Suite : public TestCommand
{
public:
    Test_TC_IDM_6_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_IDM_6_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_IDM_6_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_IDM_6_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_IDM_6_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_IDM_6_2Suite : public TestCommand
{
public:
    Test_TC_IDM_6_2Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_IDM_6_2", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_IDM_6_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_IDM_6_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_IDM_6_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_MC_3_12Suite : public TestCommand
{
public:
    Test_TC_MC_3_12Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_MC_3_12", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MC_3_12Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_3_12\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_3_12\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_MC_4_1Suite : public TestCommand
{
public:
    Test_TC_MC_4_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_MC_4_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MC_4_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_4_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_4_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_MC_8_2Suite : public TestCommand
{
public:
    Test_TC_MC_8_2Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_MC_8_2", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MC_8_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_8_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_8_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_MC_9_2Suite : public TestCommand
{
public:
    Test_TC_MC_9_2Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_MC_9_2", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MC_9_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_9_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_9_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_MC_10_1Suite : public TestCommand
{
public:
    Test_TC_MC_10_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_MC_10_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MC_10_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_10_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_10_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_MC_10_2Suite : public TestCommand
{
public:
    Test_TC_MC_10_2Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_MC_10_2", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MC_10_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_10_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_10_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_MC_10_3Suite : public TestCommand
{
public:
    Test_TC_MC_10_3Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_MC_10_3", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MC_10_3Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_10_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_10_3\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_MC_10_4Suite : public TestCommand
{
public:
    Test_TC_MC_10_4Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_MC_10_4", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MC_10_4Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_10_4\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_10_4\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_MC_10_5Suite : public TestCommand
{
public:
    Test_TC_MC_10_5Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_MC_10_5", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MC_10_5Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_10_5\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_10_5\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_MC_10_6Suite : public TestCommand
{
public:
    Test_TC_MC_10_6Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_MC_10_6", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MC_10_6Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_10_6\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_10_6\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_MF_1_1Suite : public TestCommand
{
public:
    Test_TC_MF_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_MF_1_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MF_1_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MF_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MF_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_MF_1_2Suite : public TestCommand
{
public:
    Test_TC_MF_1_2Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_MF_1_2", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MF_1_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MF_1_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MF_1_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_MF_1_3Suite : public TestCommand
{
public:
    Test_TC_MF_1_3Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_MF_1_3", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MF_1_3Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MF_1_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MF_1_3\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_MF_1_4Suite : public TestCommand
{
public:
    Test_TC_MF_1_4Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_MF_1_4", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MF_1_4Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MF_1_4\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MF_1_4\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_MF_1_5Suite : public TestCommand
{
public:
    Test_TC_MF_1_5Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_MF_1_5", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MF_1_5Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MF_1_5\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MF_1_5\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_MF_1_6Suite : public TestCommand
{
public:
    Test_TC_MF_1_6Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_MF_1_6", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MF_1_6Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MF_1_6\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MF_1_6\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_MF_1_7Suite : public TestCommand
{
public:
    Test_TC_MF_1_7Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_MF_1_7", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MF_1_7Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MF_1_7\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MF_1_7\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_MF_1_8Suite : public TestCommand
{
public:
    Test_TC_MF_1_8Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_MF_1_8", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MF_1_8Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MF_1_8\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MF_1_8\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_MF_1_9Suite : public TestCommand
{
public:
    Test_TC_MF_1_9Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_MF_1_9", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MF_1_9Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MF_1_9\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MF_1_9\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_MF_1_10Suite : public TestCommand
{
public:
    Test_TC_MF_1_10Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_MF_1_10", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MF_1_10Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MF_1_10\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MF_1_10\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_MF_1_11Suite : public TestCommand
{
public:
    Test_TC_MF_1_11Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_MF_1_11", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MF_1_11Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MF_1_11\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MF_1_11\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_MF_1_12Suite : public TestCommand
{
public:
    Test_TC_MF_1_12Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_MF_1_12", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MF_1_12Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MF_1_12\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MF_1_12\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_MF_1_13Suite : public TestCommand
{
public:
    Test_TC_MF_1_13Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_MF_1_13", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MF_1_13Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MF_1_13\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MF_1_13\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_MF_1_14Suite : public TestCommand
{
public:
    Test_TC_MF_1_14Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_MF_1_14", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MF_1_14Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MF_1_14\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MF_1_14\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_MF_1_15Suite : public TestCommand
{
public:
    Test_TC_MF_1_15Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_MF_1_15", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MF_1_15Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MF_1_15\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MF_1_15\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_MF_1_16Suite : public TestCommand
{
public:
    Test_TC_MF_1_16Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_MF_1_16", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MF_1_16Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MF_1_16\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MF_1_16\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_MF_1_17Suite : public TestCommand
{
public:
    Test_TC_MF_1_17Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_MF_1_17", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MF_1_17Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MF_1_17\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MF_1_17\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_MF_1_18Suite : public TestCommand
{
public:
    Test_TC_MF_1_18Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_MF_1_18", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MF_1_18Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MF_1_18\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MF_1_18\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_MF_1_19Suite : public TestCommand
{
public:
    Test_TC_MF_1_19Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_MF_1_19", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MF_1_19Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MF_1_19\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MF_1_19\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_MF_1_20Suite : public TestCommand
{
public:
    Test_TC_MF_1_20Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_MF_1_20", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MF_1_20Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MF_1_20\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MF_1_20\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_MF_1_21Suite : public TestCommand
{
public:
    Test_TC_MF_1_21Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_MF_1_21", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MF_1_21Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MF_1_21\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MF_1_21\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_MF_1_22Suite : public TestCommand
{
public:
    Test_TC_MF_1_22Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_MF_1_22", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MF_1_22Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MF_1_22\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MF_1_22\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_MF_1_23Suite : public TestCommand
{
public:
    Test_TC_MF_1_23Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_MF_1_23", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MF_1_23Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MF_1_23\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MF_1_23\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_MF_1_24Suite : public TestCommand
{
public:
    Test_TC_MF_1_24Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_MF_1_24", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MF_1_24Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MF_1_24\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MF_1_24\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_MOD_1_1Suite : public TestCommand
{
public:
    Test_TC_MOD_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_MOD_1_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MOD_1_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MOD_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MOD_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_MOD_1_2Suite : public TestCommand
{
public:
    Test_TC_MOD_1_2Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_MOD_1_2", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MOD_1_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MOD_1_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MOD_1_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_MOD_2_1Suite : public TestCommand
{
public:
    Test_TC_MOD_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_MOD_2_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_MOD_2_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MOD_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MOD_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_SU_1_1Suite : public TestCommand
{
public:
    Test_TC_SU_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_SU_1_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_SU_1_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_SU_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_SU_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_SU_2_1Suite : public TestCommand
{
public:
    Test_TC_SU_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_SU_2_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_SU_2_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_SU_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_SU_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_SU_2_2Suite : public TestCommand
{
public:
    Test_TC_SU_2_2Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_SU_2_2", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_SU_2_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_SU_2_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_SU_2_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_SU_2_3Suite : public TestCommand
{
public:
    Test_TC_SU_2_3Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_SU_2_3", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_SU_2_3Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_SU_2_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_SU_2_3\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_SU_2_4Suite : public TestCommand
{
public:
    Test_TC_SU_2_4Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_SU_2_4", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_SU_2_4Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_SU_2_4\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_SU_2_4\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_SU_2_5Suite : public TestCommand
{
public:
    Test_TC_SU_2_5Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_SU_2_5", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_SU_2_5Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_SU_2_5\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_SU_2_5\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_SU_2_6Suite : public TestCommand
{
public:
    Test_TC_SU_2_6Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_SU_2_6", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_SU_2_6Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_SU_2_6\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_SU_2_6\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_SU_2_7Suite : public TestCommand
{
public:
    Test_TC_SU_2_7Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_SU_2_7", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_SU_2_7Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_SU_2_7\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_SU_2_7\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_SU_3_1Suite : public TestCommand
{
public:
    Test_TC_SU_3_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_SU_3_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_SU_3_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_SU_3_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_SU_3_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_SU_3_2Suite : public TestCommand
{
public:
    Test_TC_SU_3_2Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_SU_3_2", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_SU_3_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_SU_3_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_SU_3_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_SU_3_3Suite : public TestCommand
{
public:
    Test_TC_SU_3_3Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_SU_3_3", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_SU_3_3Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_SU_3_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_SU_3_3\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_SU_3_4Suite : public TestCommand
{
public:
    Test_TC_SU_3_4Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_SU_3_4", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_SU_3_4Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_SU_3_4\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_SU_3_4\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_PSCFG_1_1Suite : public TestCommand
{
public:
    Test_TC_PSCFG_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_PSCFG_1_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_PSCFG_1_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_PSCFG_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_PSCFG_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_PSCFG_2_1Suite : public TestCommand
{
public:
    Test_TC_PSCFG_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_PSCFG_2_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_PSCFG_2_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_PSCFG_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_PSCFG_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_SC_4_5Suite : public TestCommand
{
public:
    Test_TC_SC_4_5Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_SC_4_5", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_SC_4_5Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_SC_4_5\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_SC_4_5\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_SC_4_6Suite : public TestCommand
{
public:
    Test_TC_SC_4_6Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_SC_4_6", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_SC_4_6Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_SC_4_6\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_SC_4_6\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_SC_4_7Suite : public TestCommand
{
public:
    Test_TC_SC_4_7Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_SC_4_7", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_SC_4_7Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_SC_4_7\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_SC_4_7\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_SC_4_8Suite : public TestCommand
{
public:
    Test_TC_SC_4_8Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_SC_4_8", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_SC_4_8Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_SC_4_8\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_SC_4_8\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_SC_4_9Suite : public TestCommand
{
public:
    Test_TC_SC_4_9Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_SC_4_9", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_SC_4_9Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_SC_4_9\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_SC_4_9\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_SWDIAG_1_2Suite : public TestCommand
{
public:
    Test_TC_SWDIAG_1_2Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_SWDIAG_1_2", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_SWDIAG_1_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_SWDIAG_1_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_SWDIAG_1_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_WIFIDIAG_1_2Suite : public TestCommand
{
public:
    Test_TC_WIFIDIAG_1_2Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_WIFIDIAG_1_2", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_WIFIDIAG_1_2Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_WIFIDIAG_1_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_WIFIDIAG_1_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_WIFIDIAG_2_1Suite : public TestCommand
{
public:
    Test_TC_WIFIDIAG_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_WIFIDIAG_2_1", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_WIFIDIAG_2_1Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_WIFIDIAG_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_WIFIDIAG_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

class Test_TC_WNCV_2_3Suite : public TestCommand
{
public:
    Test_TC_WNCV_2_3Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_WNCV_2_3", credsIssuerConfig), mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_WNCV_2_3Suite() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_WNCV_2_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_WNCV_2_3\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & value) override
    {
        bool isExpectedDnssdResult = false;

        VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
        NextTest();
    }

    //
    // Tests methods
    //
};

void registerCommandsTests(Commands & commands, CredentialIssuerCommands * credsIssuerConfig)
{
    const char * clusterName = "Tests";

    commands_list clusterCommands = {
        make_unique<TestList>(),
        make_unique<ManualTestList>(),
        make_unique<TestAccessControlClusterSuite>(credsIssuerConfig),
        make_unique<Test_TC_BI_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_BI_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_BI_2_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_BOOL_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_BOOL_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_BRAC_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_CC_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_CC_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_CC_3_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_CC_3_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_CC_3_3Suite>(credsIssuerConfig),
        make_unique<Test_TC_CC_4_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_CC_4_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_CC_4_3Suite>(credsIssuerConfig),
        make_unique<Test_TC_CC_4_4Suite>(credsIssuerConfig),
        make_unique<Test_TC_CC_5_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_CC_5_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_CC_5_3Suite>(credsIssuerConfig),
        make_unique<Test_TC_CC_6_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_CC_6_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_CC_6_3Suite>(credsIssuerConfig),
        make_unique<Test_TC_CC_7_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_CC_7_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_CC_7_3Suite>(credsIssuerConfig),
        make_unique<Test_TC_CC_7_4Suite>(credsIssuerConfig),
        make_unique<Test_TC_CC_8_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_CC_9_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_CC_9_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_CC_9_3Suite>(credsIssuerConfig),
        make_unique<Test_TC_DM_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_DM_3_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_DM_2_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_EMR_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_ETHDIAG_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_ETHDIAG_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_FLW_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_FLW_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_FLW_2_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_ILL_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_LVL_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_LVL_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_LVL_2_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_LVL_3_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_LVL_4_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_LVL_5_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_LVL_6_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_3_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_3_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_3_3Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_3_4Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_3_5Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_3_6Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_3_7Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_3_8Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_3_9Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_3_10Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_3_11Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_5_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_5_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_5_3Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_6_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_6_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_6_3Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_6_4Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_7_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_7_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_8_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_9_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_OCC_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_OCC_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_OCC_2_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_OO_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_OO_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_OO_2_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_OO_2_3Suite>(credsIssuerConfig),
        make_unique<Test_TC_PS_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_PRS_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_PRS_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_PCC_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_PCC_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_PCC_2_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_PCC_2_3Suite>(credsIssuerConfig),
        make_unique<Test_TC_RH_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_RH_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_RH_2_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_SWTCH_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_SWTCH_2_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_TM_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_TM_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_TM_2_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_TSTAT_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_TSTAT_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_TSTAT_2_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_TSUIC_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_TSUIC_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_TSUIC_2_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_DIAG_TH_NW_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_WIFIDIAG_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_WIFIDIAG_3_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_WNCV_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_WNCV_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_WNCV_2_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_WNCV_2_4Suite>(credsIssuerConfig),
        make_unique<Test_TC_WNCV_2_5Suite>(credsIssuerConfig),
        make_unique<Test_TC_WNCV_3_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_WNCV_3_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_WNCV_3_3Suite>(credsIssuerConfig),
        make_unique<Test_TC_WNCV_3_4Suite>(credsIssuerConfig),
        make_unique<Test_TC_WNCV_3_5Suite>(credsIssuerConfig),
        make_unique<Test_TC_WNCV_4_3Suite>(credsIssuerConfig),
        make_unique<Test_TC_WNCV_4_4Suite>(credsIssuerConfig),
        make_unique<TV_TargetNavigatorClusterSuite>(credsIssuerConfig),
        make_unique<TV_AudioOutputClusterSuite>(credsIssuerConfig),
        make_unique<TV_ApplicationLauncherClusterSuite>(credsIssuerConfig),
        make_unique<TV_KeypadInputClusterSuite>(credsIssuerConfig),
        make_unique<TV_AccountLoginClusterSuite>(credsIssuerConfig),
        make_unique<TV_WakeOnLanClusterSuite>(credsIssuerConfig),
        make_unique<TV_ApplicationBasicClusterSuite>(credsIssuerConfig),
        make_unique<TV_MediaPlaybackClusterSuite>(credsIssuerConfig),
        make_unique<TV_ChannelClusterSuite>(credsIssuerConfig),
        make_unique<TV_LowPowerClusterSuite>(credsIssuerConfig),
        make_unique<TV_ContentLauncherClusterSuite>(credsIssuerConfig),
        make_unique<TV_MediaInputClusterSuite>(credsIssuerConfig),
        make_unique<TestClusterSuite>(credsIssuerConfig),
        make_unique<TestClusterComplexTypesSuite>(credsIssuerConfig),
        make_unique<TestConstraintsSuite>(credsIssuerConfig),
        make_unique<TestDelayCommandsSuite>(credsIssuerConfig),
        make_unique<TestDiscoverySuite>(credsIssuerConfig),
        make_unique<TestLogCommandsSuite>(credsIssuerConfig),
        make_unique<TestSaveAsSuite>(credsIssuerConfig),
        make_unique<TestConfigVariablesSuite>(credsIssuerConfig),
        make_unique<TestDescriptorClusterSuite>(credsIssuerConfig),
        make_unique<TestBasicInformationSuite>(credsIssuerConfig),
        make_unique<TestIdentifyClusterSuite>(credsIssuerConfig),
        make_unique<TestOperationalCredentialsClusterSuite>(credsIssuerConfig),
        make_unique<TestModeSelectClusterSuite>(credsIssuerConfig),
        make_unique<TestSystemCommandsSuite>(credsIssuerConfig),
        make_unique<TestBindingSuite>(credsIssuerConfig),
        make_unique<Test_TC_SWDIAG_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_SWDIAG_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_SWDIAG_3_1Suite>(credsIssuerConfig),
        make_unique<TestSubscribe_OnOffSuite>(credsIssuerConfig),
        make_unique<DL_UsersAndCredentialsSuite>(credsIssuerConfig),
        make_unique<DL_LockUnlockSuite>(credsIssuerConfig),
        make_unique<DL_SchedulesSuite>(credsIssuerConfig),
        make_unique<TestGroupMessagingSuite>(credsIssuerConfig),
        make_unique<TestGroupsClusterSuite>(credsIssuerConfig),
        make_unique<TestGroupKeyManagementClusterSuite>(credsIssuerConfig),
        make_unique<Test_TC_DD_1_5Suite>(credsIssuerConfig),
        make_unique<Test_TC_DD_1_6Suite>(credsIssuerConfig),
        make_unique<Test_TC_DD_1_7Suite>(credsIssuerConfig),
        make_unique<Test_TC_DD_1_8Suite>(credsIssuerConfig),
        make_unique<Test_TC_DD_1_9Suite>(credsIssuerConfig),
        make_unique<Test_TC_DD_1_10Suite>(credsIssuerConfig),
        make_unique<Test_TC_DD_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_DD_2_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_DD_3_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_DD_3_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_DD_3_5Suite>(credsIssuerConfig),
        make_unique<Test_TC_DD_3_6Suite>(credsIssuerConfig),
        make_unique<Test_TC_DD_3_9Suite>(credsIssuerConfig),
        make_unique<Test_TC_DD_3_10Suite>(credsIssuerConfig),
        make_unique<Test_TC_DD_4_1Suite>(credsIssuerConfig),
        make_unique<TestGroupDemoCommandSuite>(credsIssuerConfig),
        make_unique<TestGroupDemoConfigSuite>(credsIssuerConfig),
        make_unique<Test_TC_BDX_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_BDX_1_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_BDX_1_3Suite>(credsIssuerConfig),
        make_unique<Test_TC_BDX_1_5Suite>(credsIssuerConfig),
        make_unique<Test_TC_BDX_1_6Suite>(credsIssuerConfig),
        make_unique<Test_TC_BDX_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_BDX_2_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_BDX_2_3Suite>(credsIssuerConfig),
        make_unique<Test_TC_BDX_2_4Suite>(credsIssuerConfig),
        make_unique<Test_TC_BDX_2_5Suite>(credsIssuerConfig),
        make_unique<Test_TC_BR_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_BR_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_BR_3Suite>(credsIssuerConfig),
        make_unique<Test_TC_BRAC_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_BRAC_2_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_DM_1_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_DM_2_3Suite>(credsIssuerConfig),
        make_unique<Test_TC_DM_3_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_DIAG_LOG_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_DIAG_LOG_1_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_DIAG_LOG_1_3Suite>(credsIssuerConfig),
        make_unique<Test_TC_DESC_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_ETHDIAG_1_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_GC_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_GC_1_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_GC_1_3Suite>(credsIssuerConfig),
        make_unique<Test_TC_GENDIAG_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_GENDIAG_1_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_I_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_I_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_I_2_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_I_2_3Suite>(credsIssuerConfig),
        make_unique<Test_TC_ILL_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_IDM_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_IDM_1_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_IDM_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_IDM_2_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_IDM_3_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_IDM_3_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_IDM_4_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_IDM_4_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_IDM_5_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_IDM_5_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_IDM_6_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_IDM_6_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_3_12Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_4_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_8_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_9_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_10_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_10_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_10_3Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_10_4Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_10_5Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_10_6Suite>(credsIssuerConfig),
        make_unique<Test_TC_MF_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_MF_1_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_MF_1_3Suite>(credsIssuerConfig),
        make_unique<Test_TC_MF_1_4Suite>(credsIssuerConfig),
        make_unique<Test_TC_MF_1_5Suite>(credsIssuerConfig),
        make_unique<Test_TC_MF_1_6Suite>(credsIssuerConfig),
        make_unique<Test_TC_MF_1_7Suite>(credsIssuerConfig),
        make_unique<Test_TC_MF_1_8Suite>(credsIssuerConfig),
        make_unique<Test_TC_MF_1_9Suite>(credsIssuerConfig),
        make_unique<Test_TC_MF_1_10Suite>(credsIssuerConfig),
        make_unique<Test_TC_MF_1_11Suite>(credsIssuerConfig),
        make_unique<Test_TC_MF_1_12Suite>(credsIssuerConfig),
        make_unique<Test_TC_MF_1_13Suite>(credsIssuerConfig),
        make_unique<Test_TC_MF_1_14Suite>(credsIssuerConfig),
        make_unique<Test_TC_MF_1_15Suite>(credsIssuerConfig),
        make_unique<Test_TC_MF_1_16Suite>(credsIssuerConfig),
        make_unique<Test_TC_MF_1_17Suite>(credsIssuerConfig),
        make_unique<Test_TC_MF_1_18Suite>(credsIssuerConfig),
        make_unique<Test_TC_MF_1_19Suite>(credsIssuerConfig),
        make_unique<Test_TC_MF_1_20Suite>(credsIssuerConfig),
        make_unique<Test_TC_MF_1_21Suite>(credsIssuerConfig),
        make_unique<Test_TC_MF_1_22Suite>(credsIssuerConfig),
        make_unique<Test_TC_MF_1_23Suite>(credsIssuerConfig),
        make_unique<Test_TC_MF_1_24Suite>(credsIssuerConfig),
        make_unique<Test_TC_MOD_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_MOD_1_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_MOD_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_SU_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_SU_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_SU_2_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_SU_2_3Suite>(credsIssuerConfig),
        make_unique<Test_TC_SU_2_4Suite>(credsIssuerConfig),
        make_unique<Test_TC_SU_2_5Suite>(credsIssuerConfig),
        make_unique<Test_TC_SU_2_6Suite>(credsIssuerConfig),
        make_unique<Test_TC_SU_2_7Suite>(credsIssuerConfig),
        make_unique<Test_TC_SU_3_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_SU_3_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_SU_3_3Suite>(credsIssuerConfig),
        make_unique<Test_TC_SU_3_4Suite>(credsIssuerConfig),
        make_unique<Test_TC_PSCFG_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_PSCFG_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_SC_4_5Suite>(credsIssuerConfig),
        make_unique<Test_TC_SC_4_6Suite>(credsIssuerConfig),
        make_unique<Test_TC_SC_4_7Suite>(credsIssuerConfig),
        make_unique<Test_TC_SC_4_8Suite>(credsIssuerConfig),
        make_unique<Test_TC_SC_4_9Suite>(credsIssuerConfig),
        make_unique<Test_TC_SWDIAG_1_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_WIFIDIAG_1_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_WIFIDIAG_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_WNCV_2_3Suite>(credsIssuerConfig),
    };

    commands.Register(clusterName, clusterCommands);
}
