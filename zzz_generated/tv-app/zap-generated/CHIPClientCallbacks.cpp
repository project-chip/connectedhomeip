/*
 *
 *    Copyright (c) 2021 Project CHIP Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

// THIS FILE IS GENERATED BY ZAP

#include <zap-generated/CHIPClientCallbacks.h>

#include <cinttypes>

#include <app-common/zap-generated/enums.h>
#include <app/Command.h>
#include <app/util/CHIPDeviceCallbacksMgr.h>
#include <app/util/af-enums.h>
#include <app/util/af.h>
#include <app/util/attribute-list-byte-span.h>
#include <app/util/basic-types.h>
#include <app/util/prepare-list.h>
#include <lib/core/CHIPEncoding.h>
#include <lib/support/SafeInt.h>
#include <lib/support/TypeTraits.h>
#include <lib/support/logging/CHIPLogging.h>

using namespace ::chip;
using namespace ::chip::app::List;

namespace {
[[maybe_unused]] constexpr uint16_t kByteSpanSizeLengthInBytes = 2;
} // namespace

#define CHECK_STATUS_WITH_RETVAL(error, retval)                                                                                    \
    if (CHIP_NO_ERROR != error)                                                                                                    \
    {                                                                                                                              \
        ChipLogError(Zcl, "CHECK_STATUS %s", ErrorStr(error));                                                                     \
        if (onFailureCallback != nullptr)                                                                                          \
        {                                                                                                                          \
            Callback::Callback<DefaultFailureCallback> * cb =                                                                      \
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);                                     \
            cb->mCall(cb->mContext, static_cast<uint8_t>(EMBER_ZCL_STATUS_INVALID_VALUE));                                         \
        }                                                                                                                          \
        return retval;                                                                                                             \
    }

#define CHECK_STATUS(error) CHECK_STATUS_WITH_RETVAL(error, true)
#define CHECK_STATUS_VOID(error) CHECK_STATUS_WITH_RETVAL(error, )

#define CHECK_MESSAGE_LENGTH_WITH_RETVAL(value, retval)                                                                            \
    if (!CanCastTo<uint16_t>(value))                                                                                               \
    {                                                                                                                              \
        ChipLogError(Zcl, "CHECK_MESSAGE_LENGTH expects a uint16_t value, got: %d", value);                                        \
        if (onFailureCallback != nullptr)                                                                                          \
        {                                                                                                                          \
            Callback::Callback<DefaultFailureCallback> * cb =                                                                      \
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);                                     \
            cb->mCall(cb->mContext, static_cast<uint8_t>(EMBER_ZCL_STATUS_INVALID_VALUE));                                         \
        }                                                                                                                          \
        return retval;                                                                                                             \
    }                                                                                                                              \
                                                                                                                                   \
    if (messageLen < value)                                                                                                        \
    {                                                                                                                              \
        ChipLogError(Zcl, "Unexpected response length: %d", messageLen);                                                           \
        if (onFailureCallback != nullptr)                                                                                          \
        {                                                                                                                          \
            Callback::Callback<DefaultFailureCallback> * cb =                                                                      \
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);                                     \
            cb->mCall(cb->mContext, static_cast<uint8_t>(EMBER_ZCL_STATUS_INVALID_VALUE));                                         \
        }                                                                                                                          \
        return retval;                                                                                                             \
    }                                                                                                                              \
                                                                                                                                   \
    messageLen = static_cast<uint16_t>(messageLen - static_cast<uint16_t>(value));

#define CHECK_MESSAGE_LENGTH(value) CHECK_MESSAGE_LENGTH_WITH_RETVAL(value, true)
#define CHECK_MESSAGE_LENGTH_VOID(value) CHECK_MESSAGE_LENGTH_WITH_RETVAL(value, )

#define GET_RESPONSE_CALLBACKS(name)                                                                                               \
    Callback::Cancelable * onSuccessCallback = nullptr;                                                                            \
    Callback::Cancelable * onFailureCallback = nullptr;                                                                            \
    NodeId sourceId                          = emberAfCurrentCommand()->SourceNodeId();                                            \
    uint8_t sequenceNumber                   = emberAfCurrentCommand()->seqNum;                                                    \
    CHIP_ERROR err = gCallbacks.GetResponseCallback(sourceId, sequenceNumber, &onSuccessCallback, &onFailureCallback);             \
                                                                                                                                   \
    if (CHIP_NO_ERROR != err)                                                                                                      \
    {                                                                                                                              \
        if (onSuccessCallback == nullptr)                                                                                          \
        {                                                                                                                          \
            ChipLogDetail(Zcl, "%s: Missing success callback", name);                                                              \
        }                                                                                                                          \
                                                                                                                                   \
        if (onFailureCallback == nullptr)                                                                                          \
        {                                                                                                                          \
            ChipLogDetail(Zcl, "%s: Missing failure callback", name);                                                              \
        }                                                                                                                          \
                                                                                                                                   \
        return true;                                                                                                               \
    }

#define GET_CLUSTER_RESPONSE_CALLBACKS(name)                                                                                       \
    Callback::Cancelable * onSuccessCallback = nullptr;                                                                            \
    Callback::Cancelable * onFailureCallback = nullptr;                                                                            \
    NodeId sourceIdentifier                  = reinterpret_cast<NodeId>(commandObj);                                               \
    /* #6559: Currently, we only have one commands for the IMInvokeCommands and to a device, so the seqNum is always set to 0. */  \
    CHIP_ERROR err = gCallbacks.GetResponseCallback(sourceIdentifier, 0, &onSuccessCallback, &onFailureCallback);                  \
                                                                                                                                   \
    if (CHIP_NO_ERROR != err)                                                                                                      \
    {                                                                                                                              \
        if (onSuccessCallback == nullptr)                                                                                          \
        {                                                                                                                          \
            ChipLogDetail(Zcl, "%s: Missing success callback", name);                                                              \
        }                                                                                                                          \
                                                                                                                                   \
        if (onFailureCallback == nullptr)                                                                                          \
        {                                                                                                                          \
            ChipLogDetail(Zcl, "%s: Missing failure callback", name);                                                              \
        }                                                                                                                          \
                                                                                                                                   \
        return true;                                                                                                               \
    }

// TODO: These IM related callbacks contains small or no generated code, should be put into seperate file to reduce the size of
// template. Singleton instance of the callbacks manager

app::CHIPDeviceCallbacksMgr & gCallbacks = app::CHIPDeviceCallbacksMgr::GetInstance();

bool emberAfDiscoverAttributesResponseCallback(ClusterId clusterId, bool discoveryComplete, uint8_t * message, uint16_t messageLen,
                                               bool extended)
{
    ChipLogProgress(Zcl, "DiscoverAttributesResponse:");
    ChipLogProgress(Zcl, "  ClusterId: " ChipLogFormatMEI, ChipLogValueMEI(clusterId));
    ChipLogProgress(Zcl, "  discoveryComplete: %d", discoveryComplete);
    ChipLogProgress(Zcl, "  extended: %d", extended);

    GET_RESPONSE_CALLBACKS("emberAfDiscoverAttributesCallback");

    // struct discoverAttributesResponseRecord[]
    while (messageLen)
    {
        CHECK_MESSAGE_LENGTH(4);
        AttributeId attributeId = Encoding::LittleEndian::Read32(message); // attribId
        ChipLogProgress(Zcl, "  attributeId: " ChipLogFormatMEI, ChipLogValueMEI(attributeId));
        // Silence unused var warning if progress logging is disabled.  Note
        // that we _do_ want to call Read32 unconditionally here, because we
        // want to advance the 'message' pointer even if we don't use
        // attributeId.
        UNUSED_VAR(attributeId);

        CHECK_MESSAGE_LENGTH(1);
        uint8_t attributeType = Encoding::Read8(message); // zclType
        ChipLogProgress(Zcl, "  attributeType: 0x%02x", attributeType);
        // Silence unused var warning if progress logging is disabled.  Note
        // that we _do_ want to call Read8 unconditionally here, because we want
        // to advance the 'message' pointer even if we don't use attributeType.
        UNUSED_VAR(attributeType);
    }

    Callback::Callback<DefaultSuccessCallback> * cb = Callback::Callback<DefaultSuccessCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext);
    return true;
}

bool emberAfDiscoverCommandsGeneratedResponseCallback(ClusterId clusterId, uint16_t manufacturerCode, bool discoveryComplete,
                                                      CommandId * commandIds, uint16_t commandIdCount)
{
    ChipLogProgress(Zcl, "DiscoverCommandsGeneratedResponse:");
    ChipLogProgress(Zcl, "  ClusterId: " ChipLogFormatMEI, ChipLogValueMEI(clusterId));
    ChipLogProgress(Zcl, "  manufacturerCode: 0x%04x", manufacturerCode);
    ChipLogProgress(Zcl, "  discoveryComplete: %d", discoveryComplete);
    ChipLogProgress(Zcl, "  commandIdCount: %" PRIu16, commandIdCount);

    for (uint16_t i = 0; i < commandIdCount; i++)
    {
        ChipLogProgress(Zcl, "  commandId: " ChipLogFormatMEI, ChipLogValueMEI(*commandIds));
        commandIds++;
    }

    GET_RESPONSE_CALLBACKS("emberAfDiscoverCommandsGeneratedResponseCallback");
    Callback::Callback<DefaultSuccessCallback> * cb = Callback::Callback<DefaultSuccessCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext);
    return true;
}

bool emberAfDiscoverCommandsReceivedResponseCallback(ClusterId clusterId, uint16_t manufacturerCode, bool discoveryComplete,
                                                     CommandId * commandIds, uint16_t commandIdCount)
{
    ChipLogProgress(Zcl, "DiscoverCommandsReceivedResponse:");
    ChipLogProgress(Zcl, "  ClusterId: " ChipLogFormatMEI, ChipLogValueMEI(clusterId));
    ChipLogProgress(Zcl, "  manufacturerCode: 0x%04x", manufacturerCode);
    ChipLogProgress(Zcl, "  discoveryComplete: %d", discoveryComplete);
    ChipLogProgress(Zcl, "  commandIdCount: %" PRIu16, commandIdCount);

    for (uint16_t i = 0; i < commandIdCount; i++)
    {
        ChipLogProgress(Zcl, "  commandId: " ChipLogFormatMEI, ChipLogValueMEI(*commandIds));
        commandIds++;
    }

    GET_RESPONSE_CALLBACKS("emberAfDiscoverCommandsGeneratedResponseCallback");
    Callback::Callback<DefaultSuccessCallback> * cb = Callback::Callback<DefaultSuccessCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext);
    return true;
}

#if !defined(__clang__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstack-usage="
#endif // __clang__
void GeneralCommissioningClusterBasicCommissioningInfoListListAttributeFilter(TLV::TLVReader * tlvData,
                                                                              Callback::Cancelable * onSuccessCallback,
                                                                              Callback::Cancelable * onFailureCallback)
{
    // TODO: Add actual support for array and lists.
    const uint8_t * message = nullptr;
    uint16_t messageLen     = 0;
    EmberAfStatus res       = PrepareListFromTLV(tlvData, message, messageLen);
    if (res != EMBER_ZCL_STATUS_SUCCESS)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, res);
        }
        return;
    }

    CHECK_MESSAGE_LENGTH_VOID(2);
    uint16_t count = Encoding::LittleEndian::Read16(message);
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wvla"
    _BasicCommissioningInfoType data[count];
#pragma GCC diagnostic pop
    for (size_t i = 0; i < count; i++)
    {
        CHECK_MESSAGE_LENGTH_VOID(4);
        data[i].FailSafeExpiryLengthMs = emberAfGetInt32u(message, 0, 4);
        message += 4;
    }
    Callback::Callback<GeneralCommissioningBasicCommissioningInfoListListAttributeCallback> * cb =
        Callback::Callback<GeneralCommissioningBasicCommissioningInfoListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, count, data);
}
#if !defined(__clang__)
#pragma GCC diagnostic pop
#endif // __clang__

#if !defined(__clang__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstack-usage="
#endif // __clang__
void OperationalCredentialsClusterFabricsListListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                                 Callback::Cancelable * onFailureCallback)
{
    // TODO: Add actual support for array and lists.
    const uint8_t * message = nullptr;
    uint16_t messageLen     = 0;
    EmberAfStatus res       = PrepareListFromTLV(tlvData, message, messageLen);
    if (res != EMBER_ZCL_STATUS_SUCCESS)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, res);
        }
        return;
    }

    CHECK_MESSAGE_LENGTH_VOID(2);
    uint16_t count = Encoding::LittleEndian::Read16(message);
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wvla"
    _FabricDescriptor data[count];
#pragma GCC diagnostic pop
    for (size_t i = 0; i < count; i++)
    {
        CHECK_MESSAGE_LENGTH_VOID(1);
        data[i].FabricIndex = emberAfGetInt8u(message, 0, 1);
        message += 1;
        CHECK_STATUS_VOID(ReadByteSpan(message, 67, &data[i].RootPublicKey));
        messageLen = static_cast<uint16_t>(messageLen - 67);
        message += 67;
        CHECK_MESSAGE_LENGTH_VOID(2);
        data[i].VendorId = emberAfGetInt16u(message, 0, 2);
        message += 2;
        CHECK_MESSAGE_LENGTH_VOID(8);
        data[i].FabricId = emberAfGetInt64u(message, 0, 8);
        message += 8;
        CHECK_MESSAGE_LENGTH_VOID(8);
        data[i].NodeId = emberAfGetInt64u(message, 0, 8);
        message += 8;
        CHECK_STATUS_VOID(ReadByteSpan(message, 34, &data[i].Label));
        messageLen = static_cast<uint16_t>(messageLen - 34);
        message += 34;
    }
    Callback::Callback<OperationalCredentialsFabricsListListAttributeCallback> * cb =
        Callback::Callback<OperationalCredentialsFabricsListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, count, data);
}
#if !defined(__clang__)
#pragma GCC diagnostic pop
#endif // __clang__

#if !defined(__clang__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstack-usage="
#endif // __clang__
void OperationalCredentialsClusterTrustedRootCertificatesListAttributeFilter(TLV::TLVReader * tlvData,
                                                                             Callback::Cancelable * onSuccessCallback,
                                                                             Callback::Cancelable * onFailureCallback)
{
    // TODO: Add actual support for array and lists.
    const uint8_t * message = nullptr;
    uint16_t messageLen     = 0;
    EmberAfStatus res       = PrepareListFromTLV(tlvData, message, messageLen);
    if (res != EMBER_ZCL_STATUS_SUCCESS)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, res);
        }
        return;
    }

    CHECK_MESSAGE_LENGTH_VOID(2);
    uint16_t count = Encoding::LittleEndian::Read16(message);
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wvla"
    chip::ByteSpan data[count];
#pragma GCC diagnostic pop
    for (size_t i = 0; i < count; i++)
    {
        CHECK_STATUS_VOID(ReadByteSpan(message, messageLen, &data[i]));
        uint16_t entryLength = static_cast<uint16_t>(data[i].size() + kByteSpanSizeLengthInBytes);
        messageLen           = static_cast<uint16_t>(messageLen - entryLength);
        message += entryLength;
    }
    Callback::Callback<OperationalCredentialsTrustedRootCertificatesListAttributeCallback> * cb =
        Callback::Callback<OperationalCredentialsTrustedRootCertificatesListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, count, data);
}
#if !defined(__clang__)
#pragma GCC diagnostic pop
#endif // __clang__

bool emberAfGeneralCommissioningClusterArmFailSafeResponseCallback(EndpointId endpoint, app::CommandSender * commandObj,
                                                                   uint8_t errorCode, chip::CharSpan debugText)
{
    ChipLogProgress(Zcl, "ArmFailSafeResponse:");
    ChipLogProgress(Zcl, "  errorCode: %" PRIu8 "", errorCode);
    ChipLogProgress(Zcl, "  debugText: %.*s", static_cast<int>(debugText.size()), debugText.data());

    GET_CLUSTER_RESPONSE_CALLBACKS("GeneralCommissioningClusterArmFailSafeResponseCallback");

    Callback::Callback<GeneralCommissioningClusterArmFailSafeResponseCallback> * cb =
        Callback::Callback<GeneralCommissioningClusterArmFailSafeResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, errorCode, debugText);
    return true;
}

bool emberAfGeneralCommissioningClusterCommissioningCompleteResponseCallback(EndpointId endpoint, app::CommandSender * commandObj,
                                                                             uint8_t errorCode, chip::CharSpan debugText)
{
    ChipLogProgress(Zcl, "CommissioningCompleteResponse:");
    ChipLogProgress(Zcl, "  errorCode: %" PRIu8 "", errorCode);
    ChipLogProgress(Zcl, "  debugText: %.*s", static_cast<int>(debugText.size()), debugText.data());

    GET_CLUSTER_RESPONSE_CALLBACKS("GeneralCommissioningClusterCommissioningCompleteResponseCallback");

    Callback::Callback<GeneralCommissioningClusterCommissioningCompleteResponseCallback> * cb =
        Callback::Callback<GeneralCommissioningClusterCommissioningCompleteResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, errorCode, debugText);
    return true;
}

bool emberAfGeneralCommissioningClusterSetRegulatoryConfigResponseCallback(EndpointId endpoint, app::CommandSender * commandObj,
                                                                           uint8_t errorCode, chip::CharSpan debugText)
{
    ChipLogProgress(Zcl, "SetRegulatoryConfigResponse:");
    ChipLogProgress(Zcl, "  errorCode: %" PRIu8 "", errorCode);
    ChipLogProgress(Zcl, "  debugText: %.*s", static_cast<int>(debugText.size()), debugText.data());

    GET_CLUSTER_RESPONSE_CALLBACKS("GeneralCommissioningClusterSetRegulatoryConfigResponseCallback");

    Callback::Callback<GeneralCommissioningClusterSetRegulatoryConfigResponseCallback> * cb =
        Callback::Callback<GeneralCommissioningClusterSetRegulatoryConfigResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, errorCode, debugText);
    return true;
}

bool emberAfNetworkCommissioningClusterAddThreadNetworkResponseCallback(EndpointId endpoint, app::CommandSender * commandObj,
                                                                        uint8_t errorCode, chip::CharSpan debugText)
{
    ChipLogProgress(Zcl, "AddThreadNetworkResponse:");
    ChipLogProgress(Zcl, "  errorCode: %" PRIu8 "", errorCode);
    ChipLogProgress(Zcl, "  debugText: %.*s", static_cast<int>(debugText.size()), debugText.data());

    GET_CLUSTER_RESPONSE_CALLBACKS("NetworkCommissioningClusterAddThreadNetworkResponseCallback");

    Callback::Callback<NetworkCommissioningClusterAddThreadNetworkResponseCallback> * cb =
        Callback::Callback<NetworkCommissioningClusterAddThreadNetworkResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, errorCode, debugText);
    return true;
}

bool emberAfNetworkCommissioningClusterAddWiFiNetworkResponseCallback(EndpointId endpoint, app::CommandSender * commandObj,
                                                                      uint8_t errorCode, chip::CharSpan debugText)
{
    ChipLogProgress(Zcl, "AddWiFiNetworkResponse:");
    ChipLogProgress(Zcl, "  errorCode: %" PRIu8 "", errorCode);
    ChipLogProgress(Zcl, "  debugText: %.*s", static_cast<int>(debugText.size()), debugText.data());

    GET_CLUSTER_RESPONSE_CALLBACKS("NetworkCommissioningClusterAddWiFiNetworkResponseCallback");

    Callback::Callback<NetworkCommissioningClusterAddWiFiNetworkResponseCallback> * cb =
        Callback::Callback<NetworkCommissioningClusterAddWiFiNetworkResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, errorCode, debugText);
    return true;
}

bool emberAfNetworkCommissioningClusterDisableNetworkResponseCallback(EndpointId endpoint, app::CommandSender * commandObj,
                                                                      uint8_t errorCode, chip::CharSpan debugText)
{
    ChipLogProgress(Zcl, "DisableNetworkResponse:");
    ChipLogProgress(Zcl, "  errorCode: %" PRIu8 "", errorCode);
    ChipLogProgress(Zcl, "  debugText: %.*s", static_cast<int>(debugText.size()), debugText.data());

    GET_CLUSTER_RESPONSE_CALLBACKS("NetworkCommissioningClusterDisableNetworkResponseCallback");

    Callback::Callback<NetworkCommissioningClusterDisableNetworkResponseCallback> * cb =
        Callback::Callback<NetworkCommissioningClusterDisableNetworkResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, errorCode, debugText);
    return true;
}

bool emberAfNetworkCommissioningClusterEnableNetworkResponseCallback(EndpointId endpoint, app::CommandSender * commandObj,
                                                                     uint8_t errorCode, chip::CharSpan debugText)
{
    ChipLogProgress(Zcl, "EnableNetworkResponse:");
    ChipLogProgress(Zcl, "  errorCode: %" PRIu8 "", errorCode);
    ChipLogProgress(Zcl, "  debugText: %.*s", static_cast<int>(debugText.size()), debugText.data());

    GET_CLUSTER_RESPONSE_CALLBACKS("NetworkCommissioningClusterEnableNetworkResponseCallback");

    Callback::Callback<NetworkCommissioningClusterEnableNetworkResponseCallback> * cb =
        Callback::Callback<NetworkCommissioningClusterEnableNetworkResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, errorCode, debugText);
    return true;
}

bool emberAfNetworkCommissioningClusterRemoveNetworkResponseCallback(EndpointId endpoint, app::CommandSender * commandObj,
                                                                     uint8_t errorCode, chip::CharSpan debugText)
{
    ChipLogProgress(Zcl, "RemoveNetworkResponse:");
    ChipLogProgress(Zcl, "  errorCode: %" PRIu8 "", errorCode);
    ChipLogProgress(Zcl, "  debugText: %.*s", static_cast<int>(debugText.size()), debugText.data());

    GET_CLUSTER_RESPONSE_CALLBACKS("NetworkCommissioningClusterRemoveNetworkResponseCallback");

    Callback::Callback<NetworkCommissioningClusterRemoveNetworkResponseCallback> * cb =
        Callback::Callback<NetworkCommissioningClusterRemoveNetworkResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, errorCode, debugText);
    return true;
}

bool emberAfNetworkCommissioningClusterScanNetworksResponseCallback(
    EndpointId endpoint, app::CommandSender * commandObj, uint8_t errorCode, chip::CharSpan debugText,
    /* TYPE WARNING: array array defaults to */ uint8_t * wifiScanResults,
    /* TYPE WARNING: array array defaults to */ uint8_t * threadScanResults)
{
    ChipLogProgress(Zcl, "ScanNetworksResponse:");
    ChipLogProgress(Zcl, "  errorCode: %" PRIu8 "", errorCode);
    ChipLogProgress(Zcl, "  debugText: %.*s", static_cast<int>(debugText.size()), debugText.data());
    ChipLogProgress(Zcl, "  wifiScanResults: %p", wifiScanResults);
    ChipLogProgress(Zcl, "  threadScanResults: %p", threadScanResults);

    GET_CLUSTER_RESPONSE_CALLBACKS("NetworkCommissioningClusterScanNetworksResponseCallback");

    Callback::Callback<NetworkCommissioningClusterScanNetworksResponseCallback> * cb =
        Callback::Callback<NetworkCommissioningClusterScanNetworksResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, errorCode, debugText, wifiScanResults, threadScanResults);
    return true;
}

bool emberAfNetworkCommissioningClusterUpdateThreadNetworkResponseCallback(EndpointId endpoint, app::CommandSender * commandObj,
                                                                           uint8_t errorCode, chip::CharSpan debugText)
{
    ChipLogProgress(Zcl, "UpdateThreadNetworkResponse:");
    ChipLogProgress(Zcl, "  errorCode: %" PRIu8 "", errorCode);
    ChipLogProgress(Zcl, "  debugText: %.*s", static_cast<int>(debugText.size()), debugText.data());

    GET_CLUSTER_RESPONSE_CALLBACKS("NetworkCommissioningClusterUpdateThreadNetworkResponseCallback");

    Callback::Callback<NetworkCommissioningClusterUpdateThreadNetworkResponseCallback> * cb =
        Callback::Callback<NetworkCommissioningClusterUpdateThreadNetworkResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, errorCode, debugText);
    return true;
}

bool emberAfNetworkCommissioningClusterUpdateWiFiNetworkResponseCallback(EndpointId endpoint, app::CommandSender * commandObj,
                                                                         uint8_t errorCode, chip::CharSpan debugText)
{
    ChipLogProgress(Zcl, "UpdateWiFiNetworkResponse:");
    ChipLogProgress(Zcl, "  errorCode: %" PRIu8 "", errorCode);
    ChipLogProgress(Zcl, "  debugText: %.*s", static_cast<int>(debugText.size()), debugText.data());

    GET_CLUSTER_RESPONSE_CALLBACKS("NetworkCommissioningClusterUpdateWiFiNetworkResponseCallback");

    Callback::Callback<NetworkCommissioningClusterUpdateWiFiNetworkResponseCallback> * cb =
        Callback::Callback<NetworkCommissioningClusterUpdateWiFiNetworkResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, errorCode, debugText);
    return true;
}

bool emberAfOperationalCredentialsClusterAttestationResponseCallback(EndpointId endpoint, app::CommandSender * commandObj,
                                                                     chip::ByteSpan AttestationElements, chip::ByteSpan Signature)
{
    ChipLogProgress(Zcl, "AttestationResponse:");
    ChipLogProgress(Zcl, "  AttestationElements: %zu", AttestationElements.size());
    ChipLogProgress(Zcl, "  Signature: %zu", Signature.size());

    GET_CLUSTER_RESPONSE_CALLBACKS("OperationalCredentialsClusterAttestationResponseCallback");

    Callback::Callback<OperationalCredentialsClusterAttestationResponseCallback> * cb =
        Callback::Callback<OperationalCredentialsClusterAttestationResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, AttestationElements, Signature);
    return true;
}

bool emberAfOperationalCredentialsClusterCertificateChainResponseCallback(EndpointId endpoint, app::CommandSender * commandObj,
                                                                          chip::ByteSpan Certificate)
{
    ChipLogProgress(Zcl, "CertificateChainResponse:");
    ChipLogProgress(Zcl, "  Certificate: %zu", Certificate.size());

    GET_CLUSTER_RESPONSE_CALLBACKS("OperationalCredentialsClusterCertificateChainResponseCallback");

    Callback::Callback<OperationalCredentialsClusterCertificateChainResponseCallback> * cb =
        Callback::Callback<OperationalCredentialsClusterCertificateChainResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, Certificate);
    return true;
}

bool emberAfOperationalCredentialsClusterNOCResponseCallback(EndpointId endpoint, app::CommandSender * commandObj,
                                                             uint8_t StatusCode, uint8_t FabricIndex, chip::ByteSpan DebugText)
{
    ChipLogProgress(Zcl, "NOCResponse:");
    ChipLogProgress(Zcl, "  StatusCode: %" PRIu8 "", StatusCode);
    ChipLogProgress(Zcl, "  FabricIndex: %" PRIu8 "", FabricIndex);
    ChipLogProgress(Zcl, "  DebugText: %zu", DebugText.size());

    GET_CLUSTER_RESPONSE_CALLBACKS("OperationalCredentialsClusterNOCResponseCallback");

    Callback::Callback<OperationalCredentialsClusterNOCResponseCallback> * cb =
        Callback::Callback<OperationalCredentialsClusterNOCResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, StatusCode, FabricIndex, DebugText);
    return true;
}

bool emberAfOperationalCredentialsClusterOpCSRResponseCallback(EndpointId endpoint, app::CommandSender * commandObj,
                                                               chip::ByteSpan NOCSRElements, chip::ByteSpan AttestationSignature)
{
    ChipLogProgress(Zcl, "OpCSRResponse:");
    ChipLogProgress(Zcl, "  NOCSRElements: %zu", NOCSRElements.size());
    ChipLogProgress(Zcl, "  AttestationSignature: %zu", AttestationSignature.size());

    GET_CLUSTER_RESPONSE_CALLBACKS("OperationalCredentialsClusterOpCSRResponseCallback");

    Callback::Callback<OperationalCredentialsClusterOpCSRResponseCallback> * cb =
        Callback::Callback<OperationalCredentialsClusterOpCSRResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, NOCSRElements, AttestationSignature);
    return true;
}
