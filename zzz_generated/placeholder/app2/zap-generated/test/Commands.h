/*
 *
 *    Copyright (c) 2022 Project CHIP Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

// THIS FILE IS GENERATED BY ZAP

#pragma once

#include "TestCommand.h"

#include <app/data-model/ListLargeSystemExtensions.h>

class Test_TC_WNCV_5_1_SimulatedSuite : public TestCommand
{
public:
    Test_TC_WNCV_5_1_SimulatedSuite() : TestCommand("Test_TC_WNCV_5_1_Simulated", 5)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_WNCV_5_1_SimulatedSuite() {}

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Step 1a: DUT reads the FeatureMap attribute from TH");
            return WaitAttribute(GetEndpoint(0), WindowCovering::Id, WindowCovering::Attributes::FeatureMap::Id);
        }
        case 1: {
            LogStep(1, "Step 2a: DUT reads the Type attribute from TH");
            VerifyOrDo(!ShouldSkip("WNCV.C.A0000"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitAttribute(GetEndpoint(0), WindowCovering::Id, WindowCovering::Attributes::Type::Id);
        }
        case 2: {
            LogStep(2, "Step 2b: DUT reads the EndProductType attribute from TH");
            VerifyOrDo(!ShouldSkip("WNCV.C.A000d"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitAttribute(GetEndpoint(0), WindowCovering::Id, WindowCovering::Attributes::EndProductType::Id);
        }
        case 3: {
            LogStep(3, "Step 3a: DUT reads the Mode attribute from TH");
            VerifyOrDo(!ShouldSkip("WNCV.C.A0017"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitAttribute(GetEndpoint(0), WindowCovering::Id, WindowCovering::Attributes::Mode::Id);
        }
        case 4: {
            LogStep(4, "Step 3b: DUT reads the ConfigStatus attribute from TH");
            VerifyOrDo(!ShouldSkip("WNCV.C.A0007"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitAttribute(GetEndpoint(0), WindowCovering::Id, WindowCovering::Attributes::ConfigStatus::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_OCC_2_4_SimulatedSuite : public TestCommand
{
public:
    Test_TC_OCC_2_4_SimulatedSuite() : TestCommand("Test_TC_OCC_2_4_Simulated", 2)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_OCC_2_4_SimulatedSuite() {}

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "TH reads OccupancySensorType attribute from DUT");
            VerifyOrDo(!ShouldSkip("OCC.C.A0001"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitAttribute(GetEndpoint(1), OccupancySensing::Id, OccupancySensing::Attributes::OccupancySensorType::Id);
        }
        case 1: {
            LogStep(1, "TH reads OccupancySensorTypeBitmap attribute from DUT");
            VerifyOrDo(!ShouldSkip("OCC.C.A0002"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitAttribute(GetEndpoint(1), OccupancySensing::Id, OccupancySensing::Attributes::OccupancySensorTypeBitmap::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_DGSW_3_2_SimulatedSuite : public TestCommand
{
public:
    Test_TC_DGSW_3_2_SimulatedSuite() : TestCommand("Test_TC_DGSW_3_2_Simulated", 1)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_DGSW_3_2_SimulatedSuite() {}

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "DUT sends ResetWatermarks to TH");
            VerifyOrDo(!ShouldSkip("DGSW.C.C00.Tx"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitCommand(GetEndpoint(0), SoftwareDiagnostics::Id, SoftwareDiagnostics::Commands::ResetWatermarks::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_DGETH_3_2_SimulatedSuite : public TestCommand
{
public:
    Test_TC_DGETH_3_2_SimulatedSuite() : TestCommand("Test_TC_DGETH_3_2_Simulated", 1)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_DGETH_3_2_SimulatedSuite() {}

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "DUT sends ResetCounts to TH");
            VerifyOrDo(!ShouldSkip("DGETH.C.C00.Tx"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitCommand(GetEndpoint(0), EthernetNetworkDiagnostics::Id,
                               EthernetNetworkDiagnostics::Commands::ResetCounts::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_DGWIFI_3_2_SimulatedSuite : public TestCommand
{
public:
    Test_TC_DGWIFI_3_2_SimulatedSuite() : TestCommand("Test_TC_DGWIFI_3_2_Simulated", 1)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_DGWIFI_3_2_SimulatedSuite() {}

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "DUT sends ResetCounts command to TH");
            VerifyOrDo(!ShouldSkip("DGWIFI.C.C00.Tx"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitCommand(GetEndpoint(0), WiFiNetworkDiagnostics::Id, WiFiNetworkDiagnostics::Commands::ResetCounts::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_WNCV_6_1_SimulatedSuite : public TestCommand
{
public:
    Test_TC_WNCV_6_1_SimulatedSuite() : TestCommand("Test_TC_WNCV_6_1_Simulated", 3)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_WNCV_6_1_SimulatedSuite() {}

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Step 1a: DUT sends UpOrOpen command to TH");
            VerifyOrDo(!ShouldSkip("WNCV.C.C00.Tx"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitCommand(GetEndpoint(0), WindowCovering::Id, WindowCovering::Commands::UpOrOpen::Id);
        }
        case 1: {
            LogStep(1, "Step 2a: DUT sends DownOrClose command to TH");
            VerifyOrDo(!ShouldSkip("WNCV.C.C01.Tx"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitCommand(GetEndpoint(0), WindowCovering::Id, WindowCovering::Commands::DownOrClose::Id);
        }
        case 2: {
            LogStep(2, "Step 3a: DUT sends StopMotion command to TH");
            VerifyOrDo(!ShouldSkip("WNCV.C.C02.Tx"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitCommand(GetEndpoint(0), WindowCovering::Id, WindowCovering::Commands::StopMotion::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_WNCV_7_1_SimulatedSuite : public TestCommand
{
public:
    Test_TC_WNCV_7_1_SimulatedSuite() : TestCommand("Test_TC_WNCV_7_1_Simulated", 2)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_WNCV_7_1_SimulatedSuite() {}

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Step 1a: If (PA_LF & LF) DUT sends GoToLiftPercentage command with 50% to DUT");
            VerifyOrDo(!ShouldSkip("WNCV.C.C05.Tx"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitCommand(GetEndpoint(0), WindowCovering::Id, WindowCovering::Commands::GoToLiftPercentage::Id);
        }
        case 1: {
            LogStep(1, "Step 2a: If (PA_TL & TL) DUT sends GoToTiltPercentage command with 50% to DUT");
            VerifyOrDo(!ShouldSkip("WNCV.C.C08.Tx"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitCommand(GetEndpoint(0), WindowCovering::Id, WindowCovering::Commands::GoToTiltPercentage::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_CC_3_4_SimulatedSuite : public TestCommand
{
public:
    Test_TC_CC_3_4_SimulatedSuite() : TestCommand("Test_TC_CC_3_4_Simulated", 16)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
        AddArgument("ConfigTransitionTime", 0, UINT16_MAX, &mConfigTransitionTime);
    }

    ~Test_TC_CC_3_4_SimulatedSuite() {}

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;
    chip::Optional<uint16_t> mConfigTransitionTime;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 14:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "PreCondition: Set TH OnOff to On");
            return WaitCommand(GetEndpoint(1), OnOff::Id, OnOff::Commands::On::Id);
        }
        case 1: {
            LogStep(1, "DUT sends MoveToHue command to TH an Hue with _TransitionTime 300");
            VerifyOrDo(!ShouldSkip("CC.C.C00.Tx && CC.C.F00"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitCommand(GetEndpoint(1), ColorControl::Id, ColorControl::Commands::MoveToHue::Id);
        }
        case 2: {
            LogStep(2, "DUT reads CurrentHue attribute from TH periodically");
            VerifyOrDo(!ShouldSkip("CC.C.C00.Tx && CC.C.A0000 && CC.C.F00"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitAttribute(GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::CurrentHue::Id);
        }
        case 3: {
            LogStep(3, "Wait for ConfigTransitionTime");
            VerifyOrDo(!ShouldSkip("CC.C.F00"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            ListFreer listFreer;
            chip::app::Clusters::DelayCommands::Commands::WaitForMs::Type value;
            value.ms = mConfigTransitionTime.HasValue() ? mConfigTransitionTime.Value() : 3000UL;
            return WaitForMs(kIdentityAlpha, value);
        }
        case 4: {
            LogStep(4, "DUT reads CurrentHue attribute from TH periodically");
            VerifyOrDo(!ShouldSkip("CC.C.C00.Tx && CC.C.A0000 && CC.C.F00"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitAttribute(GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::CurrentHue::Id);
        }
        case 5: {
            LogStep(5, "DUT sends MoveHue command to TH");
            VerifyOrDo(!ShouldSkip("CC.C.C01.Tx && CC.C.F00"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitCommand(GetEndpoint(1), ColorControl::Id, ColorControl::Commands::MoveHue::Id);
        }
        case 6: {
            LogStep(6, "DUT reads CurrentHue attribute from TH several times.");
            VerifyOrDo(!ShouldSkip("CC.C.C01.Tx && CC.C.A0000 && CC.C.F00"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitAttribute(GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::CurrentHue::Id);
        }
        case 7: {
            LogStep(7, "Wait for ConfigTransitionTime");
            VerifyOrDo(!ShouldSkip("CC.C.F00"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            ListFreer listFreer;
            chip::app::Clusters::DelayCommands::Commands::WaitForMs::Type value;
            value.ms = mConfigTransitionTime.HasValue() ? mConfigTransitionTime.Value() : 3000UL;
            return WaitForMs(kIdentityAlpha, value);
        }
        case 8: {
            LogStep(8, "DUT reads CurrentHue attribute from TH several times.");
            VerifyOrDo(!ShouldSkip("CC.C.C01.Tx && CC.C.A0000 && CC.C.F00"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitAttribute(GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::CurrentHue::Id);
        }
        case 9: {
            LogStep(9, "DUT sends StepHue command to TH");
            VerifyOrDo(!ShouldSkip("CC.C.C02.Tx && CC.C.F00"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitCommand(GetEndpoint(1), ColorControl::Id, ColorControl::Commands::StepHue::Id);
        }
        case 10: {
            LogStep(10, "DUT reads CurrentHue attribute from TH several times.");
            VerifyOrDo(!ShouldSkip("CC.C.C02.Tx && CC.C.A0000 && CC.C.F00"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitAttribute(GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::CurrentHue::Id);
        }
        case 11: {
            LogStep(11, "Wait for ConfigTransitionTime");
            VerifyOrDo(!ShouldSkip("CC.C.F00"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            ListFreer listFreer;
            chip::app::Clusters::DelayCommands::Commands::WaitForMs::Type value;
            value.ms = mConfigTransitionTime.HasValue() ? mConfigTransitionTime.Value() : 3000UL;
            return WaitForMs(kIdentityAlpha, value);
        }
        case 12: {
            LogStep(12, "DUT reads CurrentHue attribute from TH several times.");
            VerifyOrDo(!ShouldSkip("CC.C.C02.Tx && CC.C.A0000 && CC.C.F00"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitAttribute(GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::CurrentHue::Id);
        }
        case 13: {
            LogStep(13, "DUT sends StopMoveStep command to TH");
            VerifyOrDo(!ShouldSkip("CC.C.C03.Tx && CC.C.A0000 && CC.C.F00"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitCommand(GetEndpoint(1), ColorControl::Id, ColorControl::Commands::StopMoveStep::Id);
        }
        case 14: {
            LogStep(14, "Wait for ConfigTransitionTime");
            VerifyOrDo(!ShouldSkip("CC.C.F00"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            ListFreer listFreer;
            chip::app::Clusters::DelayCommands::Commands::WaitForMs::Type value;
            value.ms = mConfigTransitionTime.HasValue() ? mConfigTransitionTime.Value() : 3000UL;
            return WaitForMs(kIdentityAlpha, value);
        }
        case 15: {
            LogStep(15, "Over TransitionTime, DUT reads CurrentHue attribute from TH");
            VerifyOrDo(!ShouldSkip("CC.C.C03.Tx && CC.C.A0000 && CC.C.F00"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitAttribute(GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::CurrentHue::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_CC_4_5_SimulatedSuite : public TestCommand
{
public:
    Test_TC_CC_4_5_SimulatedSuite() : TestCommand("Test_TC_CC_4_5_Simulated", 22)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
        AddArgument("ConfigTransitionTime", 0, UINT16_MAX, &mConfigTransitionTime);
    }

    ~Test_TC_CC_4_5_SimulatedSuite() {}

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;
    chip::Optional<uint16_t> mConfigTransitionTime;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 16:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 20:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "PreCondition: Set TH OnOff to On");
            return WaitCommand(GetEndpoint(1), OnOff::Id, OnOff::Commands::On::Id);
        }
        case 1: {
            LogStep(1, "DUT sends MoveToSaturation command to TH");
            VerifyOrDo(!ShouldSkip("CC.C.C03.Tx && CC.C.F00"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitCommand(GetEndpoint(1), ColorControl::Id, ColorControl::Commands::MoveToSaturation::Id);
        }
        case 2: {
            LogStep(2, "DUT reads CurrentSaturation attribute from TH periodically");
            VerifyOrDo(!ShouldSkip("CC.C.C03.Tx && CC.C.A0001 && CC.C.F00"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitAttribute(GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::CurrentSaturation::Id);
        }
        case 3: {
            LogStep(3, "Wait for ConfigTransitionTime");
            VerifyOrDo(!ShouldSkip("CC.C.F00"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            ListFreer listFreer;
            chip::app::Clusters::DelayCommands::Commands::WaitForMs::Type value;
            value.ms = mConfigTransitionTime.HasValue() ? mConfigTransitionTime.Value() : 3000UL;
            return WaitForMs(kIdentityAlpha, value);
        }
        case 4: {
            LogStep(4, "DUT reads CurrentSaturation attribute from TH periodically");
            VerifyOrDo(!ShouldSkip("CC.C.C03.Tx && CC.C.A0001 && CC.C.F00"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitAttribute(GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::CurrentSaturation::Id);
        }
        case 5: {
            LogStep(5, "DUT sends MoveSaturation command to TH");
            VerifyOrDo(!ShouldSkip("CC.C.C04.Tx && CC.C.F00"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitCommand(GetEndpoint(1), ColorControl::Id, ColorControl::Commands::MoveSaturation::Id);
        }
        case 6: {
            LogStep(6, "DUT reads CurrentSaturation attribute from TH several times.");
            VerifyOrDo(!ShouldSkip("CC.C.C04.Tx && CC.C.A0001 && CC.C.F00"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitAttribute(GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::CurrentSaturation::Id);
        }
        case 7: {
            LogStep(7, "Wait for ConfigTransitionTime");
            VerifyOrDo(!ShouldSkip("CC.C.F00"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            ListFreer listFreer;
            chip::app::Clusters::DelayCommands::Commands::WaitForMs::Type value;
            value.ms = mConfigTransitionTime.HasValue() ? mConfigTransitionTime.Value() : 3000UL;
            return WaitForMs(kIdentityAlpha, value);
        }
        case 8: {
            LogStep(8, "DUT reads CurrentSaturation attribute from TH several times.");
            VerifyOrDo(!ShouldSkip("CC.C.C04.Tx && CC.C.A0001 && CC.C.F00"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitAttribute(GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::CurrentSaturation::Id);
        }
        case 9: {
            LogStep(9, "DUT sends StepSaturation command to TH");
            VerifyOrDo(!ShouldSkip("CC.C.C05.Tx && CC.C.F00"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitCommand(GetEndpoint(1), ColorControl::Id, ColorControl::Commands::StepSaturation::Id);
        }
        case 10: {
            LogStep(10, "DUT reads CurrentSaturation attribute from TH several times.");
            VerifyOrDo(!ShouldSkip("CC.C.C05.Tx && CC.C.A0001 && CC.C.F00"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitAttribute(GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::CurrentSaturation::Id);
        }
        case 11: {
            LogStep(11, "Wait for ConfigTransitionTime");
            VerifyOrDo(!ShouldSkip("CC.C.F00"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            ListFreer listFreer;
            chip::app::Clusters::DelayCommands::Commands::WaitForMs::Type value;
            value.ms = mConfigTransitionTime.HasValue() ? mConfigTransitionTime.Value() : 3000UL;
            return WaitForMs(kIdentityAlpha, value);
        }
        case 12: {
            LogStep(12, "DUT reads CurrentSaturation attribute from TH several times.");
            VerifyOrDo(!ShouldSkip("CC.C.C05.Tx && CC.C.A0001 && CC.C.F00"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitAttribute(GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::CurrentSaturation::Id);
        }
        case 13: {
            LogStep(13, "DUT sends MoveToHueAndSaturation command to TH");
            VerifyOrDo(!ShouldSkip("CC.C.C06.Tx && CC.C.F00"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitCommand(GetEndpoint(1), ColorControl::Id, ColorControl::Commands::MoveToHueAndSaturation::Id);
        }
        case 14: {
            LogStep(14, "DUT reads CurrentSaturation attribute from TH several times.");
            VerifyOrDo(!ShouldSkip("CC.C.C06.Tx && CC.C.A0001 && CC.C.F00"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitAttribute(GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::CurrentSaturation::Id);
        }
        case 15: {
            LogStep(15, "DUT reads CurrentHue attribute from TH periodically");
            VerifyOrDo(!ShouldSkip("CC.C.C06.Tx && CC.C.A0000 && CC.C.F00"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitAttribute(GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::CurrentHue::Id);
        }
        case 16: {
            LogStep(16, "Wait for ConfigTransitionTime");
            VerifyOrDo(!ShouldSkip("CC.C.F00"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            ListFreer listFreer;
            chip::app::Clusters::DelayCommands::Commands::WaitForMs::Type value;
            value.ms = mConfigTransitionTime.HasValue() ? mConfigTransitionTime.Value() : 3000UL;
            return WaitForMs(kIdentityAlpha, value);
        }
        case 17: {
            LogStep(17, "DUT reads CurrentSaturation attribute from TH several times.");
            VerifyOrDo(!ShouldSkip("CC.C.C06.Tx && CC.C.A0001 && CC.C.F00"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitAttribute(GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::CurrentSaturation::Id);
        }
        case 18: {
            LogStep(18, "DUT reads CurrentHue attribute from TH periodically");
            VerifyOrDo(!ShouldSkip("CC.C.C06.Tx && CC.C.A0000 && CC.C.F00"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitAttribute(GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::CurrentHue::Id);
        }
        case 19: {
            LogStep(19, "DUT sends StopMoveStep command to TH");
            VerifyOrDo(!ShouldSkip("CC.C.C47.Tx && CC.C.F00"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitCommand(GetEndpoint(1), ColorControl::Id, ColorControl::Commands::StopMoveStep::Id);
        }
        case 20: {
            LogStep(20, "Wait for ConfigTransitionTime");
            VerifyOrDo(!ShouldSkip("CC.C.F00"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            ListFreer listFreer;
            chip::app::Clusters::DelayCommands::Commands::WaitForMs::Type value;
            value.ms = mConfigTransitionTime.HasValue() ? mConfigTransitionTime.Value() : 3000UL;
            return WaitForMs(kIdentityAlpha, value);
        }
        case 21: {
            LogStep(21, "Over TransitionTime, DUT reads CurrentSaturation attribute from TH");
            VerifyOrDo(!ShouldSkip("CC.C.C47.Tx && CC.C.A0001 && CC.C.F00"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitAttribute(GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::CurrentSaturation::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_CC_5_4_SimulatedSuite : public TestCommand
{
public:
    Test_TC_CC_5_4_SimulatedSuite() : TestCommand("Test_TC_CC_5_4_Simulated", 9)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("ConfigTransitionTime", 0, UINT16_MAX, &mConfigTransitionTime);
    }

    ~Test_TC_CC_5_4_SimulatedSuite() {}

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<uint16_t> mTimeout;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mConfigTransitionTime;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "PreCondition: Set TH OnOff to On");
            return WaitCommand(GetEndpoint(1), OnOff::Id, OnOff::Commands::On::Id);
        }
        case 1: {
            LogStep(1, "DUT sends MoveToColor command to TH");
            VerifyOrDo(!ShouldSkip("CC.C.C07.Tx && CC.C.F03"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitCommand(GetEndpoint(1), ColorControl::Id, ColorControl::Commands::MoveToColor::Id);
        }
        case 2: {
            LogStep(2, "Wait for ConfigTransitionTime");
            ListFreer listFreer;
            chip::app::Clusters::DelayCommands::Commands::WaitForMs::Type value;
            value.ms = mConfigTransitionTime.HasValue() ? mConfigTransitionTime.Value() : 3000UL;
            return WaitForMs(kIdentityAlpha, value);
        }
        case 3: {
            LogStep(3, "DUT sends MoveColor command to TH");
            VerifyOrDo(!ShouldSkip("CC.C.C08.Tx && CC.C.F03"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitCommand(GetEndpoint(1), ColorControl::Id, ColorControl::Commands::MoveColor::Id);
        }
        case 4: {
            LogStep(4, "Wait for ConfigTransitionTime");
            ListFreer listFreer;
            chip::app::Clusters::DelayCommands::Commands::WaitForMs::Type value;
            value.ms = mConfigTransitionTime.HasValue() ? mConfigTransitionTime.Value() : 3000UL;
            return WaitForMs(kIdentityAlpha, value);
        }
        case 5: {
            LogStep(5, "DUT sends StepColor command to TH");
            VerifyOrDo(!ShouldSkip("CC.C.C09.Tx"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitCommand(GetEndpoint(1), ColorControl::Id, ColorControl::Commands::StepColor::Id);
        }
        case 6: {
            LogStep(6, "Wait for ConfigTransitionTime");
            ListFreer listFreer;
            chip::app::Clusters::DelayCommands::Commands::WaitForMs::Type value;
            value.ms = mConfigTransitionTime.HasValue() ? mConfigTransitionTime.Value() : 3000UL;
            return WaitForMs(kIdentityAlpha, value);
        }
        case 7: {
            LogStep(7, "DUT sends StopMoveStep command to TH");
            VerifyOrDo(!ShouldSkip("CC.C.C47.Tx"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitCommand(GetEndpoint(1), ColorControl::Id, ColorControl::Commands::StopMoveStep::Id);
        }
        case 8: {
            LogStep(8, "Wait for ConfigTransitionTime");
            ListFreer listFreer;
            chip::app::Clusters::DelayCommands::Commands::WaitForMs::Type value;
            value.ms = mConfigTransitionTime.HasValue() ? mConfigTransitionTime.Value() : 3000UL;
            return WaitForMs(kIdentityAlpha, value);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_CC_6_4_SimulatedSuite : public TestCommand
{
public:
    Test_TC_CC_6_4_SimulatedSuite() : TestCommand("Test_TC_CC_6_4_Simulated", 18)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("ConfigTransitionTime", 0, UINT16_MAX, &mConfigTransitionTime);
    }

    ~Test_TC_CC_6_4_SimulatedSuite() {}

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<uint16_t> mTimeout;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mConfigTransitionTime;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 13:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 16:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "PreCondition: Set TH OnOff to On");
            return WaitCommand(GetEndpoint(1), OnOff::Id, OnOff::Commands::On::Id);
        }
        case 1: {
            LogStep(1,
                    "* TH provides a server implementation of Color Control with F04(CT)=true and reasonable values of "
                    "ColorTempPhysicalMinMireds (e.g. 153 (6500K), ColorTempPhysicalMaxMireds (e.g. 454 (2200K)) DUT read "
                    "attribute ColorTempPhysicalMinMireds from TH");
            VerifyOrDo(!ShouldSkip("CC.C.A400b && CC.C.F04"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitAttribute(GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorTempPhysicalMinMireds::Id);
        }
        case 2: {
            LogStep(2,
                    "* TH provides a server implementation of Color Control with F04(CT)=true and reasonable values of "
                    "ColorTempPhysicalMinMireds (e.g. 153 (6500K), ColorTempPhysicalMaxMireds (e.g. 454 (2200K)) DUT read "
                    "attribute ColorTempPhysicalMaxMireds from TH");
            VerifyOrDo(!ShouldSkip("CC.C.A400c && CC.C.F04"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitAttribute(GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorTempPhysicalMaxMireds::Id);
        }
        case 3: {
            LogStep(3, "DUT sends MoveToColorTemperature command to TH");
            VerifyOrDo(!ShouldSkip("CC.C.C0a.Tx && CC.C.F04"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitCommand(GetEndpoint(1), ColorControl::Id, ColorControl::Commands::MoveToColorTemperature::Id);
        }
        case 4: {
            LogStep(4, "DUT reads CurrentColorTemperatureMireds attribute from TH (potentially multiple times)");
            VerifyOrDo(!ShouldSkip("CC.C.C0a.Tx && CC.C.A0007 && CC.C.F04"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitAttribute(GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorTemperatureMireds::Id);
        }
        case 5: {
            LogStep(5, "Wait for ConfigTransitionTime");
            ListFreer listFreer;
            chip::app::Clusters::DelayCommands::Commands::WaitForMs::Type value;
            value.ms = mConfigTransitionTime.HasValue() ? mConfigTransitionTime.Value() : 3000UL;
            return WaitForMs(kIdentityAlpha, value);
        }
        case 6: {
            LogStep(6, "DUT reads CurrentColorTemperatureMireds attribute from TH (potentially multiple times)");
            VerifyOrDo(!ShouldSkip("CC.C.C0a.Tx && CC.C.A0007 && CC.C.F04"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitAttribute(GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorTemperatureMireds::Id);
        }
        case 7: {
            LogStep(7, "DUT sends MoveColorTemperatureMireds command to TH");
            VerifyOrDo(!ShouldSkip("CC.C.C4b.Tx && CC.C.F04"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitCommand(GetEndpoint(1), ColorControl::Id, ColorControl::Commands::MoveColorTemperature::Id);
        }
        case 8: {
            LogStep(8, "DUT reads CurrentColorTemperatureMireds attribute from TH (potentially multiple times)");
            VerifyOrDo(!ShouldSkip("CC.C.C4b.Tx && CC.C.A0007 && CC.C.F04"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitAttribute(GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorTemperatureMireds::Id);
        }
        case 9: {
            LogStep(9, "Wait for ConfigTransitionTime");
            ListFreer listFreer;
            chip::app::Clusters::DelayCommands::Commands::WaitForMs::Type value;
            value.ms = mConfigTransitionTime.HasValue() ? mConfigTransitionTime.Value() : 3000UL;
            return WaitForMs(kIdentityAlpha, value);
        }
        case 10: {
            LogStep(10, "DUT reads CurrentColorTemperatureMireds attribute from TH (potentially multiple times)");
            VerifyOrDo(!ShouldSkip("CC.C.C4b.Tx && CC.C.A0007 && CC.C.F04"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitAttribute(GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorTemperatureMireds::Id);
        }
        case 11: {
            LogStep(11, "DUT sends StepColorTemperature command to TH");
            VerifyOrDo(!ShouldSkip("CC.C.C4c.Tx && CC.C.F04"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitCommand(GetEndpoint(1), ColorControl::Id, ColorControl::Commands::StepColorTemperature::Id);
        }
        case 12: {
            LogStep(12, "DUT reads CurrentColorTemperatureMireds attribute from TH (potentially multiple times)");
            VerifyOrDo(!ShouldSkip("CC.C.C4c.Tx && CC.C.A0007 && CC.C.F04"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitAttribute(GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorTemperatureMireds::Id);
        }
        case 13: {
            LogStep(13, "Wait for ConfigTransitionTime");
            ListFreer listFreer;
            chip::app::Clusters::DelayCommands::Commands::WaitForMs::Type value;
            value.ms = mConfigTransitionTime.HasValue() ? mConfigTransitionTime.Value() : 3000UL;
            return WaitForMs(kIdentityAlpha, value);
        }
        case 14: {
            LogStep(14, "DUT reads CurrentColorTemperatureMireds attribute from TH (potentially multiple times)");
            VerifyOrDo(!ShouldSkip("CC.C.C4c.Tx && CC.C.A0007 && CC.C.F04"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitAttribute(GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorTemperatureMireds::Id);
        }
        case 15: {
            LogStep(15, "DUT sends StopMoveStep command to TH");
            VerifyOrDo(!ShouldSkip("CC.C.C47.Tx && CC.C.F04"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitCommand(GetEndpoint(1), ColorControl::Id, ColorControl::Commands::StopMoveStep::Id);
        }
        case 16: {
            LogStep(16, "Wait for ConfigTransitionTime");
            ListFreer listFreer;
            chip::app::Clusters::DelayCommands::Commands::WaitForMs::Type value;
            value.ms = mConfigTransitionTime.HasValue() ? mConfigTransitionTime.Value() : 3000UL;
            return WaitForMs(kIdentityAlpha, value);
        }
        case 17: {
            LogStep(17, "DUT reads CurrentColorTemperatureMireds attribute from TH (potentially multiple times)");
            VerifyOrDo(!ShouldSkip("CC.C.C47.Tx && CC.C.A0007 && CC.C.F04"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitAttribute(GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorTemperatureMireds::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_CC_7_5_SimulatedSuite : public TestCommand
{
public:
    Test_TC_CC_7_5_SimulatedSuite() : TestCommand("Test_TC_CC_7_5_Simulated", 23)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("ConfigTransitionTime", 0, UINT16_MAX, &mConfigTransitionTime);
    }

    ~Test_TC_CC_7_5_SimulatedSuite() {}

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<uint16_t> mTimeout;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mConfigTransitionTime;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 16:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 21:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "PreCondition: Set TH OnOff to On");
            return WaitCommand(GetEndpoint(1), OnOff::Id, OnOff::Commands::On::Id);
        }
        case 1: {
            LogStep(1, "DUT sends MoveToEnhancedHue command to TH");
            VerifyOrDo(!ShouldSkip("CC.C.C40.Tx && CC.C.F01"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitCommand(GetEndpoint(1), ColorControl::Id, ColorControl::Commands::EnhancedMoveToHue::Id);
        }
        case 2: {
            LogStep(2, "DUT reads EnhancedCurrentHue attribute from TH (potentially multiple times)");
            VerifyOrDo(!ShouldSkip("CC.C.C40.Tx && CC.C.A4000 && CC.C.F01"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitAttribute(GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::EnhancedCurrentHue::Id);
        }
        case 3: {
            LogStep(3, "Wait for ConfigTransitionTime");
            ListFreer listFreer;
            chip::app::Clusters::DelayCommands::Commands::WaitForMs::Type value;
            value.ms = mConfigTransitionTime.HasValue() ? mConfigTransitionTime.Value() : 3000UL;
            return WaitForMs(kIdentityAlpha, value);
        }
        case 4: {
            LogStep(4, "DUT reads EnhancedCurrentHue attribute from TH (potentially multiple times)");
            VerifyOrDo(!ShouldSkip("CC.C.C40.Tx && CC.C.A4000 && CC.C.F01"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitAttribute(GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::EnhancedCurrentHue::Id);
        }
        case 5: {
            LogStep(5, "DUT sends MoveEnhanced Hue command to TH");
            VerifyOrDo(!ShouldSkip("CC.C.C41.Tx"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitCommand(GetEndpoint(1), ColorControl::Id, ColorControl::Commands::EnhancedMoveHue::Id);
        }
        case 6: {
            LogStep(6, "DUT reads EnhancedCurrentHue attribute from TH (potentially multiple times)");
            VerifyOrDo(!ShouldSkip("CC.C.C41.Tx && CC.C.A4000 && CC.C.F01"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitAttribute(GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::EnhancedCurrentHue::Id);
        }
        case 7: {
            LogStep(7, "Wait for ConfigTransitionTime");
            ListFreer listFreer;
            chip::app::Clusters::DelayCommands::Commands::WaitForMs::Type value;
            value.ms = mConfigTransitionTime.HasValue() ? mConfigTransitionTime.Value() : 3000UL;
            return WaitForMs(kIdentityAlpha, value);
        }
        case 8: {
            LogStep(8, "DUT reads EnhancedCurrentHue attribute from TH (potentially multiple times)");
            VerifyOrDo(!ShouldSkip("CC.C.C41.Tx && CC.C.A4000 && CC.C.F01"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitAttribute(GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::EnhancedCurrentHue::Id);
        }
        case 9: {
            LogStep(9, "DUT sends StepEnhanced command to TH");
            VerifyOrDo(!ShouldSkip("CC.C.C42.Tx"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitCommand(GetEndpoint(1), ColorControl::Id, ColorControl::Commands::EnhancedStepHue::Id);
        }
        case 10: {
            LogStep(10, "DUT reads EnhancedCurrentHue attribute from TH (potentially multiple times)");
            VerifyOrDo(!ShouldSkip("CC.C.C42.Tx && CC.C.A4000 && CC.C.F01"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitAttribute(GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::EnhancedCurrentHue::Id);
        }
        case 11: {
            LogStep(11, "Wait for ConfigTransitionTime");
            ListFreer listFreer;
            chip::app::Clusters::DelayCommands::Commands::WaitForMs::Type value;
            value.ms = mConfigTransitionTime.HasValue() ? mConfigTransitionTime.Value() : 3000UL;
            return WaitForMs(kIdentityAlpha, value);
        }
        case 12: {
            LogStep(12, "DUT reads EnhancedCurrentHue attribute from TH (potentially multiple times)");
            VerifyOrDo(!ShouldSkip("CC.C.C42.Tx && CC.C.A4000 && CC.C.F01"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitAttribute(GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::EnhancedCurrentHue::Id);
        }
        case 13: {
            LogStep(13, "DUT sends EnhancedMoveToHueAndSaturation command to TH");
            VerifyOrDo(!ShouldSkip("CC.C.C43.Tx && CC.C.F01"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitCommand(GetEndpoint(1), ColorControl::Id, ColorControl::Commands::EnhancedMoveToHueAndSaturation::Id);
        }
        case 14: {
            LogStep(14, "DUT reads EnhancedCurrentHue attribute from TH (potentially multiple times)");
            VerifyOrDo(!ShouldSkip("CC.C.C43.Tx && CC.C.A4000 && CC.C.F01"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitAttribute(GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::EnhancedCurrentHue::Id);
        }
        case 15: {
            LogStep(15, "DUT reads CurrentSaturation attribute from TH (potentially multiple times)");
            VerifyOrDo(!ShouldSkip("CC.C.C43.Tx && CC.C.A0001 && CC.C.F01"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitAttribute(GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::CurrentSaturation::Id);
        }
        case 16: {
            LogStep(16, "Wait for ConfigTransitionTime");
            ListFreer listFreer;
            chip::app::Clusters::DelayCommands::Commands::WaitForMs::Type value;
            value.ms = mConfigTransitionTime.HasValue() ? mConfigTransitionTime.Value() : 3000UL;
            return WaitForMs(kIdentityAlpha, value);
        }
        case 17: {
            LogStep(17, "DUT reads EnhancedCurrentHue attribute from TH (potentially multiple times)");
            VerifyOrDo(!ShouldSkip("CC.C.C43.Tx && CC.C.A4000 && CC.C.F01"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitAttribute(GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::EnhancedCurrentHue::Id);
        }
        case 18: {
            LogStep(18, "DUT reads CurrentSaturation attribute from TH (potentially multiple times)");
            VerifyOrDo(!ShouldSkip("CC.C.C43.Tx && CC.C.A0001 && CC.C.F01"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitAttribute(GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::CurrentSaturation::Id);
        }
        case 19: {
            LogStep(19, "DUT sends StopMoveStep command to TH");
            VerifyOrDo(!ShouldSkip("CC.C.C47.Tx && CC.C.F01"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitCommand(GetEndpoint(1), ColorControl::Id, ColorControl::Commands::StopMoveStep::Id);
        }
        case 20: {
            LogStep(20, "DUT reads EnhancedCurrentHue attribute from TH (potentially multiple times)");
            VerifyOrDo(!ShouldSkip("CC.C.C47.Tx && CC.C.A4000 && CC.C.F01"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitAttribute(GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::EnhancedCurrentHue::Id);
        }
        case 21: {
            LogStep(21, "Wait for ConfigTransitionTime");
            ListFreer listFreer;
            chip::app::Clusters::DelayCommands::Commands::WaitForMs::Type value;
            value.ms = mConfigTransitionTime.HasValue() ? mConfigTransitionTime.Value() : 3000UL;
            return WaitForMs(kIdentityAlpha, value);
        }
        case 22: {
            LogStep(22, "DUT reads EnhancedCurrentHue attribute from TH (potentially multiple times)");
            VerifyOrDo(!ShouldSkip("CC.C.C47.Tx && CC.C.A4000 && CC.C.F01"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitAttribute(GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::EnhancedCurrentHue::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_CC_9_4_SimulatedSuite : public TestCommand
{
public:
    Test_TC_CC_9_4_SimulatedSuite() : TestCommand("Test_TC_CC_9_4_Simulated", 19)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
    }

    ~Test_TC_CC_9_4_SimulatedSuite() {}

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<uint16_t> mTimeout;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 13:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 15:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 17:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "PreCondition: Set TH OnOff to On");
            return WaitCommand(GetEndpoint(1), OnOff::Id, OnOff::Commands::On::Id);
        }
        case 1: {
            LogStep(1, "DUT sends ColorLoopSet command to TH");
            VerifyOrDo(!ShouldSkip("CC.C.C44.Tx && CC.C.F02 && CC.C.F01"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitCommand(GetEndpoint(1), ColorControl::Id, ColorControl::Commands::ColorLoopSet::Id);
        }
        case 2: {
            LogStep(2, "DUT reads ColorLoopActive attribute from TH periodically");
            VerifyOrDo(!ShouldSkip("CC.C.A4002 && CC.C.F02 && CC.C.F01"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitAttribute(GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorLoopActive::Id);
        }
        case 3: {
            LogStep(3, "DUT reads ColorLoopDirection attribute from TH periodically");
            VerifyOrDo(!ShouldSkip("CC.C.A4003 && CC.C.F02 && CC.C.F01"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitAttribute(GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorLoopDirection::Id);
        }
        case 4: {
            LogStep(4, "DUT reads ColorLoopTime attribute from TH periodically");
            VerifyOrDo(!ShouldSkip("CC.C.A4004 && CC.C.F02 && CC.C.F01"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitAttribute(GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorLoopTime::Id);
        }
        case 5: {
            LogStep(5, "DUT reads ColorLoopStartEnhancedHue attribute from TH periodically");
            VerifyOrDo(!ShouldSkip("CC.C.A4005 && CC.C.F02 && CC.C.F01"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitAttribute(GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorLoopStartEnhancedHue::Id);
        }
        case 6: {
            LogStep(6, "DUT reads EnhancedCurrentHue attribute from TH periodically");
            VerifyOrDo(!ShouldSkip("CC.C.A4000 && CC.C.F02 && CC.C.F01"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitAttribute(GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::EnhancedCurrentHue::Id);
        }
        case 7: {
            LogStep(7, "Wait 5000ms");
            VerifyOrDo(!ShouldSkip("CC.C.F02 && CC.C.F01"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            ListFreer listFreer;
            chip::app::Clusters::DelayCommands::Commands::WaitForMs::Type value;
            value.ms = 5000UL;
            return WaitForMs(kIdentityAlpha, value);
        }
        case 8: {
            LogStep(8, "DUT reads EnhancedCurrentHue attribute from TH periodically");
            VerifyOrDo(!ShouldSkip("CC.C.A4000 && CC.C.F02 && CC.C.F01"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitAttribute(GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::EnhancedCurrentHue::Id);
        }
        case 9: {
            LogStep(9, "Wait 5000ms");
            VerifyOrDo(!ShouldSkip("CC.C.F02 && CC.C.F01"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            ListFreer listFreer;
            chip::app::Clusters::DelayCommands::Commands::WaitForMs::Type value;
            value.ms = 5000UL;
            return WaitForMs(kIdentityAlpha, value);
        }
        case 10: {
            LogStep(10, "DUT reads EnhancedCurrentHue attribute from TH periodically");
            VerifyOrDo(!ShouldSkip("CC.C.A4000 && CC.C.F02 && CC.C.F01"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitAttribute(GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::EnhancedCurrentHue::Id);
        }
        case 11: {
            LogStep(11, "Wait 5000ms");
            VerifyOrDo(!ShouldSkip("CC.C.F02 && CC.C.F01"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            ListFreer listFreer;
            chip::app::Clusters::DelayCommands::Commands::WaitForMs::Type value;
            value.ms = 5000UL;
            return WaitForMs(kIdentityAlpha, value);
        }
        case 12: {
            LogStep(12, "DUT reads EnhancedCurrentHue attribute from TH periodically");
            VerifyOrDo(!ShouldSkip("CC.C.A4000 && CC.C.F02 && CC.C.F01"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitAttribute(GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::EnhancedCurrentHue::Id);
        }
        case 13: {
            LogStep(13, "Wait 5000ms");
            VerifyOrDo(!ShouldSkip("CC.C.F02 && CC.C.F01"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            ListFreer listFreer;
            chip::app::Clusters::DelayCommands::Commands::WaitForMs::Type value;
            value.ms = 5000UL;
            return WaitForMs(kIdentityAlpha, value);
        }
        case 14: {
            LogStep(14, "DUT reads EnhancedCurrentHue attribute from TH periodically");
            VerifyOrDo(!ShouldSkip("CC.C.A4000 && CC.C.F02 && CC.C.F01"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitAttribute(GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::EnhancedCurrentHue::Id);
        }
        case 15: {
            LogStep(15, "Wait 5000ms");
            VerifyOrDo(!ShouldSkip("CC.C.F02 && CC.C.F01"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            ListFreer listFreer;
            chip::app::Clusters::DelayCommands::Commands::WaitForMs::Type value;
            value.ms = 5000UL;
            return WaitForMs(kIdentityAlpha, value);
        }
        case 16: {
            LogStep(16, "DUT reads EnhancedCurrentHue attribute from TH periodically");
            VerifyOrDo(!ShouldSkip("CC.C.A4000 && CC.C.F02 && CC.C.F01"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitAttribute(GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::EnhancedCurrentHue::Id);
        }
        case 17: {
            LogStep(17, "Wait 5000ms");
            VerifyOrDo(!ShouldSkip("CC.C.F02 && CC.C.F01"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            ListFreer listFreer;
            chip::app::Clusters::DelayCommands::Commands::WaitForMs::Type value;
            value.ms = 5000UL;
            return WaitForMs(kIdentityAlpha, value);
        }
        case 18: {
            LogStep(18, "DUT reads EnhancedCurrentHue attribute from TH periodically");
            VerifyOrDo(!ShouldSkip("CC.C.A4000 && CC.C.F02 && CC.C.F01"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitAttribute(GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::EnhancedCurrentHue::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_DGTHREAD_3_4_SimulatedSuite : public TestCommand
{
public:
    Test_TC_DGTHREAD_3_4_SimulatedSuite() : TestCommand("Test_TC_DGTHREAD_3_4_Simulated", 2)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_DGTHREAD_3_4_SimulatedSuite() {}

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "DUT sends ResetCounts command to TH");
            VerifyOrDo(!ShouldSkip("DGTHREAD.C.C00.Tx"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitCommand(GetEndpoint(0), ThreadNetworkDiagnostics::Id, ThreadNetworkDiagnostics::Commands::ResetCounts::Id);
        }
        case 1: {
            LogStep(1, "DUT reads OverrunCount attribute value from TH");
            VerifyOrDo(!ShouldSkip("DGTHREAD.C.A0006"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitAttribute(GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::OverrunCount::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_OO_3_2_SimulatedSuite : public TestCommand
{
public:
    Test_TC_OO_3_2_SimulatedSuite() : TestCommand("Test_TC_OO_3_2_Simulated", 6)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_OO_3_2_SimulatedSuite() {}

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "DUT issues an Off command to the TH");
            VerifyOrDo(!ShouldSkip("OO.C.C00.Tx"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitCommand(GetEndpoint(1), OnOff::Id, OnOff::Commands::Off::Id);
        }
        case 1: {
            LogStep(1, "DUT issues an On command to the TH");
            VerifyOrDo(!ShouldSkip("OO.C.C01.Tx"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitCommand(GetEndpoint(1), OnOff::Id, OnOff::Commands::On::Id);
        }
        case 2: {
            LogStep(2, "DUT issues an Toggle command to the TH");
            VerifyOrDo(!ShouldSkip("OO.C.C02.Tx"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitCommand(GetEndpoint(1), OnOff::Id, OnOff::Commands::Toggle::Id);
        }
        case 3: {
            LogStep(3, "DUT issues an OffWithEffect command to the TH");
            VerifyOrDo(!ShouldSkip("OO.C.C40.Tx"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitCommand(GetEndpoint(1), OnOff::Id, OnOff::Commands::OffWithEffect::Id);
        }
        case 4: {
            LogStep(4, "DUT issues an OnWithRecallGlobalScene command to the TH");
            VerifyOrDo(!ShouldSkip("OO.C.C41.Tx"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitCommand(GetEndpoint(1), OnOff::Id, OnOff::Commands::OnWithRecallGlobalScene::Id);
        }
        case 5: {
            LogStep(5, "DUT issues an OnWithTimedOff command to the TH");
            VerifyOrDo(!ShouldSkip("OO.C.C42.Tx"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return WaitCommand(GetEndpoint(1), OnOff::Id, OnOff::Commands::OnWithTimedOff::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

std::unique_ptr<TestCommand> GetTestCommand(std::string testName)
{
    if (testName == "Test_TC_WNCV_5_1_Simulated")
    {
        return std::unique_ptr<Test_TC_WNCV_5_1_SimulatedSuite>(new Test_TC_WNCV_5_1_SimulatedSuite());
    }
    if (testName == "Test_TC_OCC_2_4_Simulated")
    {
        return std::unique_ptr<Test_TC_OCC_2_4_SimulatedSuite>(new Test_TC_OCC_2_4_SimulatedSuite());
    }
    if (testName == "Test_TC_DGSW_3_2_Simulated")
    {
        return std::unique_ptr<Test_TC_DGSW_3_2_SimulatedSuite>(new Test_TC_DGSW_3_2_SimulatedSuite());
    }
    if (testName == "Test_TC_DGETH_3_2_Simulated")
    {
        return std::unique_ptr<Test_TC_DGETH_3_2_SimulatedSuite>(new Test_TC_DGETH_3_2_SimulatedSuite());
    }
    if (testName == "Test_TC_DGWIFI_3_2_Simulated")
    {
        return std::unique_ptr<Test_TC_DGWIFI_3_2_SimulatedSuite>(new Test_TC_DGWIFI_3_2_SimulatedSuite());
    }
    if (testName == "Test_TC_WNCV_6_1_Simulated")
    {
        return std::unique_ptr<Test_TC_WNCV_6_1_SimulatedSuite>(new Test_TC_WNCV_6_1_SimulatedSuite());
    }
    if (testName == "Test_TC_WNCV_7_1_Simulated")
    {
        return std::unique_ptr<Test_TC_WNCV_7_1_SimulatedSuite>(new Test_TC_WNCV_7_1_SimulatedSuite());
    }
    if (testName == "Test_TC_CC_3_4_Simulated")
    {
        return std::unique_ptr<Test_TC_CC_3_4_SimulatedSuite>(new Test_TC_CC_3_4_SimulatedSuite());
    }
    if (testName == "Test_TC_CC_4_5_Simulated")
    {
        return std::unique_ptr<Test_TC_CC_4_5_SimulatedSuite>(new Test_TC_CC_4_5_SimulatedSuite());
    }
    if (testName == "Test_TC_CC_5_4_Simulated")
    {
        return std::unique_ptr<Test_TC_CC_5_4_SimulatedSuite>(new Test_TC_CC_5_4_SimulatedSuite());
    }
    if (testName == "Test_TC_CC_6_4_Simulated")
    {
        return std::unique_ptr<Test_TC_CC_6_4_SimulatedSuite>(new Test_TC_CC_6_4_SimulatedSuite());
    }
    if (testName == "Test_TC_CC_7_5_Simulated")
    {
        return std::unique_ptr<Test_TC_CC_7_5_SimulatedSuite>(new Test_TC_CC_7_5_SimulatedSuite());
    }
    if (testName == "Test_TC_CC_9_4_Simulated")
    {
        return std::unique_ptr<Test_TC_CC_9_4_SimulatedSuite>(new Test_TC_CC_9_4_SimulatedSuite());
    }
    if (testName == "Test_TC_DGTHREAD_3_4_Simulated")
    {
        return std::unique_ptr<Test_TC_DGTHREAD_3_4_SimulatedSuite>(new Test_TC_DGTHREAD_3_4_SimulatedSuite());
    }
    if (testName == "Test_TC_OO_3_2_Simulated")
    {
        return std::unique_ptr<Test_TC_OO_3_2_SimulatedSuite>(new Test_TC_OO_3_2_SimulatedSuite());
    }

    return nullptr;
}

void PrintTestCommands()
{
    ChipLogError(chipTool, "Supported commands:");
    ChipLogError(chipTool, "\t* Test_TC_WNCV_5_1_Simulated");
    ChipLogError(chipTool, "\t* Test_TC_OCC_2_4_Simulated");
    ChipLogError(chipTool, "\t* Test_TC_DGSW_3_2_Simulated");
    ChipLogError(chipTool, "\t* Test_TC_DGETH_3_2_Simulated");
    ChipLogError(chipTool, "\t* Test_TC_DGWIFI_3_2_Simulated");
    ChipLogError(chipTool, "\t* Test_TC_WNCV_6_1_Simulated");
    ChipLogError(chipTool, "\t* Test_TC_WNCV_7_1_Simulated");
    ChipLogError(chipTool, "\t* Test_TC_CC_3_4_Simulated");
    ChipLogError(chipTool, "\t* Test_TC_CC_4_5_Simulated");
    ChipLogError(chipTool, "\t* Test_TC_CC_5_4_Simulated");
    ChipLogError(chipTool, "\t* Test_TC_CC_6_4_Simulated");
    ChipLogError(chipTool, "\t* Test_TC_CC_7_5_Simulated");
    ChipLogError(chipTool, "\t* Test_TC_CC_9_4_Simulated");
    ChipLogError(chipTool, "\t* Test_TC_DGTHREAD_3_4_Simulated");
    ChipLogError(chipTool, "\t* Test_TC_OO_3_2_Simulated");
}
