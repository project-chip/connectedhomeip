/*
 *
 *    Copyright (c) 2022 Project CHIP Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

// THIS FILE IS GENERATED BY ZAP

#pragma once

#include <commands/common/CommandInvoker.h>
#include <commands/tests/TestCommandBridge.h>
#include <lib/core/Optional.h>
#include <system/SystemClock.h>

#include <math.h> // For INFINITY

class TestList : public Command {
public:
    TestList()
        : Command("list") {};
    CHIP_ERROR Run() override
    {
        printf("TestAccessControlCluster\n");
        printf("Test_TC_BI_1_1\n");
        printf("Test_TC_BI_2_1\n");
        printf("Test_TC_BI_2_2\n");
        printf("Test_TC_BOOL_1_1\n");
        printf("Test_TC_BOOL_2_1\n");
        printf("Test_TC_BRAC_1_1\n");
        printf("Test_TC_CC_1_1\n");
        printf("Test_TC_CC_2_1\n");
        printf("Test_TC_CC_3_1\n");
        printf("Test_TC_CC_3_2\n");
        printf("Test_TC_CC_3_3\n");
        printf("Test_TC_CC_4_1\n");
        printf("Test_TC_CC_4_2\n");
        printf("Test_TC_CC_4_3\n");
        printf("Test_TC_CC_4_4\n");
        printf("Test_TC_CC_5_1\n");
        printf("Test_TC_CC_5_2\n");
        printf("Test_TC_CC_5_3\n");
        printf("Test_TC_CC_6_1\n");
        printf("Test_TC_CC_6_2\n");
        printf("Test_TC_CC_6_3\n");
        printf("Test_TC_CC_7_1\n");
        printf("Test_TC_CC_7_2\n");
        printf("Test_TC_CC_7_3\n");
        printf("Test_TC_CC_7_4\n");
        printf("Test_TC_CC_8_1\n");
        printf("Test_TC_CC_9_1\n");
        printf("Test_TC_CC_9_2\n");
        printf("Test_TC_CC_9_3\n");
        printf("Test_TC_DD_1_5\n");
        printf("Test_TC_DD_1_6\n");
        printf("Test_TC_DD_1_7\n");
        printf("Test_TC_DD_1_8\n");
        printf("Test_TC_DD_1_9\n");
        printf("Test_TC_DM_1_1\n");
        printf("Test_TC_DM_3_1\n");
        printf("Test_TC_EMR_1_1\n");
        printf("Test_TC_ETHDIAG_1_1\n");
        printf("Test_TC_ETHDIAG_2_1\n");
        printf("Test_TC_FLW_1_1\n");
        printf("Test_TC_FLW_2_1\n");
        printf("Test_TC_FLW_2_2\n");
        printf("Test_TC_ILL_1_1\n");
        printf("Test_TC_LVL_1_1\n");
        printf("Test_TC_LVL_2_1\n");
        printf("Test_TC_LVL_2_2\n");
        printf("Test_TC_LVL_3_1\n");
        printf("Test_TC_LVL_4_1\n");
        printf("Test_TC_LVL_5_1\n");
        printf("Test_TC_LVL_6_1\n");
        printf("Test_TC_MC_1_1\n");
        printf("Test_TC_MC_2_1\n");
        printf("Test_TC_MC_3_1\n");
        printf("Test_TC_MC_3_2\n");
        printf("Test_TC_MC_3_3\n");
        printf("Test_TC_MC_3_4\n");
        printf("Test_TC_MC_3_5\n");
        printf("Test_TC_MC_3_6\n");
        printf("Test_TC_MC_3_7\n");
        printf("Test_TC_MC_3_8\n");
        printf("Test_TC_MC_3_9\n");
        printf("Test_TC_MC_3_10\n");
        printf("Test_TC_MC_3_11\n");
        printf("Test_TC_MC_5_1\n");
        printf("Test_TC_MC_5_2\n");
        printf("Test_TC_MC_5_3\n");
        printf("Test_TC_MC_6_1\n");
        printf("Test_TC_MC_6_2\n");
        printf("Test_TC_MC_6_3\n");
        printf("Test_TC_MC_6_4\n");
        printf("Test_TC_MC_7_1\n");
        printf("Test_TC_MC_7_2\n");
        printf("Test_TC_MC_8_1\n");
        printf("Test_TC_MC_9_1\n");
        printf("Test_TC_OCC_1_1\n");
        printf("Test_TC_OCC_2_1\n");
        printf("Test_TC_OCC_2_2\n");
        printf("Test_TC_OO_1_1\n");
        printf("Test_TC_OO_2_1\n");
        printf("Test_TC_OO_2_2\n");
        printf("Test_TC_OO_2_3\n");
        printf("Test_TC_PS_1_1\n");
        printf("Test_TC_PRS_1_1\n");
        printf("Test_TC_PRS_2_1\n");
        printf("Test_TC_PCC_1_1\n");
        printf("Test_TC_PCC_2_1\n");
        printf("Test_TC_PCC_2_2\n");
        printf("Test_TC_PCC_2_3\n");
        printf("Test_TC_RH_1_1\n");
        printf("Test_TC_RH_2_1\n");
        printf("Test_TC_RH_2_2\n");
        printf("Test_TC_SWTCH_2_1\n");
        printf("Test_TC_SWTCH_2_2\n");
        printf("Test_TC_TM_1_1\n");
        printf("Test_TC_TM_2_1\n");
        printf("Test_TC_TM_2_2\n");
        printf("Test_TC_TSTAT_1_1\n");
        printf("Test_TC_TSTAT_2_1\n");
        printf("Test_TC_TSTAT_2_2\n");
        printf("Test_TC_TSUIC_1_1\n");
        printf("Test_TC_TSUIC_2_1\n");
        printf("Test_TC_TSUIC_2_2\n");
        printf("Test_TC_DIAG_TH_NW_1_1\n");
        printf("Test_TC_WIFIDIAG_1_1\n");
        printf("Test_TC_WIFIDIAG_3_1\n");
        printf("Test_TC_WNCV_1_1\n");
        printf("Test_TC_WNCV_2_1\n");
        printf("Test_TC_WNCV_2_2\n");
        printf("Test_TC_WNCV_2_4\n");
        printf("Test_TC_WNCV_2_5\n");
        printf("Test_TC_WNCV_3_4\n");
        printf("Test_TC_WNCV_3_5\n");
        printf("Test_TC_WNCV_4_3\n");
        printf("Test_TC_WNCV_4_4\n");
        printf("TestCluster\n");
        printf("TestSaveAs\n");
        printf("TestConstraints\n");
        printf("TestDelayCommands\n");
        printf("TestDescriptorCluster\n");
        printf("TestBasicInformation\n");
        printf("TestGroupsCluster\n");
        printf("TestGroupKeyManagementCluster\n");
        printf("TestIdentifyCluster\n");
        printf("TestLogCommands\n");
        printf("TestOperationalCredentialsCluster\n");
        printf("TestBinding\n");
        printf("Test_TC_SWDIAG_1_1\n");
        printf("Test_TC_SWDIAG_2_1\n");
        printf("Test_TC_SWDIAG_3_1\n");
        printf("TestSubscribe_OnOff\n");

        return CHIP_NO_ERROR;
    }
};

class ManualTestList : public Command {
public:
    ManualTestList()
        : Command("list-manual") {};
    CHIP_ERROR Run() override { return CHIP_NO_ERROR; }
};

class TestAccessControlCluster : public TestCommandBridge {
public:
    TestAccessControlCluster()
        : TestCommandBridge("TestAccessControlCluster")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~TestAccessControlCluster() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: TestAccessControlCluster\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: TestAccessControlCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for commissionee\n");
            err = TestWaitForCommissionee_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Write entries\n");
            err = TestWriteEntries_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Verify\n");
            err = TestVerify_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Write entries empty lists\n");
            err = TestWriteEntriesEmptyLists_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Verify\n");
            err = TestVerify_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Write entry invalid privilege\n");
            err = TestWriteEntryInvalidPrivilege_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Verify\n");
            err = TestVerify_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Write entry invalid auth mode\n");
            err = TestWriteEntryInvalidAuthMode_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Verify\n");
            err = TestVerify_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Write entry invalid subject\n");
            err = TestWriteEntryInvalidSubject_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Verify\n");
            err = TestVerify_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : Write entry invalid target\n");
            err = TestWriteEntryInvalidTarget_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : Verify\n");
            err = TestVerify_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : Write entry too many subjects\n");
            err = TestWriteEntryTooManySubjects_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : Verify\n");
            err = TestVerify_14();
            break;
        case 15:
            ChipLogProgress(chipTool, " ***** Test Step 15 : Write entry too many targets\n");
            err = TestWriteEntryTooManyTargets_15();
            break;
        case 16:
            ChipLogProgress(chipTool, " ***** Test Step 16 : Verify\n");
            err = TestVerify_16();
            break;
        case 17:
            ChipLogProgress(chipTool, " ***** Test Step 17 : Restore ACL\n");
            err = TestRestoreAcl_17();
            break;
        case 18:
            ChipLogProgress(chipTool, " ***** Test Step 18 : Verify\n");
            err = TestVerify_18();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 19;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForCommissionee_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteEntries_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestAccessControl * cluster = [[CHIPTestAccessControl alloc] initWithDevice:device endpoint:0 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id aclArgument;
        {
            NSMutableArray * temp_0 = [[NSMutableArray alloc] init];
            temp_0[0] = [[CHIPAccessControlClusterAccessControlEntry alloc] init];
            ((CHIPAccessControlClusterAccessControlEntry *) temp_0[0]).privilege = [NSNumber numberWithUnsignedChar:5];
            ((CHIPAccessControlClusterAccessControlEntry *) temp_0[0]).authMode = [NSNumber numberWithUnsignedChar:2];
            ((CHIPAccessControlClusterAccessControlEntry *) temp_0[0]).subjects = nil;
            {
                NSMutableArray * temp_3 = [[NSMutableArray alloc] init];
                temp_3[0] = [[CHIPAccessControlClusterTarget alloc] init];
                ((CHIPAccessControlClusterTarget *) temp_3[0]).cluster = nil;
                ((CHIPAccessControlClusterTarget *) temp_3[0]).endpoint = [NSNumber numberWithUnsignedShort:0U];
                ((CHIPAccessControlClusterTarget *) temp_3[0]).deviceType = nil;

                temp_3[1] = [[CHIPAccessControlClusterTarget alloc] init];
                ((CHIPAccessControlClusterTarget *) temp_3[1]).cluster = [NSNumber numberWithUnsignedInt:1UL];
                ((CHIPAccessControlClusterTarget *) temp_3[1]).endpoint = nil;
                ((CHIPAccessControlClusterTarget *) temp_3[1]).deviceType = nil;

                temp_3[2] = [[CHIPAccessControlClusterTarget alloc] init];
                ((CHIPAccessControlClusterTarget *) temp_3[2]).cluster = [NSNumber numberWithUnsignedInt:2UL];
                ((CHIPAccessControlClusterTarget *) temp_3[2]).endpoint = [NSNumber numberWithUnsignedShort:3U];
                ((CHIPAccessControlClusterTarget *) temp_3[2]).deviceType = nil;

                ((CHIPAccessControlClusterAccessControlEntry *) temp_0[0]).targets = temp_3;
            }
            ((CHIPAccessControlClusterAccessControlEntry *) temp_0[0]).fabricIndex = [NSNumber numberWithUnsignedChar:0];

            temp_0[1] = [[CHIPAccessControlClusterAccessControlEntry alloc] init];
            ((CHIPAccessControlClusterAccessControlEntry *) temp_0[1]).privilege = [NSNumber numberWithUnsignedChar:1];
            ((CHIPAccessControlClusterAccessControlEntry *) temp_0[1]).authMode = [NSNumber numberWithUnsignedChar:2];
            {
                NSMutableArray * temp_3 = [[NSMutableArray alloc] init];
                temp_3[0] = [NSNumber numberWithUnsignedLongLong:4ULL];
                temp_3[1] = [NSNumber numberWithUnsignedLongLong:5ULL];
                temp_3[2] = [NSNumber numberWithUnsignedLongLong:6ULL];
                temp_3[3] = [NSNumber numberWithUnsignedLongLong:7ULL];
                ((CHIPAccessControlClusterAccessControlEntry *) temp_0[1]).subjects = temp_3;
            }
            {
                NSMutableArray * temp_3 = [[NSMutableArray alloc] init];
                temp_3[0] = [[CHIPAccessControlClusterTarget alloc] init];
                ((CHIPAccessControlClusterTarget *) temp_3[0]).cluster = nil;
                ((CHIPAccessControlClusterTarget *) temp_3[0]).endpoint = [NSNumber numberWithUnsignedShort:8U];
                ((CHIPAccessControlClusterTarget *) temp_3[0]).deviceType = nil;

                temp_3[1] = [[CHIPAccessControlClusterTarget alloc] init];
                ((CHIPAccessControlClusterTarget *) temp_3[1]).cluster = [NSNumber numberWithUnsignedInt:9UL];
                ((CHIPAccessControlClusterTarget *) temp_3[1]).endpoint = nil;
                ((CHIPAccessControlClusterTarget *) temp_3[1]).deviceType = nil;

                temp_3[2] = [[CHIPAccessControlClusterTarget alloc] init];
                ((CHIPAccessControlClusterTarget *) temp_3[2]).cluster = [NSNumber numberWithUnsignedInt:10UL];
                ((CHIPAccessControlClusterTarget *) temp_3[2]).endpoint = [NSNumber numberWithUnsignedShort:11U];
                ((CHIPAccessControlClusterTarget *) temp_3[2]).deviceType = nil;

                ((CHIPAccessControlClusterAccessControlEntry *) temp_0[1]).targets = temp_3;
            }
            ((CHIPAccessControlClusterAccessControlEntry *) temp_0[1]).fabricIndex = [NSNumber numberWithUnsignedChar:0];

            temp_0[2] = [[CHIPAccessControlClusterAccessControlEntry alloc] init];
            ((CHIPAccessControlClusterAccessControlEntry *) temp_0[2]).privilege = [NSNumber numberWithUnsignedChar:3];
            ((CHIPAccessControlClusterAccessControlEntry *) temp_0[2]).authMode = [NSNumber numberWithUnsignedChar:3];
            {
                NSMutableArray * temp_3 = [[NSMutableArray alloc] init];
                temp_3[0] = [NSNumber numberWithUnsignedLongLong:12ULL];
                temp_3[1] = [NSNumber numberWithUnsignedLongLong:13ULL];
                temp_3[2] = [NSNumber numberWithUnsignedLongLong:14ULL];
                temp_3[3] = [NSNumber numberWithUnsignedLongLong:15ULL];
                ((CHIPAccessControlClusterAccessControlEntry *) temp_0[2]).subjects = temp_3;
            }
            {
                NSMutableArray * temp_3 = [[NSMutableArray alloc] init];
                temp_3[0] = [[CHIPAccessControlClusterTarget alloc] init];
                ((CHIPAccessControlClusterTarget *) temp_3[0]).cluster = nil;
                ((CHIPAccessControlClusterTarget *) temp_3[0]).endpoint = [NSNumber numberWithUnsignedShort:16U];
                ((CHIPAccessControlClusterTarget *) temp_3[0]).deviceType = nil;

                temp_3[1] = [[CHIPAccessControlClusterTarget alloc] init];
                ((CHIPAccessControlClusterTarget *) temp_3[1]).cluster = [NSNumber numberWithUnsignedInt:17UL];
                ((CHIPAccessControlClusterTarget *) temp_3[1]).endpoint = nil;
                ((CHIPAccessControlClusterTarget *) temp_3[1]).deviceType = nil;

                temp_3[2] = [[CHIPAccessControlClusterTarget alloc] init];
                ((CHIPAccessControlClusterTarget *) temp_3[2]).cluster = [NSNumber numberWithUnsignedInt:18UL];
                ((CHIPAccessControlClusterTarget *) temp_3[2]).endpoint = [NSNumber numberWithUnsignedShort:19U];
                ((CHIPAccessControlClusterTarget *) temp_3[2]).deviceType = nil;

                ((CHIPAccessControlClusterAccessControlEntry *) temp_0[2]).targets = temp_3;
            }
            ((CHIPAccessControlClusterAccessControlEntry *) temp_0[2]).fabricIndex = [NSNumber numberWithUnsignedChar:0];

            aclArgument = temp_0;
        }
        [cluster writeAttributeAclWithValue:aclArgument
                          completionHandler:^(NSError * _Nullable err) {
                              NSLog(@"Write entries Error: %@", err);

                              VerifyOrReturn(CheckValue("status", err, 0));

                              NextTest();
                          }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestVerify_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestAccessControl * cluster = [[CHIPTestAccessControl alloc] initWithDevice:device endpoint:0 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        CHIPReadParams * params = [[CHIPReadParams alloc] init];
        params.fabricFiltered = [NSNumber numberWithBool:true];
        [cluster
            readAttributeAclWithParams:params
                     completionHandler:^(NSArray * _Nullable value, NSError * _Nullable err) {
                         NSLog(@"Verify Error: %@", err);

                         VerifyOrReturn(CheckValue("status", err, 0));

                         {
                             id actualValue = value;
                             VerifyOrReturn(CheckValue("ACL", [actualValue count], static_cast<uint32_t>(3)));
                             VerifyOrReturn(CheckValue(
                                 "Privilege", ((CHIPAccessControlClusterAccessControlEntry *) actualValue[0]).privilege, 5));
                             VerifyOrReturn(CheckValue(
                                 "AuthMode", ((CHIPAccessControlClusterAccessControlEntry *) actualValue[0]).authMode, 2));
                             VerifyOrReturn(CheckValueNull(
                                 "Subjects", ((CHIPAccessControlClusterAccessControlEntry *) actualValue[0]).subjects));
                             VerifyOrReturn(CheckValueNonNull(
                                 "Targets", ((CHIPAccessControlClusterAccessControlEntry *) actualValue[0]).targets));
                             VerifyOrReturn(CheckValue("Targets",
                                 [((CHIPAccessControlClusterAccessControlEntry *) actualValue[0]).targets count],
                                 static_cast<uint32_t>(3)));
                             VerifyOrReturn(CheckValueNull("Cluster",
                                 ((CHIPAccessControlClusterTarget *) ((CHIPAccessControlClusterAccessControlEntry *) actualValue[0])
                                         .targets[0])
                                     .cluster));
                             VerifyOrReturn(CheckValueNonNull("Endpoint",
                                 ((CHIPAccessControlClusterTarget *) ((CHIPAccessControlClusterAccessControlEntry *) actualValue[0])
                                         .targets[0])
                                     .endpoint));
                             VerifyOrReturn(CheckValue("Endpoint",
                                 ((CHIPAccessControlClusterTarget *) ((CHIPAccessControlClusterAccessControlEntry *) actualValue[0])
                                         .targets[0])
                                     .endpoint,
                                 0U));
                             VerifyOrReturn(CheckValueNull("DeviceType",
                                 ((CHIPAccessControlClusterTarget *) ((CHIPAccessControlClusterAccessControlEntry *) actualValue[0])
                                         .targets[0])
                                     .deviceType));
                             VerifyOrReturn(CheckValueNonNull("Cluster",
                                 ((CHIPAccessControlClusterTarget *) ((CHIPAccessControlClusterAccessControlEntry *) actualValue[0])
                                         .targets[1])
                                     .cluster));
                             VerifyOrReturn(CheckValue("Cluster",
                                 ((CHIPAccessControlClusterTarget *) ((CHIPAccessControlClusterAccessControlEntry *) actualValue[0])
                                         .targets[1])
                                     .cluster,
                                 1UL));
                             VerifyOrReturn(CheckValueNull("Endpoint",
                                 ((CHIPAccessControlClusterTarget *) ((CHIPAccessControlClusterAccessControlEntry *) actualValue[0])
                                         .targets[1])
                                     .endpoint));
                             VerifyOrReturn(CheckValueNull("DeviceType",
                                 ((CHIPAccessControlClusterTarget *) ((CHIPAccessControlClusterAccessControlEntry *) actualValue[0])
                                         .targets[1])
                                     .deviceType));
                             VerifyOrReturn(CheckValueNonNull("Cluster",
                                 ((CHIPAccessControlClusterTarget *) ((CHIPAccessControlClusterAccessControlEntry *) actualValue[0])
                                         .targets[2])
                                     .cluster));
                             VerifyOrReturn(CheckValue("Cluster",
                                 ((CHIPAccessControlClusterTarget *) ((CHIPAccessControlClusterAccessControlEntry *) actualValue[0])
                                         .targets[2])
                                     .cluster,
                                 2UL));
                             VerifyOrReturn(CheckValueNonNull("Endpoint",
                                 ((CHIPAccessControlClusterTarget *) ((CHIPAccessControlClusterAccessControlEntry *) actualValue[0])
                                         .targets[2])
                                     .endpoint));
                             VerifyOrReturn(CheckValue("Endpoint",
                                 ((CHIPAccessControlClusterTarget *) ((CHIPAccessControlClusterAccessControlEntry *) actualValue[0])
                                         .targets[2])
                                     .endpoint,
                                 3U));
                             VerifyOrReturn(CheckValueNull("DeviceType",
                                 ((CHIPAccessControlClusterTarget *) ((CHIPAccessControlClusterAccessControlEntry *) actualValue[0])
                                         .targets[2])
                                     .deviceType));
                             VerifyOrReturn(CheckValue(
                                 "FabricIndex", ((CHIPAccessControlClusterAccessControlEntry *) actualValue[0]).fabricIndex, 1));
                             VerifyOrReturn(CheckValue(
                                 "Privilege", ((CHIPAccessControlClusterAccessControlEntry *) actualValue[1]).privilege, 1));
                             VerifyOrReturn(CheckValue(
                                 "AuthMode", ((CHIPAccessControlClusterAccessControlEntry *) actualValue[1]).authMode, 2));
                             VerifyOrReturn(CheckValueNonNull(
                                 "Subjects", ((CHIPAccessControlClusterAccessControlEntry *) actualValue[1]).subjects));
                             VerifyOrReturn(CheckValue("Subjects",
                                 [((CHIPAccessControlClusterAccessControlEntry *) actualValue[1]).subjects count],
                                 static_cast<uint32_t>(4)));
                             VerifyOrReturn(
                                 CheckValue("", ((CHIPAccessControlClusterAccessControlEntry *) actualValue[1]).subjects[0], 4ULL));
                             VerifyOrReturn(
                                 CheckValue("", ((CHIPAccessControlClusterAccessControlEntry *) actualValue[1]).subjects[1], 5ULL));
                             VerifyOrReturn(
                                 CheckValue("", ((CHIPAccessControlClusterAccessControlEntry *) actualValue[1]).subjects[2], 6ULL));
                             VerifyOrReturn(
                                 CheckValue("", ((CHIPAccessControlClusterAccessControlEntry *) actualValue[1]).subjects[3], 7ULL));
                             VerifyOrReturn(CheckValueNonNull(
                                 "Targets", ((CHIPAccessControlClusterAccessControlEntry *) actualValue[1]).targets));
                             VerifyOrReturn(CheckValue("Targets",
                                 [((CHIPAccessControlClusterAccessControlEntry *) actualValue[1]).targets count],
                                 static_cast<uint32_t>(3)));
                             VerifyOrReturn(CheckValueNull("Cluster",
                                 ((CHIPAccessControlClusterTarget *) ((CHIPAccessControlClusterAccessControlEntry *) actualValue[1])
                                         .targets[0])
                                     .cluster));
                             VerifyOrReturn(CheckValueNonNull("Endpoint",
                                 ((CHIPAccessControlClusterTarget *) ((CHIPAccessControlClusterAccessControlEntry *) actualValue[1])
                                         .targets[0])
                                     .endpoint));
                             VerifyOrReturn(CheckValue("Endpoint",
                                 ((CHIPAccessControlClusterTarget *) ((CHIPAccessControlClusterAccessControlEntry *) actualValue[1])
                                         .targets[0])
                                     .endpoint,
                                 8U));
                             VerifyOrReturn(CheckValueNull("DeviceType",
                                 ((CHIPAccessControlClusterTarget *) ((CHIPAccessControlClusterAccessControlEntry *) actualValue[1])
                                         .targets[0])
                                     .deviceType));
                             VerifyOrReturn(CheckValueNonNull("Cluster",
                                 ((CHIPAccessControlClusterTarget *) ((CHIPAccessControlClusterAccessControlEntry *) actualValue[1])
                                         .targets[1])
                                     .cluster));
                             VerifyOrReturn(CheckValue("Cluster",
                                 ((CHIPAccessControlClusterTarget *) ((CHIPAccessControlClusterAccessControlEntry *) actualValue[1])
                                         .targets[1])
                                     .cluster,
                                 9UL));
                             VerifyOrReturn(CheckValueNull("Endpoint",
                                 ((CHIPAccessControlClusterTarget *) ((CHIPAccessControlClusterAccessControlEntry *) actualValue[1])
                                         .targets[1])
                                     .endpoint));
                             VerifyOrReturn(CheckValueNull("DeviceType",
                                 ((CHIPAccessControlClusterTarget *) ((CHIPAccessControlClusterAccessControlEntry *) actualValue[1])
                                         .targets[1])
                                     .deviceType));
                             VerifyOrReturn(CheckValueNonNull("Cluster",
                                 ((CHIPAccessControlClusterTarget *) ((CHIPAccessControlClusterAccessControlEntry *) actualValue[1])
                                         .targets[2])
                                     .cluster));
                             VerifyOrReturn(CheckValue("Cluster",
                                 ((CHIPAccessControlClusterTarget *) ((CHIPAccessControlClusterAccessControlEntry *) actualValue[1])
                                         .targets[2])
                                     .cluster,
                                 10UL));
                             VerifyOrReturn(CheckValueNonNull("Endpoint",
                                 ((CHIPAccessControlClusterTarget *) ((CHIPAccessControlClusterAccessControlEntry *) actualValue[1])
                                         .targets[2])
                                     .endpoint));
                             VerifyOrReturn(CheckValue("Endpoint",
                                 ((CHIPAccessControlClusterTarget *) ((CHIPAccessControlClusterAccessControlEntry *) actualValue[1])
                                         .targets[2])
                                     .endpoint,
                                 11U));
                             VerifyOrReturn(CheckValueNull("DeviceType",
                                 ((CHIPAccessControlClusterTarget *) ((CHIPAccessControlClusterAccessControlEntry *) actualValue[1])
                                         .targets[2])
                                     .deviceType));
                             VerifyOrReturn(CheckValue(
                                 "FabricIndex", ((CHIPAccessControlClusterAccessControlEntry *) actualValue[1]).fabricIndex, 1));
                             VerifyOrReturn(CheckValue(
                                 "Privilege", ((CHIPAccessControlClusterAccessControlEntry *) actualValue[2]).privilege, 3));
                             VerifyOrReturn(CheckValue(
                                 "AuthMode", ((CHIPAccessControlClusterAccessControlEntry *) actualValue[2]).authMode, 3));
                             VerifyOrReturn(CheckValueNonNull(
                                 "Subjects", ((CHIPAccessControlClusterAccessControlEntry *) actualValue[2]).subjects));
                             VerifyOrReturn(CheckValue("Subjects",
                                 [((CHIPAccessControlClusterAccessControlEntry *) actualValue[2]).subjects count],
                                 static_cast<uint32_t>(4)));
                             VerifyOrReturn(CheckValue(
                                 "", ((CHIPAccessControlClusterAccessControlEntry *) actualValue[2]).subjects[0], 12ULL));
                             VerifyOrReturn(CheckValue(
                                 "", ((CHIPAccessControlClusterAccessControlEntry *) actualValue[2]).subjects[1], 13ULL));
                             VerifyOrReturn(CheckValue(
                                 "", ((CHIPAccessControlClusterAccessControlEntry *) actualValue[2]).subjects[2], 14ULL));
                             VerifyOrReturn(CheckValue(
                                 "", ((CHIPAccessControlClusterAccessControlEntry *) actualValue[2]).subjects[3], 15ULL));
                             VerifyOrReturn(CheckValueNonNull(
                                 "Targets", ((CHIPAccessControlClusterAccessControlEntry *) actualValue[2]).targets));
                             VerifyOrReturn(CheckValue("Targets",
                                 [((CHIPAccessControlClusterAccessControlEntry *) actualValue[2]).targets count],
                                 static_cast<uint32_t>(3)));
                             VerifyOrReturn(CheckValueNull("Cluster",
                                 ((CHIPAccessControlClusterTarget *) ((CHIPAccessControlClusterAccessControlEntry *) actualValue[2])
                                         .targets[0])
                                     .cluster));
                             VerifyOrReturn(CheckValueNonNull("Endpoint",
                                 ((CHIPAccessControlClusterTarget *) ((CHIPAccessControlClusterAccessControlEntry *) actualValue[2])
                                         .targets[0])
                                     .endpoint));
                             VerifyOrReturn(CheckValue("Endpoint",
                                 ((CHIPAccessControlClusterTarget *) ((CHIPAccessControlClusterAccessControlEntry *) actualValue[2])
                                         .targets[0])
                                     .endpoint,
                                 16U));
                             VerifyOrReturn(CheckValueNull("DeviceType",
                                 ((CHIPAccessControlClusterTarget *) ((CHIPAccessControlClusterAccessControlEntry *) actualValue[2])
                                         .targets[0])
                                     .deviceType));
                             VerifyOrReturn(CheckValueNonNull("Cluster",
                                 ((CHIPAccessControlClusterTarget *) ((CHIPAccessControlClusterAccessControlEntry *) actualValue[2])
                                         .targets[1])
                                     .cluster));
                             VerifyOrReturn(CheckValue("Cluster",
                                 ((CHIPAccessControlClusterTarget *) ((CHIPAccessControlClusterAccessControlEntry *) actualValue[2])
                                         .targets[1])
                                     .cluster,
                                 17UL));
                             VerifyOrReturn(CheckValueNull("Endpoint",
                                 ((CHIPAccessControlClusterTarget *) ((CHIPAccessControlClusterAccessControlEntry *) actualValue[2])
                                         .targets[1])
                                     .endpoint));
                             VerifyOrReturn(CheckValueNull("DeviceType",
                                 ((CHIPAccessControlClusterTarget *) ((CHIPAccessControlClusterAccessControlEntry *) actualValue[2])
                                         .targets[1])
                                     .deviceType));
                             VerifyOrReturn(CheckValueNonNull("Cluster",
                                 ((CHIPAccessControlClusterTarget *) ((CHIPAccessControlClusterAccessControlEntry *) actualValue[2])
                                         .targets[2])
                                     .cluster));
                             VerifyOrReturn(CheckValue("Cluster",
                                 ((CHIPAccessControlClusterTarget *) ((CHIPAccessControlClusterAccessControlEntry *) actualValue[2])
                                         .targets[2])
                                     .cluster,
                                 18UL));
                             VerifyOrReturn(CheckValueNonNull("Endpoint",
                                 ((CHIPAccessControlClusterTarget *) ((CHIPAccessControlClusterAccessControlEntry *) actualValue[2])
                                         .targets[2])
                                     .endpoint));
                             VerifyOrReturn(CheckValue("Endpoint",
                                 ((CHIPAccessControlClusterTarget *) ((CHIPAccessControlClusterAccessControlEntry *) actualValue[2])
                                         .targets[2])
                                     .endpoint,
                                 19U));
                             VerifyOrReturn(CheckValueNull("DeviceType",
                                 ((CHIPAccessControlClusterTarget *) ((CHIPAccessControlClusterAccessControlEntry *) actualValue[2])
                                         .targets[2])
                                     .deviceType));
                             VerifyOrReturn(CheckValue(
                                 "FabricIndex", ((CHIPAccessControlClusterAccessControlEntry *) actualValue[2]).fabricIndex, 1));
                         }

                         NextTest();
                     }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteEntriesEmptyLists_3()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestAccessControl * cluster = [[CHIPTestAccessControl alloc] initWithDevice:device endpoint:0 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id aclArgument;
        {
            NSMutableArray * temp_0 = [[NSMutableArray alloc] init];
            temp_0[0] = [[CHIPAccessControlClusterAccessControlEntry alloc] init];
            ((CHIPAccessControlClusterAccessControlEntry *) temp_0[0]).privilege = [NSNumber numberWithUnsignedChar:5];
            ((CHIPAccessControlClusterAccessControlEntry *) temp_0[0]).authMode = [NSNumber numberWithUnsignedChar:2];
            ((CHIPAccessControlClusterAccessControlEntry *) temp_0[0]).subjects = nil;
            ((CHIPAccessControlClusterAccessControlEntry *) temp_0[0]).targets = nil;
            ((CHIPAccessControlClusterAccessControlEntry *) temp_0[0]).fabricIndex = [NSNumber numberWithUnsignedChar:0];

            temp_0[1] = [[CHIPAccessControlClusterAccessControlEntry alloc] init];
            ((CHIPAccessControlClusterAccessControlEntry *) temp_0[1]).privilege = [NSNumber numberWithUnsignedChar:1];
            ((CHIPAccessControlClusterAccessControlEntry *) temp_0[1]).authMode = [NSNumber numberWithUnsignedChar:2];
            {
                NSMutableArray * temp_3 = [[NSMutableArray alloc] init];
                ((CHIPAccessControlClusterAccessControlEntry *) temp_0[1]).subjects = temp_3;
            }
            {
                NSMutableArray * temp_3 = [[NSMutableArray alloc] init];
                ((CHIPAccessControlClusterAccessControlEntry *) temp_0[1]).targets = temp_3;
            }
            ((CHIPAccessControlClusterAccessControlEntry *) temp_0[1]).fabricIndex = [NSNumber numberWithUnsignedChar:0];

            aclArgument = temp_0;
        }
        [cluster writeAttributeAclWithValue:aclArgument
                          completionHandler:^(NSError * _Nullable err) {
                              NSLog(@"Write entries empty lists Error: %@", err);

                              VerifyOrReturn(CheckValue("status", err, 0));

                              NextTest();
                          }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestVerify_4()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestAccessControl * cluster = [[CHIPTestAccessControl alloc] initWithDevice:device endpoint:0 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        CHIPReadParams * params = [[CHIPReadParams alloc] init];
        params.fabricFiltered = [NSNumber numberWithBool:true];
        [cluster readAttributeAclWithParams:params
                          completionHandler:^(NSArray * _Nullable value, NSError * _Nullable err) {
                              NSLog(@"Verify Error: %@", err);

                              VerifyOrReturn(CheckValue("status", err, 0));

                              {
                                  id actualValue = value;
                                  VerifyOrReturn(CheckValue("ACL", [actualValue count], static_cast<uint32_t>(2)));
                                  VerifyOrReturn(CheckValue(
                                      "Privilege", ((CHIPAccessControlClusterAccessControlEntry *) actualValue[0]).privilege, 5));
                                  VerifyOrReturn(CheckValue(
                                      "AuthMode", ((CHIPAccessControlClusterAccessControlEntry *) actualValue[0]).authMode, 2));
                                  VerifyOrReturn(CheckValueNull(
                                      "Subjects", ((CHIPAccessControlClusterAccessControlEntry *) actualValue[0]).subjects));
                                  VerifyOrReturn(CheckValueNull(
                                      "Targets", ((CHIPAccessControlClusterAccessControlEntry *) actualValue[0]).targets));
                                  VerifyOrReturn(CheckValue("FabricIndex",
                                      ((CHIPAccessControlClusterAccessControlEntry *) actualValue[0]).fabricIndex, 1));
                                  VerifyOrReturn(CheckValue(
                                      "Privilege", ((CHIPAccessControlClusterAccessControlEntry *) actualValue[1]).privilege, 1));
                                  VerifyOrReturn(CheckValue(
                                      "AuthMode", ((CHIPAccessControlClusterAccessControlEntry *) actualValue[1]).authMode, 2));
                                  VerifyOrReturn(CheckValueNull(
                                      "Subjects", ((CHIPAccessControlClusterAccessControlEntry *) actualValue[1]).subjects));
                                  VerifyOrReturn(CheckValueNull(
                                      "Targets", ((CHIPAccessControlClusterAccessControlEntry *) actualValue[1]).targets));
                                  VerifyOrReturn(CheckValue("FabricIndex",
                                      ((CHIPAccessControlClusterAccessControlEntry *) actualValue[1]).fabricIndex, 1));
                              }

                              NextTest();
                          }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteEntryInvalidPrivilege_5()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestAccessControl * cluster = [[CHIPTestAccessControl alloc] initWithDevice:device endpoint:0 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id aclArgument;
        {
            NSMutableArray * temp_0 = [[NSMutableArray alloc] init];
            temp_0[0] = [[CHIPAccessControlClusterAccessControlEntry alloc] init];
            ((CHIPAccessControlClusterAccessControlEntry *) temp_0[0]).privilege = [NSNumber numberWithUnsignedChar:5];
            ((CHIPAccessControlClusterAccessControlEntry *) temp_0[0]).authMode = [NSNumber numberWithUnsignedChar:2];
            ((CHIPAccessControlClusterAccessControlEntry *) temp_0[0]).subjects = nil;
            ((CHIPAccessControlClusterAccessControlEntry *) temp_0[0]).targets = nil;
            ((CHIPAccessControlClusterAccessControlEntry *) temp_0[0]).fabricIndex = [NSNumber numberWithUnsignedChar:0];

            temp_0[1] = [[CHIPAccessControlClusterAccessControlEntry alloc] init];
            ((CHIPAccessControlClusterAccessControlEntry *) temp_0[1]).privilege = [NSNumber numberWithUnsignedChar:5];
            ((CHIPAccessControlClusterAccessControlEntry *) temp_0[1]).authMode = [NSNumber numberWithUnsignedChar:3];
            ((CHIPAccessControlClusterAccessControlEntry *) temp_0[1]).subjects = nil;
            ((CHIPAccessControlClusterAccessControlEntry *) temp_0[1]).targets = nil;
            ((CHIPAccessControlClusterAccessControlEntry *) temp_0[1]).fabricIndex = [NSNumber numberWithUnsignedChar:0];

            aclArgument = temp_0;
        }
        [cluster writeAttributeAclWithValue:aclArgument
                          completionHandler:^(NSError * _Nullable err) {
                              NSLog(@"Write entry invalid privilege Error: %@", err);

                              VerifyOrReturn(CheckValue("status", err, 1));
                              NextTest();
                          }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestVerify_6()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestAccessControl * cluster = [[CHIPTestAccessControl alloc] initWithDevice:device endpoint:0 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        CHIPReadParams * params = [[CHIPReadParams alloc] init];
        params.fabricFiltered = [NSNumber numberWithBool:true];
        [cluster readAttributeAclWithParams:params
                          completionHandler:^(NSArray * _Nullable value, NSError * _Nullable err) {
                              NSLog(@"Verify Error: %@", err);

                              VerifyOrReturn(CheckValue("status", err, 0));

                              {
                                  id actualValue = value;
                                  VerifyOrReturn(CheckValue("ACL", [actualValue count], static_cast<uint32_t>(1)));
                                  VerifyOrReturn(CheckValue(
                                      "Privilege", ((CHIPAccessControlClusterAccessControlEntry *) actualValue[0]).privilege, 5));
                                  VerifyOrReturn(CheckValue(
                                      "AuthMode", ((CHIPAccessControlClusterAccessControlEntry *) actualValue[0]).authMode, 2));
                                  VerifyOrReturn(CheckValueNull(
                                      "Subjects", ((CHIPAccessControlClusterAccessControlEntry *) actualValue[0]).subjects));
                                  VerifyOrReturn(CheckValueNull(
                                      "Targets", ((CHIPAccessControlClusterAccessControlEntry *) actualValue[0]).targets));
                                  VerifyOrReturn(CheckValue("FabricIndex",
                                      ((CHIPAccessControlClusterAccessControlEntry *) actualValue[0]).fabricIndex, 1));
                              }

                              NextTest();
                          }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteEntryInvalidAuthMode_7()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestAccessControl * cluster = [[CHIPTestAccessControl alloc] initWithDevice:device endpoint:0 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id aclArgument;
        {
            NSMutableArray * temp_0 = [[NSMutableArray alloc] init];
            temp_0[0] = [[CHIPAccessControlClusterAccessControlEntry alloc] init];
            ((CHIPAccessControlClusterAccessControlEntry *) temp_0[0]).privilege = [NSNumber numberWithUnsignedChar:5];
            ((CHIPAccessControlClusterAccessControlEntry *) temp_0[0]).authMode = [NSNumber numberWithUnsignedChar:2];
            ((CHIPAccessControlClusterAccessControlEntry *) temp_0[0]).subjects = nil;
            ((CHIPAccessControlClusterAccessControlEntry *) temp_0[0]).targets = nil;
            ((CHIPAccessControlClusterAccessControlEntry *) temp_0[0]).fabricIndex = [NSNumber numberWithUnsignedChar:0];

            temp_0[1] = [[CHIPAccessControlClusterAccessControlEntry alloc] init];
            ((CHIPAccessControlClusterAccessControlEntry *) temp_0[1]).privilege = [NSNumber numberWithUnsignedChar:1];
            ((CHIPAccessControlClusterAccessControlEntry *) temp_0[1]).authMode = [NSNumber numberWithUnsignedChar:1];
            ((CHIPAccessControlClusterAccessControlEntry *) temp_0[1]).subjects = nil;
            ((CHIPAccessControlClusterAccessControlEntry *) temp_0[1]).targets = nil;
            ((CHIPAccessControlClusterAccessControlEntry *) temp_0[1]).fabricIndex = [NSNumber numberWithUnsignedChar:0];

            aclArgument = temp_0;
        }
        [cluster writeAttributeAclWithValue:aclArgument
                          completionHandler:^(NSError * _Nullable err) {
                              NSLog(@"Write entry invalid auth mode Error: %@", err);

                              VerifyOrReturn(CheckValue("status", err, 1));
                              NextTest();
                          }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestVerify_8()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestAccessControl * cluster = [[CHIPTestAccessControl alloc] initWithDevice:device endpoint:0 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        CHIPReadParams * params = [[CHIPReadParams alloc] init];
        params.fabricFiltered = [NSNumber numberWithBool:true];
        [cluster readAttributeAclWithParams:params
                          completionHandler:^(NSArray * _Nullable value, NSError * _Nullable err) {
                              NSLog(@"Verify Error: %@", err);

                              VerifyOrReturn(CheckValue("status", err, 0));

                              {
                                  id actualValue = value;
                                  VerifyOrReturn(CheckValue("ACL", [actualValue count], static_cast<uint32_t>(1)));
                                  VerifyOrReturn(CheckValue(
                                      "Privilege", ((CHIPAccessControlClusterAccessControlEntry *) actualValue[0]).privilege, 5));
                                  VerifyOrReturn(CheckValue(
                                      "AuthMode", ((CHIPAccessControlClusterAccessControlEntry *) actualValue[0]).authMode, 2));
                                  VerifyOrReturn(CheckValueNull(
                                      "Subjects", ((CHIPAccessControlClusterAccessControlEntry *) actualValue[0]).subjects));
                                  VerifyOrReturn(CheckValueNull(
                                      "Targets", ((CHIPAccessControlClusterAccessControlEntry *) actualValue[0]).targets));
                                  VerifyOrReturn(CheckValue("FabricIndex",
                                      ((CHIPAccessControlClusterAccessControlEntry *) actualValue[0]).fabricIndex, 1));
                              }

                              NextTest();
                          }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteEntryInvalidSubject_9()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestAccessControl * cluster = [[CHIPTestAccessControl alloc] initWithDevice:device endpoint:0 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id aclArgument;
        {
            NSMutableArray * temp_0 = [[NSMutableArray alloc] init];
            temp_0[0] = [[CHIPAccessControlClusterAccessControlEntry alloc] init];
            ((CHIPAccessControlClusterAccessControlEntry *) temp_0[0]).privilege = [NSNumber numberWithUnsignedChar:5];
            ((CHIPAccessControlClusterAccessControlEntry *) temp_0[0]).authMode = [NSNumber numberWithUnsignedChar:2];
            ((CHIPAccessControlClusterAccessControlEntry *) temp_0[0]).subjects = nil;
            ((CHIPAccessControlClusterAccessControlEntry *) temp_0[0]).targets = nil;
            ((CHIPAccessControlClusterAccessControlEntry *) temp_0[0]).fabricIndex = [NSNumber numberWithUnsignedChar:0];

            temp_0[1] = [[CHIPAccessControlClusterAccessControlEntry alloc] init];
            ((CHIPAccessControlClusterAccessControlEntry *) temp_0[1]).privilege = [NSNumber numberWithUnsignedChar:1];
            ((CHIPAccessControlClusterAccessControlEntry *) temp_0[1]).authMode = [NSNumber numberWithUnsignedChar:2];
            {
                NSMutableArray * temp_3 = [[NSMutableArray alloc] init];
                temp_3[0] = [NSNumber numberWithUnsignedLongLong:0ULL];
                ((CHIPAccessControlClusterAccessControlEntry *) temp_0[1]).subjects = temp_3;
            }
            ((CHIPAccessControlClusterAccessControlEntry *) temp_0[1]).targets = nil;
            ((CHIPAccessControlClusterAccessControlEntry *) temp_0[1]).fabricIndex = [NSNumber numberWithUnsignedChar:0];

            aclArgument = temp_0;
        }
        [cluster writeAttributeAclWithValue:aclArgument
                          completionHandler:^(NSError * _Nullable err) {
                              NSLog(@"Write entry invalid subject Error: %@", err);

                              VerifyOrReturn(CheckValue("status", err, 1));
                              NextTest();
                          }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestVerify_10()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestAccessControl * cluster = [[CHIPTestAccessControl alloc] initWithDevice:device endpoint:0 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        CHIPReadParams * params = [[CHIPReadParams alloc] init];
        params.fabricFiltered = [NSNumber numberWithBool:true];
        [cluster readAttributeAclWithParams:params
                          completionHandler:^(NSArray * _Nullable value, NSError * _Nullable err) {
                              NSLog(@"Verify Error: %@", err);

                              VerifyOrReturn(CheckValue("status", err, 0));

                              {
                                  id actualValue = value;
                                  VerifyOrReturn(CheckValue("ACL", [actualValue count], static_cast<uint32_t>(1)));
                                  VerifyOrReturn(CheckValue(
                                      "Privilege", ((CHIPAccessControlClusterAccessControlEntry *) actualValue[0]).privilege, 5));
                                  VerifyOrReturn(CheckValue(
                                      "AuthMode", ((CHIPAccessControlClusterAccessControlEntry *) actualValue[0]).authMode, 2));
                                  VerifyOrReturn(CheckValueNull(
                                      "Subjects", ((CHIPAccessControlClusterAccessControlEntry *) actualValue[0]).subjects));
                                  VerifyOrReturn(CheckValueNull(
                                      "Targets", ((CHIPAccessControlClusterAccessControlEntry *) actualValue[0]).targets));
                                  VerifyOrReturn(CheckValue("FabricIndex",
                                      ((CHIPAccessControlClusterAccessControlEntry *) actualValue[0]).fabricIndex, 1));
                              }

                              NextTest();
                          }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteEntryInvalidTarget_11()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestAccessControl * cluster = [[CHIPTestAccessControl alloc] initWithDevice:device endpoint:0 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id aclArgument;
        {
            NSMutableArray * temp_0 = [[NSMutableArray alloc] init];
            temp_0[0] = [[CHIPAccessControlClusterAccessControlEntry alloc] init];
            ((CHIPAccessControlClusterAccessControlEntry *) temp_0[0]).privilege = [NSNumber numberWithUnsignedChar:5];
            ((CHIPAccessControlClusterAccessControlEntry *) temp_0[0]).authMode = [NSNumber numberWithUnsignedChar:2];
            ((CHIPAccessControlClusterAccessControlEntry *) temp_0[0]).subjects = nil;
            ((CHIPAccessControlClusterAccessControlEntry *) temp_0[0]).targets = nil;
            ((CHIPAccessControlClusterAccessControlEntry *) temp_0[0]).fabricIndex = [NSNumber numberWithUnsignedChar:0];

            temp_0[1] = [[CHIPAccessControlClusterAccessControlEntry alloc] init];
            ((CHIPAccessControlClusterAccessControlEntry *) temp_0[1]).privilege = [NSNumber numberWithUnsignedChar:1];
            ((CHIPAccessControlClusterAccessControlEntry *) temp_0[1]).authMode = [NSNumber numberWithUnsignedChar:2];
            ((CHIPAccessControlClusterAccessControlEntry *) temp_0[1]).subjects = nil;
            {
                NSMutableArray * temp_3 = [[NSMutableArray alloc] init];
                temp_3[0] = [[CHIPAccessControlClusterTarget alloc] init];
                ((CHIPAccessControlClusterTarget *) temp_3[0]).cluster = nil;
                ((CHIPAccessControlClusterTarget *) temp_3[0]).endpoint = nil;
                ((CHIPAccessControlClusterTarget *) temp_3[0]).deviceType = nil;

                ((CHIPAccessControlClusterAccessControlEntry *) temp_0[1]).targets = temp_3;
            }
            ((CHIPAccessControlClusterAccessControlEntry *) temp_0[1]).fabricIndex = [NSNumber numberWithUnsignedChar:0];

            aclArgument = temp_0;
        }
        [cluster writeAttributeAclWithValue:aclArgument
                          completionHandler:^(NSError * _Nullable err) {
                              NSLog(@"Write entry invalid target Error: %@", err);

                              VerifyOrReturn(CheckValue("status", err, 1));
                              NextTest();
                          }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestVerify_12()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestAccessControl * cluster = [[CHIPTestAccessControl alloc] initWithDevice:device endpoint:0 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        CHIPReadParams * params = [[CHIPReadParams alloc] init];
        params.fabricFiltered = [NSNumber numberWithBool:true];
        [cluster readAttributeAclWithParams:params
                          completionHandler:^(NSArray * _Nullable value, NSError * _Nullable err) {
                              NSLog(@"Verify Error: %@", err);

                              VerifyOrReturn(CheckValue("status", err, 0));

                              {
                                  id actualValue = value;
                                  VerifyOrReturn(CheckValue("ACL", [actualValue count], static_cast<uint32_t>(1)));
                                  VerifyOrReturn(CheckValue(
                                      "Privilege", ((CHIPAccessControlClusterAccessControlEntry *) actualValue[0]).privilege, 5));
                                  VerifyOrReturn(CheckValue(
                                      "AuthMode", ((CHIPAccessControlClusterAccessControlEntry *) actualValue[0]).authMode, 2));
                                  VerifyOrReturn(CheckValueNull(
                                      "Subjects", ((CHIPAccessControlClusterAccessControlEntry *) actualValue[0]).subjects));
                                  VerifyOrReturn(CheckValueNull(
                                      "Targets", ((CHIPAccessControlClusterAccessControlEntry *) actualValue[0]).targets));
                                  VerifyOrReturn(CheckValue("FabricIndex",
                                      ((CHIPAccessControlClusterAccessControlEntry *) actualValue[0]).fabricIndex, 1));
                              }

                              NextTest();
                          }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteEntryTooManySubjects_13()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestAccessControl * cluster = [[CHIPTestAccessControl alloc] initWithDevice:device endpoint:0 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id aclArgument;
        {
            NSMutableArray * temp_0 = [[NSMutableArray alloc] init];
            temp_0[0] = [[CHIPAccessControlClusterAccessControlEntry alloc] init];
            ((CHIPAccessControlClusterAccessControlEntry *) temp_0[0]).privilege = [NSNumber numberWithUnsignedChar:5];
            ((CHIPAccessControlClusterAccessControlEntry *) temp_0[0]).authMode = [NSNumber numberWithUnsignedChar:2];
            ((CHIPAccessControlClusterAccessControlEntry *) temp_0[0]).subjects = nil;
            ((CHIPAccessControlClusterAccessControlEntry *) temp_0[0]).targets = nil;
            ((CHIPAccessControlClusterAccessControlEntry *) temp_0[0]).fabricIndex = [NSNumber numberWithUnsignedChar:0];

            temp_0[1] = [[CHIPAccessControlClusterAccessControlEntry alloc] init];
            ((CHIPAccessControlClusterAccessControlEntry *) temp_0[1]).privilege = [NSNumber numberWithUnsignedChar:1];
            ((CHIPAccessControlClusterAccessControlEntry *) temp_0[1]).authMode = [NSNumber numberWithUnsignedChar:2];
            {
                NSMutableArray * temp_3 = [[NSMutableArray alloc] init];
                temp_3[0] = [NSNumber numberWithUnsignedLongLong:1ULL];
                temp_3[1] = [NSNumber numberWithUnsignedLongLong:2ULL];
                temp_3[2] = [NSNumber numberWithUnsignedLongLong:3ULL];
                temp_3[3] = [NSNumber numberWithUnsignedLongLong:4ULL];
                temp_3[4] = [NSNumber numberWithUnsignedLongLong:5ULL];
                temp_3[5] = [NSNumber numberWithUnsignedLongLong:6ULL];
                temp_3[6] = [NSNumber numberWithUnsignedLongLong:7ULL];
                temp_3[7] = [NSNumber numberWithUnsignedLongLong:8ULL];
                temp_3[8] = [NSNumber numberWithUnsignedLongLong:9ULL];
                temp_3[9] = [NSNumber numberWithUnsignedLongLong:10ULL];
                temp_3[10] = [NSNumber numberWithUnsignedLongLong:11ULL];
                temp_3[11] = [NSNumber numberWithUnsignedLongLong:12ULL];
                temp_3[12] = [NSNumber numberWithUnsignedLongLong:13ULL];
                temp_3[13] = [NSNumber numberWithUnsignedLongLong:14ULL];
                temp_3[14] = [NSNumber numberWithUnsignedLongLong:15ULL];
                temp_3[15] = [NSNumber numberWithUnsignedLongLong:16ULL];
                temp_3[16] = [NSNumber numberWithUnsignedLongLong:17ULL];
                temp_3[17] = [NSNumber numberWithUnsignedLongLong:18ULL];
                temp_3[18] = [NSNumber numberWithUnsignedLongLong:19ULL];
                temp_3[19] = [NSNumber numberWithUnsignedLongLong:20ULL];
                ((CHIPAccessControlClusterAccessControlEntry *) temp_0[1]).subjects = temp_3;
            }
            ((CHIPAccessControlClusterAccessControlEntry *) temp_0[1]).targets = nil;
            ((CHIPAccessControlClusterAccessControlEntry *) temp_0[1]).fabricIndex = [NSNumber numberWithUnsignedChar:0];

            aclArgument = temp_0;
        }
        [cluster writeAttributeAclWithValue:aclArgument
                          completionHandler:^(NSError * _Nullable err) {
                              NSLog(@"Write entry too many subjects Error: %@", err);

                              VerifyOrReturn(CheckValue("status", err, 1));
                              NextTest();
                          }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestVerify_14()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestAccessControl * cluster = [[CHIPTestAccessControl alloc] initWithDevice:device endpoint:0 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        CHIPReadParams * params = [[CHIPReadParams alloc] init];
        params.fabricFiltered = [NSNumber numberWithBool:true];
        [cluster readAttributeAclWithParams:params
                          completionHandler:^(NSArray * _Nullable value, NSError * _Nullable err) {
                              NSLog(@"Verify Error: %@", err);

                              VerifyOrReturn(CheckValue("status", err, 0));

                              {
                                  id actualValue = value;
                                  VerifyOrReturn(CheckValue("ACL", [actualValue count], static_cast<uint32_t>(1)));
                                  VerifyOrReturn(CheckValue(
                                      "Privilege", ((CHIPAccessControlClusterAccessControlEntry *) actualValue[0]).privilege, 5));
                                  VerifyOrReturn(CheckValue(
                                      "AuthMode", ((CHIPAccessControlClusterAccessControlEntry *) actualValue[0]).authMode, 2));
                                  VerifyOrReturn(CheckValueNull(
                                      "Subjects", ((CHIPAccessControlClusterAccessControlEntry *) actualValue[0]).subjects));
                                  VerifyOrReturn(CheckValueNull(
                                      "Targets", ((CHIPAccessControlClusterAccessControlEntry *) actualValue[0]).targets));
                                  VerifyOrReturn(CheckValue("FabricIndex",
                                      ((CHIPAccessControlClusterAccessControlEntry *) actualValue[0]).fabricIndex, 1));
                              }

                              NextTest();
                          }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteEntryTooManyTargets_15()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestAccessControl * cluster = [[CHIPTestAccessControl alloc] initWithDevice:device endpoint:0 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id aclArgument;
        {
            NSMutableArray * temp_0 = [[NSMutableArray alloc] init];
            temp_0[0] = [[CHIPAccessControlClusterAccessControlEntry alloc] init];
            ((CHIPAccessControlClusterAccessControlEntry *) temp_0[0]).privilege = [NSNumber numberWithUnsignedChar:5];
            ((CHIPAccessControlClusterAccessControlEntry *) temp_0[0]).authMode = [NSNumber numberWithUnsignedChar:2];
            ((CHIPAccessControlClusterAccessControlEntry *) temp_0[0]).subjects = nil;
            ((CHIPAccessControlClusterAccessControlEntry *) temp_0[0]).targets = nil;
            ((CHIPAccessControlClusterAccessControlEntry *) temp_0[0]).fabricIndex = [NSNumber numberWithUnsignedChar:0];

            temp_0[1] = [[CHIPAccessControlClusterAccessControlEntry alloc] init];
            ((CHIPAccessControlClusterAccessControlEntry *) temp_0[1]).privilege = [NSNumber numberWithUnsignedChar:1];
            ((CHIPAccessControlClusterAccessControlEntry *) temp_0[1]).authMode = [NSNumber numberWithUnsignedChar:2];
            ((CHIPAccessControlClusterAccessControlEntry *) temp_0[1]).subjects = nil;
            {
                NSMutableArray * temp_3 = [[NSMutableArray alloc] init];
                temp_3[0] = [[CHIPAccessControlClusterTarget alloc] init];
                ((CHIPAccessControlClusterTarget *) temp_3[0]).cluster = nil;
                ((CHIPAccessControlClusterTarget *) temp_3[0]).endpoint = [NSNumber numberWithUnsignedShort:1U];
                ((CHIPAccessControlClusterTarget *) temp_3[0]).deviceType = nil;

                temp_3[1] = [[CHIPAccessControlClusterTarget alloc] init];
                ((CHIPAccessControlClusterTarget *) temp_3[1]).cluster = nil;
                ((CHIPAccessControlClusterTarget *) temp_3[1]).endpoint = [NSNumber numberWithUnsignedShort:2U];
                ((CHIPAccessControlClusterTarget *) temp_3[1]).deviceType = nil;

                temp_3[2] = [[CHIPAccessControlClusterTarget alloc] init];
                ((CHIPAccessControlClusterTarget *) temp_3[2]).cluster = nil;
                ((CHIPAccessControlClusterTarget *) temp_3[2]).endpoint = [NSNumber numberWithUnsignedShort:3U];
                ((CHIPAccessControlClusterTarget *) temp_3[2]).deviceType = nil;

                temp_3[3] = [[CHIPAccessControlClusterTarget alloc] init];
                ((CHIPAccessControlClusterTarget *) temp_3[3]).cluster = nil;
                ((CHIPAccessControlClusterTarget *) temp_3[3]).endpoint = [NSNumber numberWithUnsignedShort:4U];
                ((CHIPAccessControlClusterTarget *) temp_3[3]).deviceType = nil;

                temp_3[4] = [[CHIPAccessControlClusterTarget alloc] init];
                ((CHIPAccessControlClusterTarget *) temp_3[4]).cluster = nil;
                ((CHIPAccessControlClusterTarget *) temp_3[4]).endpoint = [NSNumber numberWithUnsignedShort:5U];
                ((CHIPAccessControlClusterTarget *) temp_3[4]).deviceType = nil;

                temp_3[5] = [[CHIPAccessControlClusterTarget alloc] init];
                ((CHIPAccessControlClusterTarget *) temp_3[5]).cluster = nil;
                ((CHIPAccessControlClusterTarget *) temp_3[5]).endpoint = [NSNumber numberWithUnsignedShort:6U];
                ((CHIPAccessControlClusterTarget *) temp_3[5]).deviceType = nil;

                temp_3[6] = [[CHIPAccessControlClusterTarget alloc] init];
                ((CHIPAccessControlClusterTarget *) temp_3[6]).cluster = nil;
                ((CHIPAccessControlClusterTarget *) temp_3[6]).endpoint = [NSNumber numberWithUnsignedShort:7U];
                ((CHIPAccessControlClusterTarget *) temp_3[6]).deviceType = nil;

                temp_3[7] = [[CHIPAccessControlClusterTarget alloc] init];
                ((CHIPAccessControlClusterTarget *) temp_3[7]).cluster = nil;
                ((CHIPAccessControlClusterTarget *) temp_3[7]).endpoint = [NSNumber numberWithUnsignedShort:8U];
                ((CHIPAccessControlClusterTarget *) temp_3[7]).deviceType = nil;

                temp_3[8] = [[CHIPAccessControlClusterTarget alloc] init];
                ((CHIPAccessControlClusterTarget *) temp_3[8]).cluster = nil;
                ((CHIPAccessControlClusterTarget *) temp_3[8]).endpoint = [NSNumber numberWithUnsignedShort:9U];
                ((CHIPAccessControlClusterTarget *) temp_3[8]).deviceType = nil;

                temp_3[9] = [[CHIPAccessControlClusterTarget alloc] init];
                ((CHIPAccessControlClusterTarget *) temp_3[9]).cluster = nil;
                ((CHIPAccessControlClusterTarget *) temp_3[9]).endpoint = [NSNumber numberWithUnsignedShort:10U];
                ((CHIPAccessControlClusterTarget *) temp_3[9]).deviceType = nil;

                temp_3[10] = [[CHIPAccessControlClusterTarget alloc] init];
                ((CHIPAccessControlClusterTarget *) temp_3[10]).cluster = nil;
                ((CHIPAccessControlClusterTarget *) temp_3[10]).endpoint = [NSNumber numberWithUnsignedShort:11U];
                ((CHIPAccessControlClusterTarget *) temp_3[10]).deviceType = nil;

                temp_3[11] = [[CHIPAccessControlClusterTarget alloc] init];
                ((CHIPAccessControlClusterTarget *) temp_3[11]).cluster = nil;
                ((CHIPAccessControlClusterTarget *) temp_3[11]).endpoint = [NSNumber numberWithUnsignedShort:12U];
                ((CHIPAccessControlClusterTarget *) temp_3[11]).deviceType = nil;

                temp_3[12] = [[CHIPAccessControlClusterTarget alloc] init];
                ((CHIPAccessControlClusterTarget *) temp_3[12]).cluster = nil;
                ((CHIPAccessControlClusterTarget *) temp_3[12]).endpoint = [NSNumber numberWithUnsignedShort:13U];
                ((CHIPAccessControlClusterTarget *) temp_3[12]).deviceType = nil;

                temp_3[13] = [[CHIPAccessControlClusterTarget alloc] init];
                ((CHIPAccessControlClusterTarget *) temp_3[13]).cluster = nil;
                ((CHIPAccessControlClusterTarget *) temp_3[13]).endpoint = [NSNumber numberWithUnsignedShort:14U];
                ((CHIPAccessControlClusterTarget *) temp_3[13]).deviceType = nil;

                temp_3[14] = [[CHIPAccessControlClusterTarget alloc] init];
                ((CHIPAccessControlClusterTarget *) temp_3[14]).cluster = nil;
                ((CHIPAccessControlClusterTarget *) temp_3[14]).endpoint = [NSNumber numberWithUnsignedShort:15U];
                ((CHIPAccessControlClusterTarget *) temp_3[14]).deviceType = nil;

                temp_3[15] = [[CHIPAccessControlClusterTarget alloc] init];
                ((CHIPAccessControlClusterTarget *) temp_3[15]).cluster = nil;
                ((CHIPAccessControlClusterTarget *) temp_3[15]).endpoint = [NSNumber numberWithUnsignedShort:16U];
                ((CHIPAccessControlClusterTarget *) temp_3[15]).deviceType = nil;

                temp_3[16] = [[CHIPAccessControlClusterTarget alloc] init];
                ((CHIPAccessControlClusterTarget *) temp_3[16]).cluster = nil;
                ((CHIPAccessControlClusterTarget *) temp_3[16]).endpoint = [NSNumber numberWithUnsignedShort:17U];
                ((CHIPAccessControlClusterTarget *) temp_3[16]).deviceType = nil;

                temp_3[17] = [[CHIPAccessControlClusterTarget alloc] init];
                ((CHIPAccessControlClusterTarget *) temp_3[17]).cluster = nil;
                ((CHIPAccessControlClusterTarget *) temp_3[17]).endpoint = [NSNumber numberWithUnsignedShort:18U];
                ((CHIPAccessControlClusterTarget *) temp_3[17]).deviceType = nil;

                temp_3[18] = [[CHIPAccessControlClusterTarget alloc] init];
                ((CHIPAccessControlClusterTarget *) temp_3[18]).cluster = nil;
                ((CHIPAccessControlClusterTarget *) temp_3[18]).endpoint = [NSNumber numberWithUnsignedShort:19U];
                ((CHIPAccessControlClusterTarget *) temp_3[18]).deviceType = nil;

                temp_3[19] = [[CHIPAccessControlClusterTarget alloc] init];
                ((CHIPAccessControlClusterTarget *) temp_3[19]).cluster = nil;
                ((CHIPAccessControlClusterTarget *) temp_3[19]).endpoint = [NSNumber numberWithUnsignedShort:20U];
                ((CHIPAccessControlClusterTarget *) temp_3[19]).deviceType = nil;

                ((CHIPAccessControlClusterAccessControlEntry *) temp_0[1]).targets = temp_3;
            }
            ((CHIPAccessControlClusterAccessControlEntry *) temp_0[1]).fabricIndex = [NSNumber numberWithUnsignedChar:0];

            aclArgument = temp_0;
        }
        [cluster writeAttributeAclWithValue:aclArgument
                          completionHandler:^(NSError * _Nullable err) {
                              NSLog(@"Write entry too many targets Error: %@", err);

                              VerifyOrReturn(CheckValue("status", err, 1));
                              NextTest();
                          }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestVerify_16()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestAccessControl * cluster = [[CHIPTestAccessControl alloc] initWithDevice:device endpoint:0 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        CHIPReadParams * params = [[CHIPReadParams alloc] init];
        params.fabricFiltered = [NSNumber numberWithBool:true];
        [cluster readAttributeAclWithParams:params
                          completionHandler:^(NSArray * _Nullable value, NSError * _Nullable err) {
                              NSLog(@"Verify Error: %@", err);

                              VerifyOrReturn(CheckValue("status", err, 0));

                              {
                                  id actualValue = value;
                                  VerifyOrReturn(CheckValue("ACL", [actualValue count], static_cast<uint32_t>(1)));
                                  VerifyOrReturn(CheckValue(
                                      "Privilege", ((CHIPAccessControlClusterAccessControlEntry *) actualValue[0]).privilege, 5));
                                  VerifyOrReturn(CheckValue(
                                      "AuthMode", ((CHIPAccessControlClusterAccessControlEntry *) actualValue[0]).authMode, 2));
                                  VerifyOrReturn(CheckValueNull(
                                      "Subjects", ((CHIPAccessControlClusterAccessControlEntry *) actualValue[0]).subjects));
                                  VerifyOrReturn(CheckValueNull(
                                      "Targets", ((CHIPAccessControlClusterAccessControlEntry *) actualValue[0]).targets));
                                  VerifyOrReturn(CheckValue("FabricIndex",
                                      ((CHIPAccessControlClusterAccessControlEntry *) actualValue[0]).fabricIndex, 1));
                              }

                              NextTest();
                          }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestRestoreAcl_17()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestAccessControl * cluster = [[CHIPTestAccessControl alloc] initWithDevice:device endpoint:0 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id aclArgument;
        {
            NSMutableArray * temp_0 = [[NSMutableArray alloc] init];
            temp_0[0] = [[CHIPAccessControlClusterAccessControlEntry alloc] init];
            ((CHIPAccessControlClusterAccessControlEntry *) temp_0[0]).privilege = [NSNumber numberWithUnsignedChar:5];
            ((CHIPAccessControlClusterAccessControlEntry *) temp_0[0]).authMode = [NSNumber numberWithUnsignedChar:2];
            ((CHIPAccessControlClusterAccessControlEntry *) temp_0[0]).subjects = nil;
            ((CHIPAccessControlClusterAccessControlEntry *) temp_0[0]).targets = nil;
            ((CHIPAccessControlClusterAccessControlEntry *) temp_0[0]).fabricIndex = [NSNumber numberWithUnsignedChar:0];

            aclArgument = temp_0;
        }
        [cluster writeAttributeAclWithValue:aclArgument
                          completionHandler:^(NSError * _Nullable err) {
                              NSLog(@"Restore ACL Error: %@", err);

                              VerifyOrReturn(CheckValue("status", err, 0));

                              NextTest();
                          }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestVerify_18()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestAccessControl * cluster = [[CHIPTestAccessControl alloc] initWithDevice:device endpoint:0 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        CHIPReadParams * params = [[CHIPReadParams alloc] init];
        params.fabricFiltered = [NSNumber numberWithBool:true];
        [cluster readAttributeAclWithParams:params
                          completionHandler:^(NSArray * _Nullable value, NSError * _Nullable err) {
                              NSLog(@"Verify Error: %@", err);

                              VerifyOrReturn(CheckValue("status", err, 0));

                              {
                                  id actualValue = value;
                                  VerifyOrReturn(CheckValue("ACL", [actualValue count], static_cast<uint32_t>(1)));
                                  VerifyOrReturn(CheckValue(
                                      "Privilege", ((CHIPAccessControlClusterAccessControlEntry *) actualValue[0]).privilege, 5));
                                  VerifyOrReturn(CheckValue(
                                      "AuthMode", ((CHIPAccessControlClusterAccessControlEntry *) actualValue[0]).authMode, 2));
                                  VerifyOrReturn(CheckValueNull(
                                      "Subjects", ((CHIPAccessControlClusterAccessControlEntry *) actualValue[0]).subjects));
                                  VerifyOrReturn(CheckValueNull(
                                      "Targets", ((CHIPAccessControlClusterAccessControlEntry *) actualValue[0]).targets));
                                  VerifyOrReturn(CheckValue("FabricIndex",
                                      ((CHIPAccessControlClusterAccessControlEntry *) actualValue[0]).fabricIndex, 1));
                              }

                              NextTest();
                          }];

        return CHIP_NO_ERROR;
    }
};

class Test_TC_BI_1_1 : public TestCommandBridge {
public:
    Test_TC_BI_1_1()
        : TestCommandBridge("Test_TC_BI_1_1")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_BI_1_1() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_BI_1_1\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_BI_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : read the global attribute: ClusterRevision\n");
            err = TestReadTheGlobalAttributeClusterRevision_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read the global attribute constraints: ClusterRevision\n");
            err = TestReadTheGlobalAttributeConstraintsClusterRevision_2();
            break;
        case 3:
            ChipLogProgress(
                chipTool, " ***** Test Step 3 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : reads back global attribute: ClusterRevision\n");
            err = TestReadsBackGlobalAttributeClusterRevision_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Read the global attribute: AttributeList\n");
            err = TestReadTheGlobalAttributeAttributeList_5();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 6;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheGlobalAttributeClusterRevision_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestBinaryInputBasic * cluster = [[CHIPTestBinaryInputBasic alloc] initWithDevice:device
                                                                                     endpoint:1
                                                                                        queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read the global attribute: ClusterRevision Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("ClusterRevision", actualValue, 1U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheGlobalAttributeConstraintsClusterRevision_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestBinaryInputBasic * cluster = [[CHIPTestBinaryInputBasic alloc] initWithDevice:device
                                                                                     endpoint:1
                                                                                        queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read the global attribute constraints: ClusterRevision Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("clusterRevision", "", "uint16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_3()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestBinaryInputBasic * cluster = [[CHIPTestBinaryInputBasic alloc] initWithDevice:device
                                                                                     endpoint:1
                                                                                        queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id clusterRevisionArgument;
        clusterRevisionArgument = [NSNumber numberWithUnsignedShort:1U];
        [cluster
            writeAttributeClusterRevisionWithValue:clusterRevisionArgument
                                 completionHandler:^(NSError * _Nullable err) {
                                     NSLog(
                                         @"write the default values to mandatory global attribute: ClusterRevision Error: %@", err);

                                     VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                                     NextTest();
                                 }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsBackGlobalAttributeClusterRevision_4()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestBinaryInputBasic * cluster = [[CHIPTestBinaryInputBasic alloc] initWithDevice:device
                                                                                     endpoint:1
                                                                                        queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"reads back global attribute: ClusterRevision Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("ClusterRevision", actualValue, 1U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheGlobalAttributeAttributeList_5()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestBinaryInputBasic * cluster = [[CHIPTestBinaryInputBasic alloc] initWithDevice:device
                                                                                     endpoint:1
                                                                                        queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read the global attribute: AttributeList Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("attributeList", "", "list"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
};

class Test_TC_BI_2_1 : public TestCommandBridge {
public:
    Test_TC_BI_2_1()
        : TestCommandBridge("Test_TC_BI_2_1")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_BI_2_1() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_BI_2_1\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_BI_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read mandatory non-global attribute: OutOfService\n");
            err = TestReadMandatoryNonGlobalAttributeOutOfService_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read mandatory non-global attribute constraints: OutOfService\n");
            err = TestReadMandatoryNonGlobalAttributeConstraintsOutOfService_2();
            break;
        case 3:
            ChipLogProgress(
                chipTool, " ***** Test Step 3 : Write the default values to mandatory non-global attribute: OutOfService\n");
            err = TestWriteTheDefaultValuesToMandatoryNonGlobalAttributeOutOfService_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Reads back the mandatory non-global attribute: OutOfService\n");
            err = TestReadsBackTheMandatoryNonGlobalAttributeOutOfService_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Read mandatory non-global attribute constraints: PresentValue\n");
            err = TestReadMandatoryNonGlobalAttributeConstraintsPresentValue_5();
            break;
        case 6:
            ChipLogProgress(
                chipTool, " ***** Test Step 6 : Write the default values to mandatory non-global attribute: PresentValue\n");
            err = TestWriteTheDefaultValuesToMandatoryNonGlobalAttributePresentValue_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Reads back the mandatory non-global attribute: PresentValue\n");
            err = TestReadsBackTheMandatoryNonGlobalAttributePresentValue_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Read mandatory non-global attribute: StatusFlags\n");
            err = TestReadMandatoryNonGlobalAttributeStatusFlags_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Read mandatory non-global attribute constraints: StatusFlags\n");
            err = TestReadMandatoryNonGlobalAttributeConstraintsStatusFlags_9();
            break;
        case 10:
            ChipLogProgress(
                chipTool, " ***** Test Step 10 : Write the default values to mandatory non-global attribute: StatusFlags\n");
            err = TestWriteTheDefaultValuesToMandatoryNonGlobalAttributeStatusFlags_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : Reads back the mandatory non-global attribute: StatusFlags\n");
            err = TestReadsBackTheMandatoryNonGlobalAttributeStatusFlags_11();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 12;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadMandatoryNonGlobalAttributeOutOfService_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestBinaryInputBasic * cluster = [[CHIPTestBinaryInputBasic alloc] initWithDevice:device
                                                                                     endpoint:1
                                                                                        queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOutOfServiceWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read mandatory non-global attribute: OutOfService Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("out of service", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadMandatoryNonGlobalAttributeConstraintsOutOfService_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestBinaryInputBasic * cluster = [[CHIPTestBinaryInputBasic alloc] initWithDevice:device
                                                                                     endpoint:1
                                                                                        queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOutOfServiceWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read mandatory non-global attribute constraints: OutOfService Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("outOfService", "", "bool"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryNonGlobalAttributeOutOfService_3()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestBinaryInputBasic * cluster = [[CHIPTestBinaryInputBasic alloc] initWithDevice:device
                                                                                     endpoint:1
                                                                                        queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id outOfServiceArgument;
        outOfServiceArgument = [NSNumber numberWithBool:0];
        [cluster
            writeAttributeOutOfServiceWithValue:outOfServiceArgument
                              completionHandler:^(NSError * _Nullable err) {
                                  NSLog(@"Write the default values to mandatory non-global attribute: OutOfService Error: %@", err);

                                  VerifyOrReturn(CheckValue("status", err, 0));

                                  NextTest();
                              }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsBackTheMandatoryNonGlobalAttributeOutOfService_4()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestBinaryInputBasic * cluster = [[CHIPTestBinaryInputBasic alloc] initWithDevice:device
                                                                                     endpoint:1
                                                                                        queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOutOfServiceWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads back the mandatory non-global attribute: OutOfService Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("out of service", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadMandatoryNonGlobalAttributeConstraintsPresentValue_5()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestBinaryInputBasic * cluster = [[CHIPTestBinaryInputBasic alloc] initWithDevice:device
                                                                                     endpoint:1
                                                                                        queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributePresentValueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read mandatory non-global attribute constraints: PresentValue Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("presentValue", "", "bool"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryNonGlobalAttributePresentValue_6()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestBinaryInputBasic * cluster = [[CHIPTestBinaryInputBasic alloc] initWithDevice:device
                                                                                     endpoint:1
                                                                                        queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id presentValueArgument;
        presentValueArgument = [NSNumber numberWithBool:0];
        [cluster
            writeAttributePresentValueWithValue:presentValueArgument
                              completionHandler:^(NSError * _Nullable err) {
                                  NSLog(@"Write the default values to mandatory non-global attribute: PresentValue Error: %@", err);

                                  VerifyOrReturn(CheckValue("status", err, 0));

                                  NextTest();
                              }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsBackTheMandatoryNonGlobalAttributePresentValue_7()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestBinaryInputBasic * cluster = [[CHIPTestBinaryInputBasic alloc] initWithDevice:device
                                                                                     endpoint:1
                                                                                        queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributePresentValueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads back the mandatory non-global attribute: PresentValue Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("present value", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadMandatoryNonGlobalAttributeStatusFlags_8()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestBinaryInputBasic * cluster = [[CHIPTestBinaryInputBasic alloc] initWithDevice:device
                                                                                     endpoint:1
                                                                                        queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeStatusFlagsWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read mandatory non-global attribute: StatusFlags Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("status flags", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadMandatoryNonGlobalAttributeConstraintsStatusFlags_9()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestBinaryInputBasic * cluster = [[CHIPTestBinaryInputBasic alloc] initWithDevice:device
                                                                                     endpoint:1
                                                                                        queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeStatusFlagsWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read mandatory non-global attribute constraints: StatusFlags Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("statusFlags", "", "map8"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<uint8_t>("statusFlags", [value unsignedCharValue], 0));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("statusFlags", [value unsignedCharValue], 15));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryNonGlobalAttributeStatusFlags_10()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestBinaryInputBasic * cluster = [[CHIPTestBinaryInputBasic alloc] initWithDevice:device
                                                                                     endpoint:1
                                                                                        queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id statusFlagsArgument;
        statusFlagsArgument = [NSNumber numberWithUnsignedChar:0];
        [cluster
            writeAttributeStatusFlagsWithValue:statusFlagsArgument
                             completionHandler:^(NSError * _Nullable err) {
                                 NSLog(@"Write the default values to mandatory non-global attribute: StatusFlags Error: %@", err);

                                 VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                                 NextTest();
                             }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsBackTheMandatoryNonGlobalAttributeStatusFlags_11()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestBinaryInputBasic * cluster = [[CHIPTestBinaryInputBasic alloc] initWithDevice:device
                                                                                     endpoint:1
                                                                                        queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeStatusFlagsWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads back the mandatory non-global attribute: StatusFlags Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("status flags", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
};

class Test_TC_BI_2_2 : public TestCommandBridge {
public:
    Test_TC_BI_2_2()
        : TestCommandBridge("Test_TC_BI_2_2")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_BI_2_2() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_BI_2_2\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_BI_2_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Reads PresentValue attribute from DUT\n");
            if (ShouldSkip("A_PRESENTVALUE")) {
                NextTest();
                return;
            }
            err = TestReadsPresentValueAttributeFromDut_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Reads OutOfService attribute from DUT\n");
            if (ShouldSkip("A_OUTOFSERVICE")) {
                NextTest();
                return;
            }
            err = TestReadsOutOfServiceAttributeFromDut_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Reads StatusFlags attribute from DUT\n");
            if (ShouldSkip("A_STATUSFLAGS")) {
                NextTest();
                return;
            }
            err = TestReadsStatusFlagsAttributeFromDut_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Reads PresentValue attribute from DUT\n");
            if (ShouldSkip("A_PRESENTVALUE")) {
                NextTest();
                return;
            }
            err = TestReadsPresentValueAttributeFromDut_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Reads OutOfService attribute from DUT\n");
            if (ShouldSkip("A_OUTOFSERVICE")) {
                NextTest();
                return;
            }
            err = TestReadsOutOfServiceAttributeFromDut_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Reads StatusFlags attribute from DUT\n");
            if (ShouldSkip("A_STATUSFLAGS")) {
                NextTest();
                return;
            }
            err = TestReadsStatusFlagsAttributeFromDut_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Reads StatusFlags attribute from DUT\n");
            if (ShouldSkip("A_STATUSFLAGS")) {
                NextTest();
                return;
            }
            err = TestReadsStatusFlagsAttributeFromDut_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Reads StatusFlags attribute from DUT\n");
            if (ShouldSkip("A_STATUSFLAGS")) {
                NextTest();
                return;
            }
            err = TestReadsStatusFlagsAttributeFromDut_8();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 9;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsPresentValueAttributeFromDut_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestBinaryInputBasic * cluster = [[CHIPTestBinaryInputBasic alloc] initWithDevice:device
                                                                                     endpoint:1
                                                                                        queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributePresentValueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads PresentValue attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("present value", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsOutOfServiceAttributeFromDut_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestBinaryInputBasic * cluster = [[CHIPTestBinaryInputBasic alloc] initWithDevice:device
                                                                                     endpoint:1
                                                                                        queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOutOfServiceWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads OutOfService attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("out of service", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsStatusFlagsAttributeFromDut_3()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestBinaryInputBasic * cluster = [[CHIPTestBinaryInputBasic alloc] initWithDevice:device
                                                                                     endpoint:1
                                                                                        queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeStatusFlagsWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads StatusFlags attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("status flags", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsPresentValueAttributeFromDut_4()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestBinaryInputBasic * cluster = [[CHIPTestBinaryInputBasic alloc] initWithDevice:device
                                                                                     endpoint:1
                                                                                        queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributePresentValueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads PresentValue attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("present value", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsOutOfServiceAttributeFromDut_5()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestBinaryInputBasic * cluster = [[CHIPTestBinaryInputBasic alloc] initWithDevice:device
                                                                                     endpoint:1
                                                                                        queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOutOfServiceWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads OutOfService attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("out of service", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsStatusFlagsAttributeFromDut_6()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestBinaryInputBasic * cluster = [[CHIPTestBinaryInputBasic alloc] initWithDevice:device
                                                                                     endpoint:1
                                                                                        queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeStatusFlagsWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads StatusFlags attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("status flags", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsStatusFlagsAttributeFromDut_7()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestBinaryInputBasic * cluster = [[CHIPTestBinaryInputBasic alloc] initWithDevice:device
                                                                                     endpoint:1
                                                                                        queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeStatusFlagsWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads StatusFlags attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("status flags", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsStatusFlagsAttributeFromDut_8()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestBinaryInputBasic * cluster = [[CHIPTestBinaryInputBasic alloc] initWithDevice:device
                                                                                     endpoint:1
                                                                                        queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeStatusFlagsWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads StatusFlags attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("status flags", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
};

class Test_TC_BOOL_1_1 : public TestCommandBridge {
public:
    Test_TC_BOOL_1_1()
        : TestCommandBridge("Test_TC_BOOL_1_1")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_BOOL_1_1() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_BOOL_1_1\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_BOOL_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : read the global attribute: ClusterRevision\n");
            err = TestReadTheGlobalAttributeClusterRevision_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read the global attribute constraints: ClusterRevision\n");
            err = TestReadTheGlobalAttributeConstraintsClusterRevision_2();
            break;
        case 3:
            ChipLogProgress(
                chipTool, " ***** Test Step 3 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : reads back global attribute: ClusterRevision\n");
            err = TestReadsBackGlobalAttributeClusterRevision_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Read the global attribute: AttributeList\n");
            err = TestReadTheGlobalAttributeAttributeList_5();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 6;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheGlobalAttributeClusterRevision_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestBooleanState * cluster = [[CHIPTestBooleanState alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read the global attribute: ClusterRevision Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("ClusterRevision", actualValue, 1U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheGlobalAttributeConstraintsClusterRevision_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestBooleanState * cluster = [[CHIPTestBooleanState alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read the global attribute constraints: ClusterRevision Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("clusterRevision", "", "uint16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_3()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestBooleanState * cluster = [[CHIPTestBooleanState alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id clusterRevisionArgument;
        clusterRevisionArgument = [NSNumber numberWithUnsignedShort:1U];
        [cluster
            writeAttributeClusterRevisionWithValue:clusterRevisionArgument
                                 completionHandler:^(NSError * _Nullable err) {
                                     NSLog(
                                         @"write the default values to mandatory global attribute: ClusterRevision Error: %@", err);

                                     VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                                     NextTest();
                                 }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsBackGlobalAttributeClusterRevision_4()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestBooleanState * cluster = [[CHIPTestBooleanState alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"reads back global attribute: ClusterRevision Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("ClusterRevision", actualValue, 1U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheGlobalAttributeAttributeList_5()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestBooleanState * cluster = [[CHIPTestBooleanState alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read the global attribute: AttributeList Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("attributeList", "", "list"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
};

class Test_TC_BOOL_2_1 : public TestCommandBridge {
public:
    Test_TC_BOOL_2_1()
        : TestCommandBridge("Test_TC_BOOL_2_1")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_BOOL_2_1() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_BOOL_2_1\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_BOOL_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read mandatory non-global attribute: StateValue\n");
            err = TestReadMandatoryNonGlobalAttributeStateValue_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read mandatory non-global attribute constraints: StateValue\n");
            err = TestReadMandatoryNonGlobalAttributeConstraintsStateValue_2();
            break;
        case 3:
            ChipLogProgress(
                chipTool, " ***** Test Step 3 : Write the default value to mandatory non-global attribute: StateValue\n");
            err = TestWriteTheDefaultValueToMandatoryNonGlobalAttributeStateValue_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Reads back the mandatory non-global attribute: StateValue\n");
            err = TestReadsBackTheMandatoryNonGlobalAttributeStateValue_4();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 5;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadMandatoryNonGlobalAttributeStateValue_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestBooleanState * cluster = [[CHIPTestBooleanState alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeStateValueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read mandatory non-global attribute: StateValue Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("StateValue", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadMandatoryNonGlobalAttributeConstraintsStateValue_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestBooleanState * cluster = [[CHIPTestBooleanState alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeStateValueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read mandatory non-global attribute constraints: StateValue Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("stateValue", "", "bool"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteTheDefaultValueToMandatoryNonGlobalAttributeStateValue_3()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestBooleanState * cluster = [[CHIPTestBooleanState alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id stateValueArgument;
        stateValueArgument = [NSNumber numberWithBool:1];
        [cluster writeAttributeStateValueWithValue:stateValueArgument
                                 completionHandler:^(NSError * _Nullable err) {
                                     NSLog(@"Write the default value to mandatory non-global attribute: StateValue Error: %@", err);

                                     VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                                     NextTest();
                                 }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsBackTheMandatoryNonGlobalAttributeStateValue_4()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestBooleanState * cluster = [[CHIPTestBooleanState alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeStateValueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads back the mandatory non-global attribute: StateValue Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("StateValue", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
};

class Test_TC_BRAC_1_1 : public TestCommandBridge {
public:
    Test_TC_BRAC_1_1()
        : TestCommandBridge("Test_TC_BRAC_1_1")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_BRAC_1_1() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_BRAC_1_1\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_BRAC_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read the global attribute: ClusterRevision\n");
            err = TestReadTheGlobalAttributeClusterRevision_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read the global attribute constraints: ClusterRevision\n");
            err = TestReadTheGlobalAttributeConstraintsClusterRevision_2();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 3;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheGlobalAttributeClusterRevision_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestBridgedActions * cluster = [[CHIPTestBridgedActions alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read the global attribute: ClusterRevision Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("ClusterRevision", actualValue, 1U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheGlobalAttributeConstraintsClusterRevision_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestBridgedActions * cluster = [[CHIPTestBridgedActions alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read the global attribute constraints: ClusterRevision Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("clusterRevision", "", "uint16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
};

class Test_TC_CC_1_1 : public TestCommandBridge {
public:
    Test_TC_CC_1_1()
        : TestCommandBridge("Test_TC_CC_1_1")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_CC_1_1() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_1_1\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read the global attribute constraints : ClusterRevision\n");
            err = TestReadTheGlobalAttributeConstraintsClusterRevision_1();
            break;
        case 2:
            ChipLogProgress(
                chipTool, " ***** Test Step 2 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read the global attribute: AttributeList\n");
            err = TestReadTheGlobalAttributeAttributeList_3();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 4;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheGlobalAttributeConstraintsClusterRevision_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read the global attribute constraints : ClusterRevision Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("clusterRevision", "", "uint16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id clusterRevisionArgument;
        clusterRevisionArgument = [NSNumber numberWithUnsignedShort:4U];
        [cluster
            writeAttributeClusterRevisionWithValue:clusterRevisionArgument
                                 completionHandler:^(NSError * _Nullable err) {
                                     NSLog(
                                         @"write the default values to mandatory global attribute: ClusterRevision Error: %@", err);

                                     VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                                     NextTest();
                                 }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheGlobalAttributeAttributeList_3()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read the global attribute: AttributeList Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("attributeList", "", "list"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
};

class Test_TC_CC_2_1 : public TestCommandBridge {
public:
    Test_TC_CC_2_1()
        : TestCommandBridge("Test_TC_CC_2_1")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_CC_2_1() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_2_1\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Validate constraints of attribute: current hue\n");
            err = TestValidateConstraintsOfAttributeCurrentHue_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Write the default value to mandatory attribute: CurrentHue\n");
            err = TestWriteTheDefaultValueToMandatoryAttributeCurrentHue_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Reads back mandatory attribute: CurrentHue\n");
            err = TestReadsBackMandatoryAttributeCurrentHue_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Validate constraints of attribute: CurrentSaturation\n");
            err = TestValidateConstraintsOfAttributeCurrentSaturation_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Write the default value to mandatory attribute: CurrentSaturation\n");
            err = TestWriteTheDefaultValueToMandatoryAttributeCurrentSaturation_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Reads back mandatory attribute: CurrentSaturation\n");
            err = TestReadsBackMandatoryAttributeCurrentSaturation_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Validate constraints of attribute: CurrentX\n");
            err = TestValidateConstraintsOfAttributeCurrentX_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Write the default value to mandatory attribute: CurrentX\n");
            err = TestWriteTheDefaultValueToMandatoryAttributeCurrentX_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Reads back mandatory attribute: CurrentX\n");
            err = TestReadsBackMandatoryAttributeCurrentX_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Validate constraints of attribute: CurrentY\n");
            err = TestValidateConstraintsOfAttributeCurrentY_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : Write the default values to mandatory attribute: CurrentY\n");
            err = TestWriteTheDefaultValuesToMandatoryAttributeCurrentY_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : Reads back mandatory attribute: CurrentY\n");
            err = TestReadsBackMandatoryAttributeCurrentY_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : Validate constraints of attribute: ColorTemperatureMireds\n");
            err = TestValidateConstraintsOfAttributeColorTemperatureMireds_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : Validate constraints of attribute: ColorMode\n");
            err = TestValidateConstraintsOfAttributeColorMode_14();
            break;
        case 15:
            ChipLogProgress(chipTool, " ***** Test Step 15 : Validate constraints of attribute: Options\n");
            err = TestValidateConstraintsOfAttributeOptions_15();
            break;
        case 16:
            ChipLogProgress(chipTool, " ***** Test Step 16 : Write the default values to mandatory attribute: Options\n");
            err = TestWriteTheDefaultValuesToMandatoryAttributeOptions_16();
            break;
        case 17:
            ChipLogProgress(chipTool, " ***** Test Step 17 : Reads back mandatory attribute: Options\n");
            err = TestReadsBackMandatoryAttributeOptions_17();
            break;
        case 18:
            ChipLogProgress(chipTool, " ***** Test Step 18 : Validate constraints of attribute: EnhancedCurrentHue\n");
            err = TestValidateConstraintsOfAttributeEnhancedCurrentHue_18();
            break;
        case 19:
            ChipLogProgress(
                chipTool, " ***** Test Step 19 : Write the default values to mandatory attribute: EnhancedCurrentHue\n");
            err = TestWriteTheDefaultValuesToMandatoryAttributeEnhancedCurrentHue_19();
            break;
        case 20:
            ChipLogProgress(chipTool, " ***** Test Step 20 : Reads back mandatory attribute: EnhancedCurrentHue\n");
            err = TestReadsBackMandatoryAttributeEnhancedCurrentHue_20();
            break;
        case 21:
            ChipLogProgress(chipTool, " ***** Test Step 21 : Validate constraints of attribute: EnhancedColorMode\n");
            err = TestValidateConstraintsOfAttributeEnhancedColorMode_21();
            break;
        case 22:
            ChipLogProgress(chipTool, " ***** Test Step 22 : Validate constraints of attribute: ColorLoopActive\n");
            err = TestValidateConstraintsOfAttributeColorLoopActive_22();
            break;
        case 23:
            ChipLogProgress(chipTool, " ***** Test Step 23 : Write the default values to mandatory attribute: ColorLoopActive\n");
            err = TestWriteTheDefaultValuesToMandatoryAttributeColorLoopActive_23();
            break;
        case 24:
            ChipLogProgress(chipTool, " ***** Test Step 24 : Reads back mandatory attribute: ColorLoopActive\n");
            err = TestReadsBackMandatoryAttributeColorLoopActive_24();
            break;
        case 25:
            ChipLogProgress(chipTool, " ***** Test Step 25 : Validate constraints of attribute: ColorLoopDirection\n");
            err = TestValidateConstraintsOfAttributeColorLoopDirection_25();
            break;
        case 26:
            ChipLogProgress(
                chipTool, " ***** Test Step 26 : Write the default values to mandatory attribute: ColorLoopDirection\n");
            err = TestWriteTheDefaultValuesToMandatoryAttributeColorLoopDirection_26();
            break;
        case 27:
            ChipLogProgress(chipTool, " ***** Test Step 27 : Reads back mandatory attribute: ColorLoopDirection\n");
            err = TestReadsBackMandatoryAttributeColorLoopDirection_27();
            break;
        case 28:
            ChipLogProgress(chipTool, " ***** Test Step 28 : Validate constraints of attribute: ColorLoopTime\n");
            err = TestValidateConstraintsOfAttributeColorLoopTime_28();
            break;
        case 29:
            ChipLogProgress(chipTool, " ***** Test Step 29 : Write the default values to mandatory attribute: ColorLoopTime\n");
            err = TestWriteTheDefaultValuesToMandatoryAttributeColorLoopTime_29();
            break;
        case 30:
            ChipLogProgress(chipTool, " ***** Test Step 30 : Reads back mandatory attribute: ColorLoopTime\n");
            err = TestReadsBackMandatoryAttributeColorLoopTime_30();
            break;
        case 31:
            ChipLogProgress(chipTool, " ***** Test Step 31 : Validate constraints of attribute: ColorLoopStartEnhancedHue\n");
            err = TestValidateConstraintsOfAttributeColorLoopStartEnhancedHue_31();
            break;
        case 32:
            ChipLogProgress(
                chipTool, " ***** Test Step 32 : Write the default values to mandatory attribute: ColorLoopStartEnhancedHue\n");
            err = TestWriteTheDefaultValuesToMandatoryAttributeColorLoopStartEnhancedHue_32();
            break;
        case 33:
            ChipLogProgress(chipTool, " ***** Test Step 33 : Reads back mandatory attribute: ColorLoopStartEnhancedHue\n");
            err = TestReadsBackMandatoryAttributeColorLoopStartEnhancedHue_33();
            break;
        case 34:
            ChipLogProgress(chipTool, " ***** Test Step 34 : Validate constraints of attribute: ColorLoopStoredEnhancedHue\n");
            err = TestValidateConstraintsOfAttributeColorLoopStoredEnhancedHue_34();
            break;
        case 35:
            ChipLogProgress(
                chipTool, " ***** Test Step 35 : Write the default values to mandatory attribute: ColorLoopStoredEnhancedHue\n");
            err = TestWriteTheDefaultValuesToMandatoryAttributeColorLoopStoredEnhancedHue_35();
            break;
        case 36:
            ChipLogProgress(chipTool, " ***** Test Step 36 : Reads back mandatory attribute: ColorLoopStoredEnhancedHue\n");
            err = TestReadsBackMandatoryAttributeColorLoopStoredEnhancedHue_36();
            break;
        case 37:
            ChipLogProgress(chipTool, " ***** Test Step 37 : Validate constraints of attribute: ColorCapabilities\n");
            err = TestValidateConstraintsOfAttributeColorCapabilities_37();
            break;
        case 38:
            ChipLogProgress(chipTool, " ***** Test Step 38 : Write the default values to mandatory attribute: ColorCapabilities\n");
            err = TestWriteTheDefaultValuesToMandatoryAttributeColorCapabilities_38();
            break;
        case 39:
            ChipLogProgress(chipTool, " ***** Test Step 39 : Reads back mandatory attribute: ColorCapabilities\n");
            err = TestReadsBackMandatoryAttributeColorCapabilities_39();
            break;
        case 40:
            ChipLogProgress(chipTool, " ***** Test Step 40 : Validate constraints of attribute: ColorTempPhysicalMinMireds\n");
            err = TestValidateConstraintsOfAttributeColorTempPhysicalMinMireds_40();
            break;
        case 41:
            ChipLogProgress(
                chipTool, " ***** Test Step 41 : Write the default values to mandatory  attribute: ColorTempPhysicalMinMireds\n");
            err = TestWriteTheDefaultValuesToMandatoryAttributeColorTempPhysicalMinMireds_41();
            break;
        case 42:
            ChipLogProgress(chipTool, " ***** Test Step 42 : Reads back mandatory attribute: ColorTempPhysicalMinMireds\n");
            err = TestReadsBackMandatoryAttributeColorTempPhysicalMinMireds_42();
            break;
        case 43:
            ChipLogProgress(chipTool, " ***** Test Step 43 : Validate constraints of attribute: ColorTempPhysicalMaxMireds\n");
            err = TestValidateConstraintsOfAttributeColorTempPhysicalMaxMireds_43();
            break;
        case 44:
            ChipLogProgress(
                chipTool, " ***** Test Step 44 : Write the default values to mandatory attribute: ColorTempPhysicalMaxMireds\n");
            err = TestWriteTheDefaultValuesToMandatoryAttributeColorTempPhysicalMaxMireds_44();
            break;
        case 45:
            ChipLogProgress(chipTool, " ***** Test Step 45 : Reads back mandatory attribute: ColorTempPhysicalMaxMireds\n");
            err = TestReadsBackMandatoryAttributeColorTempPhysicalMaxMireds_45();
            break;
        case 46:
            ChipLogProgress(chipTool, " ***** Test Step 46 : Read the optional attribute: CoupleColorTempToLevelMinMireds\n");
            err = TestReadTheOptionalAttributeCoupleColorTempToLevelMinMireds_46();
            break;
        case 47:
            ChipLogProgress(chipTool,
                " ***** Test Step 47 : Write the default values to optional attribute: CoupleColorTempToLevelMinMireds\n");
            err = TestWriteTheDefaultValuesToOptionalAttributeCoupleColorTempToLevelMinMireds_47();
            break;
        case 48:
            ChipLogProgress(chipTool, " ***** Test Step 48 : Reads back optional attribute: CoupleColorTempToLevelMinMireds\n");
            err = TestReadsBackOptionalAttributeCoupleColorTempToLevelMinMireds_48();
            break;
        case 49:
            ChipLogProgress(chipTool, " ***** Test Step 49 : Read the optional attribute: StartUpColorTemperatureMireds\n");
            err = TestReadTheOptionalAttributeStartUpColorTemperatureMireds_49();
            break;
        case 50:
            ChipLogProgress(
                chipTool, " ***** Test Step 50 : Write the default values to optional attribute: StartUpColorTemperatureMireds\n");
            err = TestWriteTheDefaultValuesToOptionalAttributeStartUpColorTemperatureMireds_50();
            break;
        case 51:
            ChipLogProgress(chipTool, " ***** Test Step 51 : Reads back optional attribute: StartUpColorTemperatureMireds\n");
            err = TestReadsBackOptionalAttributeStartUpColorTemperatureMireds_51();
            break;
        case 52:
            ChipLogProgress(chipTool, " ***** Test Step 52 : Validate constraints of attribute: RemainingTime\n");
            err = TestValidateConstraintsOfAttributeRemainingTime_52();
            break;
        case 53:
            ChipLogProgress(chipTool, " ***** Test Step 53 : Write the default values to optional attribute: RemainingTime\n");
            err = TestWriteTheDefaultValuesToOptionalAttributeRemainingTime_53();
            break;
        case 54:
            ChipLogProgress(chipTool, " ***** Test Step 54 : Reads back optional attribute: RemainingTime\n");
            err = TestReadsBackOptionalAttributeRemainingTime_54();
            break;
        case 55:
            ChipLogProgress(chipTool, " ***** Test Step 55 : Read the optional attribute: DriftCompensation\n");
            err = TestReadTheOptionalAttributeDriftCompensation_55();
            break;
        case 56:
            ChipLogProgress(chipTool, " ***** Test Step 56 : Write the default values to optional attribute: DriftCompensation\n");
            err = TestWriteTheDefaultValuesToOptionalAttributeDriftCompensation_56();
            break;
        case 57:
            ChipLogProgress(chipTool, " ***** Test Step 57 : Reads back optional attribute: DriftCompensation\n");
            err = TestReadsBackOptionalAttributeDriftCompensation_57();
            break;
        case 58:
            ChipLogProgress(chipTool, " ***** Test Step 58 : Read the optional attribute: CompensationText\n");
            err = TestReadTheOptionalAttributeCompensationText_58();
            break;
        case 59:
            ChipLogProgress(chipTool, " ***** Test Step 59 : Write the default values to optional attribute: CompensationText\n");
            err = TestWriteTheDefaultValuesToOptionalAttributeCompensationText_59();
            break;
        case 60:
            ChipLogProgress(chipTool, " ***** Test Step 60 : Reads back optional attribute: CompensationText\n");
            err = TestReadsBackOptionalAttributeCompensationText_60();
            break;
        case 61:
            ChipLogProgress(chipTool, " ***** Test Step 61 : Read the mandatory attribute: NumberOfPrimaries\n");
            err = TestReadTheMandatoryAttributeNumberOfPrimaries_61();
            break;
        case 62:
            ChipLogProgress(chipTool, " ***** Test Step 62 : Write the default mandatory attribute: NumberOfPrimaries\n");
            err = TestWriteTheDefaultMandatoryAttributeNumberOfPrimaries_62();
            break;
        case 63:
            ChipLogProgress(chipTool, " ***** Test Step 63 : Read back the mandatory attribute: NumberOfPrimaries\n");
            err = TestReadBackTheMandatoryAttributeNumberOfPrimaries_63();
            break;
        case 64:
            ChipLogProgress(chipTool, " ***** Test Step 64 : Read the mandatory attribute: Primary1X\n");
            err = TestReadTheMandatoryAttributePrimary1X_64();
            break;
        case 65:
            ChipLogProgress(chipTool, " ***** Test Step 65 : Write the default mandatory attribute: Primary1X\n");
            err = TestWriteTheDefaultMandatoryAttributePrimary1X_65();
            break;
        case 66:
            ChipLogProgress(chipTool, " ***** Test Step 66 : Read back the mandatory attribute: Primary1X\n");
            err = TestReadBackTheMandatoryAttributePrimary1X_66();
            break;
        case 67:
            ChipLogProgress(chipTool, " ***** Test Step 67 : Read the mandatory attribute: Primary1Y\n");
            err = TestReadTheMandatoryAttributePrimary1Y_67();
            break;
        case 68:
            ChipLogProgress(chipTool, " ***** Test Step 68 : Write the default mandatory attribute: Primary1Y\n");
            err = TestWriteTheDefaultMandatoryAttributePrimary1Y_68();
            break;
        case 69:
            ChipLogProgress(chipTool, " ***** Test Step 69 : Read back the mandatory attribute: Primary1Y\n");
            err = TestReadBackTheMandatoryAttributePrimary1Y_69();
            break;
        case 70:
            ChipLogProgress(chipTool, " ***** Test Step 70 : Read the mandatory attribute: Primary1Intensity\n");
            err = TestReadTheMandatoryAttributePrimary1Intensity_70();
            break;
        case 71:
            ChipLogProgress(chipTool, " ***** Test Step 71 : Read the mandatory attribute: Primary2X\n");
            err = TestReadTheMandatoryAttributePrimary2X_71();
            break;
        case 72:
            ChipLogProgress(chipTool, " ***** Test Step 72 : Write the default mandatory attribute: Primary2X\n");
            err = TestWriteTheDefaultMandatoryAttributePrimary2X_72();
            break;
        case 73:
            ChipLogProgress(chipTool, " ***** Test Step 73 : Read back the mandatory attribute: Primary2X\n");
            err = TestReadBackTheMandatoryAttributePrimary2X_73();
            break;
        case 74:
            ChipLogProgress(chipTool, " ***** Test Step 74 : Read the mandatory attribute: Primary2Y\n");
            err = TestReadTheMandatoryAttributePrimary2Y_74();
            break;
        case 75:
            ChipLogProgress(chipTool, " ***** Test Step 75 : Write the default mandatory attribute: Primary2Y\n");
            err = TestWriteTheDefaultMandatoryAttributePrimary2Y_75();
            break;
        case 76:
            ChipLogProgress(chipTool, " ***** Test Step 76 : Read back the mandatory attribute: Primary2Y\n");
            err = TestReadBackTheMandatoryAttributePrimary2Y_76();
            break;
        case 77:
            ChipLogProgress(chipTool, " ***** Test Step 77 : Validate constraints of attribute: Primary2Intensity\n");
            err = TestValidateConstraintsOfAttributePrimary2Intensity_77();
            break;
        case 78:
            ChipLogProgress(chipTool, " ***** Test Step 78 : Read the mandatory attribute: Primary3X\n");
            err = TestReadTheMandatoryAttributePrimary3X_78();
            break;
        case 79:
            ChipLogProgress(chipTool, " ***** Test Step 79 : Write the default mandatory attribute: Primary3X\n");
            err = TestWriteTheDefaultMandatoryAttributePrimary3X_79();
            break;
        case 80:
            ChipLogProgress(chipTool, " ***** Test Step 80 : Read back the mandatory attribute: Primary3X\n");
            err = TestReadBackTheMandatoryAttributePrimary3X_80();
            break;
        case 81:
            ChipLogProgress(chipTool, " ***** Test Step 81 : Read the mandatory attribute: Primary3Y\n");
            err = TestReadTheMandatoryAttributePrimary3Y_81();
            break;
        case 82:
            ChipLogProgress(chipTool, " ***** Test Step 82 : Write the default mandatory attribute: Primary3Y\n");
            err = TestWriteTheDefaultMandatoryAttributePrimary3Y_82();
            break;
        case 83:
            ChipLogProgress(chipTool, " ***** Test Step 83 : Read back the mandatory attribute: Primary3Y\n");
            err = TestReadBackTheMandatoryAttributePrimary3Y_83();
            break;
        case 84:
            ChipLogProgress(chipTool, " ***** Test Step 84 : Read the mandatory attribute: Primary3Intensity\n");
            err = TestReadTheMandatoryAttributePrimary3Intensity_84();
            break;
        case 85:
            ChipLogProgress(chipTool, " ***** Test Step 85 : Read the mandatory attribute: Primary4X\n");
            err = TestReadTheMandatoryAttributePrimary4X_85();
            break;
        case 86:
            ChipLogProgress(chipTool, " ***** Test Step 86 : Write the default mandatory attribute: Primary4X\n");
            err = TestWriteTheDefaultMandatoryAttributePrimary4X_86();
            break;
        case 87:
            ChipLogProgress(chipTool, " ***** Test Step 87 : Read back the mandatory attribute: Primary4X\n");
            err = TestReadBackTheMandatoryAttributePrimary4X_87();
            break;
        case 88:
            ChipLogProgress(chipTool, " ***** Test Step 88 : Read the mandatory attribute: Primary4Y\n");
            err = TestReadTheMandatoryAttributePrimary4Y_88();
            break;
        case 89:
            ChipLogProgress(chipTool, " ***** Test Step 89 : Write the default mandatory attribute: Primary4Y\n");
            err = TestWriteTheDefaultMandatoryAttributePrimary4Y_89();
            break;
        case 90:
            ChipLogProgress(chipTool, " ***** Test Step 90 : Read back the mandatory attribute: Primary4Y\n");
            err = TestReadBackTheMandatoryAttributePrimary4Y_90();
            break;
        case 91:
            ChipLogProgress(chipTool, " ***** Test Step 91 : Read the mandatory attribute: Primary4Intensity\n");
            err = TestReadTheMandatoryAttributePrimary4Intensity_91();
            break;
        case 92:
            ChipLogProgress(chipTool, " ***** Test Step 92 : Read the mandatory attribute: Primary5X\n");
            err = TestReadTheMandatoryAttributePrimary5X_92();
            break;
        case 93:
            ChipLogProgress(chipTool, " ***** Test Step 93 : Write the default mandatory attribute: Primary5X\n");
            err = TestWriteTheDefaultMandatoryAttributePrimary5X_93();
            break;
        case 94:
            ChipLogProgress(chipTool, " ***** Test Step 94 : Read back the mandatory attribute: Primary5X\n");
            err = TestReadBackTheMandatoryAttributePrimary5X_94();
            break;
        case 95:
            ChipLogProgress(chipTool, " ***** Test Step 95 : Read the mandatory attribute: Primary5Y\n");
            err = TestReadTheMandatoryAttributePrimary5Y_95();
            break;
        case 96:
            ChipLogProgress(chipTool, " ***** Test Step 96 : Write the default mandatory attribute: Primary5Y\n");
            err = TestWriteTheDefaultMandatoryAttributePrimary5Y_96();
            break;
        case 97:
            ChipLogProgress(chipTool, " ***** Test Step 97 : Read back the mandatory attribute: Primary5Y\n");
            err = TestReadBackTheMandatoryAttributePrimary5Y_97();
            break;
        case 98:
            ChipLogProgress(chipTool, " ***** Test Step 98 : Read the mandatory attribute: Primary5Intensity\n");
            err = TestReadTheMandatoryAttributePrimary5Intensity_98();
            break;
        case 99:
            ChipLogProgress(chipTool, " ***** Test Step 99 : Read the mandatory attribute: Primary6X\n");
            err = TestReadTheMandatoryAttributePrimary6X_99();
            break;
        case 100:
            ChipLogProgress(chipTool, " ***** Test Step 100 : Write the default mandatory attribute: Primary6X\n");
            err = TestWriteTheDefaultMandatoryAttributePrimary6X_100();
            break;
        case 101:
            ChipLogProgress(chipTool, " ***** Test Step 101 : Read back the mandatory attribute: Primary6X\n");
            err = TestReadBackTheMandatoryAttributePrimary6X_101();
            break;
        case 102:
            ChipLogProgress(chipTool, " ***** Test Step 102 : Read the mandatory attribute: Primary6Y\n");
            err = TestReadTheMandatoryAttributePrimary6Y_102();
            break;
        case 103:
            ChipLogProgress(chipTool, " ***** Test Step 103 : Write the default mandatory attribute: Primary6Y\n");
            err = TestWriteTheDefaultMandatoryAttributePrimary6Y_103();
            break;
        case 104:
            ChipLogProgress(chipTool, " ***** Test Step 104 : Read back the mandatory attribute: Primary6Y\n");
            err = TestReadBackTheMandatoryAttributePrimary6Y_104();
            break;
        case 105:
            ChipLogProgress(chipTool, " ***** Test Step 105 : Read the mandatory attribute: Primary6Intensity\n");
            err = TestReadTheMandatoryAttributePrimary6Intensity_105();
            break;
        case 106:
            ChipLogProgress(chipTool, " ***** Test Step 106 : Read the optional attribute: WhitePointX\n");
            err = TestReadTheOptionalAttributeWhitePointX_106();
            break;
        case 107:
            ChipLogProgress(chipTool, " ***** Test Step 107 : Write the default optional attribute: WhitePointX\n");
            err = TestWriteTheDefaultOptionalAttributeWhitePointX_107();
            break;
        case 108:
            ChipLogProgress(chipTool, " ***** Test Step 108 : Read back the optional attribute: WhitePointX\n");
            err = TestReadBackTheOptionalAttributeWhitePointX_108();
            break;
        case 109:
            ChipLogProgress(chipTool, " ***** Test Step 109 : Read the optional attribute: WhitePointY\n");
            err = TestReadTheOptionalAttributeWhitePointY_109();
            break;
        case 110:
            ChipLogProgress(chipTool, " ***** Test Step 110 : Write the default optional attribute: WhitePointY\n");
            err = TestWriteTheDefaultOptionalAttributeWhitePointY_110();
            break;
        case 111:
            ChipLogProgress(chipTool, " ***** Test Step 111 : Read back the optional attribute: WhitePointY\n");
            err = TestReadBackTheOptionalAttributeWhitePointY_111();
            break;
        case 112:
            ChipLogProgress(chipTool, " ***** Test Step 112 : Read the optional attribute: ColorPointRX\n");
            err = TestReadTheOptionalAttributeColorPointRX_112();
            break;
        case 113:
            ChipLogProgress(chipTool, " ***** Test Step 113 : Write the default optional attribute: ColorPointRX\n");
            err = TestWriteTheDefaultOptionalAttributeColorPointRX_113();
            break;
        case 114:
            ChipLogProgress(chipTool, " ***** Test Step 114 : Read back the optional attribute: ColorPointRX\n");
            err = TestReadBackTheOptionalAttributeColorPointRX_114();
            break;
        case 115:
            ChipLogProgress(chipTool, " ***** Test Step 115 : Read the optional attribute: ColorPointRY\n");
            err = TestReadTheOptionalAttributeColorPointRY_115();
            break;
        case 116:
            ChipLogProgress(chipTool, " ***** Test Step 116 : Write the default optional attribute: ColorPointRY\n");
            err = TestWriteTheDefaultOptionalAttributeColorPointRY_116();
            break;
        case 117:
            ChipLogProgress(chipTool, " ***** Test Step 117 : Read back the optional attribute: ColorPointRY\n");
            err = TestReadBackTheOptionalAttributeColorPointRY_117();
            break;
        case 118:
            ChipLogProgress(chipTool, " ***** Test Step 118 : Read the optional attribute: ColorPointRIntensity\n");
            err = TestReadTheOptionalAttributeColorPointRIntensity_118();
            break;
        case 119:
            ChipLogProgress(chipTool, " ***** Test Step 119 : Write the default optional attribute: ColorPointRIntensity\n");
            err = TestWriteTheDefaultOptionalAttributeColorPointRIntensity_119();
            break;
        case 120:
            ChipLogProgress(chipTool, " ***** Test Step 120 : Read back the optional attribute: ColorPointRIntensity\n");
            err = TestReadBackTheOptionalAttributeColorPointRIntensity_120();
            break;
        case 121:
            ChipLogProgress(chipTool, " ***** Test Step 121 : Read the optional attribute: ColorPointGX\n");
            err = TestReadTheOptionalAttributeColorPointGX_121();
            break;
        case 122:
            ChipLogProgress(chipTool, " ***** Test Step 122 : Write the default optional attribute: ColorPointGX\n");
            err = TestWriteTheDefaultOptionalAttributeColorPointGX_122();
            break;
        case 123:
            ChipLogProgress(chipTool, " ***** Test Step 123 : Read back the optional attribute: ColorPointGX\n");
            err = TestReadBackTheOptionalAttributeColorPointGX_123();
            break;
        case 124:
            ChipLogProgress(chipTool, " ***** Test Step 124 : Read the optional attribute: ColorPointGY\n");
            err = TestReadTheOptionalAttributeColorPointGY_124();
            break;
        case 125:
            ChipLogProgress(chipTool, " ***** Test Step 125 : Write the default optional attribute: ColorPointGY\n");
            err = TestWriteTheDefaultOptionalAttributeColorPointGY_125();
            break;
        case 126:
            ChipLogProgress(chipTool, " ***** Test Step 126 : Read back the optional attribute: ColorPointGY\n");
            err = TestReadBackTheOptionalAttributeColorPointGY_126();
            break;
        case 127:
            ChipLogProgress(chipTool, " ***** Test Step 127 : Read the optional attribute: ColorPointGIntensity\n");
            err = TestReadTheOptionalAttributeColorPointGIntensity_127();
            break;
        case 128:
            ChipLogProgress(chipTool, " ***** Test Step 128 : Write the default optional attribute: ColorPointGIntensity\n");
            err = TestWriteTheDefaultOptionalAttributeColorPointGIntensity_128();
            break;
        case 129:
            ChipLogProgress(chipTool, " ***** Test Step 129 : Read back the optional attribute: ColorPointGIntensity\n");
            err = TestReadBackTheOptionalAttributeColorPointGIntensity_129();
            break;
        case 130:
            ChipLogProgress(chipTool, " ***** Test Step 130 : Read the optional attribute: ColorPointBX\n");
            err = TestReadTheOptionalAttributeColorPointBX_130();
            break;
        case 131:
            ChipLogProgress(chipTool, " ***** Test Step 131 : Write the default optional attribute: ColorPointBX\n");
            err = TestWriteTheDefaultOptionalAttributeColorPointBX_131();
            break;
        case 132:
            ChipLogProgress(chipTool, " ***** Test Step 132 : Read back the optional attribute: ColorPointBX\n");
            err = TestReadBackTheOptionalAttributeColorPointBX_132();
            break;
        case 133:
            ChipLogProgress(chipTool, " ***** Test Step 133 : Read the optional attribute: ColorPointBY\n");
            err = TestReadTheOptionalAttributeColorPointBY_133();
            break;
        case 134:
            ChipLogProgress(chipTool, " ***** Test Step 134 : Write the default optional attribute: ColorPointBY\n");
            err = TestWriteTheDefaultOptionalAttributeColorPointBY_134();
            break;
        case 135:
            ChipLogProgress(chipTool, " ***** Test Step 135 : Read back the optional attribute: ColorPointBY\n");
            err = TestReadBackTheOptionalAttributeColorPointBY_135();
            break;
        case 136:
            ChipLogProgress(chipTool, " ***** Test Step 136 : Read the optional attribute: ColorPointBIntensity\n");
            err = TestReadTheOptionalAttributeColorPointBIntensity_136();
            break;
        case 137:
            ChipLogProgress(chipTool, " ***** Test Step 137 : Write the default optional attribute: ColorPointBIntensity\n");
            err = TestWriteTheDefaultOptionalAttributeColorPointBIntensity_137();
            break;
        case 138:
            ChipLogProgress(chipTool, " ***** Test Step 138 : Read back the optional attribute: ColorPointBIntensity\n");
            err = TestReadBackTheOptionalAttributeColorPointBIntensity_138();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 139;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeCurrentHue_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeCurrentHueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Validate constraints of attribute: current hue Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("currentHue", "", "uint8"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<uint8_t>("currentHue", [value unsignedCharValue], 0));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("currentHue", [value unsignedCharValue], 254));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteTheDefaultValueToMandatoryAttributeCurrentHue_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id currentHueArgument;
        currentHueArgument = [NSNumber numberWithUnsignedChar:0];
        [cluster writeAttributeCurrentHueWithValue:currentHueArgument
                                 completionHandler:^(NSError * _Nullable err) {
                                     NSLog(@"Write the default value to mandatory attribute: CurrentHue Error: %@", err);

                                     VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                                     NextTest();
                                 }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsBackMandatoryAttributeCurrentHue_3()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeCurrentHueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads back mandatory attribute: CurrentHue Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("current hue", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeCurrentSaturation_4()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeCurrentSaturationWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Validate constraints of attribute: CurrentSaturation Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("currentSaturation", "", "uint8"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<uint8_t>("currentSaturation", [value unsignedCharValue], 0));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("currentSaturation", [value unsignedCharValue], 254));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteTheDefaultValueToMandatoryAttributeCurrentSaturation_5()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id currentSaturationArgument;
        currentSaturationArgument = [NSNumber numberWithUnsignedChar:0];
        [cluster
            writeAttributeCurrentSaturationWithValue:currentSaturationArgument
                                   completionHandler:^(NSError * _Nullable err) {
                                       NSLog(@"Write the default value to mandatory attribute: CurrentSaturation Error: %@", err);

                                       VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                                       NextTest();
                                   }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsBackMandatoryAttributeCurrentSaturation_6()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeCurrentSaturationWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads back mandatory attribute: CurrentSaturation Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("current saturation", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeCurrentX_7()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeCurrentXWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Validate constraints of attribute: CurrentX Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("currentX", "", "uint16"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("currentX", [value unsignedShortValue], 0U));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("currentX", [value unsignedShortValue], 65279U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteTheDefaultValueToMandatoryAttributeCurrentX_8()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id currentXArgument;
        currentXArgument = [NSNumber numberWithUnsignedShort:24939U];
        [cluster writeAttributeCurrentXWithValue:currentXArgument
                               completionHandler:^(NSError * _Nullable err) {
                                   NSLog(@"Write the default value to mandatory attribute: CurrentX Error: %@", err);

                                   VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                                   NextTest();
                               }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsBackMandatoryAttributeCurrentX_9()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeCurrentXWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads back mandatory attribute: CurrentX Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("current x", actualValue, 24939U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeCurrentY_10()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeCurrentYWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Validate constraints of attribute: CurrentY Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("currentY", "", "uint16"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("currentY", [value unsignedShortValue], 0U));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("currentY", [value unsignedShortValue], 65279U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryAttributeCurrentY_11()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id currentYArgument;
        currentYArgument = [NSNumber numberWithUnsignedShort:24701U];
        [cluster writeAttributeCurrentYWithValue:currentYArgument
                               completionHandler:^(NSError * _Nullable err) {
                                   NSLog(@"Write the default values to mandatory attribute: CurrentY Error: %@", err);

                                   VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                                   NextTest();
                               }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsBackMandatoryAttributeCurrentY_12()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeCurrentYWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads back mandatory attribute: CurrentY Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("current y", actualValue, 24701U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeColorTemperatureMireds_13()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeColorTemperatureWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Validate constraints of attribute: ColorTemperatureMireds Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("colorTemperature", "", "uint16"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("colorTemperature", [value unsignedShortValue], 0U));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("colorTemperature", [value unsignedShortValue], 65279U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeColorMode_14()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeColorModeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Validate constraints of attribute: ColorMode Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("colorMode", "", "enum8"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<uint8_t>("colorMode", [value unsignedCharValue], 0));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("colorMode", [value unsignedCharValue], 2));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeOptions_15()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeColorControlOptionsWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Validate constraints of attribute: Options Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("colorControlOptions", "", "map8"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryAttributeOptions_16()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id colorControlOptionsArgument;
        colorControlOptionsArgument = [NSNumber numberWithUnsignedChar:0];
        [cluster writeAttributeColorControlOptionsWithValue:colorControlOptionsArgument
                                          completionHandler:^(NSError * _Nullable err) {
                                              NSLog(@"Write the default values to mandatory attribute: Options Error: %@", err);

                                              VerifyOrReturn(CheckValue("status", err, 0));

                                              NextTest();
                                          }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsBackMandatoryAttributeOptions_17()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeColorControlOptionsWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads back mandatory attribute: Options Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("color control options", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeEnhancedCurrentHue_18()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeEnhancedCurrentHueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Validate constraints of attribute: EnhancedCurrentHue Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("enhancedCurrentHue", "", "uint16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryAttributeEnhancedCurrentHue_19()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id enhancedCurrentHueArgument;
        enhancedCurrentHueArgument = [NSNumber numberWithUnsignedShort:0U];
        [cluster writeAttributeEnhancedCurrentHueWithValue:enhancedCurrentHueArgument
                                         completionHandler:^(NSError * _Nullable err) {
                                             NSLog(@"Write the default values to mandatory attribute: EnhancedCurrentHue Error: %@",
                                                 err);

                                             VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                                             NextTest();
                                         }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsBackMandatoryAttributeEnhancedCurrentHue_20()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeEnhancedCurrentHueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads back mandatory attribute: EnhancedCurrentHue Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("enhanced current hue", actualValue, 0U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeEnhancedColorMode_21()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeEnhancedColorModeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Validate constraints of attribute: EnhancedColorMode Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("enhancedColorMode", "", "enum8"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeColorLoopActive_22()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeColorLoopActiveWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Validate constraints of attribute: ColorLoopActive Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("colorLoopActive", "", "uint8"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryAttributeColorLoopActive_23()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id colorLoopActiveArgument;
        colorLoopActiveArgument = [NSNumber numberWithUnsignedChar:0];
        [cluster writeAttributeColorLoopActiveWithValue:colorLoopActiveArgument
                                      completionHandler:^(NSError * _Nullable err) {
                                          NSLog(@"Write the default values to mandatory attribute: ColorLoopActive Error: %@", err);

                                          VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                                          NextTest();
                                      }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsBackMandatoryAttributeColorLoopActive_24()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeColorLoopActiveWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads back mandatory attribute: ColorLoopActive Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("color loop active", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeColorLoopDirection_25()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeColorLoopDirectionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Validate constraints of attribute: ColorLoopDirection Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("colorLoopDirection", "", "uint8"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryAttributeColorLoopDirection_26()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id colorLoopDirectionArgument;
        colorLoopDirectionArgument = [NSNumber numberWithUnsignedChar:0];
        [cluster writeAttributeColorLoopDirectionWithValue:colorLoopDirectionArgument
                                         completionHandler:^(NSError * _Nullable err) {
                                             NSLog(@"Write the default values to mandatory attribute: ColorLoopDirection Error: %@",
                                                 err);

                                             VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                                             NextTest();
                                         }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsBackMandatoryAttributeColorLoopDirection_27()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeColorLoopDirectionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads back mandatory attribute: ColorLoopDirection Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("color loop direction", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeColorLoopTime_28()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeColorLoopTimeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Validate constraints of attribute: ColorLoopTime Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("colorLoopTime", "", "uint16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryAttributeColorLoopTime_29()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id colorLoopTimeArgument;
        colorLoopTimeArgument = [NSNumber numberWithUnsignedShort:25U];
        [cluster writeAttributeColorLoopTimeWithValue:colorLoopTimeArgument
                                    completionHandler:^(NSError * _Nullable err) {
                                        NSLog(@"Write the default values to mandatory attribute: ColorLoopTime Error: %@", err);

                                        VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                                        NextTest();
                                    }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsBackMandatoryAttributeColorLoopTime_30()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeColorLoopTimeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads back mandatory attribute: ColorLoopTime Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("color loop time", actualValue, 25U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeColorLoopStartEnhancedHue_31()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster
            readAttributeColorLoopStartEnhancedHueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
                NSLog(@"Validate constraints of attribute: ColorLoopStartEnhancedHue Error: %@", err);

                VerifyOrReturn(CheckValue("status", err, 0));

                VerifyOrReturn(CheckConstraintType("colorLoopStartEnhancedHue", "", "uint16"));
                NextTest();
            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryAttributeColorLoopStartEnhancedHue_32()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id colorLoopStartEnhancedHueArgument;
        colorLoopStartEnhancedHueArgument = [NSNumber numberWithUnsignedShort:8960U];
        [cluster writeAttributeColorLoopStartEnhancedHueWithValue:colorLoopStartEnhancedHueArgument
                                                completionHandler:^(NSError * _Nullable err) {
                                                    NSLog(@"Write the default values to mandatory attribute: "
                                                          @"ColorLoopStartEnhancedHue Error: %@",
                                                        err);

                                                    VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                                                    NextTest();
                                                }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsBackMandatoryAttributeColorLoopStartEnhancedHue_33()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster
            readAttributeColorLoopStartEnhancedHueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
                NSLog(@"Reads back mandatory attribute: ColorLoopStartEnhancedHue Error: %@", err);

                VerifyOrReturn(CheckValue("status", err, 0));

                {
                    id actualValue = value;
                    VerifyOrReturn(CheckValue("color loop start enhanced hue", actualValue, 8960U));
                }

                NextTest();
            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeColorLoopStoredEnhancedHue_34()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster
            readAttributeColorLoopStoredEnhancedHueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
                NSLog(@"Validate constraints of attribute: ColorLoopStoredEnhancedHue Error: %@", err);

                VerifyOrReturn(CheckValue("status", err, 0));

                VerifyOrReturn(CheckConstraintType("colorLoopStoredEnhancedHue", "", "uint16"));
                NextTest();
            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryAttributeColorLoopStoredEnhancedHue_35()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id colorLoopStoredEnhancedHueArgument;
        colorLoopStoredEnhancedHueArgument = [NSNumber numberWithUnsignedShort:0U];
        [cluster writeAttributeColorLoopStoredEnhancedHueWithValue:colorLoopStoredEnhancedHueArgument
                                                 completionHandler:^(NSError * _Nullable err) {
                                                     NSLog(@"Write the default values to mandatory attribute: "
                                                           @"ColorLoopStoredEnhancedHue Error: %@",
                                                         err);

                                                     VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                                                     NextTest();
                                                 }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsBackMandatoryAttributeColorLoopStoredEnhancedHue_36()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster
            readAttributeColorLoopStoredEnhancedHueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
                NSLog(@"Reads back mandatory attribute: ColorLoopStoredEnhancedHue Error: %@", err);

                VerifyOrReturn(CheckValue("status", err, 0));

                {
                    id actualValue = value;
                    VerifyOrReturn(CheckValue("color loop stored enhanced hue", actualValue, 0U));
                }

                NextTest();
            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeColorCapabilities_37()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeColorCapabilitiesWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Validate constraints of attribute: ColorCapabilities Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("colorCapabilities", "", "map16"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("colorCapabilities", [value unsignedShortValue], 0U));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("colorCapabilities", [value unsignedShortValue], 31U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryAttributeColorCapabilities_38()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id colorCapabilitiesArgument;
        colorCapabilitiesArgument = [NSNumber numberWithUnsignedShort:0U];
        [cluster
            writeAttributeColorCapabilitiesWithValue:colorCapabilitiesArgument
                                   completionHandler:^(NSError * _Nullable err) {
                                       NSLog(@"Write the default values to mandatory attribute: ColorCapabilities Error: %@", err);

                                       VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                                       NextTest();
                                   }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsBackMandatoryAttributeColorCapabilities_39()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeColorCapabilitiesWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads back mandatory attribute: ColorCapabilities Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("color capabilities", actualValue, 0U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeColorTempPhysicalMinMireds_40()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeColorTempPhysicalMinWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Validate constraints of attribute: ColorTempPhysicalMinMireds Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("colorTempPhysicalMin", "", "uint16"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("colorTempPhysicalMin", [value unsignedShortValue], 0U));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("colorTempPhysicalMin", [value unsignedShortValue], 65279U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryAttributeColorTempPhysicalMinMireds_41()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id colorTempPhysicalMinArgument;
        colorTempPhysicalMinArgument = [NSNumber numberWithUnsignedShort:0U];
        [cluster writeAttributeColorTempPhysicalMinWithValue:colorTempPhysicalMinArgument
                                           completionHandler:^(NSError * _Nullable err) {
                                               NSLog(@"Write the default values to mandatory  attribute: "
                                                     @"ColorTempPhysicalMinMireds Error: %@",
                                                   err);

                                               VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                                               NextTest();
                                           }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsBackMandatoryAttributeColorTempPhysicalMinMireds_42()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeColorTempPhysicalMinWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads back mandatory attribute: ColorTempPhysicalMinMireds Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("color temp physical min", actualValue, 0U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeColorTempPhysicalMaxMireds_43()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeColorTempPhysicalMaxWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Validate constraints of attribute: ColorTempPhysicalMaxMireds Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("colorTempPhysicalMax", "", "uint16"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("colorTempPhysicalMax", [value unsignedShortValue], 0U));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("colorTempPhysicalMax", [value unsignedShortValue], 65279U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryAttributeColorTempPhysicalMaxMireds_44()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id colorTempPhysicalMaxArgument;
        colorTempPhysicalMaxArgument = [NSNumber numberWithUnsignedShort:65279U];
        [cluster writeAttributeColorTempPhysicalMaxWithValue:colorTempPhysicalMaxArgument
                                           completionHandler:^(NSError * _Nullable err) {
                                               NSLog(@"Write the default values to mandatory attribute: ColorTempPhysicalMaxMireds "
                                                     @"Error: %@",
                                                   err);

                                               VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                                               NextTest();
                                           }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsBackMandatoryAttributeColorTempPhysicalMaxMireds_45()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeColorTempPhysicalMaxWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads back mandatory attribute: ColorTempPhysicalMaxMireds Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("color temp physical max", actualValue, 65279U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheOptionalAttributeCoupleColorTempToLevelMinMireds_46()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeCoupleColorTempToLevelMinMiredsWithCompletionHandler:^(
            NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read the optional attribute: CoupleColorTempToLevelMinMireds Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("coupleColorTempToLevelMinMireds", "", "uint16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteTheDefaultValuesToOptionalAttributeCoupleColorTempToLevelMinMireds_47()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id coupleColorTempToLevelMinMiredsArgument;
        coupleColorTempToLevelMinMiredsArgument = [NSNumber numberWithUnsignedShort:0U];
        [cluster
            writeAttributeCoupleColorTempToLevelMinMiredsWithValue:coupleColorTempToLevelMinMiredsArgument
                                                 completionHandler:^(NSError * _Nullable err) {
                                                     NSLog(@"Write the default values to optional attribute: "
                                                           @"CoupleColorTempToLevelMinMireds Error: %@",
                                                         err);

                                                     if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                                                         NextTest();
                                                         return;
                                                     }

                                                     VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                                                     NextTest();
                                                 }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsBackOptionalAttributeCoupleColorTempToLevelMinMireds_48()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeCoupleColorTempToLevelMinMiredsWithCompletionHandler:^(
            NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads back optional attribute: CoupleColorTempToLevelMinMireds Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("couple color temp to level min-mireds", actualValue, 0U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheOptionalAttributeStartUpColorTemperatureMireds_49()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeStartUpColorTemperatureMiredsWithCompletionHandler:^(
            NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read the optional attribute: StartUpColorTemperatureMireds Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("startUpColorTemperatureMireds", "", "uint16"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("startUpColorTemperatureMireds", [value unsignedShortValue], 0U));
            }
            if (value != nil) {
                VerifyOrReturn(
                    CheckConstraintMaxValue<uint16_t>("startUpColorTemperatureMireds", [value unsignedShortValue], 65279U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteTheDefaultValuesToOptionalAttributeStartUpColorTemperatureMireds_50()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id startUpColorTemperatureMiredsArgument;
        startUpColorTemperatureMiredsArgument = [NSNumber numberWithUnsignedShort:0U];
        [cluster writeAttributeStartUpColorTemperatureMiredsWithValue:startUpColorTemperatureMiredsArgument
                                                    completionHandler:^(NSError * _Nullable err) {
                                                        NSLog(@"Write the default values to optional attribute: "
                                                              @"StartUpColorTemperatureMireds Error: %@",
                                                            err);

                                                        if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                                                            NextTest();
                                                            return;
                                                        }

                                                        VerifyOrReturn(CheckValue("status", err, 0));

                                                        NextTest();
                                                    }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsBackOptionalAttributeStartUpColorTemperatureMireds_51()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster
            readAttributeStartUpColorTemperatureMiredsWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
                NSLog(@"Reads back optional attribute: StartUpColorTemperatureMireds Error: %@", err);

                if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                    NextTest();
                    return;
                }

                VerifyOrReturn(CheckValue("status", err, 0));

                {
                    id actualValue = value;
                    VerifyOrReturn(CheckValue("start up color temperature mireds", actualValue, 0U));
                }

                NextTest();
            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeRemainingTime_52()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeRemainingTimeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Validate constraints of attribute: RemainingTime Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("remainingTime", "", "uint16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteTheDefaultValuesToOptionalAttributeRemainingTime_53()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id remainingTimeArgument;
        remainingTimeArgument = [NSNumber numberWithUnsignedShort:0U];
        [cluster writeAttributeRemainingTimeWithValue:remainingTimeArgument
                                    completionHandler:^(NSError * _Nullable err) {
                                        NSLog(@"Write the default values to optional attribute: RemainingTime Error: %@", err);

                                        if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                                            NextTest();
                                            return;
                                        }

                                        VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                                        NextTest();
                                    }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsBackOptionalAttributeRemainingTime_54()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeRemainingTimeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads back optional attribute: RemainingTime Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("remaining time", actualValue, 0U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheOptionalAttributeDriftCompensation_55()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeDriftCompensationWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read the optional attribute: DriftCompensation Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("driftCompensation", "", "enum8"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<uint8_t>("driftCompensation", [value unsignedCharValue], 0));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("driftCompensation", [value unsignedCharValue], 4));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteTheDefaultValuesToOptionalAttributeDriftCompensation_56()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id driftCompensationArgument;
        driftCompensationArgument = [NSNumber numberWithUnsignedChar:0];
        [cluster
            writeAttributeDriftCompensationWithValue:driftCompensationArgument
                                   completionHandler:^(NSError * _Nullable err) {
                                       NSLog(@"Write the default values to optional attribute: DriftCompensation Error: %@", err);

                                       if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                                           NextTest();
                                           return;
                                       }

                                       VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                                       NextTest();
                                   }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsBackOptionalAttributeDriftCompensation_57()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeDriftCompensationWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads back optional attribute: DriftCompensation Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("drift compensation", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheOptionalAttributeCompensationText_58()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeCompensationTextWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read the optional attribute: CompensationText Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("compensationText", "", "string"));
            VerifyOrReturn(CheckConstraintMaxLength("compensationText", [value length], 254));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteTheDefaultValuesToOptionalAttributeCompensationText_59()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id compensationTextArgument;
        compensationTextArgument = @"";
        [cluster
            writeAttributeCompensationTextWithValue:compensationTextArgument
                                  completionHandler:^(NSError * _Nullable err) {
                                      NSLog(@"Write the default values to optional attribute: CompensationText Error: %@", err);

                                      if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                                          NextTest();
                                          return;
                                      }

                                      VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                                      NextTest();
                                  }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsBackOptionalAttributeCompensationText_60()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeCompensationTextWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads back optional attribute: CompensationText Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueAsString("compensation text", actualValue, @""));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheMandatoryAttributeNumberOfPrimaries_61()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNumberOfPrimariesWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read the mandatory attribute: NumberOfPrimaries Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("numberOfPrimaries", "", "uint8"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<uint8_t>("numberOfPrimaries", [value unsignedCharValue], 0));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("numberOfPrimaries", [value unsignedCharValue], 6));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteTheDefaultMandatoryAttributeNumberOfPrimaries_62()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id numberOfPrimariesArgument;
        numberOfPrimariesArgument = [NSNumber numberWithUnsignedChar:0];
        [cluster writeAttributeNumberOfPrimariesWithValue:numberOfPrimariesArgument
                                        completionHandler:^(NSError * _Nullable err) {
                                            NSLog(@"Write the default mandatory attribute: NumberOfPrimaries Error: %@", err);

                                            VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                                            NextTest();
                                        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadBackTheMandatoryAttributeNumberOfPrimaries_63()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNumberOfPrimariesWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read back the mandatory attribute: NumberOfPrimaries Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("number of primaries", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheMandatoryAttributePrimary1X_64()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributePrimary1XWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read the mandatory attribute: Primary1X Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("primary1X", "", "uint16"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("primary1X", [value unsignedShortValue], 0U));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("primary1X", [value unsignedShortValue], 65279U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteTheDefaultMandatoryAttributePrimary1X_65()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id primary1XArgument;
        primary1XArgument = [NSNumber numberWithUnsignedShort:0U];
        [cluster writeAttributePrimary1XWithValue:primary1XArgument
                                completionHandler:^(NSError * _Nullable err) {
                                    NSLog(@"Write the default mandatory attribute: Primary1X Error: %@", err);

                                    VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                                    NextTest();
                                }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadBackTheMandatoryAttributePrimary1X_66()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributePrimary1XWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read back the mandatory attribute: Primary1X Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("primary 1 x", actualValue, 0U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheMandatoryAttributePrimary1Y_67()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributePrimary1YWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read the mandatory attribute: Primary1Y Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("primary1Y", "", "uint16"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("primary1Y", [value unsignedShortValue], 0U));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("primary1Y", [value unsignedShortValue], 65279U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteTheDefaultMandatoryAttributePrimary1Y_68()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id primary1YArgument;
        primary1YArgument = [NSNumber numberWithUnsignedShort:0U];
        [cluster writeAttributePrimary1YWithValue:primary1YArgument
                                completionHandler:^(NSError * _Nullable err) {
                                    NSLog(@"Write the default mandatory attribute: Primary1Y Error: %@", err);

                                    VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                                    NextTest();
                                }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadBackTheMandatoryAttributePrimary1Y_69()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributePrimary1YWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read back the mandatory attribute: Primary1Y Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("primary 1 y", actualValue, 0U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheMandatoryAttributePrimary1Intensity_70()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributePrimary1IntensityWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read the mandatory attribute: Primary1Intensity Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("primary1Intensity", "", "uint8"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheMandatoryAttributePrimary2X_71()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributePrimary2XWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read the mandatory attribute: Primary2X Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("primary2X", "", "uint16"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("primary2X", [value unsignedShortValue], 0U));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("primary2X", [value unsignedShortValue], 65279U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteTheDefaultMandatoryAttributePrimary2X_72()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id primary2XArgument;
        primary2XArgument = [NSNumber numberWithUnsignedShort:0U];
        [cluster writeAttributePrimary2XWithValue:primary2XArgument
                                completionHandler:^(NSError * _Nullable err) {
                                    NSLog(@"Write the default mandatory attribute: Primary2X Error: %@", err);

                                    VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                                    NextTest();
                                }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadBackTheMandatoryAttributePrimary2X_73()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributePrimary2XWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read back the mandatory attribute: Primary2X Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("primary 2 x", actualValue, 0U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheMandatoryAttributePrimary2Y_74()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributePrimary2YWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read the mandatory attribute: Primary2Y Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("primary2Y", "", "uint16"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("primary2Y", [value unsignedShortValue], 0U));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("primary2Y", [value unsignedShortValue], 65279U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteTheDefaultMandatoryAttributePrimary2Y_75()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id primary2YArgument;
        primary2YArgument = [NSNumber numberWithUnsignedShort:0U];
        [cluster writeAttributePrimary2YWithValue:primary2YArgument
                                completionHandler:^(NSError * _Nullable err) {
                                    NSLog(@"Write the default mandatory attribute: Primary2Y Error: %@", err);

                                    VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                                    NextTest();
                                }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadBackTheMandatoryAttributePrimary2Y_76()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributePrimary2YWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read back the mandatory attribute: Primary2Y Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("primary 2 y", actualValue, 0U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestValidateConstraintsOfAttributePrimary2Intensity_77()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributePrimary2IntensityWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Validate constraints of attribute: Primary2Intensity Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("primary2Intensity", "", "uint8"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheMandatoryAttributePrimary3X_78()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributePrimary3XWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read the mandatory attribute: Primary3X Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("primary3X", "", "uint16"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("primary3X", [value unsignedShortValue], 0U));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("primary3X", [value unsignedShortValue], 65279U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteTheDefaultMandatoryAttributePrimary3X_79()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id primary3XArgument;
        primary3XArgument = [NSNumber numberWithUnsignedShort:0U];
        [cluster writeAttributePrimary3XWithValue:primary3XArgument
                                completionHandler:^(NSError * _Nullable err) {
                                    NSLog(@"Write the default mandatory attribute: Primary3X Error: %@", err);

                                    VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                                    NextTest();
                                }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadBackTheMandatoryAttributePrimary3X_80()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributePrimary3XWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read back the mandatory attribute: Primary3X Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("primary 3 x", actualValue, 0U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheMandatoryAttributePrimary3Y_81()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributePrimary3YWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read the mandatory attribute: Primary3Y Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("primary3Y", "", "uint16"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("primary3Y", [value unsignedShortValue], 0U));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("primary3Y", [value unsignedShortValue], 65279U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteTheDefaultMandatoryAttributePrimary3Y_82()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id primary3YArgument;
        primary3YArgument = [NSNumber numberWithUnsignedShort:0U];
        [cluster writeAttributePrimary3YWithValue:primary3YArgument
                                completionHandler:^(NSError * _Nullable err) {
                                    NSLog(@"Write the default mandatory attribute: Primary3Y Error: %@", err);

                                    VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                                    NextTest();
                                }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadBackTheMandatoryAttributePrimary3Y_83()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributePrimary3YWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read back the mandatory attribute: Primary3Y Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("primary 3 y", actualValue, 0U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheMandatoryAttributePrimary3Intensity_84()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributePrimary3IntensityWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read the mandatory attribute: Primary3Intensity Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("primary3Intensity", "", "uint8"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheMandatoryAttributePrimary4X_85()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributePrimary4XWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read the mandatory attribute: Primary4X Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("primary4X", "", "uint16"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("primary4X", [value unsignedShortValue], 0U));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("primary4X", [value unsignedShortValue], 65279U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteTheDefaultMandatoryAttributePrimary4X_86()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id primary4XArgument;
        primary4XArgument = [NSNumber numberWithUnsignedShort:0U];
        [cluster writeAttributePrimary4XWithValue:primary4XArgument
                                completionHandler:^(NSError * _Nullable err) {
                                    NSLog(@"Write the default mandatory attribute: Primary4X Error: %@", err);

                                    VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                                    NextTest();
                                }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadBackTheMandatoryAttributePrimary4X_87()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributePrimary4XWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read back the mandatory attribute: Primary4X Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("primary 4 x", actualValue, 0U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheMandatoryAttributePrimary4Y_88()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributePrimary4YWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read the mandatory attribute: Primary4Y Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("primary4Y", "", "uint16"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("primary4Y", [value unsignedShortValue], 0U));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("primary4Y", [value unsignedShortValue], 65279U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteTheDefaultMandatoryAttributePrimary4Y_89()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id primary4YArgument;
        primary4YArgument = [NSNumber numberWithUnsignedShort:0U];
        [cluster writeAttributePrimary4YWithValue:primary4YArgument
                                completionHandler:^(NSError * _Nullable err) {
                                    NSLog(@"Write the default mandatory attribute: Primary4Y Error: %@", err);

                                    VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                                    NextTest();
                                }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadBackTheMandatoryAttributePrimary4Y_90()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributePrimary4YWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read back the mandatory attribute: Primary4Y Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("primary 4 y", actualValue, 0U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheMandatoryAttributePrimary4Intensity_91()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributePrimary4IntensityWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read the mandatory attribute: Primary4Intensity Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("primary4Intensity", "", "uint8"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheMandatoryAttributePrimary5X_92()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributePrimary5XWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read the mandatory attribute: Primary5X Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("primary5X", "", "uint16"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("primary5X", [value unsignedShortValue], 0U));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("primary5X", [value unsignedShortValue], 65279U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteTheDefaultMandatoryAttributePrimary5X_93()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id primary5XArgument;
        primary5XArgument = [NSNumber numberWithUnsignedShort:0U];
        [cluster writeAttributePrimary5XWithValue:primary5XArgument
                                completionHandler:^(NSError * _Nullable err) {
                                    NSLog(@"Write the default mandatory attribute: Primary5X Error: %@", err);

                                    VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                                    NextTest();
                                }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadBackTheMandatoryAttributePrimary5X_94()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributePrimary5XWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read back the mandatory attribute: Primary5X Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("primary 5 x", actualValue, 0U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheMandatoryAttributePrimary5Y_95()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributePrimary5YWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read the mandatory attribute: Primary5Y Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("primary5Y", "", "uint16"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("primary5Y", [value unsignedShortValue], 0U));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("primary5Y", [value unsignedShortValue], 65279U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteTheDefaultMandatoryAttributePrimary5Y_96()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id primary5YArgument;
        primary5YArgument = [NSNumber numberWithUnsignedShort:0U];
        [cluster writeAttributePrimary5YWithValue:primary5YArgument
                                completionHandler:^(NSError * _Nullable err) {
                                    NSLog(@"Write the default mandatory attribute: Primary5Y Error: %@", err);

                                    VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                                    NextTest();
                                }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadBackTheMandatoryAttributePrimary5Y_97()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributePrimary5YWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read back the mandatory attribute: Primary5Y Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("primary 5 y", actualValue, 0U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheMandatoryAttributePrimary5Intensity_98()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributePrimary5IntensityWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read the mandatory attribute: Primary5Intensity Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("primary5Intensity", "", "uint8"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheMandatoryAttributePrimary6X_99()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributePrimary6XWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read the mandatory attribute: Primary6X Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("primary6X", "", "uint16"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("primary6X", [value unsignedShortValue], 0U));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("primary6X", [value unsignedShortValue], 65279U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteTheDefaultMandatoryAttributePrimary6X_100()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id primary6XArgument;
        primary6XArgument = [NSNumber numberWithUnsignedShort:0U];
        [cluster writeAttributePrimary6XWithValue:primary6XArgument
                                completionHandler:^(NSError * _Nullable err) {
                                    NSLog(@"Write the default mandatory attribute: Primary6X Error: %@", err);

                                    VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                                    NextTest();
                                }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadBackTheMandatoryAttributePrimary6X_101()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributePrimary6XWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read back the mandatory attribute: Primary6X Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("primary 6 x", actualValue, 0U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheMandatoryAttributePrimary6Y_102()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributePrimary6YWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read the mandatory attribute: Primary6Y Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("primary6Y", "", "uint16"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("primary6Y", [value unsignedShortValue], 0U));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("primary6Y", [value unsignedShortValue], 65279U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteTheDefaultMandatoryAttributePrimary6Y_103()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id primary6YArgument;
        primary6YArgument = [NSNumber numberWithUnsignedShort:0U];
        [cluster writeAttributePrimary6YWithValue:primary6YArgument
                                completionHandler:^(NSError * _Nullable err) {
                                    NSLog(@"Write the default mandatory attribute: Primary6Y Error: %@", err);

                                    VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                                    NextTest();
                                }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadBackTheMandatoryAttributePrimary6Y_104()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributePrimary6YWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read back the mandatory attribute: Primary6Y Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("primary 6 y", actualValue, 0U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheMandatoryAttributePrimary6Intensity_105()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributePrimary6IntensityWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read the mandatory attribute: Primary6Intensity Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("primary6Intensity", "", "uint8"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheOptionalAttributeWhitePointX_106()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeWhitePointXWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read the optional attribute: WhitePointX Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("whitePointX", "", "uint16"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("whitePointX", [value unsignedShortValue], 0U));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("whitePointX", [value unsignedShortValue], 65279U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteTheDefaultOptionalAttributeWhitePointX_107()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id whitePointXArgument;
        whitePointXArgument = [NSNumber numberWithUnsignedShort:0U];
        [cluster writeAttributeWhitePointXWithValue:whitePointXArgument
                                  completionHandler:^(NSError * _Nullable err) {
                                      NSLog(@"Write the default optional attribute: WhitePointX Error: %@", err);

                                      if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                                          NextTest();
                                          return;
                                      }

                                      VerifyOrReturn(CheckValue("status", err, 0));

                                      NextTest();
                                  }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadBackTheOptionalAttributeWhitePointX_108()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeWhitePointXWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read back the optional attribute: WhitePointX Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("white point x", actualValue, 0U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheOptionalAttributeWhitePointY_109()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeWhitePointYWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read the optional attribute: WhitePointY Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("whitePointY", "", "uint16"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("whitePointY", [value unsignedShortValue], 0U));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("whitePointY", [value unsignedShortValue], 65279U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteTheDefaultOptionalAttributeWhitePointY_110()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id whitePointYArgument;
        whitePointYArgument = [NSNumber numberWithUnsignedShort:0U];
        [cluster writeAttributeWhitePointYWithValue:whitePointYArgument
                                  completionHandler:^(NSError * _Nullable err) {
                                      NSLog(@"Write the default optional attribute: WhitePointY Error: %@", err);

                                      if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                                          NextTest();
                                          return;
                                      }

                                      VerifyOrReturn(CheckValue("status", err, 0));

                                      NextTest();
                                  }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadBackTheOptionalAttributeWhitePointY_111()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeWhitePointYWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read back the optional attribute: WhitePointY Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("white point y", actualValue, 0U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheOptionalAttributeColorPointRX_112()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeColorPointRXWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read the optional attribute: ColorPointRX Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("colorPointRX", "", "uint16"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("colorPointRX", [value unsignedShortValue], 0U));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("colorPointRX", [value unsignedShortValue], 65279U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteTheDefaultOptionalAttributeColorPointRX_113()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id colorPointRXArgument;
        colorPointRXArgument = [NSNumber numberWithUnsignedShort:0U];
        [cluster writeAttributeColorPointRXWithValue:colorPointRXArgument
                                   completionHandler:^(NSError * _Nullable err) {
                                       NSLog(@"Write the default optional attribute: ColorPointRX Error: %@", err);

                                       if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                                           NextTest();
                                           return;
                                       }

                                       VerifyOrReturn(CheckValue("status", err, 0));

                                       NextTest();
                                   }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadBackTheOptionalAttributeColorPointRX_114()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeColorPointRXWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read back the optional attribute: ColorPointRX Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("color point r x", actualValue, 0U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheOptionalAttributeColorPointRY_115()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeColorPointRYWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read the optional attribute: ColorPointRY Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("colorPointRY", "", "uint16"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("colorPointRY", [value unsignedShortValue], 0U));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("colorPointRY", [value unsignedShortValue], 65279U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteTheDefaultOptionalAttributeColorPointRY_116()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id colorPointRYArgument;
        colorPointRYArgument = [NSNumber numberWithUnsignedShort:0U];
        [cluster writeAttributeColorPointRYWithValue:colorPointRYArgument
                                   completionHandler:^(NSError * _Nullable err) {
                                       NSLog(@"Write the default optional attribute: ColorPointRY Error: %@", err);

                                       if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                                           NextTest();
                                           return;
                                       }

                                       VerifyOrReturn(CheckValue("status", err, 0));

                                       NextTest();
                                   }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadBackTheOptionalAttributeColorPointRY_117()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeColorPointRYWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read back the optional attribute: ColorPointRY Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("color point r y", actualValue, 0U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheOptionalAttributeColorPointRIntensity_118()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeColorPointRIntensityWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read the optional attribute: ColorPointRIntensity Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("colorPointRIntensity", "", "uint8"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteTheDefaultOptionalAttributeColorPointRIntensity_119()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id colorPointRIntensityArgument;
        colorPointRIntensityArgument = [NSNumber numberWithUnsignedChar:0];
        [cluster writeAttributeColorPointRIntensityWithValue:colorPointRIntensityArgument
                                           completionHandler:^(NSError * _Nullable err) {
                                               NSLog(@"Write the default optional attribute: ColorPointRIntensity Error: %@", err);

                                               if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                                                   NextTest();
                                                   return;
                                               }

                                               VerifyOrReturn(CheckValue("status", err, 0));

                                               NextTest();
                                           }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadBackTheOptionalAttributeColorPointRIntensity_120()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeColorPointRIntensityWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read back the optional attribute: ColorPointRIntensity Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("color point r intensity", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheOptionalAttributeColorPointGX_121()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeColorPointGXWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read the optional attribute: ColorPointGX Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("colorPointGX", "", "uint16"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("colorPointGX", [value unsignedShortValue], 0U));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("colorPointGX", [value unsignedShortValue], 65279U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteTheDefaultOptionalAttributeColorPointGX_122()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id colorPointGXArgument;
        colorPointGXArgument = [NSNumber numberWithUnsignedShort:0U];
        [cluster writeAttributeColorPointGXWithValue:colorPointGXArgument
                                   completionHandler:^(NSError * _Nullable err) {
                                       NSLog(@"Write the default optional attribute: ColorPointGX Error: %@", err);

                                       if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                                           NextTest();
                                           return;
                                       }

                                       VerifyOrReturn(CheckValue("status", err, 0));

                                       NextTest();
                                   }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadBackTheOptionalAttributeColorPointGX_123()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeColorPointGXWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read back the optional attribute: ColorPointGX Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("color point g x", actualValue, 0U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheOptionalAttributeColorPointGY_124()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeColorPointGYWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read the optional attribute: ColorPointGY Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("colorPointGY", "", "uint16"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("colorPointGY", [value unsignedShortValue], 0U));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("colorPointGY", [value unsignedShortValue], 65279U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteTheDefaultOptionalAttributeColorPointGY_125()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id colorPointGYArgument;
        colorPointGYArgument = [NSNumber numberWithUnsignedShort:0U];
        [cluster writeAttributeColorPointGYWithValue:colorPointGYArgument
                                   completionHandler:^(NSError * _Nullable err) {
                                       NSLog(@"Write the default optional attribute: ColorPointGY Error: %@", err);

                                       if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                                           NextTest();
                                           return;
                                       }

                                       VerifyOrReturn(CheckValue("status", err, 0));

                                       NextTest();
                                   }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadBackTheOptionalAttributeColorPointGY_126()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeColorPointGYWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read back the optional attribute: ColorPointGY Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("color point g y", actualValue, 0U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheOptionalAttributeColorPointGIntensity_127()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeColorPointGIntensityWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read the optional attribute: ColorPointGIntensity Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("colorPointGIntensity", "", "uint8"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteTheDefaultOptionalAttributeColorPointGIntensity_128()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id colorPointGIntensityArgument;
        colorPointGIntensityArgument = [NSNumber numberWithUnsignedChar:0];
        [cluster writeAttributeColorPointGIntensityWithValue:colorPointGIntensityArgument
                                           completionHandler:^(NSError * _Nullable err) {
                                               NSLog(@"Write the default optional attribute: ColorPointGIntensity Error: %@", err);

                                               if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                                                   NextTest();
                                                   return;
                                               }

                                               VerifyOrReturn(CheckValue("status", err, 0));

                                               NextTest();
                                           }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadBackTheOptionalAttributeColorPointGIntensity_129()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeColorPointGIntensityWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read back the optional attribute: ColorPointGIntensity Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("color point g intensity", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheOptionalAttributeColorPointBX_130()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeColorPointBXWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read the optional attribute: ColorPointBX Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("colorPointBX", "", "uint16"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("colorPointBX", [value unsignedShortValue], 0U));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("colorPointBX", [value unsignedShortValue], 65279U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteTheDefaultOptionalAttributeColorPointBX_131()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id colorPointBXArgument;
        colorPointBXArgument = [NSNumber numberWithUnsignedShort:0U];
        [cluster writeAttributeColorPointBXWithValue:colorPointBXArgument
                                   completionHandler:^(NSError * _Nullable err) {
                                       NSLog(@"Write the default optional attribute: ColorPointBX Error: %@", err);

                                       if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                                           NextTest();
                                           return;
                                       }

                                       VerifyOrReturn(CheckValue("status", err, 0));

                                       NextTest();
                                   }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadBackTheOptionalAttributeColorPointBX_132()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeColorPointBXWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read back the optional attribute: ColorPointBX Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("color point b x", actualValue, 0U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheOptionalAttributeColorPointBY_133()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeColorPointBYWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read the optional attribute: ColorPointBY Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("colorPointBY", "", "uint16"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("colorPointBY", [value unsignedShortValue], 0U));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("colorPointBY", [value unsignedShortValue], 65279U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteTheDefaultOptionalAttributeColorPointBY_134()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id colorPointBYArgument;
        colorPointBYArgument = [NSNumber numberWithUnsignedShort:0U];
        [cluster writeAttributeColorPointBYWithValue:colorPointBYArgument
                                   completionHandler:^(NSError * _Nullable err) {
                                       NSLog(@"Write the default optional attribute: ColorPointBY Error: %@", err);

                                       if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                                           NextTest();
                                           return;
                                       }

                                       VerifyOrReturn(CheckValue("status", err, 0));

                                       NextTest();
                                   }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadBackTheOptionalAttributeColorPointBY_135()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeColorPointBYWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read back the optional attribute: ColorPointBY Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("color point b y", actualValue, 0U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheOptionalAttributeColorPointBIntensity_136()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeColorPointBIntensityWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read the optional attribute: ColorPointBIntensity Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("colorPointBIntensity", "", "uint8"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteTheDefaultOptionalAttributeColorPointBIntensity_137()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id colorPointBIntensityArgument;
        colorPointBIntensityArgument = [NSNumber numberWithUnsignedChar:0];
        [cluster writeAttributeColorPointBIntensityWithValue:colorPointBIntensityArgument
                                           completionHandler:^(NSError * _Nullable err) {
                                               NSLog(@"Write the default optional attribute: ColorPointBIntensity Error: %@", err);

                                               if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                                                   NextTest();
                                                   return;
                                               }

                                               VerifyOrReturn(CheckValue("status", err, 0));

                                               NextTest();
                                           }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadBackTheOptionalAttributeColorPointBIntensity_138()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeColorPointBIntensityWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read back the optional attribute: ColorPointBIntensity Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("color point b intensity", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
};

class Test_TC_CC_3_1 : public TestCommandBridge {
public:
    Test_TC_CC_3_1()
        : TestCommandBridge("Test_TC_CC_3_1")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_CC_3_1() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_3_1\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_3_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Reads CurrentHue attribute from DUT.\n");
            err = TestReadsCurrentHueAttributeFromDut_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Move to hue shortest distance command\n");
            err = TestMoveToHueShortestDistanceCommand_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Move to hue longest distance command\n");
            err = TestMoveToHueLongestDistanceCommand_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Move to hue up command\n");
            err = TestMoveToHueUpCommand_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Move to hue down command\n");
            err = TestMoveToHueDownCommand_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_9();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 10;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestTurnOnLightForColorControlTests_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster onWithCompletionHandler:^(NSError * _Nullable err) {
            NSLog(@"Turn on light for color control tests Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOnOffWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Check on/off attribute value is true after on command Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("OnOff", actualValue, 1));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsCurrentHueAttributeFromDut_3()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeCurrentHueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads CurrentHue attribute from DUT. Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("currentHue", "", "uint8"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<uint8_t>("currentHue", [value unsignedCharValue], 0));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("currentHue", [value unsignedCharValue], 254));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestMoveToHueShortestDistanceCommand_4()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPColorControlClusterMoveToHueParams alloc] init];
        params.hue = [NSNumber numberWithUnsignedChar:150];
        params.direction = [NSNumber numberWithUnsignedChar:0];
        params.transitionTime = [NSNumber numberWithUnsignedShort:300U];
        params.optionsMask = [NSNumber numberWithUnsignedChar:0];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:0];
        [cluster moveToHueWithParams:params
                   completionHandler:^(NSError * _Nullable err) {
                       NSLog(@"Move to hue shortest distance command Error: %@", err);

                       VerifyOrReturn(CheckValue("status", err, 0));

                       NextTest();
                   }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestMoveToHueLongestDistanceCommand_5()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPColorControlClusterMoveToHueParams alloc] init];
        params.hue = [NSNumber numberWithUnsignedChar:200];
        params.direction = [NSNumber numberWithUnsignedChar:1];
        params.transitionTime = [NSNumber numberWithUnsignedShort:300U];
        params.optionsMask = [NSNumber numberWithUnsignedChar:0];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:0];
        [cluster moveToHueWithParams:params
                   completionHandler:^(NSError * _Nullable err) {
                       NSLog(@"Move to hue longest distance command Error: %@", err);

                       VerifyOrReturn(CheckValue("status", err, 0));

                       NextTest();
                   }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestMoveToHueUpCommand_6()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPColorControlClusterMoveToHueParams alloc] init];
        params.hue = [NSNumber numberWithUnsignedChar:250];
        params.direction = [NSNumber numberWithUnsignedChar:2];
        params.transitionTime = [NSNumber numberWithUnsignedShort:300U];
        params.optionsMask = [NSNumber numberWithUnsignedChar:0];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:0];
        [cluster moveToHueWithParams:params
                   completionHandler:^(NSError * _Nullable err) {
                       NSLog(@"Move to hue up command Error: %@", err);

                       VerifyOrReturn(CheckValue("status", err, 0));

                       NextTest();
                   }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestMoveToHueDownCommand_7()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPColorControlClusterMoveToHueParams alloc] init];
        params.hue = [NSNumber numberWithUnsignedChar:225];
        params.direction = [NSNumber numberWithUnsignedChar:3];
        params.transitionTime = [NSNumber numberWithUnsignedShort:300U];
        params.optionsMask = [NSNumber numberWithUnsignedChar:0];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:0];
        [cluster moveToHueWithParams:params
                   completionHandler:^(NSError * _Nullable err) {
                       NSLog(@"Move to hue down command Error: %@", err);

                       VerifyOrReturn(CheckValue("status", err, 0));

                       NextTest();
                   }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_8()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster offWithCompletionHandler:^(NSError * _Nullable err) {
            NSLog(@"Turn off light that we turned on Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_9()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOnOffWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Check on/off attribute value is false after off command Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("OnOff", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
};

class Test_TC_CC_3_2 : public TestCommandBridge {
public:
    Test_TC_CC_3_2()
        : TestCommandBridge("Test_TC_CC_3_2")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_CC_3_2() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_3_2\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_3_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Move hue up command\n");
            err = TestMoveHueUpCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Move hue stop command\n");
            err = TestMoveHueStopCommand_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Move hue down command\n");
            err = TestMoveHueDownCommand_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Move hue stop command\n");
            err = TestMoveHueStopCommand_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_8();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 9;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestTurnOnLightForColorControlTests_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster onWithCompletionHandler:^(NSError * _Nullable err) {
            NSLog(@"Turn on light for color control tests Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOnOffWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Check on/off attribute value is true after on command Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("OnOff", actualValue, 1));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestMoveHueUpCommand_3()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPColorControlClusterMoveHueParams alloc] init];
        params.moveMode = [NSNumber numberWithUnsignedChar:1];
        params.rate = [NSNumber numberWithUnsignedChar:50];
        params.optionsMask = [NSNumber numberWithUnsignedChar:0];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:0];
        [cluster moveHueWithParams:params
                 completionHandler:^(NSError * _Nullable err) {
                     NSLog(@"Move hue up command Error: %@", err);

                     VerifyOrReturn(CheckValue("status", err, 0));

                     NextTest();
                 }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestMoveHueStopCommand_4()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPColorControlClusterMoveHueParams alloc] init];
        params.moveMode = [NSNumber numberWithUnsignedChar:0];
        params.rate = [NSNumber numberWithUnsignedChar:50];
        params.optionsMask = [NSNumber numberWithUnsignedChar:0];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:0];
        [cluster moveHueWithParams:params
                 completionHandler:^(NSError * _Nullable err) {
                     NSLog(@"Move hue stop command Error: %@", err);

                     VerifyOrReturn(CheckValue("status", err, 0));

                     NextTest();
                 }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestMoveHueDownCommand_5()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPColorControlClusterMoveHueParams alloc] init];
        params.moveMode = [NSNumber numberWithUnsignedChar:3];
        params.rate = [NSNumber numberWithUnsignedChar:50];
        params.optionsMask = [NSNumber numberWithUnsignedChar:0];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:0];
        [cluster moveHueWithParams:params
                 completionHandler:^(NSError * _Nullable err) {
                     NSLog(@"Move hue down command Error: %@", err);

                     VerifyOrReturn(CheckValue("status", err, 0));

                     NextTest();
                 }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestMoveHueStopCommand_6()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPColorControlClusterMoveHueParams alloc] init];
        params.moveMode = [NSNumber numberWithUnsignedChar:0];
        params.rate = [NSNumber numberWithUnsignedChar:50];
        params.optionsMask = [NSNumber numberWithUnsignedChar:0];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:0];
        [cluster moveHueWithParams:params
                 completionHandler:^(NSError * _Nullable err) {
                     NSLog(@"Move hue stop command Error: %@", err);

                     VerifyOrReturn(CheckValue("status", err, 0));

                     NextTest();
                 }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_7()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster offWithCompletionHandler:^(NSError * _Nullable err) {
            NSLog(@"Turn off light that we turned on Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_8()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOnOffWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Check on/off attribute value is false after off command Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("OnOff", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
};

class Test_TC_CC_3_3 : public TestCommandBridge {
public:
    Test_TC_CC_3_3()
        : TestCommandBridge("Test_TC_CC_3_3")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_CC_3_3() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_3_3\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_3_3\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Step hue up command\n");
            err = TestStepHueUpCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Step hue down command\n");
            err = TestStepHueDownCommand_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_6();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 7;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestTurnOnLightForColorControlTests_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster onWithCompletionHandler:^(NSError * _Nullable err) {
            NSLog(@"Turn on light for color control tests Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOnOffWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Check on/off attribute value is true after on command Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("OnOff", actualValue, 1));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestStepHueUpCommand_3()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPColorControlClusterStepHueParams alloc] init];
        params.stepMode = [NSNumber numberWithUnsignedChar:1];
        params.stepSize = [NSNumber numberWithUnsignedChar:5];
        params.transitionTime = [NSNumber numberWithUnsignedChar:25];
        params.optionsMask = [NSNumber numberWithUnsignedChar:0];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:0];
        [cluster stepHueWithParams:params
                 completionHandler:^(NSError * _Nullable err) {
                     NSLog(@"Step hue up command Error: %@", err);

                     VerifyOrReturn(CheckValue("status", err, 0));

                     NextTest();
                 }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestStepHueDownCommand_4()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPColorControlClusterStepHueParams alloc] init];
        params.stepMode = [NSNumber numberWithUnsignedChar:3];
        params.stepSize = [NSNumber numberWithUnsignedChar:5];
        params.transitionTime = [NSNumber numberWithUnsignedChar:25];
        params.optionsMask = [NSNumber numberWithUnsignedChar:0];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:0];
        [cluster stepHueWithParams:params
                 completionHandler:^(NSError * _Nullable err) {
                     NSLog(@"Step hue down command Error: %@", err);

                     VerifyOrReturn(CheckValue("status", err, 0));

                     NextTest();
                 }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_5()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster offWithCompletionHandler:^(NSError * _Nullable err) {
            NSLog(@"Turn off light that we turned on Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_6()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOnOffWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Check on/off attribute value is false after off command Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("OnOff", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
};

class Test_TC_CC_4_1 : public TestCommandBridge {
public:
    Test_TC_CC_4_1()
        : TestCommandBridge("Test_TC_CC_4_1")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_CC_4_1() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_4_1\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_4_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Move to saturation command\n");
            err = TestMoveToSaturationCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_5();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 6;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestTurnOnLightForColorControlTests_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster onWithCompletionHandler:^(NSError * _Nullable err) {
            NSLog(@"Turn on light for color control tests Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOnOffWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Check on/off attribute value is true after on command Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("OnOff", actualValue, 1));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestMoveToSaturationCommand_3()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPColorControlClusterMoveToSaturationParams alloc] init];
        params.saturation = [NSNumber numberWithUnsignedChar:90];
        params.transitionTime = [NSNumber numberWithUnsignedShort:10U];
        params.optionsMask = [NSNumber numberWithUnsignedChar:0];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:0];
        [cluster moveToSaturationWithParams:params
                          completionHandler:^(NSError * _Nullable err) {
                              NSLog(@"Move to saturation command Error: %@", err);

                              VerifyOrReturn(CheckValue("status", err, 0));

                              NextTest();
                          }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_4()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster offWithCompletionHandler:^(NSError * _Nullable err) {
            NSLog(@"Turn off light that we turned on Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_5()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOnOffWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Check on/off attribute value is false after off command Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("OnOff", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
};

class Test_TC_CC_4_2 : public TestCommandBridge {
public:
    Test_TC_CC_4_2()
        : TestCommandBridge("Test_TC_CC_4_2")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_CC_4_2() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_4_2\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_4_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Move saturation up command\n");
            err = TestMoveSaturationUpCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Move saturation down command\n");
            err = TestMoveSaturationDownCommand_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Move saturation up command\n");
            err = TestMoveSaturationUpCommand_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Move saturation stop command\n");
            err = TestMoveSaturationStopCommand_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Move saturation down command\n");
            err = TestMoveSaturationDownCommand_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Move saturation stop command\n");
            err = TestMoveSaturationStopCommand_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_10();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 11;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestTurnOnLightForColorControlTests_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster onWithCompletionHandler:^(NSError * _Nullable err) {
            NSLog(@"Turn on light for color control tests Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOnOffWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Check on/off attribute value is true after on command Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("OnOff", actualValue, 1));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestMoveSaturationUpCommand_3()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPColorControlClusterMoveSaturationParams alloc] init];
        params.moveMode = [NSNumber numberWithUnsignedChar:1];
        params.rate = [NSNumber numberWithUnsignedChar:5];
        params.optionsMask = [NSNumber numberWithUnsignedChar:0];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:0];
        [cluster moveSaturationWithParams:params
                        completionHandler:^(NSError * _Nullable err) {
                            NSLog(@"Move saturation up command Error: %@", err);

                            VerifyOrReturn(CheckValue("status", err, 0));

                            NextTest();
                        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestMoveSaturationDownCommand_4()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPColorControlClusterMoveSaturationParams alloc] init];
        params.moveMode = [NSNumber numberWithUnsignedChar:3];
        params.rate = [NSNumber numberWithUnsignedChar:5];
        params.optionsMask = [NSNumber numberWithUnsignedChar:0];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:0];
        [cluster moveSaturationWithParams:params
                        completionHandler:^(NSError * _Nullable err) {
                            NSLog(@"Move saturation down command Error: %@", err);

                            VerifyOrReturn(CheckValue("status", err, 0));

                            NextTest();
                        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestMoveSaturationUpCommand_5()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPColorControlClusterMoveSaturationParams alloc] init];
        params.moveMode = [NSNumber numberWithUnsignedChar:1];
        params.rate = [NSNumber numberWithUnsignedChar:5];
        params.optionsMask = [NSNumber numberWithUnsignedChar:0];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:0];
        [cluster moveSaturationWithParams:params
                        completionHandler:^(NSError * _Nullable err) {
                            NSLog(@"Move saturation up command Error: %@", err);

                            VerifyOrReturn(CheckValue("status", err, 0));

                            NextTest();
                        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestMoveSaturationStopCommand_6()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPColorControlClusterMoveSaturationParams alloc] init];
        params.moveMode = [NSNumber numberWithUnsignedChar:0];
        params.rate = [NSNumber numberWithUnsignedChar:5];
        params.optionsMask = [NSNumber numberWithUnsignedChar:0];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:0];
        [cluster moveSaturationWithParams:params
                        completionHandler:^(NSError * _Nullable err) {
                            NSLog(@"Move saturation stop command Error: %@", err);

                            VerifyOrReturn(CheckValue("status", err, 0));

                            NextTest();
                        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestMoveSaturationDownCommand_7()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPColorControlClusterMoveSaturationParams alloc] init];
        params.moveMode = [NSNumber numberWithUnsignedChar:3];
        params.rate = [NSNumber numberWithUnsignedChar:5];
        params.optionsMask = [NSNumber numberWithUnsignedChar:0];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:0];
        [cluster moveSaturationWithParams:params
                        completionHandler:^(NSError * _Nullable err) {
                            NSLog(@"Move saturation down command Error: %@", err);

                            VerifyOrReturn(CheckValue("status", err, 0));

                            NextTest();
                        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestMoveSaturationStopCommand_8()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPColorControlClusterMoveSaturationParams alloc] init];
        params.moveMode = [NSNumber numberWithUnsignedChar:0];
        params.rate = [NSNumber numberWithUnsignedChar:5];
        params.optionsMask = [NSNumber numberWithUnsignedChar:0];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:0];
        [cluster moveSaturationWithParams:params
                        completionHandler:^(NSError * _Nullable err) {
                            NSLog(@"Move saturation stop command Error: %@", err);

                            VerifyOrReturn(CheckValue("status", err, 0));

                            NextTest();
                        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_9()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster offWithCompletionHandler:^(NSError * _Nullable err) {
            NSLog(@"Turn off light that we turned on Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_10()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOnOffWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Check on/off attribute value is false after off command Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("OnOff", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
};

class Test_TC_CC_4_3 : public TestCommandBridge {
public:
    Test_TC_CC_4_3()
        : TestCommandBridge("Test_TC_CC_4_3")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_CC_4_3() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_4_3\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_4_3\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Step saturation up command\n");
            err = TestStepSaturationUpCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Step saturation down command\n");
            err = TestStepSaturationDownCommand_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_6();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 7;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestTurnOnLightForColorControlTests_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster onWithCompletionHandler:^(NSError * _Nullable err) {
            NSLog(@"Turn on light for color control tests Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOnOffWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Check on/off attribute value is true after on command Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("OnOff", actualValue, 1));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestStepSaturationUpCommand_3()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPColorControlClusterStepSaturationParams alloc] init];
        params.stepMode = [NSNumber numberWithUnsignedChar:1];
        params.stepSize = [NSNumber numberWithUnsignedChar:15];
        params.transitionTime = [NSNumber numberWithUnsignedChar:10];
        params.optionsMask = [NSNumber numberWithUnsignedChar:0];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:0];
        [cluster stepSaturationWithParams:params
                        completionHandler:^(NSError * _Nullable err) {
                            NSLog(@"Step saturation up command Error: %@", err);

                            VerifyOrReturn(CheckValue("status", err, 0));

                            NextTest();
                        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestStepSaturationDownCommand_4()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPColorControlClusterStepSaturationParams alloc] init];
        params.stepMode = [NSNumber numberWithUnsignedChar:3];
        params.stepSize = [NSNumber numberWithUnsignedChar:20];
        params.transitionTime = [NSNumber numberWithUnsignedChar:10];
        params.optionsMask = [NSNumber numberWithUnsignedChar:0];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:0];
        [cluster stepSaturationWithParams:params
                        completionHandler:^(NSError * _Nullable err) {
                            NSLog(@"Step saturation down command Error: %@", err);

                            VerifyOrReturn(CheckValue("status", err, 0));

                            NextTest();
                        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_5()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster offWithCompletionHandler:^(NSError * _Nullable err) {
            NSLog(@"Turn off light that we turned on Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_6()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOnOffWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Check on/off attribute value is false after off command Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("OnOff", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
};

class Test_TC_CC_4_4 : public TestCommandBridge {
public:
    Test_TC_CC_4_4()
        : TestCommandBridge("Test_TC_CC_4_4")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_CC_4_4() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_4_4\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_4_4\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Move To current hue and saturation command\n");
            err = TestMoveToCurrentHueAndSaturationCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_5();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 6;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestTurnOnLightForColorControlTests_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster onWithCompletionHandler:^(NSError * _Nullable err) {
            NSLog(@"Turn on light for color control tests Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOnOffWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Check on/off attribute value is true after on command Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("OnOff", actualValue, 1));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestMoveToCurrentHueAndSaturationCommand_3()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPColorControlClusterMoveToHueAndSaturationParams alloc] init];
        params.hue = [NSNumber numberWithUnsignedChar:40];
        params.saturation = [NSNumber numberWithUnsignedChar:160];
        params.transitionTime = [NSNumber numberWithUnsignedShort:10U];
        params.optionsMask = [NSNumber numberWithUnsignedChar:0];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:0];
        [cluster moveToHueAndSaturationWithParams:params
                                completionHandler:^(NSError * _Nullable err) {
                                    NSLog(@"Move To current hue and saturation command Error: %@", err);

                                    VerifyOrReturn(CheckValue("status", err, 0));

                                    NextTest();
                                }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_4()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster offWithCompletionHandler:^(NSError * _Nullable err) {
            NSLog(@"Turn off light that we turned on Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_5()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOnOffWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Check on/off attribute value is false after off command Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("OnOff", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
};

class Test_TC_CC_5_1 : public TestCommandBridge {
public:
    Test_TC_CC_5_1()
        : TestCommandBridge("Test_TC_CC_5_1")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_CC_5_1() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_5_1\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_5_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Move to Color command\n");
            err = TestMoveToColorCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_5();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 6;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestTurnOnLightForColorControlTests_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster onWithCompletionHandler:^(NSError * _Nullable err) {
            NSLog(@"Turn on light for color control tests Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOnOffWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Check on/off attribute value is true after on command Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("OnOff", actualValue, 1));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestMoveToColorCommand_3()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPColorControlClusterMoveToColorParams alloc] init];
        params.colorX = [NSNumber numberWithUnsignedShort:200U];
        params.colorY = [NSNumber numberWithUnsignedShort:300U];
        params.transitionTime = [NSNumber numberWithUnsignedShort:20U];
        params.optionsMask = [NSNumber numberWithUnsignedChar:0];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:0];
        [cluster moveToColorWithParams:params
                     completionHandler:^(NSError * _Nullable err) {
                         NSLog(@"Move to Color command Error: %@", err);

                         VerifyOrReturn(CheckValue("status", err, 0));

                         NextTest();
                     }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_4()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster offWithCompletionHandler:^(NSError * _Nullable err) {
            NSLog(@"Turn off light that we turned on Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_5()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOnOffWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Check on/off attribute value is false after off command Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("OnOff", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
};

class Test_TC_CC_5_2 : public TestCommandBridge {
public:
    Test_TC_CC_5_2()
        : TestCommandBridge("Test_TC_CC_5_2")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_CC_5_2() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_5_2\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_5_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Move Color command\n");
            err = TestMoveColorCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Stop Move Step command\n");
            err = TestStopMoveStepCommand_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_6();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 7;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestTurnOnLightForColorControlTests_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster onWithCompletionHandler:^(NSError * _Nullable err) {
            NSLog(@"Turn on light for color control tests Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOnOffWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Check on/off attribute value is true after on command Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("OnOff", actualValue, 1));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestMoveColorCommand_3()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPColorControlClusterMoveColorParams alloc] init];
        params.rateX = [NSNumber numberWithShort:15];
        params.rateY = [NSNumber numberWithShort:20];
        params.optionsMask = [NSNumber numberWithUnsignedChar:0];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:0];
        [cluster moveColorWithParams:params
                   completionHandler:^(NSError * _Nullable err) {
                       NSLog(@"Move Color command Error: %@", err);

                       VerifyOrReturn(CheckValue("status", err, 0));

                       NextTest();
                   }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestStopMoveStepCommand_4()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPColorControlClusterStopMoveStepParams alloc] init];
        params.optionsMask = [NSNumber numberWithUnsignedChar:0];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:0];
        [cluster stopMoveStepWithParams:params
                      completionHandler:^(NSError * _Nullable err) {
                          NSLog(@"Stop Move Step command Error: %@", err);

                          VerifyOrReturn(CheckValue("status", err, 0));

                          NextTest();
                      }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_5()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster offWithCompletionHandler:^(NSError * _Nullable err) {
            NSLog(@"Turn off light that we turned on Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_6()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOnOffWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Check on/off attribute value is false after off command Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("OnOff", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
};

class Test_TC_CC_5_3 : public TestCommandBridge {
public:
    Test_TC_CC_5_3()
        : TestCommandBridge("Test_TC_CC_5_3")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_CC_5_3() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_5_3\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_5_3\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Step Color command\n");
            err = TestStepColorCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_5();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 6;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestTurnOnLightForColorControlTests_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster onWithCompletionHandler:^(NSError * _Nullable err) {
            NSLog(@"Turn on light for color control tests Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOnOffWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Check on/off attribute value is true after on command Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("OnOff", actualValue, 1));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestStepColorCommand_3()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPColorControlClusterStepColorParams alloc] init];
        params.stepX = [NSNumber numberWithShort:15];
        params.stepY = [NSNumber numberWithShort:20];
        params.transitionTime = [NSNumber numberWithUnsignedShort:50U];
        params.optionsMask = [NSNumber numberWithUnsignedChar:0];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:0];
        [cluster stepColorWithParams:params
                   completionHandler:^(NSError * _Nullable err) {
                       NSLog(@"Step Color command Error: %@", err);

                       VerifyOrReturn(CheckValue("status", err, 0));

                       NextTest();
                   }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_4()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster offWithCompletionHandler:^(NSError * _Nullable err) {
            NSLog(@"Turn off light that we turned on Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_5()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOnOffWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Check on/off attribute value is false after off command Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("OnOff", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
};

class Test_TC_CC_6_1 : public TestCommandBridge {
public:
    Test_TC_CC_6_1()
        : TestCommandBridge("Test_TC_CC_6_1")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_CC_6_1() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_6_1\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_6_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Move To Color Temperature command\n");
            err = TestMoveToColorTemperatureCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_5();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 6;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestTurnOnLightForColorControlTests_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster onWithCompletionHandler:^(NSError * _Nullable err) {
            NSLog(@"Turn on light for color control tests Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOnOffWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Check on/off attribute value is true after on command Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("OnOff", actualValue, 1));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestMoveToColorTemperatureCommand_3()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPColorControlClusterMoveToColorTemperatureParams alloc] init];
        params.colorTemperature = [NSNumber numberWithUnsignedShort:100U];
        params.transitionTime = [NSNumber numberWithUnsignedShort:10U];
        params.optionsMask = [NSNumber numberWithUnsignedChar:0];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:0];
        [cluster moveToColorTemperatureWithParams:params
                                completionHandler:^(NSError * _Nullable err) {
                                    NSLog(@"Move To Color Temperature command Error: %@", err);

                                    VerifyOrReturn(CheckValue("status", err, 0));

                                    NextTest();
                                }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_4()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster offWithCompletionHandler:^(NSError * _Nullable err) {
            NSLog(@"Turn off light that we turned on Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_5()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOnOffWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Check on/off attribute value is false after off command Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("OnOff", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
};

class Test_TC_CC_6_2 : public TestCommandBridge {
public:
    Test_TC_CC_6_2()
        : TestCommandBridge("Test_TC_CC_6_2")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_CC_6_2() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_6_2\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_6_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read current color temprature\n");
            err = TestReadCurrentColorTemprature_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Move up color temperature command\n");
            err = TestMoveUpColorTemperatureCommand_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Move down color temperature command\n");
            err = TestMoveDownColorTemperatureCommand_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Move up color temperature command\n");
            err = TestMoveUpColorTemperatureCommand_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Stop Color Temperature command\n");
            err = TestStopColorTemperatureCommand_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Move down color temperature command\n");
            err = TestMoveDownColorTemperatureCommand_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Stop Color Temperature command\n");
            err = TestStopColorTemperatureCommand_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_11();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 12;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestTurnOnLightForColorControlTests_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster onWithCompletionHandler:^(NSError * _Nullable err) {
            NSLog(@"Turn on light for color control tests Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOnOffWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Check on/off attribute value is true after on command Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("OnOff", actualValue, 1));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadCurrentColorTemprature_3()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeColorTemperatureWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read current color temprature Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("colorTemperature", "", "uint16"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("colorTemperature", [value unsignedShortValue], 0U));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("colorTemperature", [value unsignedShortValue], 65279U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestMoveUpColorTemperatureCommand_4()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPColorControlClusterMoveColorTemperatureParams alloc] init];
        params.moveMode = [NSNumber numberWithUnsignedChar:1];
        params.rate = [NSNumber numberWithUnsignedShort:10U];
        params.colorTemperatureMinimum = [NSNumber numberWithUnsignedShort:1U];
        params.colorTemperatureMaximum = [NSNumber numberWithUnsignedShort:255U];
        params.optionsMask = [NSNumber numberWithUnsignedChar:0];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:0];
        [cluster moveColorTemperatureWithParams:params
                              completionHandler:^(NSError * _Nullable err) {
                                  NSLog(@"Move up color temperature command Error: %@", err);

                                  VerifyOrReturn(CheckValue("status", err, 0));

                                  NextTest();
                              }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestMoveDownColorTemperatureCommand_5()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPColorControlClusterMoveColorTemperatureParams alloc] init];
        params.moveMode = [NSNumber numberWithUnsignedChar:3];
        params.rate = [NSNumber numberWithUnsignedShort:20U];
        params.colorTemperatureMinimum = [NSNumber numberWithUnsignedShort:1U];
        params.colorTemperatureMaximum = [NSNumber numberWithUnsignedShort:255U];
        params.optionsMask = [NSNumber numberWithUnsignedChar:0];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:0];
        [cluster moveColorTemperatureWithParams:params
                              completionHandler:^(NSError * _Nullable err) {
                                  NSLog(@"Move down color temperature command Error: %@", err);

                                  VerifyOrReturn(CheckValue("status", err, 0));

                                  NextTest();
                              }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestMoveUpColorTemperatureCommand_6()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPColorControlClusterMoveColorTemperatureParams alloc] init];
        params.moveMode = [NSNumber numberWithUnsignedChar:1];
        params.rate = [NSNumber numberWithUnsignedShort:10U];
        params.colorTemperatureMinimum = [NSNumber numberWithUnsignedShort:1U];
        params.colorTemperatureMaximum = [NSNumber numberWithUnsignedShort:255U];
        params.optionsMask = [NSNumber numberWithUnsignedChar:0];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:0];
        [cluster moveColorTemperatureWithParams:params
                              completionHandler:^(NSError * _Nullable err) {
                                  NSLog(@"Move up color temperature command Error: %@", err);

                                  VerifyOrReturn(CheckValue("status", err, 0));

                                  NextTest();
                              }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestStopColorTemperatureCommand_7()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPColorControlClusterMoveColorTemperatureParams alloc] init];
        params.moveMode = [NSNumber numberWithUnsignedChar:0];
        params.rate = [NSNumber numberWithUnsignedShort:10U];
        params.colorTemperatureMinimum = [NSNumber numberWithUnsignedShort:1U];
        params.colorTemperatureMaximum = [NSNumber numberWithUnsignedShort:255U];
        params.optionsMask = [NSNumber numberWithUnsignedChar:0];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:0];
        [cluster moveColorTemperatureWithParams:params
                              completionHandler:^(NSError * _Nullable err) {
                                  NSLog(@"Stop Color Temperature command Error: %@", err);

                                  VerifyOrReturn(CheckValue("status", err, 0));

                                  NextTest();
                              }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestMoveDownColorTemperatureCommand_8()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPColorControlClusterMoveColorTemperatureParams alloc] init];
        params.moveMode = [NSNumber numberWithUnsignedChar:3];
        params.rate = [NSNumber numberWithUnsignedShort:20U];
        params.colorTemperatureMinimum = [NSNumber numberWithUnsignedShort:1U];
        params.colorTemperatureMaximum = [NSNumber numberWithUnsignedShort:255U];
        params.optionsMask = [NSNumber numberWithUnsignedChar:0];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:0];
        [cluster moveColorTemperatureWithParams:params
                              completionHandler:^(NSError * _Nullable err) {
                                  NSLog(@"Move down color temperature command Error: %@", err);

                                  VerifyOrReturn(CheckValue("status", err, 0));

                                  NextTest();
                              }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestStopColorTemperatureCommand_9()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPColorControlClusterMoveColorTemperatureParams alloc] init];
        params.moveMode = [NSNumber numberWithUnsignedChar:0];
        params.rate = [NSNumber numberWithUnsignedShort:10U];
        params.colorTemperatureMinimum = [NSNumber numberWithUnsignedShort:1U];
        params.colorTemperatureMaximum = [NSNumber numberWithUnsignedShort:255U];
        params.optionsMask = [NSNumber numberWithUnsignedChar:0];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:0];
        [cluster moveColorTemperatureWithParams:params
                              completionHandler:^(NSError * _Nullable err) {
                                  NSLog(@"Stop Color Temperature command Error: %@", err);

                                  VerifyOrReturn(CheckValue("status", err, 0));

                                  NextTest();
                              }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_10()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster offWithCompletionHandler:^(NSError * _Nullable err) {
            NSLog(@"Turn off light that we turned on Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_11()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOnOffWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Check on/off attribute value is false after off command Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("OnOff", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
};

class Test_TC_CC_6_3 : public TestCommandBridge {
public:
    Test_TC_CC_6_3()
        : TestCommandBridge("Test_TC_CC_6_3")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_CC_6_3() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_6_3\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_6_3\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Step up color temperature command\n");
            err = TestStepUpColorTemperatureCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Step down color temperature command\n");
            err = TestStepDownColorTemperatureCommand_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_6();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 7;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestTurnOnLightForColorControlTests_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster onWithCompletionHandler:^(NSError * _Nullable err) {
            NSLog(@"Turn on light for color control tests Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOnOffWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Check on/off attribute value is true after on command Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("OnOff", actualValue, 1));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestStepUpColorTemperatureCommand_3()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPColorControlClusterStepColorTemperatureParams alloc] init];
        params.stepMode = [NSNumber numberWithUnsignedChar:1];
        params.stepSize = [NSNumber numberWithUnsignedShort:5U];
        params.transitionTime = [NSNumber numberWithUnsignedShort:50U];
        params.colorTemperatureMinimum = [NSNumber numberWithUnsignedShort:5U];
        params.colorTemperatureMaximum = [NSNumber numberWithUnsignedShort:100U];
        params.optionsMask = [NSNumber numberWithUnsignedChar:0];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:0];
        [cluster stepColorTemperatureWithParams:params
                              completionHandler:^(NSError * _Nullable err) {
                                  NSLog(@"Step up color temperature command Error: %@", err);

                                  VerifyOrReturn(CheckValue("status", err, 0));

                                  NextTest();
                              }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestStepDownColorTemperatureCommand_4()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPColorControlClusterStepColorTemperatureParams alloc] init];
        params.stepMode = [NSNumber numberWithUnsignedChar:3];
        params.stepSize = [NSNumber numberWithUnsignedShort:5U];
        params.transitionTime = [NSNumber numberWithUnsignedShort:50U];
        params.colorTemperatureMinimum = [NSNumber numberWithUnsignedShort:5U];
        params.colorTemperatureMaximum = [NSNumber numberWithUnsignedShort:100U];
        params.optionsMask = [NSNumber numberWithUnsignedChar:0];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:0];
        [cluster stepColorTemperatureWithParams:params
                              completionHandler:^(NSError * _Nullable err) {
                                  NSLog(@"Step down color temperature command Error: %@", err);

                                  VerifyOrReturn(CheckValue("status", err, 0));

                                  NextTest();
                              }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_5()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster offWithCompletionHandler:^(NSError * _Nullable err) {
            NSLog(@"Turn off light that we turned on Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_6()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOnOffWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Check on/off attribute value is false after off command Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("OnOff", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
};

class Test_TC_CC_7_1 : public TestCommandBridge {
public:
    Test_TC_CC_7_1()
        : TestCommandBridge("Test_TC_CC_7_1")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_CC_7_1() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_7_1\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_7_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Enhanced Move To Hue command\n");
            err = TestEnhancedMoveToHueCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Enhanced Move To Hue command\n");
            err = TestEnhancedMoveToHueCommand_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Enhanced Move To Hue command\n");
            err = TestEnhancedMoveToHueCommand_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Enhanced Move To Hue command\n");
            err = TestEnhancedMoveToHueCommand_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Enhanced Move To Hue command\n");
            err = TestEnhancedMoveToHueCommand_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_9();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 10;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestTurnOnLightForColorControlTests_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster onWithCompletionHandler:^(NSError * _Nullable err) {
            NSLog(@"Turn on light for color control tests Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOnOffWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Check on/off attribute value is true after on command Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("OnOff", actualValue, 1));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestEnhancedMoveToHueCommand_3()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPColorControlClusterEnhancedMoveToHueParams alloc] init];
        params.enhancedHue = [NSNumber numberWithUnsignedShort:1025U];
        params.direction = [NSNumber numberWithUnsignedChar:0];
        params.transitionTime = [NSNumber numberWithUnsignedShort:1U];
        params.optionsMask = [NSNumber numberWithUnsignedChar:0];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:0];
        [cluster enhancedMoveToHueWithParams:params
                           completionHandler:^(NSError * _Nullable err) {
                               NSLog(@"Enhanced Move To Hue command Error: %@", err);

                               VerifyOrReturn(CheckValue("status", err, 0));

                               NextTest();
                           }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestEnhancedMoveToHueCommand_4()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPColorControlClusterEnhancedMoveToHueParams alloc] init];
        params.enhancedHue = [NSNumber numberWithUnsignedShort:1100U];
        params.direction = [NSNumber numberWithUnsignedChar:0];
        params.transitionTime = [NSNumber numberWithUnsignedShort:300U];
        params.optionsMask = [NSNumber numberWithUnsignedChar:0];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:0];
        [cluster enhancedMoveToHueWithParams:params
                           completionHandler:^(NSError * _Nullable err) {
                               NSLog(@"Enhanced Move To Hue command Error: %@", err);

                               VerifyOrReturn(CheckValue("status", err, 0));

                               NextTest();
                           }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestEnhancedMoveToHueCommand_5()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPColorControlClusterEnhancedMoveToHueParams alloc] init];
        params.enhancedHue = [NSNumber numberWithUnsignedShort:1150U];
        params.direction = [NSNumber numberWithUnsignedChar:1];
        params.transitionTime = [NSNumber numberWithUnsignedShort:300U];
        params.optionsMask = [NSNumber numberWithUnsignedChar:0];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:0];
        [cluster enhancedMoveToHueWithParams:params
                           completionHandler:^(NSError * _Nullable err) {
                               NSLog(@"Enhanced Move To Hue command Error: %@", err);

                               VerifyOrReturn(CheckValue("status", err, 0));

                               NextTest();
                           }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestEnhancedMoveToHueCommand_6()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPColorControlClusterEnhancedMoveToHueParams alloc] init];
        params.enhancedHue = [NSNumber numberWithUnsignedShort:1200U];
        params.direction = [NSNumber numberWithUnsignedChar:2];
        params.transitionTime = [NSNumber numberWithUnsignedShort:300U];
        params.optionsMask = [NSNumber numberWithUnsignedChar:0];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:0];
        [cluster enhancedMoveToHueWithParams:params
                           completionHandler:^(NSError * _Nullable err) {
                               NSLog(@"Enhanced Move To Hue command Error: %@", err);

                               VerifyOrReturn(CheckValue("status", err, 0));

                               NextTest();
                           }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestEnhancedMoveToHueCommand_7()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPColorControlClusterEnhancedMoveToHueParams alloc] init];
        params.enhancedHue = [NSNumber numberWithUnsignedShort:1300U];
        params.direction = [NSNumber numberWithUnsignedChar:3];
        params.transitionTime = [NSNumber numberWithUnsignedShort:300U];
        params.optionsMask = [NSNumber numberWithUnsignedChar:0];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:0];
        [cluster enhancedMoveToHueWithParams:params
                           completionHandler:^(NSError * _Nullable err) {
                               NSLog(@"Enhanced Move To Hue command Error: %@", err);

                               VerifyOrReturn(CheckValue("status", err, 0));

                               NextTest();
                           }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_8()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster offWithCompletionHandler:^(NSError * _Nullable err) {
            NSLog(@"Turn off light that we turned on Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_9()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOnOffWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Check on/off attribute value is false after off command Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("OnOff", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
};

class Test_TC_CC_7_2 : public TestCommandBridge {
public:
    Test_TC_CC_7_2()
        : TestCommandBridge("Test_TC_CC_7_2")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_CC_7_2() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_7_2\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_7_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Check EnhancedCurrentHue attribute from DUT\n");
            err = TestCheckEnhancedCurrentHueAttributeFromDut_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Enhanced Move Hue Up command\n");
            err = TestEnhancedMoveHueUpCommand_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Enhanced Move Hue Stop command\n");
            err = TestEnhancedMoveHueStopCommand_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Enhanced Move Hue Down command \n");
            err = TestEnhancedMoveHueDownCommand_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Enhanced Move Hue Stop command\n");
            err = TestEnhancedMoveHueStopCommand_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_9();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 10;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestTurnOnLightForColorControlTests_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster onWithCompletionHandler:^(NSError * _Nullable err) {
            NSLog(@"Turn on light for color control tests Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOnOffWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Check on/off attribute value is true after on command Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("OnOff", actualValue, 1));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestCheckEnhancedCurrentHueAttributeFromDut_3()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeEnhancedCurrentHueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Check EnhancedCurrentHue attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("enhancedCurrentHue", "", "uint16"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("enhancedCurrentHue", [value unsignedShortValue], 0U));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("enhancedCurrentHue", [value unsignedShortValue], 65535U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestEnhancedMoveHueUpCommand_4()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPColorControlClusterEnhancedMoveHueParams alloc] init];
        params.moveMode = [NSNumber numberWithUnsignedChar:1];
        params.rate = [NSNumber numberWithUnsignedShort:50U];
        params.optionsMask = [NSNumber numberWithUnsignedChar:0];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:0];
        [cluster enhancedMoveHueWithParams:params
                         completionHandler:^(NSError * _Nullable err) {
                             NSLog(@"Enhanced Move Hue Up command Error: %@", err);

                             VerifyOrReturn(CheckValue("status", err, 0));

                             NextTest();
                         }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestEnhancedMoveHueStopCommand_5()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPColorControlClusterEnhancedMoveHueParams alloc] init];
        params.moveMode = [NSNumber numberWithUnsignedChar:0];
        params.rate = [NSNumber numberWithUnsignedShort:0U];
        params.optionsMask = [NSNumber numberWithUnsignedChar:0];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:0];
        [cluster enhancedMoveHueWithParams:params
                         completionHandler:^(NSError * _Nullable err) {
                             NSLog(@"Enhanced Move Hue Stop command Error: %@", err);

                             VerifyOrReturn(CheckValue("status", err, 0));

                             NextTest();
                         }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestEnhancedMoveHueDownCommand_6()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPColorControlClusterEnhancedMoveHueParams alloc] init];
        params.moveMode = [NSNumber numberWithUnsignedChar:3];
        params.rate = [NSNumber numberWithUnsignedShort:5U];
        params.optionsMask = [NSNumber numberWithUnsignedChar:0];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:0];
        [cluster enhancedMoveHueWithParams:params
                         completionHandler:^(NSError * _Nullable err) {
                             NSLog(@"Enhanced Move Hue Down command  Error: %@", err);

                             VerifyOrReturn(CheckValue("status", err, 0));

                             NextTest();
                         }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestEnhancedMoveHueStopCommand_7()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPColorControlClusterEnhancedMoveHueParams alloc] init];
        params.moveMode = [NSNumber numberWithUnsignedChar:0];
        params.rate = [NSNumber numberWithUnsignedShort:0U];
        params.optionsMask = [NSNumber numberWithUnsignedChar:0];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:0];
        [cluster enhancedMoveHueWithParams:params
                         completionHandler:^(NSError * _Nullable err) {
                             NSLog(@"Enhanced Move Hue Stop command Error: %@", err);

                             VerifyOrReturn(CheckValue("status", err, 0));

                             NextTest();
                         }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_8()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster offWithCompletionHandler:^(NSError * _Nullable err) {
            NSLog(@"Turn off light that we turned on Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_9()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOnOffWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Check on/off attribute value is false after off command Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("OnOff", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
};

class Test_TC_CC_7_3 : public TestCommandBridge {
public:
    Test_TC_CC_7_3()
        : TestCommandBridge("Test_TC_CC_7_3")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_CC_7_3() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_7_3\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_7_3\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Enhanced Step Hue Up command\n");
            err = TestEnhancedStepHueUpCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Enhanced Step Hue Down command\n");
            err = TestEnhancedStepHueDownCommand_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_6();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 7;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestTurnOnLightForColorControlTests_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster onWithCompletionHandler:^(NSError * _Nullable err) {
            NSLog(@"Turn on light for color control tests Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOnOffWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Check on/off attribute value is true after on command Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("OnOff", actualValue, 1));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestEnhancedStepHueUpCommand_3()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPColorControlClusterEnhancedStepHueParams alloc] init];
        params.stepMode = [NSNumber numberWithUnsignedChar:0];
        params.stepSize = [NSNumber numberWithUnsignedShort:50U];
        params.transitionTime = [NSNumber numberWithUnsignedShort:1U];
        params.optionsMask = [NSNumber numberWithUnsignedChar:0];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:0];
        [cluster enhancedStepHueWithParams:params
                         completionHandler:^(NSError * _Nullable err) {
                             NSLog(@"Enhanced Step Hue Up command Error: %@", err);

                             VerifyOrReturn(CheckValue("status", err, 0));

                             NextTest();
                         }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestEnhancedStepHueDownCommand_4()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPColorControlClusterEnhancedStepHueParams alloc] init];
        params.stepMode = [NSNumber numberWithUnsignedChar:1];
        params.stepSize = [NSNumber numberWithUnsignedShort:75U];
        params.transitionTime = [NSNumber numberWithUnsignedShort:1U];
        params.optionsMask = [NSNumber numberWithUnsignedChar:0];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:0];
        [cluster enhancedStepHueWithParams:params
                         completionHandler:^(NSError * _Nullable err) {
                             NSLog(@"Enhanced Step Hue Down command Error: %@", err);

                             VerifyOrReturn(CheckValue("status", err, 0));

                             NextTest();
                         }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_5()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster offWithCompletionHandler:^(NSError * _Nullable err) {
            NSLog(@"Turn off light that we turned on Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_6()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOnOffWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Check on/off attribute value is false after off command Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("OnOff", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
};

class Test_TC_CC_7_4 : public TestCommandBridge {
public:
    Test_TC_CC_7_4()
        : TestCommandBridge("Test_TC_CC_7_4")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_CC_7_4() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_7_4\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_7_4\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Enhanced move to hue and saturation command\n");
            err = TestEnhancedMoveToHueAndSaturationCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_5();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 6;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestTurnOnLightForColorControlTests_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster onWithCompletionHandler:^(NSError * _Nullable err) {
            NSLog(@"Turn on light for color control tests Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOnOffWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Check on/off attribute value is true after on command Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("OnOff", actualValue, 1));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestEnhancedMoveToHueAndSaturationCommand_3()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPColorControlClusterEnhancedMoveToHueAndSaturationParams alloc] init];
        params.enhancedHue = [NSNumber numberWithUnsignedShort:1200U];
        params.saturation = [NSNumber numberWithUnsignedChar:90];
        params.transitionTime = [NSNumber numberWithUnsignedShort:10U];
        params.optionsMask = [NSNumber numberWithUnsignedChar:0];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:0];
        [cluster enhancedMoveToHueAndSaturationWithParams:params
                                        completionHandler:^(NSError * _Nullable err) {
                                            NSLog(@"Enhanced move to hue and saturation command Error: %@", err);

                                            VerifyOrReturn(CheckValue("status", err, 0));

                                            NextTest();
                                        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_4()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster offWithCompletionHandler:^(NSError * _Nullable err) {
            NSLog(@"Turn off light that we turned on Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_5()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOnOffWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Check on/off attribute value is false after off command Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("OnOff", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
};

class Test_TC_CC_8_1 : public TestCommandBridge {
public:
    Test_TC_CC_8_1()
        : TestCommandBridge("Test_TC_CC_8_1")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_CC_8_1() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_8_1\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_8_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Color Loop Set Command - Set all Attributes\n");
            err = TestColorLoopSetCommandSetAllAttributes_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Check ColorLoopDirection Value\n");
            err = TestCheckColorLoopDirectionValue_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Check ColorLoopTime Value\n");
            err = TestCheckColorLoopTimeValue_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Check ColorLoopStartEnhancedHue Value\n");
            err = TestCheckColorLoopStartEnhancedHueValue_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Check ColorLoopActive Value\n");
            err = TestCheckColorLoopActiveValue_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Color Loop Set Command - Start Color Loop\n");
            err = TestColorLoopSetCommandStartColorLoop_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Check ColorLoopActive Value\n");
            err = TestCheckColorLoopActiveValue_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Color Loop Set Command - Set direction and time while running\n");
            err = TestColorLoopSetCommandSetDirectionAndTimeWhileRunning_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : Check ColorLoopDirection Value\n");
            err = TestCheckColorLoopDirectionValue_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : Check ColorLoopTime Value\n");
            err = TestCheckColorLoopTimeValue_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : Color Loop Set Command - Set direction while running\n");
            err = TestColorLoopSetCommandSetDirectionWhileRunning_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : Check ColorLoopDirection Value\n");
            err = TestCheckColorLoopDirectionValue_14();
            break;
        case 15:
            ChipLogProgress(chipTool, " ***** Test Step 15 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_15();
            break;
        case 16:
            ChipLogProgress(chipTool, " ***** Test Step 16 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_16();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 17;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestTurnOnLightForColorControlTests_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster onWithCompletionHandler:^(NSError * _Nullable err) {
            NSLog(@"Turn on light for color control tests Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOnOffWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Check on/off attribute value is true after on command Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("OnOff", actualValue, 1));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestColorLoopSetCommandSetAllAttributes_3()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPColorControlClusterColorLoopSetParams alloc] init];
        params.updateFlags = [NSNumber numberWithUnsignedChar:14];
        params.action = [NSNumber numberWithUnsignedChar:0];
        params.direction = [NSNumber numberWithUnsignedChar:1];
        params.time = [NSNumber numberWithUnsignedShort:100U];
        params.startHue = [NSNumber numberWithUnsignedShort:500U];
        params.optionsMask = [NSNumber numberWithUnsignedChar:0];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:0];
        [cluster colorLoopSetWithParams:params
                      completionHandler:^(NSError * _Nullable err) {
                          NSLog(@"Color Loop Set Command - Set all Attributes Error: %@", err);

                          VerifyOrReturn(CheckValue("status", err, 0));

                          NextTest();
                      }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestCheckColorLoopDirectionValue_4()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeColorLoopDirectionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Check ColorLoopDirection Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("color loop direction", actualValue, 1));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestCheckColorLoopTimeValue_5()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeColorLoopTimeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Check ColorLoopTime Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("color loop time", actualValue, 100U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestCheckColorLoopStartEnhancedHueValue_6()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster
            readAttributeColorLoopStartEnhancedHueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
                NSLog(@"Check ColorLoopStartEnhancedHue Value Error: %@", err);

                VerifyOrReturn(CheckValue("status", err, 0));

                {
                    id actualValue = value;
                    VerifyOrReturn(CheckValue("color loop start enhanced hue", actualValue, 500U));
                }

                NextTest();
            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestCheckColorLoopActiveValue_7()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeColorLoopActiveWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Check ColorLoopActive Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("color loop active", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestColorLoopSetCommandStartColorLoop_8()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPColorControlClusterColorLoopSetParams alloc] init];
        params.updateFlags = [NSNumber numberWithUnsignedChar:1];
        params.action = [NSNumber numberWithUnsignedChar:1];
        params.direction = [NSNumber numberWithUnsignedChar:0];
        params.time = [NSNumber numberWithUnsignedShort:0U];
        params.startHue = [NSNumber numberWithUnsignedShort:0U];
        params.optionsMask = [NSNumber numberWithUnsignedChar:0];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:0];
        [cluster colorLoopSetWithParams:params
                      completionHandler:^(NSError * _Nullable err) {
                          NSLog(@"Color Loop Set Command - Start Color Loop Error: %@", err);

                          VerifyOrReturn(CheckValue("status", err, 0));

                          NextTest();
                      }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestCheckColorLoopActiveValue_9()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeColorLoopActiveWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Check ColorLoopActive Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("color loop active", actualValue, 1));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestColorLoopSetCommandSetDirectionAndTimeWhileRunning_10()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPColorControlClusterColorLoopSetParams alloc] init];
        params.updateFlags = [NSNumber numberWithUnsignedChar:6];
        params.action = [NSNumber numberWithUnsignedChar:0];
        params.direction = [NSNumber numberWithUnsignedChar:0];
        params.time = [NSNumber numberWithUnsignedShort:3500U];
        params.startHue = [NSNumber numberWithUnsignedShort:0U];
        params.optionsMask = [NSNumber numberWithUnsignedChar:0];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:0];
        [cluster colorLoopSetWithParams:params
                      completionHandler:^(NSError * _Nullable err) {
                          NSLog(@"Color Loop Set Command - Set direction and time while running Error: %@", err);

                          VerifyOrReturn(CheckValue("status", err, 0));

                          NextTest();
                      }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestCheckColorLoopDirectionValue_11()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeColorLoopDirectionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Check ColorLoopDirection Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("color loop direction", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestCheckColorLoopTimeValue_12()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeColorLoopTimeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Check ColorLoopTime Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("color loop time", actualValue, 3500U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestColorLoopSetCommandSetDirectionWhileRunning_13()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPColorControlClusterColorLoopSetParams alloc] init];
        params.updateFlags = [NSNumber numberWithUnsignedChar:2];
        params.action = [NSNumber numberWithUnsignedChar:0];
        params.direction = [NSNumber numberWithUnsignedChar:1];
        params.time = [NSNumber numberWithUnsignedShort:0U];
        params.startHue = [NSNumber numberWithUnsignedShort:0U];
        params.optionsMask = [NSNumber numberWithUnsignedChar:0];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:0];
        [cluster colorLoopSetWithParams:params
                      completionHandler:^(NSError * _Nullable err) {
                          NSLog(@"Color Loop Set Command - Set direction while running Error: %@", err);

                          VerifyOrReturn(CheckValue("status", err, 0));

                          NextTest();
                      }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestCheckColorLoopDirectionValue_14()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeColorLoopDirectionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Check ColorLoopDirection Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("color loop direction", actualValue, 1));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_15()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster offWithCompletionHandler:^(NSError * _Nullable err) {
            NSLog(@"Turn off light that we turned on Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_16()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOnOffWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Check on/off attribute value is false after off command Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("OnOff", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
};

class Test_TC_CC_9_1 : public TestCommandBridge {
public:
    Test_TC_CC_9_1()
        : TestCommandBridge("Test_TC_CC_9_1")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_CC_9_1() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_9_1\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_9_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Precondition : Turn on light for color control tests\n");
            err = TestPreconditionTurnOnLightForColorControlTests_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Sends ColorLoopSet Command - Set all Attributes\n");
            if (ShouldSkip("CR_COLORLOOPSET")) {
                NextTest();
                return;
            }
            err = TestSendsColorLoopSetCommandSetAllAttributes_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Read ColorLoopActive attribute from DUT\n");
            if (ShouldSkip("A_COLORLOOPACTIVE")) {
                NextTest();
                return;
            }
            err = TestReadColorLoopActiveAttributeFromDut_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Sends ColorLoopSet Command - Set all Attributes\n");
            if (ShouldSkip("CR_COLORLOOPSET")) {
                NextTest();
                return;
            }
            err = TestSendsColorLoopSetCommandSetAllAttributes_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Read ColorLoopDirection attribute from DUT\n");
            if (ShouldSkip("A_COLORLOOPDIRECTION")) {
                NextTest();
                return;
            }
            err = TestReadColorLoopDirectionAttributeFromDut_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Sends ColorLoopSet Command - Set all Attributes\n");
            if (ShouldSkip("CR_COLORLOOPSET")) {
                NextTest();
                return;
            }
            err = TestSendsColorLoopSetCommandSetAllAttributes_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Read ColorLoopTime attribute from DUT\n");
            if (ShouldSkip("A_COLORLOOPTIME")) {
                NextTest();
                return;
            }
            err = TestReadColorLoopTimeAttributeFromDut_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Sends ColorLoopSet Command - Set all Attributes\n");
            if (ShouldSkip("CR_COLORLOOPSET")) {
                NextTest();
                return;
            }
            err = TestSendsColorLoopSetCommandSetAllAttributes_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Read ColorLoopStartEnhancedHue attribute from DUT\n");
            if (ShouldSkip("A_COLORLOOPSTARTENHANCEDHUE")) {
                NextTest();
                return;
            }
            err = TestReadColorLoopStartEnhancedHueAttributeFromDut_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : Sends ColorLoopSet Command - Set all Attributes\n");
            if (ShouldSkip("CR_COLORLOOPSET")) {
                NextTest();
                return;
            }
            err = TestSendsColorLoopSetCommandSetAllAttributes_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : Read ColorLoopActive attribute from DUT\n");
            if (ShouldSkip("A_COLORLOOPACTIVE")) {
                NextTest();
                return;
            }
            err = TestReadColorLoopActiveAttributeFromDut_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : Read EnhancedCurrentHue attribute from DUT\n");
            if (ShouldSkip("A_ENHANCEDCURRENTHUE")) {
                NextTest();
                return;
            }
            err = TestReadEnhancedCurrentHueAttributeFromDut_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : Read ColorLoopStoredEnhancedHue attribute from DUT.\n");
            if (ShouldSkip("A_COLORLOOPSTOREDENHANCEDHUE")) {
                NextTest();
                return;
            }
            err = TestReadColorLoopStoredEnhancedHueAttributeFromDut_14();
            break;
        case 15:
            ChipLogProgress(chipTool, " ***** Test Step 15 : Sends ColorLoopSet Command - Set all Attributes\n");
            if (ShouldSkip("CR_COLORLOOPSET")) {
                NextTest();
                return;
            }
            err = TestSendsColorLoopSetCommandSetAllAttributes_15();
            break;
        case 16:
            ChipLogProgress(chipTool, " ***** Test Step 16 : Read ColorLoopActive attribute from DUT\n");
            if (ShouldSkip("A_COLORLOOPACTIVE")) {
                NextTest();
                return;
            }
            err = TestReadColorLoopActiveAttributeFromDut_16();
            break;
        case 17:
            ChipLogProgress(chipTool, " ***** Test Step 17 : Read ColorLoopStoredEnhancedHue attribute from DUT.\n");
            if (ShouldSkip("A_COLORLOOPSTOREDENHANCEDHUE")) {
                NextTest();
                return;
            }
            err = TestReadColorLoopStoredEnhancedHueAttributeFromDut_17();
            break;
        case 18:
            ChipLogProgress(chipTool, " ***** Test Step 18 : Read EnhancedCurrentHue attribute from DUT\n");
            if (ShouldSkip("A_ENHANCEDCURRENTHUE")) {
                NextTest();
                return;
            }
            err = TestReadEnhancedCurrentHueAttributeFromDut_18();
            break;
        case 19:
            ChipLogProgress(chipTool, " ***** Test Step 19 : Sends ColorLoopSet Command - Set all Attributes\n");
            if (ShouldSkip("CR_COLORLOOPSET")) {
                NextTest();
                return;
            }
            err = TestSendsColorLoopSetCommandSetAllAttributes_19();
            break;
        case 20:
            ChipLogProgress(chipTool, " ***** Test Step 20 : Read ColorLoopDirection attribute from DUT\n");
            if (ShouldSkip("A_COLORLOOPDIRECTION")) {
                NextTest();
                return;
            }
            err = TestReadColorLoopDirectionAttributeFromDut_20();
            break;
        case 21:
            ChipLogProgress(chipTool, " ***** Test Step 21 : Sends ColorLoopSet Command - Set all Attributes\n");
            if (ShouldSkip("CR_COLORLOOPSET")) {
                NextTest();
                return;
            }
            err = TestSendsColorLoopSetCommandSetAllAttributes_21();
            break;
        case 22:
            ChipLogProgress(chipTool, " ***** Test Step 22 : Read ColorLoopActive attribute from DUT\n");
            if (ShouldSkip("A_COLORLOOPACTIVE")) {
                NextTest();
                return;
            }
            err = TestReadColorLoopActiveAttributeFromDut_22();
            break;
        case 23:
            ChipLogProgress(chipTool, " ***** Test Step 23 : Read EnhancedCurrentHue attribute from DUT\n");
            if (ShouldSkip("A_ENHANCEDCURRENTHUE")) {
                NextTest();
                return;
            }
            err = TestReadEnhancedCurrentHueAttributeFromDut_23();
            break;
        case 24:
            ChipLogProgress(chipTool, " ***** Test Step 24 : Read ColorLoopStoredEnhancedHue attribute from DUT\n");
            if (ShouldSkip("A_COLORLOOPSTOREDENHANCEDHUE")) {
                NextTest();
                return;
            }
            err = TestReadColorLoopStoredEnhancedHueAttributeFromDut_24();
            break;
        case 25:
            ChipLogProgress(chipTool, " ***** Test Step 25 : Sends ColorLoopSet Command - Set all Attributes\n");
            if (ShouldSkip("CR_COLORLOOPSET")) {
                NextTest();
                return;
            }
            err = TestSendsColorLoopSetCommandSetAllAttributes_25();
            break;
        case 26:
            ChipLogProgress(chipTool, " ***** Test Step 26 : Read ColorLoopActive attribute from DUT\n");
            if (ShouldSkip("A_COLORLOOPACTIVE")) {
                NextTest();
                return;
            }
            err = TestReadColorLoopActiveAttributeFromDut_26();
            break;
        case 27:
            ChipLogProgress(chipTool, " ***** Test Step 27 : Read ColorLoopStoredEnhancedHue attribute from DUT.\n");
            if (ShouldSkip("A_COLORLOOPSTOREDENHANCEDHUE")) {
                NextTest();
                return;
            }
            err = TestReadColorLoopStoredEnhancedHueAttributeFromDut_27();
            break;
        case 28:
            ChipLogProgress(chipTool, " ***** Test Step 28 : Read EnhancedCurrentHue attribute from DUT\n");
            if (ShouldSkip("A_ENHANCEDCURRENTHUE")) {
                NextTest();
                return;
            }
            err = TestReadEnhancedCurrentHueAttributeFromDut_28();
            break;
        case 29:
            ChipLogProgress(chipTool, " ***** Test Step 29 : Enhanced Move To Hue command\n");
            if (ShouldSkip("CR_ENHANCEDMOVETOHUE")) {
                NextTest();
                return;
            }
            err = TestEnhancedMoveToHueCommand_29();
            break;
        case 30:
            ChipLogProgress(chipTool, " ***** Test Step 30 : Wait 2000ms\n");
            err = TestWait2000ms_30();
            break;
        case 31:
            ChipLogProgress(chipTool, " ***** Test Step 31 : Read EnhancedCurrentHue attribute from DUT\n");
            if (ShouldSkip("A_ENHANCEDCURRENTHUE")) {
                NextTest();
                return;
            }
            err = TestReadEnhancedCurrentHueAttributeFromDut_31();
            break;
        case 32:
            ChipLogProgress(chipTool, " ***** Test Step 32 : Sends ColorLoopSet Command - Set all Attributes\n");
            if (ShouldSkip("CR_COLORLOOPSET")) {
                NextTest();
                return;
            }
            err = TestSendsColorLoopSetCommandSetAllAttributes_32();
            break;
        case 33:
            ChipLogProgress(chipTool, " ***** Test Step 33 : Read ColorLoopDirection attribute from DUT\n");
            if (ShouldSkip("A_COLORLOOPDIRECTION")) {
                NextTest();
                return;
            }
            err = TestReadColorLoopDirectionAttributeFromDut_33();
            break;
        case 34:
            ChipLogProgress(chipTool, " ***** Test Step 34 : Sends ColorLoopSet Command - Set all Attributes\n");
            if (ShouldSkip("CR_COLORLOOPSET")) {
                NextTest();
                return;
            }
            err = TestSendsColorLoopSetCommandSetAllAttributes_34();
            break;
        case 35:
            ChipLogProgress(chipTool, " ***** Test Step 35 : Read ColorLoopActive attribute from DUT\n");
            if (ShouldSkip("A_COLORLOOPACTIVE")) {
                NextTest();
                return;
            }
            err = TestReadColorLoopActiveAttributeFromDut_35();
            break;
        case 36:
            ChipLogProgress(chipTool, " ***** Test Step 36 : Read EnhancedCurrentHue attribute from DUT\n");
            if (ShouldSkip("A_ENHANCEDCURRENTHUE")) {
                NextTest();
                return;
            }
            err = TestReadEnhancedCurrentHueAttributeFromDut_36();
            break;
        case 37:
            ChipLogProgress(chipTool, " ***** Test Step 37 : Read ColorLoopStoredEnhancedHue attribute from DUT\n");
            if (ShouldSkip("A_COLORLOOPSTOREDENHANCEDHUE")) {
                NextTest();
                return;
            }
            err = TestReadColorLoopStoredEnhancedHueAttributeFromDut_37();
            break;
        case 38:
            ChipLogProgress(chipTool, " ***** Test Step 38 : Sends ColorLoopSet Command - Set all Attributes\n");
            if (ShouldSkip("CR_COLORLOOPSET")) {
                NextTest();
                return;
            }
            err = TestSendsColorLoopSetCommandSetAllAttributes_38();
            break;
        case 39:
            ChipLogProgress(chipTool, " ***** Test Step 39 : Read ColorLoopActive attribute from DUT\n");
            if (ShouldSkip("A_COLORLOOPACTIVE")) {
                NextTest();
                return;
            }
            err = TestReadColorLoopActiveAttributeFromDut_39();
            break;
        case 40:
            ChipLogProgress(chipTool, " ***** Test Step 40 : Read ColorLoopStoredEnhancedHue attribute from DUT.\n");
            if (ShouldSkip("A_COLORLOOPSTOREDENHANCEDHUE")) {
                NextTest();
                return;
            }
            err = TestReadColorLoopStoredEnhancedHueAttributeFromDut_40();
            break;
        case 41:
            ChipLogProgress(chipTool, " ***** Test Step 41 : Read EnhancedCurrentHue attribute from DUT\n");
            if (ShouldSkip("A_ENHANCEDCURRENTHUE")) {
                NextTest();
                return;
            }
            err = TestReadEnhancedCurrentHueAttributeFromDut_41();
            break;
        case 42:
            ChipLogProgress(chipTool, " ***** Test Step 42 : Sends ColorLoopSet Command - Set all Attributes\n");
            if (ShouldSkip("CR_COLORLOOPSET")) {
                NextTest();
                return;
            }
            err = TestSendsColorLoopSetCommandSetAllAttributes_42();
            break;
        case 43:
            ChipLogProgress(chipTool, " ***** Test Step 43 : Read ColorLoopDirection attribute from DUT\n");
            if (ShouldSkip("A_COLORLOOPDIRECTION")) {
                NextTest();
                return;
            }
            err = TestReadColorLoopDirectionAttributeFromDut_43();
            break;
        case 44:
            ChipLogProgress(chipTool, " ***** Test Step 44 : Sends ColorLoopSet Command - Set all Attributes\n");
            if (ShouldSkip("CR_COLORLOOPSET")) {
                NextTest();
                return;
            }
            err = TestSendsColorLoopSetCommandSetAllAttributes_44();
            break;
        case 45:
            ChipLogProgress(chipTool, " ***** Test Step 45 : Read ColorLoopActive attribute from DUT\n");
            if (ShouldSkip("A_COLORLOOPACTIVE")) {
                NextTest();
                return;
            }
            err = TestReadColorLoopActiveAttributeFromDut_45();
            break;
        case 46:
            ChipLogProgress(chipTool, " ***** Test Step 46 : Read EnhancedCurrentHue attribute from DUT\n");
            if (ShouldSkip("A_ENHANCEDCURRENTHUE")) {
                NextTest();
                return;
            }
            err = TestReadEnhancedCurrentHueAttributeFromDut_46();
            break;
        case 47:
            ChipLogProgress(chipTool, " ***** Test Step 47 : Read ColorLoopStoredEnhancedHue attribute from DUT\n");
            if (ShouldSkip("A_COLORLOOPSTOREDENHANCEDHUE")) {
                NextTest();
                return;
            }
            err = TestReadColorLoopStoredEnhancedHueAttributeFromDut_47();
            break;
        case 48:
            ChipLogProgress(chipTool, " ***** Test Step 48 : Sends ColorLoopSet Command - Set all Attributes\n");
            if (ShouldSkip("CR_COLORLOOPSET")) {
                NextTest();
                return;
            }
            err = TestSendsColorLoopSetCommandSetAllAttributes_48();
            break;
        case 49:
            ChipLogProgress(chipTool, " ***** Test Step 49 : Read ColorLoopActive attribute from DUT\n");
            if (ShouldSkip("A_COLORLOOPACTIVE")) {
                NextTest();
                return;
            }
            err = TestReadColorLoopActiveAttributeFromDut_49();
            break;
        case 50:
            ChipLogProgress(chipTool, " ***** Test Step 50 : Read ColorLoopStoredEnhancedHue attribute from DUT.\n");
            if (ShouldSkip("A_COLORLOOPSTOREDENHANCEDHUE")) {
                NextTest();
                return;
            }
            err = TestReadColorLoopStoredEnhancedHueAttributeFromDut_50();
            break;
        case 51:
            ChipLogProgress(chipTool, " ***** Test Step 51 : Read EnhancedCurrentHue attribute from DUT\n");
            if (ShouldSkip("A_ENHANCEDCURRENTHUE")) {
                NextTest();
                return;
            }
            err = TestReadEnhancedCurrentHueAttributeFromDut_51();
            break;
        case 52:
            ChipLogProgress(chipTool, " ***** Test Step 52 : Turn Off light for color control tests\n");
            err = TestTurnOffLightForColorControlTests_52();
            break;
        case 53:
            ChipLogProgress(chipTool, " ***** Test Step 53 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_53();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 54;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestPreconditionTurnOnLightForColorControlTests_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster onWithCompletionHandler:^(NSError * _Nullable err) {
            NSLog(@"Precondition : Turn on light for color control tests Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOnOffWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Check on/off attribute value is true after on command Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("OnOff", actualValue, 1));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSendsColorLoopSetCommandSetAllAttributes_3()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPColorControlClusterColorLoopSetParams alloc] init];
        params.updateFlags = [NSNumber numberWithUnsignedChar:1];
        params.action = [NSNumber numberWithUnsignedChar:0];
        params.direction = [NSNumber numberWithUnsignedChar:0];
        params.time = [NSNumber numberWithUnsignedShort:0U];
        params.startHue = [NSNumber numberWithUnsignedShort:0U];
        params.optionsMask = [NSNumber numberWithUnsignedChar:0];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:0];
        [cluster colorLoopSetWithParams:params
                      completionHandler:^(NSError * _Nullable err) {
                          NSLog(@"Sends ColorLoopSet Command - Set all Attributes Error: %@", err);

                          VerifyOrReturn(CheckValue("status", err, 0));

                          NextTest();
                      }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadColorLoopActiveAttributeFromDut_4()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeColorLoopActiveWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read ColorLoopActive attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("color loop active", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSendsColorLoopSetCommandSetAllAttributes_5()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPColorControlClusterColorLoopSetParams alloc] init];
        params.updateFlags = [NSNumber numberWithUnsignedChar:2];
        params.action = [NSNumber numberWithUnsignedChar:0];
        params.direction = [NSNumber numberWithUnsignedChar:0];
        params.time = [NSNumber numberWithUnsignedShort:0U];
        params.startHue = [NSNumber numberWithUnsignedShort:0U];
        params.optionsMask = [NSNumber numberWithUnsignedChar:0];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:0];
        [cluster colorLoopSetWithParams:params
                      completionHandler:^(NSError * _Nullable err) {
                          NSLog(@"Sends ColorLoopSet Command - Set all Attributes Error: %@", err);

                          VerifyOrReturn(CheckValue("status", err, 0));

                          NextTest();
                      }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadColorLoopDirectionAttributeFromDut_6()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeColorLoopDirectionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read ColorLoopDirection attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("color loop direction", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSendsColorLoopSetCommandSetAllAttributes_7()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPColorControlClusterColorLoopSetParams alloc] init];
        params.updateFlags = [NSNumber numberWithUnsignedChar:4];
        params.action = [NSNumber numberWithUnsignedChar:0];
        params.direction = [NSNumber numberWithUnsignedChar:0];
        params.time = [NSNumber numberWithUnsignedShort:30U];
        params.startHue = [NSNumber numberWithUnsignedShort:0U];
        params.optionsMask = [NSNumber numberWithUnsignedChar:0];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:0];
        [cluster colorLoopSetWithParams:params
                      completionHandler:^(NSError * _Nullable err) {
                          NSLog(@"Sends ColorLoopSet Command - Set all Attributes Error: %@", err);

                          VerifyOrReturn(CheckValue("status", err, 0));

                          NextTest();
                      }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadColorLoopTimeAttributeFromDut_8()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeColorLoopTimeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read ColorLoopTime attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("color loop time", actualValue, 30U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSendsColorLoopSetCommandSetAllAttributes_9()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPColorControlClusterColorLoopSetParams alloc] init];
        params.updateFlags = [NSNumber numberWithUnsignedChar:8];
        params.action = [NSNumber numberWithUnsignedChar:0];
        params.direction = [NSNumber numberWithUnsignedChar:0];
        params.time = [NSNumber numberWithUnsignedShort:0U];
        params.startHue = [NSNumber numberWithUnsignedShort:160U];
        params.optionsMask = [NSNumber numberWithUnsignedChar:0];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:0];
        [cluster colorLoopSetWithParams:params
                      completionHandler:^(NSError * _Nullable err) {
                          NSLog(@"Sends ColorLoopSet Command - Set all Attributes Error: %@", err);

                          VerifyOrReturn(CheckValue("status", err, 0));

                          NextTest();
                      }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadColorLoopStartEnhancedHueAttributeFromDut_10()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster
            readAttributeColorLoopStartEnhancedHueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
                NSLog(@"Read ColorLoopStartEnhancedHue attribute from DUT Error: %@", err);

                VerifyOrReturn(CheckValue("status", err, 0));

                {
                    id actualValue = value;
                    VerifyOrReturn(CheckValue("color loop start enhanced hue", actualValue, 160U));
                }

                NextTest();
            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSendsColorLoopSetCommandSetAllAttributes_11()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPColorControlClusterColorLoopSetParams alloc] init];
        params.updateFlags = [NSNumber numberWithUnsignedChar:1];
        params.action = [NSNumber numberWithUnsignedChar:1];
        params.direction = [NSNumber numberWithUnsignedChar:0];
        params.time = [NSNumber numberWithUnsignedShort:0U];
        params.startHue = [NSNumber numberWithUnsignedShort:0U];
        params.optionsMask = [NSNumber numberWithUnsignedChar:0];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:0];
        [cluster colorLoopSetWithParams:params
                      completionHandler:^(NSError * _Nullable err) {
                          NSLog(@"Sends ColorLoopSet Command - Set all Attributes Error: %@", err);

                          VerifyOrReturn(CheckValue("status", err, 0));

                          NextTest();
                      }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadColorLoopActiveAttributeFromDut_12()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeColorLoopActiveWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read ColorLoopActive attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("color loop active", actualValue, 1));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
    NSNumber * _Nonnull EnhancedCurrentHueValue1;

    CHIP_ERROR TestReadEnhancedCurrentHueAttributeFromDut_13()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeEnhancedCurrentHueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read EnhancedCurrentHue attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("enhancedCurrentHue", "", "uint16"));
            {
                EnhancedCurrentHueValue1 = value;
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadColorLoopStoredEnhancedHueAttributeFromDut_14()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster
            readAttributeColorLoopStoredEnhancedHueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
                NSLog(@"Read ColorLoopStoredEnhancedHue attribute from DUT. Error: %@", err);

                VerifyOrReturn(CheckValue("status", err, 0));

                {
                    id actualValue = value;
                    VerifyOrReturn(CheckValue("color loop stored enhanced hue", actualValue, EnhancedCurrentHueValue1));
                }

                NextTest();
            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSendsColorLoopSetCommandSetAllAttributes_15()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPColorControlClusterColorLoopSetParams alloc] init];
        params.updateFlags = [NSNumber numberWithUnsignedChar:1];
        params.action = [NSNumber numberWithUnsignedChar:0];
        params.direction = [NSNumber numberWithUnsignedChar:0];
        params.time = [NSNumber numberWithUnsignedShort:0U];
        params.startHue = [NSNumber numberWithUnsignedShort:0U];
        params.optionsMask = [NSNumber numberWithUnsignedChar:0];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:0];
        [cluster colorLoopSetWithParams:params
                      completionHandler:^(NSError * _Nullable err) {
                          NSLog(@"Sends ColorLoopSet Command - Set all Attributes Error: %@", err);

                          VerifyOrReturn(CheckValue("status", err, 0));

                          NextTest();
                      }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadColorLoopActiveAttributeFromDut_16()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeColorLoopActiveWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read ColorLoopActive attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("color loop active", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
    NSNumber * _Nonnull ColorLoopStoredEnhancedHueValue1;

    CHIP_ERROR TestReadColorLoopStoredEnhancedHueAttributeFromDut_17()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster
            readAttributeColorLoopStoredEnhancedHueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
                NSLog(@"Read ColorLoopStoredEnhancedHue attribute from DUT. Error: %@", err);

                VerifyOrReturn(CheckValue("status", err, 0));

                VerifyOrReturn(CheckConstraintType("colorLoopStoredEnhancedHue", "", "uint16"));
                {
                    ColorLoopStoredEnhancedHueValue1 = value;
                }

                NextTest();
            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadEnhancedCurrentHueAttributeFromDut_18()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeEnhancedCurrentHueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read EnhancedCurrentHue attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("enhanced current hue", actualValue, ColorLoopStoredEnhancedHueValue1));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSendsColorLoopSetCommandSetAllAttributes_19()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPColorControlClusterColorLoopSetParams alloc] init];
        params.updateFlags = [NSNumber numberWithUnsignedChar:2];
        params.action = [NSNumber numberWithUnsignedChar:0];
        params.direction = [NSNumber numberWithUnsignedChar:1];
        params.time = [NSNumber numberWithUnsignedShort:0U];
        params.startHue = [NSNumber numberWithUnsignedShort:0U];
        params.optionsMask = [NSNumber numberWithUnsignedChar:0];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:0];
        [cluster colorLoopSetWithParams:params
                      completionHandler:^(NSError * _Nullable err) {
                          NSLog(@"Sends ColorLoopSet Command - Set all Attributes Error: %@", err);

                          VerifyOrReturn(CheckValue("status", err, 0));

                          NextTest();
                      }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadColorLoopDirectionAttributeFromDut_20()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeColorLoopDirectionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read ColorLoopDirection attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("color loop direction", actualValue, 1));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSendsColorLoopSetCommandSetAllAttributes_21()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPColorControlClusterColorLoopSetParams alloc] init];
        params.updateFlags = [NSNumber numberWithUnsignedChar:1];
        params.action = [NSNumber numberWithUnsignedChar:1];
        params.direction = [NSNumber numberWithUnsignedChar:0];
        params.time = [NSNumber numberWithUnsignedShort:0U];
        params.startHue = [NSNumber numberWithUnsignedShort:0U];
        params.optionsMask = [NSNumber numberWithUnsignedChar:0];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:0];
        [cluster colorLoopSetWithParams:params
                      completionHandler:^(NSError * _Nullable err) {
                          NSLog(@"Sends ColorLoopSet Command - Set all Attributes Error: %@", err);

                          VerifyOrReturn(CheckValue("status", err, 0));

                          NextTest();
                      }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadColorLoopActiveAttributeFromDut_22()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeColorLoopActiveWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read ColorLoopActive attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("color loop active", actualValue, 1));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
    NSNumber * _Nonnull EnhancedCurrentHueValue2;

    CHIP_ERROR TestReadEnhancedCurrentHueAttributeFromDut_23()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeEnhancedCurrentHueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read EnhancedCurrentHue attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("enhancedCurrentHue", "", "uint16"));
            {
                EnhancedCurrentHueValue2 = value;
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadColorLoopStoredEnhancedHueAttributeFromDut_24()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster
            readAttributeColorLoopStoredEnhancedHueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
                NSLog(@"Read ColorLoopStoredEnhancedHue attribute from DUT Error: %@", err);

                VerifyOrReturn(CheckValue("status", err, 0));

                {
                    id actualValue = value;
                    VerifyOrReturn(CheckValue("color loop stored enhanced hue", actualValue, EnhancedCurrentHueValue2));
                }

                NextTest();
            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSendsColorLoopSetCommandSetAllAttributes_25()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPColorControlClusterColorLoopSetParams alloc] init];
        params.updateFlags = [NSNumber numberWithUnsignedChar:1];
        params.action = [NSNumber numberWithUnsignedChar:0];
        params.direction = [NSNumber numberWithUnsignedChar:0];
        params.time = [NSNumber numberWithUnsignedShort:0U];
        params.startHue = [NSNumber numberWithUnsignedShort:0U];
        params.optionsMask = [NSNumber numberWithUnsignedChar:0];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:0];
        [cluster colorLoopSetWithParams:params
                      completionHandler:^(NSError * _Nullable err) {
                          NSLog(@"Sends ColorLoopSet Command - Set all Attributes Error: %@", err);

                          VerifyOrReturn(CheckValue("status", err, 0));

                          NextTest();
                      }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadColorLoopActiveAttributeFromDut_26()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeColorLoopActiveWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read ColorLoopActive attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("color loop active", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
    NSNumber * _Nonnull ColorLoopStoredEnhancedHueValue2;

    CHIP_ERROR TestReadColorLoopStoredEnhancedHueAttributeFromDut_27()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster
            readAttributeColorLoopStoredEnhancedHueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
                NSLog(@"Read ColorLoopStoredEnhancedHue attribute from DUT. Error: %@", err);

                VerifyOrReturn(CheckValue("status", err, 0));

                VerifyOrReturn(CheckConstraintType("colorLoopStoredEnhancedHue", "", "uint16"));
                {
                    ColorLoopStoredEnhancedHueValue2 = value;
                }

                NextTest();
            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadEnhancedCurrentHueAttributeFromDut_28()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeEnhancedCurrentHueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read EnhancedCurrentHue attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("enhanced current hue", actualValue, ColorLoopStoredEnhancedHueValue2));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestEnhancedMoveToHueCommand_29()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPColorControlClusterEnhancedMoveToHueParams alloc] init];
        params.enhancedHue = [NSNumber numberWithUnsignedShort:40960U];
        params.direction = [NSNumber numberWithUnsignedChar:0];
        params.transitionTime = [NSNumber numberWithUnsignedShort:0U];
        params.optionsMask = [NSNumber numberWithUnsignedChar:0];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:0];
        [cluster enhancedMoveToHueWithParams:params
                           completionHandler:^(NSError * _Nullable err) {
                               NSLog(@"Enhanced Move To Hue command Error: %@", err);

                               VerifyOrReturn(CheckValue("status", err, 0));

                               NextTest();
                           }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWait2000ms_30()
    {
        WaitForMs(2000);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadEnhancedCurrentHueAttributeFromDut_31()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeEnhancedCurrentHueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read EnhancedCurrentHue attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("enhanced current hue", actualValue, 40960U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSendsColorLoopSetCommandSetAllAttributes_32()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPColorControlClusterColorLoopSetParams alloc] init];
        params.updateFlags = [NSNumber numberWithUnsignedChar:2];
        params.action = [NSNumber numberWithUnsignedChar:0];
        params.direction = [NSNumber numberWithUnsignedChar:0];
        params.time = [NSNumber numberWithUnsignedShort:0U];
        params.startHue = [NSNumber numberWithUnsignedShort:0U];
        params.optionsMask = [NSNumber numberWithUnsignedChar:0];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:0];
        [cluster colorLoopSetWithParams:params
                      completionHandler:^(NSError * _Nullable err) {
                          NSLog(@"Sends ColorLoopSet Command - Set all Attributes Error: %@", err);

                          VerifyOrReturn(CheckValue("status", err, 0));

                          NextTest();
                      }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadColorLoopDirectionAttributeFromDut_33()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeColorLoopDirectionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read ColorLoopDirection attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("color loop direction", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSendsColorLoopSetCommandSetAllAttributes_34()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPColorControlClusterColorLoopSetParams alloc] init];
        params.updateFlags = [NSNumber numberWithUnsignedChar:1];
        params.action = [NSNumber numberWithUnsignedChar:2];
        params.direction = [NSNumber numberWithUnsignedChar:0];
        params.time = [NSNumber numberWithUnsignedShort:0U];
        params.startHue = [NSNumber numberWithUnsignedShort:0U];
        params.optionsMask = [NSNumber numberWithUnsignedChar:0];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:0];
        [cluster colorLoopSetWithParams:params
                      completionHandler:^(NSError * _Nullable err) {
                          NSLog(@"Sends ColorLoopSet Command - Set all Attributes Error: %@", err);

                          VerifyOrReturn(CheckValue("status", err, 0));

                          NextTest();
                      }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadColorLoopActiveAttributeFromDut_35()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeColorLoopActiveWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read ColorLoopActive attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("color loop active", actualValue, 1));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
    NSNumber * _Nonnull EnhancedCurrentHueValue3;

    CHIP_ERROR TestReadEnhancedCurrentHueAttributeFromDut_36()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeEnhancedCurrentHueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read EnhancedCurrentHue attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("enhancedCurrentHue", "", "uint16"));
            {
                EnhancedCurrentHueValue3 = value;
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadColorLoopStoredEnhancedHueAttributeFromDut_37()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster
            readAttributeColorLoopStoredEnhancedHueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
                NSLog(@"Read ColorLoopStoredEnhancedHue attribute from DUT Error: %@", err);

                VerifyOrReturn(CheckValue("status", err, 0));

                {
                    id actualValue = value;
                    VerifyOrReturn(CheckValue("color loop stored enhanced hue", actualValue, EnhancedCurrentHueValue3));
                }

                NextTest();
            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSendsColorLoopSetCommandSetAllAttributes_38()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPColorControlClusterColorLoopSetParams alloc] init];
        params.updateFlags = [NSNumber numberWithUnsignedChar:1];
        params.action = [NSNumber numberWithUnsignedChar:0];
        params.direction = [NSNumber numberWithUnsignedChar:0];
        params.time = [NSNumber numberWithUnsignedShort:0U];
        params.startHue = [NSNumber numberWithUnsignedShort:0U];
        params.optionsMask = [NSNumber numberWithUnsignedChar:0];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:0];
        [cluster colorLoopSetWithParams:params
                      completionHandler:^(NSError * _Nullable err) {
                          NSLog(@"Sends ColorLoopSet Command - Set all Attributes Error: %@", err);

                          VerifyOrReturn(CheckValue("status", err, 0));

                          NextTest();
                      }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadColorLoopActiveAttributeFromDut_39()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeColorLoopActiveWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read ColorLoopActive attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("color loop active", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
    NSNumber * _Nonnull ColorLoopStoredEnhancedHueValue3;

    CHIP_ERROR TestReadColorLoopStoredEnhancedHueAttributeFromDut_40()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster
            readAttributeColorLoopStoredEnhancedHueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
                NSLog(@"Read ColorLoopStoredEnhancedHue attribute from DUT. Error: %@", err);

                VerifyOrReturn(CheckValue("status", err, 0));

                VerifyOrReturn(CheckConstraintType("colorLoopStoredEnhancedHue", "", "uint16"));
                {
                    ColorLoopStoredEnhancedHueValue3 = value;
                }

                NextTest();
            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadEnhancedCurrentHueAttributeFromDut_41()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeEnhancedCurrentHueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read EnhancedCurrentHue attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("enhanced current hue", actualValue, ColorLoopStoredEnhancedHueValue3));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSendsColorLoopSetCommandSetAllAttributes_42()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPColorControlClusterColorLoopSetParams alloc] init];
        params.updateFlags = [NSNumber numberWithUnsignedChar:2];
        params.action = [NSNumber numberWithUnsignedChar:0];
        params.direction = [NSNumber numberWithUnsignedChar:1];
        params.time = [NSNumber numberWithUnsignedShort:0U];
        params.startHue = [NSNumber numberWithUnsignedShort:0U];
        params.optionsMask = [NSNumber numberWithUnsignedChar:0];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:0];
        [cluster colorLoopSetWithParams:params
                      completionHandler:^(NSError * _Nullable err) {
                          NSLog(@"Sends ColorLoopSet Command - Set all Attributes Error: %@", err);

                          VerifyOrReturn(CheckValue("status", err, 0));

                          NextTest();
                      }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadColorLoopDirectionAttributeFromDut_43()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeColorLoopDirectionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read ColorLoopDirection attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("color loop direction", actualValue, 1));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSendsColorLoopSetCommandSetAllAttributes_44()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPColorControlClusterColorLoopSetParams alloc] init];
        params.updateFlags = [NSNumber numberWithUnsignedChar:1];
        params.action = [NSNumber numberWithUnsignedChar:2];
        params.direction = [NSNumber numberWithUnsignedChar:0];
        params.time = [NSNumber numberWithUnsignedShort:0U];
        params.startHue = [NSNumber numberWithUnsignedShort:0U];
        params.optionsMask = [NSNumber numberWithUnsignedChar:0];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:0];
        [cluster colorLoopSetWithParams:params
                      completionHandler:^(NSError * _Nullable err) {
                          NSLog(@"Sends ColorLoopSet Command - Set all Attributes Error: %@", err);

                          VerifyOrReturn(CheckValue("status", err, 0));

                          NextTest();
                      }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadColorLoopActiveAttributeFromDut_45()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeColorLoopActiveWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read ColorLoopActive attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("color loop active", actualValue, 1));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
    NSNumber * _Nonnull EnhancedCurrentHueValue4;

    CHIP_ERROR TestReadEnhancedCurrentHueAttributeFromDut_46()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeEnhancedCurrentHueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read EnhancedCurrentHue attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("enhancedCurrentHue", "", "uint16"));
            {
                EnhancedCurrentHueValue4 = value;
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadColorLoopStoredEnhancedHueAttributeFromDut_47()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster
            readAttributeColorLoopStoredEnhancedHueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
                NSLog(@"Read ColorLoopStoredEnhancedHue attribute from DUT Error: %@", err);

                VerifyOrReturn(CheckValue("status", err, 0));

                {
                    id actualValue = value;
                    VerifyOrReturn(CheckValue("color loop stored enhanced hue", actualValue, EnhancedCurrentHueValue4));
                }

                NextTest();
            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSendsColorLoopSetCommandSetAllAttributes_48()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPColorControlClusterColorLoopSetParams alloc] init];
        params.updateFlags = [NSNumber numberWithUnsignedChar:1];
        params.action = [NSNumber numberWithUnsignedChar:0];
        params.direction = [NSNumber numberWithUnsignedChar:0];
        params.time = [NSNumber numberWithUnsignedShort:0U];
        params.startHue = [NSNumber numberWithUnsignedShort:0U];
        params.optionsMask = [NSNumber numberWithUnsignedChar:0];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:0];
        [cluster colorLoopSetWithParams:params
                      completionHandler:^(NSError * _Nullable err) {
                          NSLog(@"Sends ColorLoopSet Command - Set all Attributes Error: %@", err);

                          VerifyOrReturn(CheckValue("status", err, 0));

                          NextTest();
                      }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadColorLoopActiveAttributeFromDut_49()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeColorLoopActiveWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read ColorLoopActive attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("color loop active", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
    NSNumber * _Nonnull ColorLoopStoredEnhancedHue4;

    CHIP_ERROR TestReadColorLoopStoredEnhancedHueAttributeFromDut_50()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster
            readAttributeColorLoopStoredEnhancedHueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
                NSLog(@"Read ColorLoopStoredEnhancedHue attribute from DUT. Error: %@", err);

                VerifyOrReturn(CheckValue("status", err, 0));

                VerifyOrReturn(CheckConstraintType("colorLoopStoredEnhancedHue", "", "uint16"));
                {
                    ColorLoopStoredEnhancedHue4 = value;
                }

                NextTest();
            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadEnhancedCurrentHueAttributeFromDut_51()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeEnhancedCurrentHueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read EnhancedCurrentHue attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("enhanced current hue", actualValue, ColorLoopStoredEnhancedHue4));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestTurnOffLightForColorControlTests_52()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster offWithCompletionHandler:^(NSError * _Nullable err) {
            NSLog(@"Turn Off light for color control tests Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_53()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOnOffWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Check on/off attribute value is false after off command Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("OnOff", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
};

class Test_TC_CC_9_2 : public TestCommandBridge {
public:
    Test_TC_CC_9_2()
        : TestCommandBridge("Test_TC_CC_9_2")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_CC_9_2() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_9_2\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_9_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Precondition: Turn on light for color control tests\n");
            err = TestPreconditionTurnOnLightForColorControlTests_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Precondition: Check on/off attribute value is true after on command\n");
            err = TestPreconditionCheckOnOffAttributeValueIsTrueAfterOnCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Sends ColorLoopSet Command - Set all Attributes\n");
            if (ShouldSkip("CR_COLORLOOPSET")) {
                NextTest();
                return;
            }
            err = TestSendsColorLoopSetCommandSetAllAttributes_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Read ColorLoopActive attribute from DUT\n");
            if (ShouldSkip("A_COLORLOOPACTIVE")) {
                NextTest();
                return;
            }
            err = TestReadColorLoopActiveAttributeFromDut_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Read ColorLoopDirection attribute from DUT.\n");
            if (ShouldSkip("A_COLORLOOPDIRECTION")) {
                NextTest();
                return;
            }
            err = TestReadColorLoopDirectionAttributeFromDut_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Read ColorLoopTime attribute from DUT.\n");
            if (ShouldSkip("A_COLORLOOPTIME")) {
                NextTest();
                return;
            }
            err = TestReadColorLoopTimeAttributeFromDut_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Read ColorLoopStartEnhancedHue attribute from DUT.\n");
            if (ShouldSkip("A_COLORLOOPSTARTENHANCEDHUE")) {
                NextTest();
                return;
            }
            err = TestReadColorLoopStartEnhancedHueAttributeFromDut_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Color Loop Set Command - Set all Attributes\n");
            if (ShouldSkip("CR_COLORLOOPSET")) {
                NextTest();
                return;
            }
            err = TestColorLoopSetCommandSetAllAttributes_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Read ColorLoopActive attribute from DUT.\n");
            if (ShouldSkip("A_COLORLOOPACTIVE")) {
                NextTest();
                return;
            }
            err = TestReadColorLoopActiveAttributeFromDut_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Read EnhancedCurrentHue attribute from DUT.\n");
            if (ShouldSkip("A_ENHANCEDCURRENTHUE")) {
                NextTest();
                return;
            }
            err = TestReadEnhancedCurrentHueAttributeFromDut_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : Read ColorLoopStoredEnhancedHue attribute from DUT.\n");
            if (ShouldSkip("A_COLORLOOPSTOREDENHANCEDHUE")) {
                NextTest();
                return;
            }
            err = TestReadColorLoopStoredEnhancedHueAttributeFromDut_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : Color Loop Set Command - Start Color Loop\n");
            if (ShouldSkip("CR_COLORLOOPSET")) {
                NextTest();
                return;
            }
            err = TestColorLoopSetCommandStartColorLoop_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : Read ColorLoopDirection attribute from DUT.\n");
            if (ShouldSkip("A_COLORLOOPDIRECTION")) {
                NextTest();
                return;
            }
            err = TestReadColorLoopDirectionAttributeFromDut_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : Color Loop Set Command - Start Color Loop\n");
            if (ShouldSkip("CR_COLORLOOPSET")) {
                NextTest();
                return;
            }
            err = TestColorLoopSetCommandStartColorLoop_14();
            break;
        case 15:
            ChipLogProgress(chipTool, " ***** Test Step 15 : Read ColorLoopActive attribute from DUT\n");
            if (ShouldSkip("A_COLORLOOPACTIVE")) {
                NextTest();
                return;
            }
            err = TestReadColorLoopActiveAttributeFromDut_15();
            break;
        case 16:
            ChipLogProgress(chipTool, " ***** Test Step 16 : Read ColorLoopStoredEnhancedHue attribute from DUT.\n");
            if (ShouldSkip("A_COLORLOOPSTOREDENHANCEDHUE")) {
                NextTest();
                return;
            }
            err = TestReadColorLoopStoredEnhancedHueAttributeFromDut_16();
            break;
        case 17:
            ChipLogProgress(chipTool, " ***** Test Step 17 : Read EnhancedCurrentHue attribute from DUT.\n");
            if (ShouldSkip("A_ENHANCEDCURRENTHUE")) {
                NextTest();
                return;
            }
            err = TestReadEnhancedCurrentHueAttributeFromDut_17();
            break;
        case 18:
            ChipLogProgress(chipTool, " ***** Test Step 18 : Turn off light for color control tests\n");
            err = TestTurnOffLightForColorControlTests_18();
            break;
        case 19:
            ChipLogProgress(chipTool, " ***** Test Step 19 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_19();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 20;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestPreconditionTurnOnLightForColorControlTests_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster onWithCompletionHandler:^(NSError * _Nullable err) {
            NSLog(@"Precondition: Turn on light for color control tests Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestPreconditionCheckOnOffAttributeValueIsTrueAfterOnCommand_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOnOffWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Precondition: Check on/off attribute value is true after on command Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("OnOff", actualValue, 1));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSendsColorLoopSetCommandSetAllAttributes_3()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPColorControlClusterColorLoopSetParams alloc] init];
        params.updateFlags = [NSNumber numberWithUnsignedChar:15];
        params.action = [NSNumber numberWithUnsignedChar:0];
        params.direction = [NSNumber numberWithUnsignedChar:0];
        params.time = [NSNumber numberWithUnsignedShort:30U];
        params.startHue = [NSNumber numberWithUnsignedShort:160U];
        params.optionsMask = [NSNumber numberWithUnsignedChar:0];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:0];
        [cluster colorLoopSetWithParams:params
                      completionHandler:^(NSError * _Nullable err) {
                          NSLog(@"Sends ColorLoopSet Command - Set all Attributes Error: %@", err);

                          VerifyOrReturn(CheckValue("status", err, 0));

                          NextTest();
                      }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadColorLoopActiveAttributeFromDut_4()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeColorLoopActiveWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read ColorLoopActive attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("color loop active", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadColorLoopDirectionAttributeFromDut_5()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeColorLoopDirectionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read ColorLoopDirection attribute from DUT. Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("color loop direction", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadColorLoopTimeAttributeFromDut_6()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeColorLoopTimeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read ColorLoopTime attribute from DUT. Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("color loop time", actualValue, 30U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadColorLoopStartEnhancedHueAttributeFromDut_7()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster
            readAttributeColorLoopStartEnhancedHueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
                NSLog(@"Read ColorLoopStartEnhancedHue attribute from DUT. Error: %@", err);

                VerifyOrReturn(CheckValue("status", err, 0));

                {
                    id actualValue = value;
                    VerifyOrReturn(CheckValue("color loop start enhanced hue", actualValue, 160U));
                }

                NextTest();
            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestColorLoopSetCommandSetAllAttributes_8()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPColorControlClusterColorLoopSetParams alloc] init];
        params.updateFlags = [NSNumber numberWithUnsignedChar:1];
        params.action = [NSNumber numberWithUnsignedChar:1];
        params.direction = [NSNumber numberWithUnsignedChar:0];
        params.time = [NSNumber numberWithUnsignedShort:0U];
        params.startHue = [NSNumber numberWithUnsignedShort:0U];
        params.optionsMask = [NSNumber numberWithUnsignedChar:0];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:0];
        [cluster colorLoopSetWithParams:params
                      completionHandler:^(NSError * _Nullable err) {
                          NSLog(@"Color Loop Set Command - Set all Attributes Error: %@", err);

                          VerifyOrReturn(CheckValue("status", err, 0));

                          NextTest();
                      }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadColorLoopActiveAttributeFromDut_9()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeColorLoopActiveWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read ColorLoopActive attribute from DUT. Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("color loop active", actualValue, 1));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
    NSNumber * _Nonnull EnhancedCurrentHueValue;

    CHIP_ERROR TestReadEnhancedCurrentHueAttributeFromDut_10()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeEnhancedCurrentHueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read EnhancedCurrentHue attribute from DUT. Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("enhancedCurrentHue", "", "uint16"));
            {
                EnhancedCurrentHueValue = value;
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadColorLoopStoredEnhancedHueAttributeFromDut_11()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster
            readAttributeColorLoopStoredEnhancedHueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
                NSLog(@"Read ColorLoopStoredEnhancedHue attribute from DUT. Error: %@", err);

                VerifyOrReturn(CheckValue("status", err, 0));

                {
                    id actualValue = value;
                    VerifyOrReturn(CheckValue("color loop stored enhanced hue", actualValue, EnhancedCurrentHueValue));
                }

                NextTest();
            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestColorLoopSetCommandStartColorLoop_12()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPColorControlClusterColorLoopSetParams alloc] init];
        params.updateFlags = [NSNumber numberWithUnsignedChar:2];
        params.action = [NSNumber numberWithUnsignedChar:0];
        params.direction = [NSNumber numberWithUnsignedChar:1];
        params.time = [NSNumber numberWithUnsignedShort:0U];
        params.startHue = [NSNumber numberWithUnsignedShort:0U];
        params.optionsMask = [NSNumber numberWithUnsignedChar:0];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:0];
        [cluster colorLoopSetWithParams:params
                      completionHandler:^(NSError * _Nullable err) {
                          NSLog(@"Color Loop Set Command - Start Color Loop Error: %@", err);

                          VerifyOrReturn(CheckValue("status", err, 0));

                          NextTest();
                      }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadColorLoopDirectionAttributeFromDut_13()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeColorLoopDirectionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read ColorLoopDirection attribute from DUT. Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("color loop direction", actualValue, 1));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestColorLoopSetCommandStartColorLoop_14()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPColorControlClusterColorLoopSetParams alloc] init];
        params.updateFlags = [NSNumber numberWithUnsignedChar:1];
        params.action = [NSNumber numberWithUnsignedChar:0];
        params.direction = [NSNumber numberWithUnsignedChar:0];
        params.time = [NSNumber numberWithUnsignedShort:0U];
        params.startHue = [NSNumber numberWithUnsignedShort:0U];
        params.optionsMask = [NSNumber numberWithUnsignedChar:0];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:0];
        [cluster colorLoopSetWithParams:params
                      completionHandler:^(NSError * _Nullable err) {
                          NSLog(@"Color Loop Set Command - Start Color Loop Error: %@", err);

                          VerifyOrReturn(CheckValue("status", err, 0));

                          NextTest();
                      }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadColorLoopActiveAttributeFromDut_15()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeColorLoopActiveWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read ColorLoopActive attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("color loop active", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
    NSNumber * _Nonnull ColorLoopStoredEnhancedHueValue;

    CHIP_ERROR TestReadColorLoopStoredEnhancedHueAttributeFromDut_16()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster
            readAttributeColorLoopStoredEnhancedHueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
                NSLog(@"Read ColorLoopStoredEnhancedHue attribute from DUT. Error: %@", err);

                VerifyOrReturn(CheckValue("status", err, 0));

                VerifyOrReturn(CheckConstraintType("colorLoopStoredEnhancedHue", "", "uint16"));
                {
                    ColorLoopStoredEnhancedHueValue = value;
                }

                NextTest();
            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadEnhancedCurrentHueAttributeFromDut_17()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeEnhancedCurrentHueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read EnhancedCurrentHue attribute from DUT. Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("enhanced current hue", actualValue, ColorLoopStoredEnhancedHueValue));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestTurnOffLightForColorControlTests_18()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster offWithCompletionHandler:^(NSError * _Nullable err) {
            NSLog(@"Turn off light for color control tests Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_19()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOnOffWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Check on/off attribute value is false after off command Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("OnOff", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
};

class Test_TC_CC_9_3 : public TestCommandBridge {
public:
    Test_TC_CC_9_3()
        : TestCommandBridge("Test_TC_CC_9_3")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_CC_9_3() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_9_3\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_9_3\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Precondition: Turn on light for color control tests\n");
            err = TestPreconditionTurnOnLightForColorControlTests_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Precondition: Check on/off attribute value is true after on command\n");
            err = TestPreconditionCheckOnOffAttributeValueIsTrueAfterOnCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Sends ColorLoopSet Command - Set all Attributes\n");
            if (ShouldSkip("CR_COLORLOOPSET")) {
                NextTest();
                return;
            }
            err = TestSendsColorLoopSetCommandSetAllAttributes_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Read ColorLoopActive attribute from DUT\n");
            if (ShouldSkip("A_COLORLOOPACTIVE")) {
                NextTest();
                return;
            }
            err = TestReadColorLoopActiveAttributeFromDut_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Read ColorLoopDirection attribute from DUT.\n");
            if (ShouldSkip("A_COLORLOOPDIRECTION")) {
                NextTest();
                return;
            }
            err = TestReadColorLoopDirectionAttributeFromDut_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Read ColorLoopTime attribute from DUT.\n");
            if (ShouldSkip("A_COLORLOOPTIME")) {
                NextTest();
                return;
            }
            err = TestReadColorLoopTimeAttributeFromDut_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Read ColorLoopStartEnhancedHue attribute from DUT.\n");
            if (ShouldSkip("A_COLORLOOPSTARTENHANCEDHUE")) {
                NextTest();
                return;
            }
            err = TestReadColorLoopStartEnhancedHueAttributeFromDut_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Color Loop Set Command - Set all Attributes\n");
            if (ShouldSkip("CR_COLORLOOPSET")) {
                NextTest();
                return;
            }
            err = TestColorLoopSetCommandSetAllAttributes_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Read ColorLoopActive attribute from DUT.\n");
            if (ShouldSkip("A_COLORLOOPACTIVE")) {
                NextTest();
                return;
            }
            err = TestReadColorLoopActiveAttributeFromDut_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Read EnhancedCurrentHue attribute from DUT.\n");
            if (ShouldSkip("A_ENHANCEDCURRENTHUE")) {
                NextTest();
                return;
            }
            err = TestReadEnhancedCurrentHueAttributeFromDut_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : Read ColorLoopStoredEnhancedHue attribute from DUT.\n");
            if (ShouldSkip("A_COLORLOOPSTOREDENHANCEDHUE")) {
                NextTest();
                return;
            }
            err = TestReadColorLoopStoredEnhancedHueAttributeFromDut_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : Color Loop Set Command - Start Color Loop\n");
            if (ShouldSkip("CR_COLORLOOPSET")) {
                NextTest();
                return;
            }
            err = TestColorLoopSetCommandStartColorLoop_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : Read ColorLoopTime attribute from DUT.\n");
            if (ShouldSkip("A_COLORLOOPTIME")) {
                NextTest();
                return;
            }
            err = TestReadColorLoopTimeAttributeFromDut_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : Color Loop Set Command - Start Color Loop\n");
            if (ShouldSkip("CR_COLORLOOPSET")) {
                NextTest();
                return;
            }
            err = TestColorLoopSetCommandStartColorLoop_14();
            break;
        case 15:
            ChipLogProgress(chipTool, " ***** Test Step 15 : Read ColorLoopActive attribute from DUT\n");
            if (ShouldSkip("A_COLORLOOPACTIVE")) {
                NextTest();
                return;
            }
            err = TestReadColorLoopActiveAttributeFromDut_15();
            break;
        case 16:
            ChipLogProgress(chipTool, " ***** Test Step 16 : Read ColorLoopStoredEnhancedHue attribute from DUT.\n");
            if (ShouldSkip("A_COLORLOOPSTOREDENHANCEDHUE")) {
                NextTest();
                return;
            }
            err = TestReadColorLoopStoredEnhancedHueAttributeFromDut_16();
            break;
        case 17:
            ChipLogProgress(chipTool, " ***** Test Step 17 : Read EnhancedCurrentHue attribute from DUT.\n");
            if (ShouldSkip("A_ENHANCEDCURRENTHUE")) {
                NextTest();
                return;
            }
            err = TestReadEnhancedCurrentHueAttributeFromDut_17();
            break;
        case 18:
            ChipLogProgress(chipTool, " ***** Test Step 18 : Turn off light for color control tests\n");
            err = TestTurnOffLightForColorControlTests_18();
            break;
        case 19:
            ChipLogProgress(chipTool, " ***** Test Step 19 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_19();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 20;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestPreconditionTurnOnLightForColorControlTests_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster onWithCompletionHandler:^(NSError * _Nullable err) {
            NSLog(@"Precondition: Turn on light for color control tests Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestPreconditionCheckOnOffAttributeValueIsTrueAfterOnCommand_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOnOffWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Precondition: Check on/off attribute value is true after on command Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("OnOff", actualValue, 1));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSendsColorLoopSetCommandSetAllAttributes_3()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPColorControlClusterColorLoopSetParams alloc] init];
        params.updateFlags = [NSNumber numberWithUnsignedChar:15];
        params.action = [NSNumber numberWithUnsignedChar:0];
        params.direction = [NSNumber numberWithUnsignedChar:0];
        params.time = [NSNumber numberWithUnsignedShort:30U];
        params.startHue = [NSNumber numberWithUnsignedShort:160U];
        params.optionsMask = [NSNumber numberWithUnsignedChar:0];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:0];
        [cluster colorLoopSetWithParams:params
                      completionHandler:^(NSError * _Nullable err) {
                          NSLog(@"Sends ColorLoopSet Command - Set all Attributes Error: %@", err);

                          VerifyOrReturn(CheckValue("status", err, 0));

                          NextTest();
                      }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadColorLoopActiveAttributeFromDut_4()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeColorLoopActiveWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read ColorLoopActive attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("color loop active", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadColorLoopDirectionAttributeFromDut_5()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeColorLoopDirectionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read ColorLoopDirection attribute from DUT. Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("color loop direction", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadColorLoopTimeAttributeFromDut_6()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeColorLoopTimeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read ColorLoopTime attribute from DUT. Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("color loop time", actualValue, 30U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadColorLoopStartEnhancedHueAttributeFromDut_7()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster
            readAttributeColorLoopStartEnhancedHueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
                NSLog(@"Read ColorLoopStartEnhancedHue attribute from DUT. Error: %@", err);

                VerifyOrReturn(CheckValue("status", err, 0));

                {
                    id actualValue = value;
                    VerifyOrReturn(CheckValue("color loop start enhanced hue", actualValue, 160U));
                }

                NextTest();
            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestColorLoopSetCommandSetAllAttributes_8()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPColorControlClusterColorLoopSetParams alloc] init];
        params.updateFlags = [NSNumber numberWithUnsignedChar:1];
        params.action = [NSNumber numberWithUnsignedChar:1];
        params.direction = [NSNumber numberWithUnsignedChar:0];
        params.time = [NSNumber numberWithUnsignedShort:0U];
        params.startHue = [NSNumber numberWithUnsignedShort:0U];
        params.optionsMask = [NSNumber numberWithUnsignedChar:0];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:0];
        [cluster colorLoopSetWithParams:params
                      completionHandler:^(NSError * _Nullable err) {
                          NSLog(@"Color Loop Set Command - Set all Attributes Error: %@", err);

                          VerifyOrReturn(CheckValue("status", err, 0));

                          NextTest();
                      }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadColorLoopActiveAttributeFromDut_9()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeColorLoopActiveWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read ColorLoopActive attribute from DUT. Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("color loop active", actualValue, 1));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
    NSNumber * _Nonnull EnhancedCurrentHueValue;

    CHIP_ERROR TestReadEnhancedCurrentHueAttributeFromDut_10()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeEnhancedCurrentHueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read EnhancedCurrentHue attribute from DUT. Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("enhancedCurrentHue", "", "uint16"));
            {
                EnhancedCurrentHueValue = value;
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadColorLoopStoredEnhancedHueAttributeFromDut_11()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster
            readAttributeColorLoopStoredEnhancedHueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
                NSLog(@"Read ColorLoopStoredEnhancedHue attribute from DUT. Error: %@", err);

                VerifyOrReturn(CheckValue("status", err, 0));

                {
                    id actualValue = value;
                    VerifyOrReturn(CheckValue("color loop stored enhanced hue", actualValue, EnhancedCurrentHueValue));
                }

                NextTest();
            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestColorLoopSetCommandStartColorLoop_12()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPColorControlClusterColorLoopSetParams alloc] init];
        params.updateFlags = [NSNumber numberWithUnsignedChar:4];
        params.action = [NSNumber numberWithUnsignedChar:0];
        params.direction = [NSNumber numberWithUnsignedChar:0];
        params.time = [NSNumber numberWithUnsignedShort:60U];
        params.startHue = [NSNumber numberWithUnsignedShort:0U];
        params.optionsMask = [NSNumber numberWithUnsignedChar:0];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:0];
        [cluster colorLoopSetWithParams:params
                      completionHandler:^(NSError * _Nullable err) {
                          NSLog(@"Color Loop Set Command - Start Color Loop Error: %@", err);

                          VerifyOrReturn(CheckValue("status", err, 0));

                          NextTest();
                      }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadColorLoopTimeAttributeFromDut_13()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeColorLoopTimeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read ColorLoopTime attribute from DUT. Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("color loop time", actualValue, 60U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestColorLoopSetCommandStartColorLoop_14()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPColorControlClusterColorLoopSetParams alloc] init];
        params.updateFlags = [NSNumber numberWithUnsignedChar:1];
        params.action = [NSNumber numberWithUnsignedChar:0];
        params.direction = [NSNumber numberWithUnsignedChar:0];
        params.time = [NSNumber numberWithUnsignedShort:0U];
        params.startHue = [NSNumber numberWithUnsignedShort:0U];
        params.optionsMask = [NSNumber numberWithUnsignedChar:0];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:0];
        [cluster colorLoopSetWithParams:params
                      completionHandler:^(NSError * _Nullable err) {
                          NSLog(@"Color Loop Set Command - Start Color Loop Error: %@", err);

                          VerifyOrReturn(CheckValue("status", err, 0));

                          NextTest();
                      }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadColorLoopActiveAttributeFromDut_15()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeColorLoopActiveWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read ColorLoopActive attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("color loop active", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
    NSNumber * _Nonnull ColorLoopStoredEnhancedHueValue;

    CHIP_ERROR TestReadColorLoopStoredEnhancedHueAttributeFromDut_16()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster
            readAttributeColorLoopStoredEnhancedHueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
                NSLog(@"Read ColorLoopStoredEnhancedHue attribute from DUT. Error: %@", err);

                VerifyOrReturn(CheckValue("status", err, 0));

                VerifyOrReturn(CheckConstraintType("colorLoopStoredEnhancedHue", "", "uint16"));
                {
                    ColorLoopStoredEnhancedHueValue = value;
                }

                NextTest();
            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadEnhancedCurrentHueAttributeFromDut_17()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestColorControl * cluster = [[CHIPTestColorControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeEnhancedCurrentHueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read EnhancedCurrentHue attribute from DUT. Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("enhanced current hue", actualValue, ColorLoopStoredEnhancedHueValue));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestTurnOffLightForColorControlTests_18()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster offWithCompletionHandler:^(NSError * _Nullable err) {
            NSLog(@"Turn off light for color control tests Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_19()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOnOffWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Check on/off attribute value is false after off command Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("OnOff", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
};

class Test_TC_DD_1_5 : public TestCommandBridge {
public:
    Test_TC_DD_1_5()
        : TestCommandBridge("Test_TC_DD_1_5")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_DD_1_5() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_DD_1_5\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_DD_1_5\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Step 1\n");
            err = TestStep1_0();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestStep1_0()
    {
        Log(@"Verify that the onboarding payload for NFC tags SHALL use NDEF URI Record Type Definition as defined by NFC Forum in "
            @"URI Record Type Definition RTD URI");
        return CHIP_NO_ERROR;
    }
};

class Test_TC_DD_1_6 : public TestCommandBridge {
public:
    Test_TC_DD_1_6()
        : TestCommandBridge("Test_TC_DD_1_6")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_DD_1_6() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_DD_1_6\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_DD_1_6\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Step 1\n");
            err = TestStep1_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Step 1 verification\n");
            err = TestStep1Verification_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Step 2 verificaiton\n");
            err = TestStep2Verificaiton_2();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 3;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestStep1_0()
    {
        Log(@"Scan the DUTs QR code using a QR code reader");
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestStep1Verification_1()
    {
        Log(@"Verify the QR code gets scanned successfully and the QR code must be of sufficient size and contrast respective to "
            @"surface material as to be readable with standard readers such as smartphones in normal lighting conditions");
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestStep2Verificaiton_2()
    {
        Log(@"Verify QR code version is 1 or higher");
        return CHIP_NO_ERROR;
    }
};

class Test_TC_DD_1_7 : public TestCommandBridge {
public:
    Test_TC_DD_1_7()
        : TestCommandBridge("Test_TC_DD_1_7")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_DD_1_7() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_DD_1_7\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_DD_1_7\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Precondition\n");
            err = TestPrecondition_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Step 1\n");
            err = TestStep1_1();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 2;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestPrecondition_0()
    {
        Log(@"Verify manual pairing code is printed on the device or in additional provided materials");
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestStep1_1()
    {
        Log(@"Verify that the Manual Pairing Code should be printed using a minimum font size of 6 points typically producing a "
            @"typeface height of 2.1 mm");
        return CHIP_NO_ERROR;
    }
};

class Test_TC_DD_1_8 : public TestCommandBridge {
public:
    Test_TC_DD_1_8()
        : TestCommandBridge("Test_TC_DD_1_8")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_DD_1_8() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_DD_1_8\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_DD_1_8\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Step 1\n");
            err = TestStep1_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Step 1 verification\n");
            err = TestStep1Verification_1();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 2;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestStep1_0()
    {
        Log(@"Scan the device QR code using DUT");
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestStep1Verification_1()
    {
        Log(@"Verify the DUT is able to scan and parse the QR code successfully to onboard the device onto the CHIP network");
        return CHIP_NO_ERROR;
    }
};

class Test_TC_DD_1_9 : public TestCommandBridge {
public:
    Test_TC_DD_1_9()
        : TestCommandBridge("Test_TC_DD_1_9")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_DD_1_9() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_DD_1_9\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_DD_1_9\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Precondition\n");
            err = TestPrecondition_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Step 1\n");
            err = TestStep1_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Step 1 verification\n");
            err = TestStep1Verification_2();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 3;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestPrecondition_0()
    {
        Log(@"Verify that the manual pairing code is printed on the device or in additional provided materials");
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestStep1_1()
    {
        Log(@"Provide the 11 digit or 21 digit pairing code from the Device in text speech or any format supported by DUT");
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestStep1Verification_2()
    {
        Log(@"Verify that the manual pairing code can be provided to DUT and parsed to onboard the device onto the CHIP network");
        return CHIP_NO_ERROR;
    }
};

class Test_TC_DM_1_1 : public TestCommandBridge {
public:
    Test_TC_DM_1_1()
        : TestCommandBridge("Test_TC_DM_1_1")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_DM_1_1() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_DM_1_1\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_DM_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Query Data Model Revision\n");
            err = TestQueryDataModelRevision_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Query Vendor Name\n");
            err = TestQueryVendorName_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Query VendorID\n");
            err = TestQueryVendorID_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Query Product Name\n");
            err = TestQueryProductName_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Query ProductID\n");
            err = TestQueryProductID_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Query Node Label\n");
            err = TestQueryNodeLabel_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Query User Location\n");
            err = TestQueryUserLocation_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Query HardwareVersion\n");
            err = TestQueryHardwareVersion_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Query HardwareVersionString\n");
            err = TestQueryHardwareVersionString_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Query SoftwareVersion\n");
            err = TestQuerySoftwareVersion_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : Query SoftwareVersionString\n");
            err = TestQuerySoftwareVersionString_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : Query ManufacturingDate\n");
            if (ShouldSkip("MANF_DATE")) {
                NextTest();
                return;
            }
            err = TestQueryManufacturingDate_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : Query PartNumber\n");
            if (ShouldSkip("PART_NUM")) {
                NextTest();
                return;
            }
            err = TestQueryPartNumber_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : Query ProductURL\n");
            err = TestQueryProductURL_14();
            break;
        case 15:
            ChipLogProgress(chipTool, " ***** Test Step 15 : Query ProductLabel\n");
            err = TestQueryProductLabel_15();
            break;
        case 16:
            ChipLogProgress(chipTool, " ***** Test Step 16 : Query SerialNumber\n");
            err = TestQuerySerialNumber_16();
            break;
        case 17:
            ChipLogProgress(chipTool, " ***** Test Step 17 : Query LocalConfigDisabled\n");
            err = TestQueryLocalConfigDisabled_17();
            break;
        case 18:
            ChipLogProgress(chipTool, " ***** Test Step 18 : Query Reachable\n");
            err = TestQueryReachable_18();
            break;
        case 19:
            ChipLogProgress(chipTool, " ***** Test Step 19 : Query UniqueID\n");
            err = TestQueryUniqueID_19();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 20;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestQueryDataModelRevision_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestBasic * cluster = [[CHIPTestBasic alloc] initWithDevice:device endpoint:0 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeDataModelRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Query Data Model Revision Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("dataModelRevision", "", "uint16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestQueryVendorName_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestBasic * cluster = [[CHIPTestBasic alloc] initWithDevice:device endpoint:0 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeVendorNameWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Query Vendor Name Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("vendorName", "", "string"));
            VerifyOrReturn(CheckConstraintMaxLength("vendorName", [value length], 32));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestQueryVendorID_3()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestBasic * cluster = [[CHIPTestBasic alloc] initWithDevice:device endpoint:0 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeVendorIDWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Query VendorID Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("vendorID", "", "uint16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestQueryProductName_4()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestBasic * cluster = [[CHIPTestBasic alloc] initWithDevice:device endpoint:0 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeProductNameWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Query Product Name Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("productName", "", "string"));
            VerifyOrReturn(CheckConstraintMaxLength("productName", [value length], 32));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestQueryProductID_5()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestBasic * cluster = [[CHIPTestBasic alloc] initWithDevice:device endpoint:0 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeProductIDWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Query ProductID Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("productID", "", "uint16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestQueryNodeLabel_6()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestBasic * cluster = [[CHIPTestBasic alloc] initWithDevice:device endpoint:0 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNodeLabelWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Query Node Label Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("nodeLabel", "", "string"));
            VerifyOrReturn(CheckConstraintMaxLength("nodeLabel", [value length], 32));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestQueryUserLocation_7()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestBasic * cluster = [[CHIPTestBasic alloc] initWithDevice:device endpoint:0 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeLocationWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Query User Location Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("location", "", "string"));
            VerifyOrReturn(CheckConstraintFormat("location", "", "ISO 3166-1 alpha-2"));
            VerifyOrReturn(CheckConstraintMaxLength("location", [value length], 2));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestQueryHardwareVersion_8()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestBasic * cluster = [[CHIPTestBasic alloc] initWithDevice:device endpoint:0 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeHardwareVersionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Query HardwareVersion Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("hardwareVersion", "", "uint16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestQueryHardwareVersionString_9()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestBasic * cluster = [[CHIPTestBasic alloc] initWithDevice:device endpoint:0 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeHardwareVersionStringWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Query HardwareVersionString Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("hardwareVersionString", "", "string"));
            VerifyOrReturn(CheckConstraintMinLength("hardwareVersionString", [value length], 1));
            VerifyOrReturn(CheckConstraintMaxLength("hardwareVersionString", [value length], 64));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestQuerySoftwareVersion_10()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestBasic * cluster = [[CHIPTestBasic alloc] initWithDevice:device endpoint:0 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeSoftwareVersionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Query SoftwareVersion Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("softwareVersion", "", "uint32"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestQuerySoftwareVersionString_11()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestBasic * cluster = [[CHIPTestBasic alloc] initWithDevice:device endpoint:0 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeSoftwareVersionStringWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Query SoftwareVersionString Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("softwareVersionString", "", "string"));
            VerifyOrReturn(CheckConstraintFormat("softwareVersionString", "", "ASCII"));
            VerifyOrReturn(CheckConstraintMinLength("softwareVersionString", [value length], 1));
            VerifyOrReturn(CheckConstraintMaxLength("softwareVersionString", [value length], 64));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestQueryManufacturingDate_12()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestBasic * cluster = [[CHIPTestBasic alloc] initWithDevice:device endpoint:0 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeManufacturingDateWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Query ManufacturingDate Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("manufacturingDate", "", "string"));
            VerifyOrReturn(CheckConstraintFormat("manufacturingDate", "", "ISO 8601"));
            VerifyOrReturn(CheckConstraintMinLength("manufacturingDate", [value length], 8));
            VerifyOrReturn(CheckConstraintMaxLength("manufacturingDate", [value length], 16));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestQueryPartNumber_13()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestBasic * cluster = [[CHIPTestBasic alloc] initWithDevice:device endpoint:0 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributePartNumberWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Query PartNumber Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("partNumber", "", "string"));
            VerifyOrReturn(CheckConstraintMaxLength("partNumber", [value length], 32));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestQueryProductURL_14()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestBasic * cluster = [[CHIPTestBasic alloc] initWithDevice:device endpoint:0 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeProductURLWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Query ProductURL Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("productURL", "", "string"));
            VerifyOrReturn(CheckConstraintFormat("productURL", "", "RFC3986"));
            VerifyOrReturn(CheckConstraintMaxLength("productURL", [value length], 256));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestQueryProductLabel_15()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestBasic * cluster = [[CHIPTestBasic alloc] initWithDevice:device endpoint:0 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeProductLabelWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Query ProductLabel Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("productLabel", "", "string"));
            VerifyOrReturn(CheckConstraintMaxLength("productLabel", [value length], 64));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestQuerySerialNumber_16()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestBasic * cluster = [[CHIPTestBasic alloc] initWithDevice:device endpoint:0 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeSerialNumberWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Query SerialNumber Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("serialNumber", "", "string"));
            VerifyOrReturn(CheckConstraintMaxLength("serialNumber", [value length], 32));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestQueryLocalConfigDisabled_17()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestBasic * cluster = [[CHIPTestBasic alloc] initWithDevice:device endpoint:0 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeLocalConfigDisabledWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Query LocalConfigDisabled Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("localConfigDisabled", "", "boolean"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestQueryReachable_18()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestBasic * cluster = [[CHIPTestBasic alloc] initWithDevice:device endpoint:0 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeReachableWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Query Reachable Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("reachable", "", "boolean"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestQueryUniqueID_19()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestBasic * cluster = [[CHIPTestBasic alloc] initWithDevice:device endpoint:0 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeUniqueIDWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Query UniqueID Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("uniqueID", "", "string"));
            VerifyOrReturn(CheckConstraintMaxLength("uniqueID", [value length], 32));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
};

class Test_TC_DM_3_1 : public TestCommandBridge {
public:
    Test_TC_DM_3_1()
        : TestCommandBridge("Test_TC_DM_3_1")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_DM_3_1() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_DM_3_1\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_DM_3_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Query MaxNetworks\n");
            err = TestQueryMaxNetworks_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Query Networks\n");
            err = TestQueryNetworks_2();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 3;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestQueryMaxNetworks_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestNetworkCommissioning * cluster = [[CHIPTestNetworkCommissioning alloc] initWithDevice:device
                                                                                             endpoint:0
                                                                                                queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeMaxNetworksWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Query MaxNetworks Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("maxNetworks", "", "uint8"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestQueryNetworks_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestNetworkCommissioning * cluster = [[CHIPTestNetworkCommissioning alloc] initWithDevice:device
                                                                                             endpoint:0
                                                                                                queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNetworksWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Query Networks Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("networks", "", "list"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
};

class Test_TC_EMR_1_1 : public TestCommandBridge {
public:
    Test_TC_EMR_1_1()
        : TestCommandBridge("Test_TC_EMR_1_1")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_EMR_1_1() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_EMR_1_1\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_EMR_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : read the global attribute: ClusterRevision\n");
            err = TestReadTheGlobalAttributeClusterRevision_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read the global attribute constraints: ClusterRevision\n");
            err = TestReadTheGlobalAttributeConstraintsClusterRevision_2();
            break;
        case 3:
            ChipLogProgress(
                chipTool, " ***** Test Step 3 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : reads back global attribute: ClusterRevision\n");
            err = TestReadsBackGlobalAttributeClusterRevision_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Read the global attribute: AttributeList\n");
            err = TestReadTheGlobalAttributeAttributeList_5();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 6;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheGlobalAttributeClusterRevision_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestElectricalMeasurement * cluster = [[CHIPTestElectricalMeasurement alloc] initWithDevice:device
                                                                                               endpoint:1
                                                                                                  queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read the global attribute: ClusterRevision Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("ClusterRevision", actualValue, 3U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheGlobalAttributeConstraintsClusterRevision_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestElectricalMeasurement * cluster = [[CHIPTestElectricalMeasurement alloc] initWithDevice:device
                                                                                               endpoint:1
                                                                                                  queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read the global attribute constraints: ClusterRevision Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("clusterRevision", "", "uint16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_3()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestElectricalMeasurement * cluster = [[CHIPTestElectricalMeasurement alloc] initWithDevice:device
                                                                                               endpoint:1
                                                                                                  queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id clusterRevisionArgument;
        clusterRevisionArgument = [NSNumber numberWithUnsignedShort:1U];
        [cluster
            writeAttributeClusterRevisionWithValue:clusterRevisionArgument
                                 completionHandler:^(NSError * _Nullable err) {
                                     NSLog(
                                         @"write the default values to mandatory global attribute: ClusterRevision Error: %@", err);

                                     VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                                     NextTest();
                                 }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsBackGlobalAttributeClusterRevision_4()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestElectricalMeasurement * cluster = [[CHIPTestElectricalMeasurement alloc] initWithDevice:device
                                                                                               endpoint:1
                                                                                                  queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"reads back global attribute: ClusterRevision Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("ClusterRevision", actualValue, 3U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheGlobalAttributeAttributeList_5()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestElectricalMeasurement * cluster = [[CHIPTestElectricalMeasurement alloc] initWithDevice:device
                                                                                               endpoint:1
                                                                                                  queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read the global attribute: AttributeList Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("attributeList", "", "list"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
};

class Test_TC_ETHDIAG_1_1 : public TestCommandBridge {
public:
    Test_TC_ETHDIAG_1_1()
        : TestCommandBridge("Test_TC_ETHDIAG_1_1")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_ETHDIAG_1_1() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_ETHDIAG_1_1\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_ETHDIAG_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }
};

class Test_TC_ETHDIAG_2_1 : public TestCommandBridge {
public:
    Test_TC_ETHDIAG_2_1()
        : TestCommandBridge("Test_TC_ETHDIAG_2_1")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_ETHDIAG_2_1() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_ETHDIAG_2_1\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_ETHDIAG_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }
};

class Test_TC_FLW_1_1 : public TestCommandBridge {
public:
    Test_TC_FLW_1_1()
        : TestCommandBridge("Test_TC_FLW_1_1")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_FLW_1_1() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_FLW_1_1\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_FLW_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read the global attribute constraints: ClusterRevision\n");
            err = TestReadTheGlobalAttributeConstraintsClusterRevision_1();
            break;
        case 2:
            ChipLogProgress(
                chipTool, " ***** Test Step 2 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read the global attribute: AttributeList\n");
            err = TestReadTheGlobalAttributeAttributeList_3();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 4;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheGlobalAttributeConstraintsClusterRevision_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestFlowMeasurement * cluster = [[CHIPTestFlowMeasurement alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read the global attribute constraints: ClusterRevision Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("clusterRevision", "", "uint16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestFlowMeasurement * cluster = [[CHIPTestFlowMeasurement alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id clusterRevisionArgument;
        clusterRevisionArgument = [NSNumber numberWithUnsignedShort:2U];
        [cluster
            writeAttributeClusterRevisionWithValue:clusterRevisionArgument
                                 completionHandler:^(NSError * _Nullable err) {
                                     NSLog(
                                         @"write the default values to mandatory global attribute: ClusterRevision Error: %@", err);

                                     VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                                     NextTest();
                                 }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheGlobalAttributeAttributeList_3()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestFlowMeasurement * cluster = [[CHIPTestFlowMeasurement alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read the global attribute: AttributeList Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("attributeList", "", "list"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
};

class Test_TC_FLW_2_1 : public TestCommandBridge {
public:
    Test_TC_FLW_2_1()
        : TestCommandBridge("Test_TC_FLW_2_1")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_FLW_2_1() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_FLW_2_1\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_FLW_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : read the mandatory attribute: MeasuredValue\n");
            err = TestReadTheMandatoryAttributeMeasuredValue_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : read the mandatory attribute: MinMeasuredValue\n");
            err = TestReadTheMandatoryAttributeMinMeasuredValue_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : read the mandatory attribute: MaxMeasuredValue\n");
            err = TestReadTheMandatoryAttributeMaxMeasuredValue_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : write the default value to optional attribute: MeasuredValue\n");
            err = TestWriteTheDefaultValueToOptionalAttributeMeasuredValue_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : write the default value to optional attribute: MinMeasuredValue\n");
            err = TestWriteTheDefaultValueToOptionalAttributeMinMeasuredValue_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : write the default value to optional attribute: MaxMeasuredValue\n");
            err = TestWriteTheDefaultValueToOptionalAttributeMaxMeasuredValue_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : read the mandatory attribute: MeasuredValue\n");
            err = TestReadTheMandatoryAttributeMeasuredValue_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : read the mandatory attribute: MinMeasuredValue\n");
            err = TestReadTheMandatoryAttributeMinMeasuredValue_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : read the mandatory attribute: MaxMeasuredValue\n");
            err = TestReadTheMandatoryAttributeMaxMeasuredValue_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : read the optional attribute: Tolerance\n");
            err = TestReadTheOptionalAttributeTolerance_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : read the optional attribute: Tolerance\n");
            err = TestReadTheOptionalAttributeTolerance_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : write the default value to optional attribute: Tolerance\n");
            err = TestWriteTheDefaultValueToOptionalAttributeTolerance_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : read the optional attribute: Tolerance\n");
            err = TestReadTheOptionalAttributeTolerance_13();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 14;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheMandatoryAttributeMeasuredValue_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestFlowMeasurement * cluster = [[CHIPTestFlowMeasurement alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeMeasuredValueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read the mandatory attribute: MeasuredValue Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("measuredValue", "", "uint16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheMandatoryAttributeMinMeasuredValue_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestFlowMeasurement * cluster = [[CHIPTestFlowMeasurement alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeMinMeasuredValueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read the mandatory attribute: MinMeasuredValue Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("minMeasuredValue", "", "uint16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheMandatoryAttributeMaxMeasuredValue_3()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestFlowMeasurement * cluster = [[CHIPTestFlowMeasurement alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeMaxMeasuredValueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read the mandatory attribute: MaxMeasuredValue Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("maxMeasuredValue", "", "uint16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteTheDefaultValueToOptionalAttributeMeasuredValue_4()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestFlowMeasurement * cluster = [[CHIPTestFlowMeasurement alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id measuredValueArgument;
        measuredValueArgument = [NSNumber numberWithUnsignedShort:0U];
        [cluster writeAttributeMeasuredValueWithValue:measuredValueArgument
                                    completionHandler:^(NSError * _Nullable err) {
                                        NSLog(@"write the default value to optional attribute: MeasuredValue Error: %@", err);

                                        VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                                        NextTest();
                                    }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteTheDefaultValueToOptionalAttributeMinMeasuredValue_5()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestFlowMeasurement * cluster = [[CHIPTestFlowMeasurement alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id minMeasuredValueArgument;
        minMeasuredValueArgument = [NSNumber numberWithUnsignedShort:0U];
        [cluster writeAttributeMinMeasuredValueWithValue:minMeasuredValueArgument
                                       completionHandler:^(NSError * _Nullable err) {
                                           NSLog(@"write the default value to optional attribute: MinMeasuredValue Error: %@", err);

                                           VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                                           NextTest();
                                       }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteTheDefaultValueToOptionalAttributeMaxMeasuredValue_6()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestFlowMeasurement * cluster = [[CHIPTestFlowMeasurement alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id maxMeasuredValueArgument;
        maxMeasuredValueArgument = [NSNumber numberWithUnsignedShort:0U];
        [cluster writeAttributeMaxMeasuredValueWithValue:maxMeasuredValueArgument
                                       completionHandler:^(NSError * _Nullable err) {
                                           NSLog(@"write the default value to optional attribute: MaxMeasuredValue Error: %@", err);

                                           VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                                           NextTest();
                                       }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheMandatoryAttributeMeasuredValue_7()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestFlowMeasurement * cluster = [[CHIPTestFlowMeasurement alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeMeasuredValueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read the mandatory attribute: MeasuredValue Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("measuredValue", "", "uint16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheMandatoryAttributeMinMeasuredValue_8()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestFlowMeasurement * cluster = [[CHIPTestFlowMeasurement alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeMinMeasuredValueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read the mandatory attribute: MinMeasuredValue Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("minMeasuredValue", "", "uint16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheMandatoryAttributeMaxMeasuredValue_9()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestFlowMeasurement * cluster = [[CHIPTestFlowMeasurement alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeMaxMeasuredValueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read the mandatory attribute: MaxMeasuredValue Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("maxMeasuredValue", "", "uint16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheOptionalAttributeTolerance_10()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestFlowMeasurement * cluster = [[CHIPTestFlowMeasurement alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeToleranceWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read the optional attribute: Tolerance Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("Tolerance", actualValue, 0U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheOptionalAttributeTolerance_11()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestFlowMeasurement * cluster = [[CHIPTestFlowMeasurement alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeToleranceWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read the optional attribute: Tolerance Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("tolerance", "", "uint16"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("tolerance", [value unsignedShortValue], 0U));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("tolerance", [value unsignedShortValue], 2048U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteTheDefaultValueToOptionalAttributeTolerance_12()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestFlowMeasurement * cluster = [[CHIPTestFlowMeasurement alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id toleranceArgument;
        toleranceArgument = [NSNumber numberWithUnsignedShort:0U];
        [cluster writeAttributeToleranceWithValue:toleranceArgument
                                completionHandler:^(NSError * _Nullable err) {
                                    NSLog(@"write the default value to optional attribute: Tolerance Error: %@", err);

                                    if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                                        NextTest();
                                        return;
                                    }

                                    VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                                    NextTest();
                                }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheOptionalAttributeTolerance_13()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestFlowMeasurement * cluster = [[CHIPTestFlowMeasurement alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeToleranceWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read the optional attribute: Tolerance Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("Tolerance", actualValue, 0U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
};

class Test_TC_FLW_2_2 : public TestCommandBridge {
public:
    Test_TC_FLW_2_2()
        : TestCommandBridge("Test_TC_FLW_2_2")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_FLW_2_2() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_FLW_2_2\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_FLW_2_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : read the mandatory attribute: MeasuredValue\n");
            err = TestReadTheMandatoryAttributeMeasuredValue_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : read the mandatory attribute: MeasuredValue\n");
            err = TestReadTheMandatoryAttributeMeasuredValue_2();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 3;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheMandatoryAttributeMeasuredValue_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestFlowMeasurement * cluster = [[CHIPTestFlowMeasurement alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeMeasuredValueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read the mandatory attribute: MeasuredValue Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("measuredValue", "", "uint16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheMandatoryAttributeMeasuredValue_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestFlowMeasurement * cluster = [[CHIPTestFlowMeasurement alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeMeasuredValueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read the mandatory attribute: MeasuredValue Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("measuredValue", "", "uint16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
};

class Test_TC_ILL_1_1 : public TestCommandBridge {
public:
    Test_TC_ILL_1_1()
        : TestCommandBridge("Test_TC_ILL_1_1")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_ILL_1_1() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_ILL_1_1\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_ILL_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : read the global attribute: ClusterRevision\n");
            err = TestReadTheGlobalAttributeClusterRevision_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read the global attribute constraints: ClusterRevision\n");
            err = TestReadTheGlobalAttributeConstraintsClusterRevision_2();
            break;
        case 3:
            ChipLogProgress(
                chipTool, " ***** Test Step 3 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : reads back global attribute: ClusterRevision\n");
            err = TestReadsBackGlobalAttributeClusterRevision_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Read the global attribute: AttributeList\n");
            err = TestReadTheGlobalAttributeAttributeList_5();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 6;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheGlobalAttributeClusterRevision_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestIlluminanceMeasurement * cluster = [[CHIPTestIlluminanceMeasurement alloc] initWithDevice:device
                                                                                                 endpoint:1
                                                                                                    queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read the global attribute: ClusterRevision Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("ClusterRevision", actualValue, 2U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheGlobalAttributeConstraintsClusterRevision_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestIlluminanceMeasurement * cluster = [[CHIPTestIlluminanceMeasurement alloc] initWithDevice:device
                                                                                                 endpoint:1
                                                                                                    queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read the global attribute constraints: ClusterRevision Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("clusterRevision", "", "uint16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_3()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestIlluminanceMeasurement * cluster = [[CHIPTestIlluminanceMeasurement alloc] initWithDevice:device
                                                                                                 endpoint:1
                                                                                                    queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id clusterRevisionArgument;
        clusterRevisionArgument = [NSNumber numberWithUnsignedShort:1U];
        [cluster
            writeAttributeClusterRevisionWithValue:clusterRevisionArgument
                                 completionHandler:^(NSError * _Nullable err) {
                                     NSLog(
                                         @"write the default values to mandatory global attribute: ClusterRevision Error: %@", err);

                                     VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                                     NextTest();
                                 }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsBackGlobalAttributeClusterRevision_4()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestIlluminanceMeasurement * cluster = [[CHIPTestIlluminanceMeasurement alloc] initWithDevice:device
                                                                                                 endpoint:1
                                                                                                    queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"reads back global attribute: ClusterRevision Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("ClusterRevision", actualValue, 2U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheGlobalAttributeAttributeList_5()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestIlluminanceMeasurement * cluster = [[CHIPTestIlluminanceMeasurement alloc] initWithDevice:device
                                                                                                 endpoint:1
                                                                                                    queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read the global attribute: AttributeList Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("attributeList", "", "list"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
};

class Test_TC_LVL_1_1 : public TestCommandBridge {
public:
    Test_TC_LVL_1_1()
        : TestCommandBridge("Test_TC_LVL_1_1")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_LVL_1_1() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_LVL_1_1\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_LVL_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : read the global attribute: ClusterRevision\n");
            err = TestReadTheGlobalAttributeClusterRevision_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read the global attribute constraints: ClusterRevision\n");
            err = TestReadTheGlobalAttributeConstraintsClusterRevision_2();
            break;
        case 3:
            ChipLogProgress(
                chipTool, " ***** Test Step 3 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : reads back global attribute: ClusterRevision\n");
            err = TestReadsBackGlobalAttributeClusterRevision_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Read the global attribute: AttributeList\n");
            err = TestReadTheGlobalAttributeAttributeList_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Read the optional global attribute : FeatureMap\n");
            err = TestReadTheOptionalGlobalAttributeFeatureMap_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : write the default values to optional global attribute: FeatureMap\n");
            err = TestWriteTheDefaultValuesToOptionalGlobalAttributeFeatureMap_7();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 8;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheGlobalAttributeClusterRevision_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestLevelControl * cluster = [[CHIPTestLevelControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read the global attribute: ClusterRevision Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("ClusterRevision", actualValue, 5U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheGlobalAttributeConstraintsClusterRevision_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestLevelControl * cluster = [[CHIPTestLevelControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read the global attribute constraints: ClusterRevision Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("clusterRevision", "", "uint16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_3()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestLevelControl * cluster = [[CHIPTestLevelControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id clusterRevisionArgument;
        clusterRevisionArgument = [NSNumber numberWithUnsignedShort:4U];
        [cluster
            writeAttributeClusterRevisionWithValue:clusterRevisionArgument
                                 completionHandler:^(NSError * _Nullable err) {
                                     NSLog(
                                         @"write the default values to mandatory global attribute: ClusterRevision Error: %@", err);

                                     VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                                     NextTest();
                                 }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsBackGlobalAttributeClusterRevision_4()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestLevelControl * cluster = [[CHIPTestLevelControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"reads back global attribute: ClusterRevision Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("ClusterRevision", actualValue, 5U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheGlobalAttributeAttributeList_5()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestLevelControl * cluster = [[CHIPTestLevelControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read the global attribute: AttributeList Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("attributeList", "", "list"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheOptionalGlobalAttributeFeatureMap_6()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestLevelControl * cluster = [[CHIPTestLevelControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeFeatureMapWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read the optional global attribute : FeatureMap Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("featureMap", "", "map32"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteTheDefaultValuesToOptionalGlobalAttributeFeatureMap_7()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestLevelControl * cluster = [[CHIPTestLevelControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id featureMapArgument;
        featureMapArgument = [NSNumber numberWithUnsignedInt:0UL];
        [cluster writeAttributeFeatureMapWithValue:featureMapArgument
                                 completionHandler:^(NSError * _Nullable err) {
                                     NSLog(@"write the default values to optional global attribute: FeatureMap Error: %@", err);

                                     VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                                     NextTest();
                                 }];

        return CHIP_NO_ERROR;
    }
};

class Test_TC_LVL_2_1 : public TestCommandBridge {
public:
    Test_TC_LVL_2_1()
        : TestCommandBridge("Test_TC_LVL_2_1")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_LVL_2_1() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_LVL_2_1\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_LVL_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Reset level to 254\n");
            err = TestResetLevelTo254_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Wait 100ms\n");
            err = TestWait100ms_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Reads the CurrentLevel attribute\n");
            err = TestReadsTheCurrentLevelAttribute_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Reads the RemainingTime attribute\n");
            err = TestReadsTheRemainingTimeAttribute_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Reads the MinLevel attribute\n");
            err = TestReadsTheMinLevelAttribute_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Reads the MaxLevel attribute\n");
            err = TestReadsTheMaxLevelAttribute_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Reads the CurrentFrequency attribute\n");
            err = TestReadsTheCurrentFrequencyAttribute_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Reads the MinFrequency attribute\n");
            err = TestReadsTheMinFrequencyAttribute_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Reads the MaxFrequency attribute\n");
            err = TestReadsTheMaxFrequencyAttribute_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Reads the OnOffTransitionTime attribute\n");
            err = TestReadsTheOnOffTransitionTimeAttribute_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : Reads the OnLevel attribute \n");
            err = TestReadsTheOnLevelAttribute_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : Reads the OnTransitionTime attribute \n");
            err = TestReadsTheOnTransitionTimeAttribute_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : Reads the OffTransitionTime attribute \n");
            err = TestReadsTheOffTransitionTimeAttribute_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : Reads the DefaultMoveRate attribute \n");
            err = TestReadsTheDefaultMoveRateAttribute_14();
            break;
        case 15:
            ChipLogProgress(chipTool, " ***** Test Step 15 : Reads the Options attribute \n");
            err = TestReadsTheOptionsAttribute_15();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 16;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestResetLevelTo254_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestLevelControl * cluster = [[CHIPTestLevelControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPLevelControlClusterMoveToLevelParams alloc] init];
        params.level = [NSNumber numberWithUnsignedChar:254];
        params.transitionTime = [NSNumber numberWithUnsignedShort:0U];
        params.optionMask = [NSNumber numberWithUnsignedChar:1];
        params.optionOverride = [NSNumber numberWithUnsignedChar:1];
        [cluster moveToLevelWithParams:params
                     completionHandler:^(NSError * _Nullable err) {
                         NSLog(@"Reset level to 254 Error: %@", err);

                         VerifyOrReturn(CheckValue("status", err, 0));

                         NextTest();
                     }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWait100ms_2()
    {
        WaitForMs(100);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsTheCurrentLevelAttribute_3()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestLevelControl * cluster = [[CHIPTestLevelControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeCurrentLevelWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads the CurrentLevel attribute Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("current level", actualValue, 254));
            }

            VerifyOrReturn(CheckConstraintType("currentLevel", "", "uint8"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsTheRemainingTimeAttribute_4()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestLevelControl * cluster = [[CHIPTestLevelControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeRemainingTimeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads the RemainingTime attribute Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("remaining time", actualValue, 0U));
            }

            VerifyOrReturn(CheckConstraintType("remainingTime", "", "uint16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsTheMinLevelAttribute_5()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestLevelControl * cluster = [[CHIPTestLevelControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeMinLevelWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads the MinLevel attribute Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("min level", actualValue, 0));
            }

            VerifyOrReturn(CheckConstraintType("minLevel", "", "uint8"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsTheMaxLevelAttribute_6()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestLevelControl * cluster = [[CHIPTestLevelControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeMaxLevelWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads the MaxLevel attribute Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("maxLevel", "", "uint8"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsTheCurrentFrequencyAttribute_7()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestLevelControl * cluster = [[CHIPTestLevelControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeCurrentFrequencyWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads the CurrentFrequency attribute Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("current frequency", actualValue, 0U));
            }

            VerifyOrReturn(CheckConstraintType("currentFrequency", "", "uint16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsTheMinFrequencyAttribute_8()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestLevelControl * cluster = [[CHIPTestLevelControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeMinFrequencyWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads the MinFrequency attribute Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("min frequency", actualValue, 0U));
            }

            VerifyOrReturn(CheckConstraintType("minFrequency", "", "uint16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsTheMaxFrequencyAttribute_9()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestLevelControl * cluster = [[CHIPTestLevelControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeMaxFrequencyWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads the MaxFrequency attribute Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("max frequency", actualValue, 0U));
            }

            VerifyOrReturn(CheckConstraintType("maxFrequency", "", "uint16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsTheOnOffTransitionTimeAttribute_10()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestLevelControl * cluster = [[CHIPTestLevelControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOnOffTransitionTimeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads the OnOffTransitionTime attribute Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("on off transition time", actualValue, 0U));
            }

            VerifyOrReturn(CheckConstraintType("onOffTransitionTime", "", "uint16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsTheOnLevelAttribute_11()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestLevelControl * cluster = [[CHIPTestLevelControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOnLevelWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads the OnLevel attribute  Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("onLevel", "", "uint8"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsTheOnTransitionTimeAttribute_12()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestLevelControl * cluster = [[CHIPTestLevelControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOnTransitionTimeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads the OnTransitionTime attribute  Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("onTransitionTime", "", "uint16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsTheOffTransitionTimeAttribute_13()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestLevelControl * cluster = [[CHIPTestLevelControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOffTransitionTimeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads the OffTransitionTime attribute  Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("offTransitionTime", "", "uint16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsTheDefaultMoveRateAttribute_14()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestLevelControl * cluster = [[CHIPTestLevelControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeDefaultMoveRateWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads the DefaultMoveRate attribute  Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("defaultMoveRate", "", "uint8"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsTheOptionsAttribute_15()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestLevelControl * cluster = [[CHIPTestLevelControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOptionsWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads the Options attribute  Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("options", actualValue, 0));
            }

            VerifyOrReturn(CheckConstraintType("options", "", "map8"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
};

class Test_TC_LVL_2_2 : public TestCommandBridge {
public:
    Test_TC_LVL_2_2()
        : TestCommandBridge("Test_TC_LVL_2_2")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_LVL_2_2() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_LVL_2_2\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_LVL_2_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Reads the OnOffTransitionTime attribute from the DUT\n");
            err = TestReadsTheOnOffTransitionTimeAttributeFromTheDut_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : writes the OnOffTransitionTime attribute on the DUT\n");
            err = TestWritesTheOnOffTransitionTimeAttributeOnTheDut_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Reads the OnOffTransitionTime attribute from the DUT\n");
            err = TestReadsTheOnOffTransitionTimeAttributeFromTheDut_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : writes default value of OnOffTransitionTime attribute\n");
            err = TestWritesDefaultValueOfOnOffTransitionTimeAttribute_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : writes the OnLevel attribute on the DUT\n");
            err = TestWritesTheOnLevelAttributeOnTheDut_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Reads the OnLevel attribute from the DUT\n");
            err = TestReadsTheOnLevelAttributeFromTheDut_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Writes the OnTransitionTime attribute on the DUT\n");
            err = TestWritesTheOnTransitionTimeAttributeOnTheDut_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Reads the OnTransitionTime attribute from the DUT\n");
            err = TestReadsTheOnTransitionTimeAttributeFromTheDut_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Writes the OffTransitionTime attribute on the DUT\n");
            err = TestWritesTheOffTransitionTimeAttributeOnTheDut_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Reads the OffTransitionTime attribute from the DUT\n");
            err = TestReadsTheOffTransitionTimeAttributeFromTheDut_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : Reads the DefaultMoveRate attribute from the DUT\n");
            err = TestReadsTheDefaultMoveRateAttributeFromTheDut_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : Writes the DefaultMoveRate attribute on the DUT\n");
            err = TestWritesTheDefaultMoveRateAttributeOnTheDut_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : Reads the DefaultMoveRate attribute from the DUT\n");
            err = TestReadsTheDefaultMoveRateAttributeFromTheDut_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : writes the StartUpCurrentLevel attribute on the DUT\n");
            err = TestWritesTheStartUpCurrentLevelAttributeOnTheDut_14();
            break;
        case 15:
            ChipLogProgress(chipTool, " ***** Test Step 15 : reads the StartUpCurrentLevel attribute from the DUT\n");
            err = TestReadsTheStartUpCurrentLevelAttributeFromTheDut_15();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 16;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsTheOnOffTransitionTimeAttributeFromTheDut_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestLevelControl * cluster = [[CHIPTestLevelControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOnOffTransitionTimeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads the OnOffTransitionTime attribute from the DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("on off transition time", actualValue, 0U));
            }

            VerifyOrReturn(CheckConstraintType("onOffTransitionTime", "", "uint16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWritesTheOnOffTransitionTimeAttributeOnTheDut_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestLevelControl * cluster = [[CHIPTestLevelControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id onOffTransitionTimeArgument;
        onOffTransitionTimeArgument = [NSNumber numberWithUnsignedShort:10U];
        [cluster writeAttributeOnOffTransitionTimeWithValue:onOffTransitionTimeArgument
                                          completionHandler:^(NSError * _Nullable err) {
                                              NSLog(@"writes the OnOffTransitionTime attribute on the DUT Error: %@", err);

                                              VerifyOrReturn(CheckValue("status", err, 0));

                                              NextTest();
                                          }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsTheOnOffTransitionTimeAttributeFromTheDut_3()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestLevelControl * cluster = [[CHIPTestLevelControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOnOffTransitionTimeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads the OnOffTransitionTime attribute from the DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("on off transition time", actualValue, 10U));
            }

            VerifyOrReturn(CheckConstraintType("onOffTransitionTime", "", "uint16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWritesDefaultValueOfOnOffTransitionTimeAttribute_4()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestLevelControl * cluster = [[CHIPTestLevelControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id onOffTransitionTimeArgument;
        onOffTransitionTimeArgument = [NSNumber numberWithUnsignedShort:0U];
        [cluster writeAttributeOnOffTransitionTimeWithValue:onOffTransitionTimeArgument
                                          completionHandler:^(NSError * _Nullable err) {
                                              NSLog(@"writes default value of OnOffTransitionTime attribute Error: %@", err);

                                              VerifyOrReturn(CheckValue("status", err, 0));

                                              NextTest();
                                          }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWritesTheOnLevelAttributeOnTheDut_5()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestLevelControl * cluster = [[CHIPTestLevelControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id onLevelArgument;
        onLevelArgument = [NSNumber numberWithUnsignedChar:254];
        [cluster writeAttributeOnLevelWithValue:onLevelArgument
                              completionHandler:^(NSError * _Nullable err) {
                                  NSLog(@"writes the OnLevel attribute on the DUT Error: %@", err);

                                  VerifyOrReturn(CheckValue("status", err, 0));

                                  NextTest();
                              }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsTheOnLevelAttributeFromTheDut_6()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestLevelControl * cluster = [[CHIPTestLevelControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOnLevelWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads the OnLevel attribute from the DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNonNull("on level", actualValue));
                VerifyOrReturn(CheckValue("on level", actualValue, 254));
            }

            VerifyOrReturn(CheckConstraintType("onLevel", "", "uint8"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWritesTheOnTransitionTimeAttributeOnTheDut_7()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestLevelControl * cluster = [[CHIPTestLevelControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id onTransitionTimeArgument;
        onTransitionTimeArgument = [NSNumber numberWithUnsignedShort:100U];
        [cluster writeAttributeOnTransitionTimeWithValue:onTransitionTimeArgument
                                       completionHandler:^(NSError * _Nullable err) {
                                           NSLog(@"Writes the OnTransitionTime attribute on the DUT Error: %@", err);

                                           VerifyOrReturn(CheckValue("status", err, 0));

                                           NextTest();
                                       }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsTheOnTransitionTimeAttributeFromTheDut_8()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestLevelControl * cluster = [[CHIPTestLevelControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOnTransitionTimeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads the OnTransitionTime attribute from the DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNonNull("on transition time", actualValue));
                VerifyOrReturn(CheckValue("on transition time", actualValue, 100U));
            }

            VerifyOrReturn(CheckConstraintType("onTransitionTime", "", "uint16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWritesTheOffTransitionTimeAttributeOnTheDut_9()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestLevelControl * cluster = [[CHIPTestLevelControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id offTransitionTimeArgument;
        offTransitionTimeArgument = [NSNumber numberWithUnsignedShort:100U];
        [cluster writeAttributeOffTransitionTimeWithValue:offTransitionTimeArgument
                                        completionHandler:^(NSError * _Nullable err) {
                                            NSLog(@"Writes the OffTransitionTime attribute on the DUT Error: %@", err);

                                            VerifyOrReturn(CheckValue("status", err, 0));

                                            NextTest();
                                        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsTheOffTransitionTimeAttributeFromTheDut_10()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestLevelControl * cluster = [[CHIPTestLevelControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOffTransitionTimeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads the OffTransitionTime attribute from the DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNonNull("off transition time", actualValue));
                VerifyOrReturn(CheckValue("off transition time", actualValue, 100U));
            }

            VerifyOrReturn(CheckConstraintType("offTransitionTime", "", "uint16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsTheDefaultMoveRateAttributeFromTheDut_11()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestLevelControl * cluster = [[CHIPTestLevelControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeDefaultMoveRateWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads the DefaultMoveRate attribute from the DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNonNull("default move rate", actualValue));
                VerifyOrReturn(CheckValue("default move rate", actualValue, 0));
            }

            VerifyOrReturn(CheckConstraintType("defaultMoveRate", "", "uint8"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWritesTheDefaultMoveRateAttributeOnTheDut_12()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestLevelControl * cluster = [[CHIPTestLevelControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id defaultMoveRateArgument;
        defaultMoveRateArgument = [NSNumber numberWithUnsignedChar:100];
        [cluster writeAttributeDefaultMoveRateWithValue:defaultMoveRateArgument
                                      completionHandler:^(NSError * _Nullable err) {
                                          NSLog(@"Writes the DefaultMoveRate attribute on the DUT Error: %@", err);

                                          VerifyOrReturn(CheckValue("status", err, 0));

                                          NextTest();
                                      }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsTheDefaultMoveRateAttributeFromTheDut_13()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestLevelControl * cluster = [[CHIPTestLevelControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeDefaultMoveRateWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads the DefaultMoveRate attribute from the DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNonNull("default move rate", actualValue));
                VerifyOrReturn(CheckValue("default move rate", actualValue, 100));
            }

            VerifyOrReturn(CheckConstraintType("defaultMoveRate", "", "uint8"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWritesTheStartUpCurrentLevelAttributeOnTheDut_14()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestLevelControl * cluster = [[CHIPTestLevelControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id startUpCurrentLevelArgument;
        startUpCurrentLevelArgument = [NSNumber numberWithUnsignedChar:254];
        [cluster writeAttributeStartUpCurrentLevelWithValue:startUpCurrentLevelArgument
                                          completionHandler:^(NSError * _Nullable err) {
                                              NSLog(@"writes the StartUpCurrentLevel attribute on the DUT Error: %@", err);

                                              VerifyOrReturn(CheckValue("status", err, 0));

                                              NextTest();
                                          }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsTheStartUpCurrentLevelAttributeFromTheDut_15()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestLevelControl * cluster = [[CHIPTestLevelControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeStartUpCurrentLevelWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"reads the StartUpCurrentLevel attribute from the DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNonNull("start up current level", actualValue));
                VerifyOrReturn(CheckValue("start up current level", actualValue, 254));
            }

            VerifyOrReturn(CheckConstraintType("startUpCurrentLevel", "", "uint8"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
};

class Test_TC_LVL_3_1 : public TestCommandBridge {
public:
    Test_TC_LVL_3_1()
        : TestCommandBridge("Test_TC_LVL_3_1")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_LVL_3_1() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_LVL_3_1\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_LVL_3_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : reads CurrentLevel attribute from DUT\n");
            err = TestReadsCurrentLevelAttributeFromDut_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Reads the MinLevel attribute\n");
            err = TestReadsTheMinLevelAttribute_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Reads the MaxLevel attribute\n");
            err = TestReadsTheMaxLevelAttribute_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : sends a Move to level command\n");
            err = TestSendsAMoveToLevelCommand_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Wait 100ms\n");
            err = TestWait100ms_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : reads CurrentLevel attribute from DUT\n");
            err = TestReadsCurrentLevelAttributeFromDut_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : sends a Move to level command\n");
            err = TestSendsAMoveToLevelCommand_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Wait a second\n");
            err = TestWaitASecond_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : reads CurrentLevel attribute from DUT\n");
            err = TestReadsCurrentLevelAttributeFromDut_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : reads On Off Transition Time attribute from DUT\n");
            err = TestReadsOnOffTransitionTimeAttributeFromDut_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : sends a Move to level command\n");
            err = TestSendsAMoveToLevelCommand_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : Wait 10ms\n");
            err = TestWait10ms_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : reads CurrentLevel attribute from DUT\n");
            err = TestReadsCurrentLevelAttributeFromDut_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : Reset level to 254\n");
            err = TestResetLevelTo254_14();
            break;
        case 15:
            ChipLogProgress(chipTool, " ***** Test Step 15 : Wait 100ms\n");
            err = TestWait100ms_15();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 16;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsCurrentLevelAttributeFromDut_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestLevelControl * cluster = [[CHIPTestLevelControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeCurrentLevelWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"reads CurrentLevel attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("current level", actualValue, 254));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsTheMinLevelAttribute_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestLevelControl * cluster = [[CHIPTestLevelControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeMinLevelWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads the MinLevel attribute Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("min level", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsTheMaxLevelAttribute_3()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestLevelControl * cluster = [[CHIPTestLevelControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeMaxLevelWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads the MaxLevel attribute Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("max level", actualValue, 254));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSendsAMoveToLevelCommand_4()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestLevelControl * cluster = [[CHIPTestLevelControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPLevelControlClusterMoveToLevelParams alloc] init];
        params.level = [NSNumber numberWithUnsignedChar:64];
        params.transitionTime = [NSNumber numberWithUnsignedShort:0U];
        params.optionMask = [NSNumber numberWithUnsignedChar:1];
        params.optionOverride = [NSNumber numberWithUnsignedChar:1];
        [cluster moveToLevelWithParams:params
                     completionHandler:^(NSError * _Nullable err) {
                         NSLog(@"sends a Move to level command Error: %@", err);

                         VerifyOrReturn(CheckValue("status", err, 0));

                         NextTest();
                     }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWait100ms_5()
    {
        WaitForMs(100);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsCurrentLevelAttributeFromDut_6()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestLevelControl * cluster = [[CHIPTestLevelControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeCurrentLevelWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"reads CurrentLevel attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("current level", actualValue, 64));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSendsAMoveToLevelCommand_7()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestLevelControl * cluster = [[CHIPTestLevelControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPLevelControlClusterMoveToLevelParams alloc] init];
        params.level = [NSNumber numberWithUnsignedChar:128];
        params.transitionTime = [NSNumber numberWithUnsignedShort:1U];
        params.optionMask = [NSNumber numberWithUnsignedChar:1];
        params.optionOverride = [NSNumber numberWithUnsignedChar:1];
        [cluster moveToLevelWithParams:params
                     completionHandler:^(NSError * _Nullable err) {
                         NSLog(@"sends a Move to level command Error: %@", err);

                         VerifyOrReturn(CheckValue("status", err, 0));

                         NextTest();
                     }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWaitASecond_8()
    {
        WaitForMs(1000);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsCurrentLevelAttributeFromDut_9()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestLevelControl * cluster = [[CHIPTestLevelControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeCurrentLevelWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"reads CurrentLevel attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("current level", actualValue, 128));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsOnOffTransitionTimeAttributeFromDut_10()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestLevelControl * cluster = [[CHIPTestLevelControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOnOffTransitionTimeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"reads On Off Transition Time attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("on off transition time", actualValue, 0U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSendsAMoveToLevelCommand_11()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestLevelControl * cluster = [[CHIPTestLevelControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPLevelControlClusterMoveToLevelParams alloc] init];
        params.level = [NSNumber numberWithUnsignedChar:254];
        params.transitionTime = [NSNumber numberWithUnsignedShort:65535U];
        params.optionMask = [NSNumber numberWithUnsignedChar:1];
        params.optionOverride = [NSNumber numberWithUnsignedChar:1];
        [cluster moveToLevelWithParams:params
                     completionHandler:^(NSError * _Nullable err) {
                         NSLog(@"sends a Move to level command Error: %@", err);

                         VerifyOrReturn(CheckValue("status", err, 0));

                         NextTest();
                     }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWait10ms_12()
    {
        WaitForMs(100);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsCurrentLevelAttributeFromDut_13()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestLevelControl * cluster = [[CHIPTestLevelControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeCurrentLevelWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"reads CurrentLevel attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("current level", actualValue, 254));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestResetLevelTo254_14()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestLevelControl * cluster = [[CHIPTestLevelControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPLevelControlClusterMoveToLevelParams alloc] init];
        params.level = [NSNumber numberWithUnsignedChar:254];
        params.transitionTime = [NSNumber numberWithUnsignedShort:0U];
        params.optionMask = [NSNumber numberWithUnsignedChar:1];
        params.optionOverride = [NSNumber numberWithUnsignedChar:1];
        [cluster moveToLevelWithParams:params
                     completionHandler:^(NSError * _Nullable err) {
                         NSLog(@"Reset level to 254 Error: %@", err);

                         VerifyOrReturn(CheckValue("status", err, 0));

                         NextTest();
                     }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWait100ms_15()
    {
        WaitForMs(100);
        return CHIP_NO_ERROR;
    }
};

class Test_TC_LVL_4_1 : public TestCommandBridge {
public:
    Test_TC_LVL_4_1()
        : TestCommandBridge("Test_TC_LVL_4_1")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_LVL_4_1() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_LVL_4_1\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_LVL_4_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : reads CurrentLevel attribute from DUT\n");
            err = TestReadsCurrentLevelAttributeFromDut_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : reads max level attribute from DUT\n");
            err = TestReadsMaxLevelAttributeFromDut_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : sends a Move up command\n");
            err = TestSendsAMoveUpCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Wait 3000ms\n");
            err = TestWait3000ms_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : reads CurrentLevel attribute from DUT\n");
            err = TestReadsCurrentLevelAttributeFromDut_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : reads min level attribute from DUT\n");
            err = TestReadsMinLevelAttributeFromDut_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : sends a Move down command\n");
            err = TestSendsAMoveDownCommand_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Wait 3000ms\n");
            err = TestWait3000ms_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : reads CurrentLevel attribute from DUT\n");
            err = TestReadsCurrentLevelAttributeFromDut_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Write default move rate attribute from DUT\n");
            err = TestWriteDefaultMoveRateAttributeFromDut_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : reads default move rate attribute from DUT\n");
            err = TestReadsDefaultMoveRateAttributeFromDut_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : sends a Move up command at default move rate\n");
            err = TestSendsAMoveUpCommandAtDefaultMoveRate_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : Wait 100ms\n");
            err = TestWait100ms_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : reads CurrentLevel attribute from DUT\n");
            err = TestReadsCurrentLevelAttributeFromDut_14();
            break;
        case 15:
            ChipLogProgress(chipTool, " ***** Test Step 15 : Reset level to 254\n");
            err = TestResetLevelTo254_15();
            break;
        case 16:
            ChipLogProgress(chipTool, " ***** Test Step 16 : Wait 100ms\n");
            err = TestWait100ms_16();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 17;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsCurrentLevelAttributeFromDut_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestLevelControl * cluster = [[CHIPTestLevelControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeCurrentLevelWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"reads CurrentLevel attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("current level", actualValue, 254));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsMaxLevelAttributeFromDut_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestLevelControl * cluster = [[CHIPTestLevelControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeMaxLevelWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"reads max level attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("max level", actualValue, 254));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSendsAMoveUpCommand_3()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestLevelControl * cluster = [[CHIPTestLevelControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPLevelControlClusterMoveParams alloc] init];
        params.moveMode = [NSNumber numberWithUnsignedChar:0];
        params.rate = [NSNumber numberWithUnsignedChar:200];
        params.optionMask = [NSNumber numberWithUnsignedChar:1];
        params.optionOverride = [NSNumber numberWithUnsignedChar:1];
        [cluster moveWithParams:params
              completionHandler:^(NSError * _Nullable err) {
                  NSLog(@"sends a Move up command Error: %@", err);

                  VerifyOrReturn(CheckValue("status", err, 0));

                  NextTest();
              }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWait3000ms_4()
    {
        WaitForMs(3000);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsCurrentLevelAttributeFromDut_5()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestLevelControl * cluster = [[CHIPTestLevelControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeCurrentLevelWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"reads CurrentLevel attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("current level", actualValue, 254));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsMinLevelAttributeFromDut_6()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestLevelControl * cluster = [[CHIPTestLevelControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeMinLevelWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"reads min level attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("min level", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSendsAMoveDownCommand_7()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestLevelControl * cluster = [[CHIPTestLevelControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPLevelControlClusterMoveParams alloc] init];
        params.moveMode = [NSNumber numberWithUnsignedChar:1];
        params.rate = [NSNumber numberWithUnsignedChar:250];
        params.optionMask = [NSNumber numberWithUnsignedChar:1];
        params.optionOverride = [NSNumber numberWithUnsignedChar:1];
        [cluster moveWithParams:params
              completionHandler:^(NSError * _Nullable err) {
                  NSLog(@"sends a Move down command Error: %@", err);

                  VerifyOrReturn(CheckValue("status", err, 0));

                  NextTest();
              }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWait3000ms_8()
    {
        WaitForMs(3000);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsCurrentLevelAttributeFromDut_9()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestLevelControl * cluster = [[CHIPTestLevelControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeCurrentLevelWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"reads CurrentLevel attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<uint8_t>("currentLevel", [value unsignedCharValue], 0));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("currentLevel", [value unsignedCharValue], 1));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteDefaultMoveRateAttributeFromDut_10()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestLevelControl * cluster = [[CHIPTestLevelControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id defaultMoveRateArgument;
        defaultMoveRateArgument = [NSNumber numberWithUnsignedChar:20];
        [cluster writeAttributeDefaultMoveRateWithValue:defaultMoveRateArgument
                                      completionHandler:^(NSError * _Nullable err) {
                                          NSLog(@"Write default move rate attribute from DUT Error: %@", err);

                                          VerifyOrReturn(CheckValue("status", err, 0));

                                          NextTest();
                                      }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsDefaultMoveRateAttributeFromDut_11()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestLevelControl * cluster = [[CHIPTestLevelControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeDefaultMoveRateWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"reads default move rate attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNonNull("default move rate", actualValue));
                VerifyOrReturn(CheckValue("default move rate", actualValue, 20));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSendsAMoveUpCommandAtDefaultMoveRate_12()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestLevelControl * cluster = [[CHIPTestLevelControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPLevelControlClusterMoveParams alloc] init];
        params.moveMode = [NSNumber numberWithUnsignedChar:0];
        params.rate = [NSNumber numberWithUnsignedChar:255];
        params.optionMask = [NSNumber numberWithUnsignedChar:1];
        params.optionOverride = [NSNumber numberWithUnsignedChar:1];
        [cluster moveWithParams:params
              completionHandler:^(NSError * _Nullable err) {
                  NSLog(@"sends a Move up command at default move rate Error: %@", err);

                  VerifyOrReturn(CheckValue("status", err, 0));

                  NextTest();
              }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWait100ms_13()
    {
        WaitForMs(100);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsCurrentLevelAttributeFromDut_14()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestLevelControl * cluster = [[CHIPTestLevelControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeCurrentLevelWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"reads CurrentLevel attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            if (value != nil) {
                VerifyOrReturn(CheckConstraintNotValue("currentLevel", value, 255));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestResetLevelTo254_15()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestLevelControl * cluster = [[CHIPTestLevelControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPLevelControlClusterMoveToLevelParams alloc] init];
        params.level = [NSNumber numberWithUnsignedChar:254];
        params.transitionTime = [NSNumber numberWithUnsignedShort:0U];
        params.optionMask = [NSNumber numberWithUnsignedChar:1];
        params.optionOverride = [NSNumber numberWithUnsignedChar:1];
        [cluster moveToLevelWithParams:params
                     completionHandler:^(NSError * _Nullable err) {
                         NSLog(@"Reset level to 254 Error: %@", err);

                         VerifyOrReturn(CheckValue("status", err, 0));

                         NextTest();
                     }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWait100ms_16()
    {
        WaitForMs(100);
        return CHIP_NO_ERROR;
    }
};

class Test_TC_LVL_5_1 : public TestCommandBridge {
public:
    Test_TC_LVL_5_1()
        : TestCommandBridge("Test_TC_LVL_5_1")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_LVL_5_1() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_LVL_5_1\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_LVL_5_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Sending on command\n");
            err = TestSendingOnCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Precondition: DUT level is set to 0x80\n");
            err = TestPreconditionDutLevelIsSetTo0x80_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Wait 4000ms\n");
            err = TestWait4000ms_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Reads current level attribute from DUT\n");
            err = TestReadsCurrentLevelAttributeFromDut_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Sends step down command to DUT\n");
            err = TestSendsStepDownCommandToDut_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Wait 4000ms\n");
            err = TestWait4000ms_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Reads current level attribute from DUT\n");
            err = TestReadsCurrentLevelAttributeFromDut_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Sends a Step up command\n");
            err = TestSendsAStepUpCommand_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Wait 4000ms\n");
            err = TestWait4000ms_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Reads current level attribute from DUT\n");
            err = TestReadsCurrentLevelAttributeFromDut_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : Reset level to 254\n");
            err = TestResetLevelTo254_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : Wait 100ms\n");
            err = TestWait100ms_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : Sending off command\n");
            err = TestSendingOffCommand_13();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 14;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSendingOnCommand_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster onWithCompletionHandler:^(NSError * _Nullable err) {
            NSLog(@"Sending on command Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestPreconditionDutLevelIsSetTo0x80_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestLevelControl * cluster = [[CHIPTestLevelControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPLevelControlClusterStepParams alloc] init];
        params.stepMode = [NSNumber numberWithUnsignedChar:1];
        params.stepSize = [NSNumber numberWithUnsignedChar:126];
        params.transitionTime = [NSNumber numberWithUnsignedShort:20U];
        params.optionMask = [NSNumber numberWithUnsignedChar:0];
        params.optionOverride = [NSNumber numberWithUnsignedChar:0];
        [cluster stepWithParams:params
              completionHandler:^(NSError * _Nullable err) {
                  NSLog(@"Precondition: DUT level is set to 0x80 Error: %@", err);

                  VerifyOrReturn(CheckValue("status", err, 0));

                  NextTest();
              }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWait4000ms_3()
    {
        WaitForMs(4000);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsCurrentLevelAttributeFromDut_4()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestLevelControl * cluster = [[CHIPTestLevelControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeCurrentLevelWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads current level attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("current level", actualValue, 128));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSendsStepDownCommandToDut_5()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestLevelControl * cluster = [[CHIPTestLevelControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPLevelControlClusterStepParams alloc] init];
        params.stepMode = [NSNumber numberWithUnsignedChar:1];
        params.stepSize = [NSNumber numberWithUnsignedChar:64];
        params.transitionTime = [NSNumber numberWithUnsignedShort:20U];
        params.optionMask = [NSNumber numberWithUnsignedChar:0];
        params.optionOverride = [NSNumber numberWithUnsignedChar:0];
        [cluster stepWithParams:params
              completionHandler:^(NSError * _Nullable err) {
                  NSLog(@"Sends step down command to DUT Error: %@", err);

                  VerifyOrReturn(CheckValue("status", err, 0));

                  NextTest();
              }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWait4000ms_6()
    {
        WaitForMs(4000);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsCurrentLevelAttributeFromDut_7()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestLevelControl * cluster = [[CHIPTestLevelControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeCurrentLevelWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads current level attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("current level", actualValue, 64));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSendsAStepUpCommand_8()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestLevelControl * cluster = [[CHIPTestLevelControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPLevelControlClusterStepParams alloc] init];
        params.stepMode = [NSNumber numberWithUnsignedChar:0];
        params.stepSize = [NSNumber numberWithUnsignedChar:64];
        params.transitionTime = [NSNumber numberWithUnsignedShort:20U];
        params.optionMask = [NSNumber numberWithUnsignedChar:0];
        params.optionOverride = [NSNumber numberWithUnsignedChar:0];
        [cluster stepWithParams:params
              completionHandler:^(NSError * _Nullable err) {
                  NSLog(@"Sends a Step up command Error: %@", err);

                  VerifyOrReturn(CheckValue("status", err, 0));

                  NextTest();
              }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWait4000ms_9()
    {
        WaitForMs(4000);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsCurrentLevelAttributeFromDut_10()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestLevelControl * cluster = [[CHIPTestLevelControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeCurrentLevelWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads current level attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("current level", actualValue, 128));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestResetLevelTo254_11()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestLevelControl * cluster = [[CHIPTestLevelControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPLevelControlClusterMoveToLevelParams alloc] init];
        params.level = [NSNumber numberWithUnsignedChar:254];
        params.transitionTime = [NSNumber numberWithUnsignedShort:0U];
        params.optionMask = [NSNumber numberWithUnsignedChar:1];
        params.optionOverride = [NSNumber numberWithUnsignedChar:1];
        [cluster moveToLevelWithParams:params
                     completionHandler:^(NSError * _Nullable err) {
                         NSLog(@"Reset level to 254 Error: %@", err);

                         VerifyOrReturn(CheckValue("status", err, 0));

                         NextTest();
                     }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWait100ms_12()
    {
        WaitForMs(100);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSendingOffCommand_13()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster offWithCompletionHandler:^(NSError * _Nullable err) {
            NSLog(@"Sending off command Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
};

class Test_TC_LVL_6_1 : public TestCommandBridge {
public:
    Test_TC_LVL_6_1()
        : TestCommandBridge("Test_TC_LVL_6_1")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_LVL_6_1() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_LVL_6_1\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_LVL_6_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Sending on command\n");
            err = TestSendingOnCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Precondition: set DUT to lowest point\n");
            err = TestPreconditionSetDutToLowestPoint_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Wait 100ms\n");
            err = TestWait100ms_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Reads CurrentLevel attribute from DUT\n");
            err = TestReadsCurrentLevelAttributeFromDut_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Sends a move up command to DUT\n");
            err = TestSendsAMoveUpCommandToDut_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Wait 2000ms\n");
            err = TestWait2000ms_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Sends stop command to DUT\n");
            err = TestSendsStopCommandToDut_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Reads CurrentLevel attribute from DUT\n");
            err = TestReadsCurrentLevelAttributeFromDut_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Reset level to 254\n");
            err = TestResetLevelTo254_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Wait 100ms\n");
            err = TestWait100ms_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : Sending off command\n");
            err = TestSendingOffCommand_11();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 12;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSendingOnCommand_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster onWithCompletionHandler:^(NSError * _Nullable err) {
            NSLog(@"Sending on command Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestPreconditionSetDutToLowestPoint_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestLevelControl * cluster = [[CHIPTestLevelControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPLevelControlClusterMoveToLevelParams alloc] init];
        params.level = [NSNumber numberWithUnsignedChar:0];
        params.transitionTime = [NSNumber numberWithUnsignedShort:0U];
        params.optionMask = [NSNumber numberWithUnsignedChar:1];
        params.optionOverride = [NSNumber numberWithUnsignedChar:1];
        [cluster moveToLevelWithParams:params
                     completionHandler:^(NSError * _Nullable err) {
                         NSLog(@"Precondition: set DUT to lowest point Error: %@", err);

                         VerifyOrReturn(CheckValue("status", err, 0));

                         NextTest();
                     }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWait100ms_3()
    {
        WaitForMs(100);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsCurrentLevelAttributeFromDut_4()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestLevelControl * cluster = [[CHIPTestLevelControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeCurrentLevelWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads CurrentLevel attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<uint8_t>("currentLevel", [value unsignedCharValue], 0));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("currentLevel", [value unsignedCharValue], 1));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSendsAMoveUpCommandToDut_5()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestLevelControl * cluster = [[CHIPTestLevelControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPLevelControlClusterMoveParams alloc] init];
        params.moveMode = [NSNumber numberWithUnsignedChar:0];
        params.rate = [NSNumber numberWithUnsignedChar:1];
        params.optionMask = [NSNumber numberWithUnsignedChar:1];
        params.optionOverride = [NSNumber numberWithUnsignedChar:1];
        [cluster moveWithParams:params
              completionHandler:^(NSError * _Nullable err) {
                  NSLog(@"Sends a move up command to DUT Error: %@", err);

                  VerifyOrReturn(CheckValue("status", err, 0));

                  NextTest();
              }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWait2000ms_6()
    {
        WaitForMs(2000);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSendsStopCommandToDut_7()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestLevelControl * cluster = [[CHIPTestLevelControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPLevelControlClusterStopParams alloc] init];
        params.optionMask = [NSNumber numberWithUnsignedChar:0];
        params.optionOverride = [NSNumber numberWithUnsignedChar:0];
        [cluster stopWithParams:params
              completionHandler:^(NSError * _Nullable err) {
                  NSLog(@"Sends stop command to DUT Error: %@", err);

                  VerifyOrReturn(CheckValue("status", err, 0));

                  NextTest();
              }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsCurrentLevelAttributeFromDut_8()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestLevelControl * cluster = [[CHIPTestLevelControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeCurrentLevelWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads CurrentLevel attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<uint8_t>("currentLevel", [value unsignedCharValue], 2));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("currentLevel", [value unsignedCharValue], 3));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestResetLevelTo254_9()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestLevelControl * cluster = [[CHIPTestLevelControl alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPLevelControlClusterMoveToLevelParams alloc] init];
        params.level = [NSNumber numberWithUnsignedChar:254];
        params.transitionTime = [NSNumber numberWithUnsignedShort:0U];
        params.optionMask = [NSNumber numberWithUnsignedChar:1];
        params.optionOverride = [NSNumber numberWithUnsignedChar:1];
        [cluster moveToLevelWithParams:params
                     completionHandler:^(NSError * _Nullable err) {
                         NSLog(@"Reset level to 254 Error: %@", err);

                         VerifyOrReturn(CheckValue("status", err, 0));

                         NextTest();
                     }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWait100ms_10()
    {
        WaitForMs(100);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSendingOffCommand_11()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster offWithCompletionHandler:^(NSError * _Nullable err) {
            NSLog(@"Sending off command Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
};

class Test_TC_MC_1_1 : public TestCommandBridge {
public:
    Test_TC_MC_1_1()
        : TestCommandBridge("Test_TC_MC_1_1")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MC_1_1() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_1_1\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : read the global attribute: ClusterRevision\n");
            err = TestReadTheGlobalAttributeClusterRevision_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read the global attribute constraints: ClusterRevision\n");
            err = TestReadTheGlobalAttributeConstraintsClusterRevision_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read the global attribute: AttributeList\n");
            err = TestReadTheGlobalAttributeAttributeList_3();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 4;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheGlobalAttributeClusterRevision_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestLowPower * cluster = [[CHIPTestLowPower alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read the global attribute: ClusterRevision Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("ClusterRevision", actualValue, 1U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheGlobalAttributeConstraintsClusterRevision_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestLowPower * cluster = [[CHIPTestLowPower alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read the global attribute constraints: ClusterRevision Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("clusterRevision", "", "uint16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheGlobalAttributeAttributeList_3()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestLowPower * cluster = [[CHIPTestLowPower alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read the global attribute: AttributeList Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("attributeList", "", "list"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
};

class Test_TC_MC_2_1 : public TestCommandBridge {
public:
    Test_TC_MC_2_1()
        : TestCommandBridge("Test_TC_MC_2_1")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MC_2_1() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_2_1\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Put the device into low power mode\n");
            err = TestPutTheDeviceIntoLowPowerMode_1();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 2;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestPutTheDeviceIntoLowPowerMode_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestLowPower * cluster = [[CHIPTestLowPower alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster sleepWithCompletionHandler:^(NSError * _Nullable err) {
            NSLog(@"Put the device into low power mode Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
};

class Test_TC_MC_3_1 : public TestCommandBridge {
public:
    Test_TC_MC_3_1()
        : TestCommandBridge("Test_TC_MC_3_1")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MC_3_1() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_3_1\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_3_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MC_3_2 : public TestCommandBridge {
public:
    Test_TC_MC_3_2()
        : TestCommandBridge("Test_TC_MC_3_2")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MC_3_2() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_3_2\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_3_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MC_3_3 : public TestCommandBridge {
public:
    Test_TC_MC_3_3()
        : TestCommandBridge("Test_TC_MC_3_3")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MC_3_3() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_3_3\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_3_3\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MC_3_4 : public TestCommandBridge {
public:
    Test_TC_MC_3_4()
        : TestCommandBridge("Test_TC_MC_3_4")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MC_3_4() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_3_4\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_3_4\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MC_3_5 : public TestCommandBridge {
public:
    Test_TC_MC_3_5()
        : TestCommandBridge("Test_TC_MC_3_5")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MC_3_5() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_3_5\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_3_5\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MC_3_6 : public TestCommandBridge {
public:
    Test_TC_MC_3_6()
        : TestCommandBridge("Test_TC_MC_3_6")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MC_3_6() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_3_6\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_3_6\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MC_3_7 : public TestCommandBridge {
public:
    Test_TC_MC_3_7()
        : TestCommandBridge("Test_TC_MC_3_7")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MC_3_7() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_3_7\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_3_7\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MC_3_8 : public TestCommandBridge {
public:
    Test_TC_MC_3_8()
        : TestCommandBridge("Test_TC_MC_3_8")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MC_3_8() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_3_8\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_3_8\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MC_3_9 : public TestCommandBridge {
public:
    Test_TC_MC_3_9()
        : TestCommandBridge("Test_TC_MC_3_9")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MC_3_9() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_3_9\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_3_9\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MC_3_10 : public TestCommandBridge {
public:
    Test_TC_MC_3_10()
        : TestCommandBridge("Test_TC_MC_3_10")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MC_3_10() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_3_10\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_3_10\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MC_3_11 : public TestCommandBridge {
public:
    Test_TC_MC_3_11()
        : TestCommandBridge("Test_TC_MC_3_11")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MC_3_11() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_3_11\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_3_11\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MC_5_1 : public TestCommandBridge {
public:
    Test_TC_MC_5_1()
        : TestCommandBridge("Test_TC_MC_5_1")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MC_5_1() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_5_1\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_5_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Reads the ChannelList attribute from the DUT\n");
            err = TestReadsTheChannelListAttributeFromTheDut_1();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 2;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsTheChannelListAttributeFromTheDut_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestChannel * cluster = [[CHIPTestChannel alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeChannelListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads the ChannelList attribute from the DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("channelList", "", "list"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
};

class Test_TC_MC_5_2 : public TestCommandBridge {
public:
    Test_TC_MC_5_2()
        : TestCommandBridge("Test_TC_MC_5_2")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MC_5_2() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_5_2\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_5_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : log a command\n");
            err = TestLogACommand_1();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 2;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestLogACommand_1()
    {
        UserPrompt(@"verify that the channel has changed on the device.");
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MC_5_3 : public TestCommandBridge {
public:
    Test_TC_MC_5_3()
        : TestCommandBridge("Test_TC_MC_5_3")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MC_5_3() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_5_3\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_5_3\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : log a command\n");
            err = TestLogACommand_1();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 2;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestLogACommand_1()
    {
        UserPrompt(@"verify that the channel has changed on the device");
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MC_6_1 : public TestCommandBridge {
public:
    Test_TC_MC_6_1()
        : TestCommandBridge("Test_TC_MC_6_1")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MC_6_1() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_6_1\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_6_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : log a command\n");
            err = TestLogACommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : log a command\n");
            err = TestLogACommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Reads the playback state attribute\n");
            err = TestReadsThePlaybackStateAttribute_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : log a command\n");
            err = TestLogACommand_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : log a command\n");
            err = TestLogACommand_5();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 6;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestLogACommand_1()
    {
        UserPrompt(@"Verify that media is paused");
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestLogACommand_2()
    {
        UserPrompt(@"Physically verify that the media is playing");
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsThePlaybackStateAttribute_3()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestMediaPlayback * cluster = [[CHIPTestMediaPlayback alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeCurrentStateWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads the playback state attribute Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("CurrentState", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestLogACommand_4()
    {
        UserPrompt(@"Physically verify that the media is paused");
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestLogACommand_5()
    {
        UserPrompt(@"Physically verify that the media is stoped");
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MC_6_2 : public TestCommandBridge {
public:
    Test_TC_MC_6_2()
        : TestCommandBridge("Test_TC_MC_6_2")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MC_6_2() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_6_2\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_6_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : log a command\n");
            err = TestLogACommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : log a command\n");
            err = TestLogACommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Reads the CurrentState attribute\n");
            err = TestReadsTheCurrentStateAttribute_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : log a command\n");
            err = TestLogACommand_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : log a command\n");
            err = TestLogACommand_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : log a command\n");
            err = TestLogACommand_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : log a command\n");
            err = TestLogACommand_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : log a command\n");
            err = TestLogACommand_8();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 9;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestLogACommand_1()
    {
        UserPrompt(@"Verify that media is paused");
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestLogACommand_2()
    {
        UserPrompt(@"Physically verify that the media is playing");
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsTheCurrentStateAttribute_3()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestMediaPlayback * cluster = [[CHIPTestMediaPlayback alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeCurrentStateWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads the CurrentState attribute Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("CurrentState", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestLogACommand_4()
    {
        UserPrompt(@"Physically verify that the media is started over");
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestLogACommand_5()
    {
        UserPrompt(@"Verify that the next media item in the queue has been loaded");
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestLogACommand_6()
    {
        UserPrompt(@"Verify that the previous media item in the queue has been loaded");
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestLogACommand_7()
    {
        UserPrompt(@"Verify that the media has skipped forward 10 seconds");
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestLogACommand_8()
    {
        UserPrompt(@"Verify that the media has skipped backward 10 seconds");
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MC_6_3 : public TestCommandBridge {
public:
    Test_TC_MC_6_3()
        : TestCommandBridge("Test_TC_MC_6_3")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MC_6_3() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_6_3\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_6_3\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : log a command\n");
            err = TestLogACommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : log a command\n");
            err = TestLogACommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : log a command\n");
            err = TestLogACommand_3();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 4;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestLogACommand_1()
    {
        UserPrompt(@"Verify that media is paused");
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestLogACommand_2()
    {
        UserPrompt(@"Verify that the media has moved to 10 seconds from the starting point.");
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestLogACommand_3()
    {
        UserPrompt(@"User prompt needed to enter the value beyond the furthest valid position");
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MC_6_4 : public TestCommandBridge {
public:
    Test_TC_MC_6_4()
        : TestCommandBridge("Test_TC_MC_6_4")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MC_6_4() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_6_4\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_6_4\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : log a command\n");
            err = TestLogACommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Reads the PlaybackSpeed attribute from the DUT\n");
            err = TestReadsThePlaybackSpeedAttributeFromTheDut_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : log a command\n");
            err = TestLogACommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Reads the CurrentState attribute\n");
            err = TestReadsTheCurrentStateAttribute_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : log a command\n");
            err = TestLogACommand_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : log a command\n");
            err = TestLogACommand_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Reads the CurrentState attribute\n");
            err = TestReadsTheCurrentStateAttribute_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : log a command\n");
            err = TestLogACommand_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : log a command\n");
            err = TestLogACommand_9();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 10;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestLogACommand_1()
    {
        UserPrompt(@"Verify that media is paused");
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsThePlaybackSpeedAttributeFromTheDut_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestMediaPlayback * cluster = [[CHIPTestMediaPlayback alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributePlaybackSpeedWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads the PlaybackSpeed attribute from the DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("PlaybackSpeed", actualValue, 0.0f));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestLogACommand_3()
    {
        UserPrompt(@"Verify that the media is playing");
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsTheCurrentStateAttribute_4()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestMediaPlayback * cluster = [[CHIPTestMediaPlayback alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeCurrentStateWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads the CurrentState attribute Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("CurrentState", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestLogACommand_5()
    {
        UserPrompt(@"Verify that the media play speed has increased");
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestLogACommand_6()
    {
        UserPrompt(@"Verify that the media play has reversed direction");
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsTheCurrentStateAttribute_7()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestMediaPlayback * cluster = [[CHIPTestMediaPlayback alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeCurrentStateWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads the CurrentState attribute Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("CurrentState", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestLogACommand_8()
    {
        UserPrompt(@"Verify that the media play has reversed direction");
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestLogACommand_9()
    {
        UserPrompt(@"Verify that the media is has resumed playing forward at the default speed");
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MC_7_1 : public TestCommandBridge {
public:
    Test_TC_MC_7_1()
        : TestCommandBridge("Test_TC_MC_7_1")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MC_7_1() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_7_1\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_7_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MC_7_2 : public TestCommandBridge {
public:
    Test_TC_MC_7_2()
        : TestCommandBridge("Test_TC_MC_7_2")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MC_7_2() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_7_2\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_7_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MC_8_1 : public TestCommandBridge {
public:
    Test_TC_MC_8_1()
        : TestCommandBridge("Test_TC_MC_8_1")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MC_8_1() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_8_1\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_8_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Reads the CurrentTarget attribute\n");
            err = TestReadsTheCurrentTargetAttribute_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Reads the TargetList attribute\n");
            err = TestReadsTheTargetListAttribute_2();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 3;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsTheCurrentTargetAttribute_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTargetNavigator * cluster = [[CHIPTestTargetNavigator alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeCurrentTargetWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads the CurrentTarget attribute Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("currentTarget", "", "uint8"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsTheTargetListAttribute_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTargetNavigator * cluster = [[CHIPTestTargetNavigator alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeTargetListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads the TargetList attribute Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("targetList", "", "list"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
};

class Test_TC_MC_9_1 : public TestCommandBridge {
public:
    Test_TC_MC_9_1()
        : TestCommandBridge("Test_TC_MC_9_1")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MC_9_1() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_9_1\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_9_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Precondition\n");
            err = TestPrecondition_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Reads the VendorName attribute\n");
            err = TestReadsTheVendorNameAttribute_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Reads the VendorID attribute\n");
            err = TestReadsTheVendorIDAttribute_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Reads the ApplicationName attribute\n");
            err = TestReadsTheApplicationNameAttribute_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Reads the ProductID attribute\n");
            err = TestReadsTheProductIDAttribute_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Reads the Status attribute\n");
            err = TestReadsTheStatusAttribute_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Reads the ApplicationVersion attribute\n");
            err = TestReadsTheApplicationVersionAttribute_7();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 8;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestPrecondition_1()
    {
        Log(@"DUT has one or more Content Apps available");
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsTheVendorNameAttribute_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestApplicationBasic * cluster = [[CHIPTestApplicationBasic alloc] initWithDevice:device
                                                                                     endpoint:1
                                                                                        queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeVendorNameWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads the VendorName attribute Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("vendorName", "", "string"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsTheVendorIDAttribute_3()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestApplicationBasic * cluster = [[CHIPTestApplicationBasic alloc] initWithDevice:device
                                                                                     endpoint:1
                                                                                        queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeVendorIDWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads the VendorID attribute Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("VendorID", actualValue, 0U));
            }

            VerifyOrReturn(CheckConstraintType("vendorID", "", "vendor-id"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsTheApplicationNameAttribute_4()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestApplicationBasic * cluster = [[CHIPTestApplicationBasic alloc] initWithDevice:device
                                                                                     endpoint:1
                                                                                        queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeApplicationNameWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads the ApplicationName attribute Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("applicationName", "", "string"));
            VerifyOrReturn(CheckConstraintMaxLength("applicationName", [value length], 256));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsTheProductIDAttribute_5()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestApplicationBasic * cluster = [[CHIPTestApplicationBasic alloc] initWithDevice:device
                                                                                     endpoint:1
                                                                                        queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeProductIDWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads the ProductID attribute Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("productID", "", "uint16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsTheStatusAttribute_6()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestApplicationBasic * cluster = [[CHIPTestApplicationBasic alloc] initWithDevice:device
                                                                                     endpoint:1
                                                                                        queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeStatusWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads the Status attribute Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("Status", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsTheApplicationVersionAttribute_7()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestApplicationBasic * cluster = [[CHIPTestApplicationBasic alloc] initWithDevice:device
                                                                                     endpoint:1
                                                                                        queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeApplicationVersionWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads the ApplicationVersion attribute Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("applicationVersion", "", "string"));
            VerifyOrReturn(CheckConstraintMaxLength("applicationVersion", [value length], 32));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
};

class Test_TC_OCC_1_1 : public TestCommandBridge {
public:
    Test_TC_OCC_1_1()
        : TestCommandBridge("Test_TC_OCC_1_1")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_OCC_1_1() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_OCC_1_1\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_OCC_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read the global attribute constraints: ClusterRevision\n");
            err = TestReadTheGlobalAttributeConstraintsClusterRevision_1();
            break;
        case 2:
            ChipLogProgress(
                chipTool, " ***** Test Step 2 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read the global attribute: AttributeList\n");
            err = TestReadTheGlobalAttributeAttributeList_3();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 4;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheGlobalAttributeConstraintsClusterRevision_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOccupancySensing * cluster = [[CHIPTestOccupancySensing alloc] initWithDevice:device
                                                                                     endpoint:1
                                                                                        queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read the global attribute constraints: ClusterRevision Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("clusterRevision", "", "uint16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOccupancySensing * cluster = [[CHIPTestOccupancySensing alloc] initWithDevice:device
                                                                                     endpoint:1
                                                                                        queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id clusterRevisionArgument;
        clusterRevisionArgument = [NSNumber numberWithUnsignedShort:3U];
        [cluster
            writeAttributeClusterRevisionWithValue:clusterRevisionArgument
                                 completionHandler:^(NSError * _Nullable err) {
                                     NSLog(
                                         @"write the default values to mandatory global attribute: ClusterRevision Error: %@", err);

                                     VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                                     NextTest();
                                 }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheGlobalAttributeAttributeList_3()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOccupancySensing * cluster = [[CHIPTestOccupancySensing alloc] initWithDevice:device
                                                                                     endpoint:1
                                                                                        queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read the global attribute: AttributeList Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("attributeList", "", "list"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
};

class Test_TC_OCC_2_1 : public TestCommandBridge {
public:
    Test_TC_OCC_2_1()
        : TestCommandBridge("Test_TC_OCC_2_1")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_OCC_2_1() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_OCC_2_1\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_OCC_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Reads mandatory attribute constrains: Occupancy\n");
            err = TestReadsMandatoryAttributeConstrainsOccupancy_1();
            break;
        case 2:
            ChipLogProgress(
                chipTool, " ***** Test Step 2 : Writes the respective default value to mandatory attribute: Occupancy\n");
            err = TestWritesTheRespectiveDefaultValueToMandatoryAttributeOccupancy_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Reads back mandatory attribute: Occupancy\n");
            err = TestReadsBackMandatoryAttributeOccupancy_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Reads mandatory attribute constrains: OccupancySensorType\n");
            err = TestReadsMandatoryAttributeConstrainsOccupancySensorType_4();
            break;
        case 5:
            ChipLogProgress(
                chipTool, " ***** Test Step 5 : Writes the respective default value to mandatory attribute: OccupancySensorType\n");
            err = TestWritesTheRespectiveDefaultValueToMandatoryAttributeOccupancySensorType_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Reads back mandatory attribute: OccupancySensorType\n");
            err = TestReadsBackMandatoryAttributeOccupancySensorType_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Reads mandatory attribute constrains: OccupancySensorTypeBitmap\n");
            err = TestReadsMandatoryAttributeConstrainsOccupancySensorTypeBitmap_7();
            break;
        case 8:
            ChipLogProgress(chipTool,
                " ***** Test Step 8 : Writes the respective default value to mandatory attribute: OccupancySensorTypeBitmap\n");
            err = TestWritesTheRespectiveDefaultValueToMandatoryAttributeOccupancySensorTypeBitmap_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Reads back mandatory attribute: OccupancySensorTypeBitmap\n");
            err = TestReadsBackMandatoryAttributeOccupancySensorTypeBitmap_9();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 10;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsMandatoryAttributeConstrainsOccupancy_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOccupancySensing * cluster = [[CHIPTestOccupancySensing alloc] initWithDevice:device
                                                                                     endpoint:1
                                                                                        queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOccupancyWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads mandatory attribute constrains: Occupancy Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("occupancy", "", "map8"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<uint8_t>("occupancy", [value unsignedCharValue], 0));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("occupancy", [value unsignedCharValue], 1));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWritesTheRespectiveDefaultValueToMandatoryAttributeOccupancy_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOccupancySensing * cluster = [[CHIPTestOccupancySensing alloc] initWithDevice:device
                                                                                     endpoint:1
                                                                                        queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id occupancyArgument;
        occupancyArgument = [NSNumber numberWithUnsignedChar:0];
        [cluster writeAttributeOccupancyWithValue:occupancyArgument
                                completionHandler:^(NSError * _Nullable err) {
                                    NSLog(@"Writes the respective default value to mandatory attribute: Occupancy Error: %@", err);

                                    VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                                    NextTest();
                                }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsBackMandatoryAttributeOccupancy_3()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOccupancySensing * cluster = [[CHIPTestOccupancySensing alloc] initWithDevice:device
                                                                                     endpoint:1
                                                                                        queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOccupancyWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads back mandatory attribute: Occupancy Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("occupancy", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsMandatoryAttributeConstrainsOccupancySensorType_4()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOccupancySensing * cluster = [[CHIPTestOccupancySensing alloc] initWithDevice:device
                                                                                     endpoint:1
                                                                                        queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOccupancySensorTypeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads mandatory attribute constrains: OccupancySensorType Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("occupancySensorType", "", "enum8"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<uint8_t>("occupancySensorType", [value unsignedCharValue], 0));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("occupancySensorType", [value unsignedCharValue], 3));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWritesTheRespectiveDefaultValueToMandatoryAttributeOccupancySensorType_5()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOccupancySensing * cluster = [[CHIPTestOccupancySensing alloc] initWithDevice:device
                                                                                     endpoint:1
                                                                                        queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id occupancySensorTypeArgument;
        occupancySensorTypeArgument = [NSNumber numberWithUnsignedChar:0];
        [cluster writeAttributeOccupancySensorTypeWithValue:occupancySensorTypeArgument
                                          completionHandler:^(NSError * _Nullable err) {
                                              NSLog(@"Writes the respective default value to mandatory attribute: "
                                                    @"OccupancySensorType Error: %@",
                                                  err);

                                              VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                                              NextTest();
                                          }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsBackMandatoryAttributeOccupancySensorType_6()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOccupancySensing * cluster = [[CHIPTestOccupancySensing alloc] initWithDevice:device
                                                                                     endpoint:1
                                                                                        queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOccupancySensorTypeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads back mandatory attribute: OccupancySensorType Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("occupancy sensor type", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsMandatoryAttributeConstrainsOccupancySensorTypeBitmap_7()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOccupancySensing * cluster = [[CHIPTestOccupancySensing alloc] initWithDevice:device
                                                                                     endpoint:1
                                                                                        queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster
            readAttributeOccupancySensorTypeBitmapWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
                NSLog(@"Reads mandatory attribute constrains: OccupancySensorTypeBitmap Error: %@", err);

                VerifyOrReturn(CheckValue("status", err, 0));

                VerifyOrReturn(CheckConstraintType("occupancySensorTypeBitmap", "", "map8"));
                if (value != nil) {
                    VerifyOrReturn(CheckConstraintMinValue<uint8_t>("occupancySensorTypeBitmap", [value unsignedCharValue], 1));
                }
                if (value != nil) {
                    VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("occupancySensorTypeBitmap", [value unsignedCharValue], 7));
                }

                NextTest();
            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWritesTheRespectiveDefaultValueToMandatoryAttributeOccupancySensorTypeBitmap_8()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOccupancySensing * cluster = [[CHIPTestOccupancySensing alloc] initWithDevice:device
                                                                                     endpoint:1
                                                                                        queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id occupancySensorTypeBitmapArgument;
        occupancySensorTypeBitmapArgument = [NSNumber numberWithUnsignedChar:1];
        [cluster writeAttributeOccupancySensorTypeBitmapWithValue:occupancySensorTypeBitmapArgument
                                                completionHandler:^(NSError * _Nullable err) {
                                                    NSLog(@"Writes the respective default value to mandatory attribute: "
                                                          @"OccupancySensorTypeBitmap Error: %@",
                                                        err);

                                                    VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                                                    NextTest();
                                                }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsBackMandatoryAttributeOccupancySensorTypeBitmap_9()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOccupancySensing * cluster = [[CHIPTestOccupancySensing alloc] initWithDevice:device
                                                                                     endpoint:1
                                                                                        queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster
            readAttributeOccupancySensorTypeBitmapWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
                NSLog(@"Reads back mandatory attribute: OccupancySensorTypeBitmap Error: %@", err);

                VerifyOrReturn(CheckValue("status", err, 0));

                {
                    id actualValue = value;
                    VerifyOrReturn(CheckValue("occupancy sensor type bitmap", actualValue, 1));
                }

                NextTest();
            }];

        return CHIP_NO_ERROR;
    }
};

class Test_TC_OCC_2_2 : public TestCommandBridge {
public:
    Test_TC_OCC_2_2()
        : TestCommandBridge("Test_TC_OCC_2_2")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_OCC_2_2() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_OCC_2_2\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_OCC_2_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Reads Occupancy attribute from DUT\n");
            if (ShouldSkip("A_OCCUPANCY")) {
                NextTest();
                return;
            }
            err = TestReadsOccupancyAttributeFromDut_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Reads Occupancy attribute from DUT\n");
            if (ShouldSkip("A_OCCUPANCY")) {
                NextTest();
                return;
            }
            err = TestReadsOccupancyAttributeFromDut_2();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 3;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsOccupancyAttributeFromDut_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOccupancySensing * cluster = [[CHIPTestOccupancySensing alloc] initWithDevice:device
                                                                                     endpoint:1
                                                                                        queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOccupancyWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads Occupancy attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("occupancy", "", "map8"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsOccupancyAttributeFromDut_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOccupancySensing * cluster = [[CHIPTestOccupancySensing alloc] initWithDevice:device
                                                                                     endpoint:1
                                                                                        queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOccupancyWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads Occupancy attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("occupancy", "", "map8"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
};

class Test_TC_OO_1_1 : public TestCommandBridge {
public:
    Test_TC_OO_1_1()
        : TestCommandBridge("Test_TC_OO_1_1")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_OO_1_1() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_OO_1_1\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_OO_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : read the global attribute: ClusterRevision\n");
            err = TestReadTheGlobalAttributeClusterRevision_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read the global attribute constraints: ClusterRevision\n");
            err = TestReadTheGlobalAttributeConstraintsClusterRevision_2();
            break;
        case 3:
            ChipLogProgress(
                chipTool, " ***** Test Step 3 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : reads back global attribute: ClusterRevision\n");
            err = TestReadsBackGlobalAttributeClusterRevision_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Read the global attribute: AttributeList\n");
            err = TestReadTheGlobalAttributeAttributeList_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : read the optional global attribute: FeatureMap\n");
            err = TestReadTheOptionalGlobalAttributeFeatureMap_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Read the optional global attribute : FeatureMap\n");
            err = TestReadTheOptionalGlobalAttributeFeatureMap_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : write the default values to optional global attribute: FeatureMap\n");
            err = TestWriteTheDefaultValuesToOptionalGlobalAttributeFeatureMap_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : reads back optional global attribute: FeatureMap\n");
            err = TestReadsBackOptionalGlobalAttributeFeatureMap_9();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 10;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheGlobalAttributeClusterRevision_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read the global attribute: ClusterRevision Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("ClusterRevision", actualValue, 4U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheGlobalAttributeConstraintsClusterRevision_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read the global attribute constraints: ClusterRevision Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("clusterRevision", "", "uint16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_3()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id clusterRevisionArgument;
        clusterRevisionArgument = [NSNumber numberWithUnsignedShort:3U];
        [cluster
            writeAttributeClusterRevisionWithValue:clusterRevisionArgument
                                 completionHandler:^(NSError * _Nullable err) {
                                     NSLog(
                                         @"write the default values to mandatory global attribute: ClusterRevision Error: %@", err);

                                     VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                                     NextTest();
                                 }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsBackGlobalAttributeClusterRevision_4()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"reads back global attribute: ClusterRevision Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("ClusterRevision", actualValue, 4U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheGlobalAttributeAttributeList_5()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read the global attribute: AttributeList Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("attributeList", "", "list"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheOptionalGlobalAttributeFeatureMap_6()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeFeatureMapWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read the optional global attribute: FeatureMap Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("FeatureMap", actualValue, 1UL));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheOptionalGlobalAttributeFeatureMap_7()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeFeatureMapWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read the optional global attribute : FeatureMap Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("featureMap", "", "map32"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteTheDefaultValuesToOptionalGlobalAttributeFeatureMap_8()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id featureMapArgument;
        featureMapArgument = [NSNumber numberWithUnsignedInt:0UL];
        [cluster writeAttributeFeatureMapWithValue:featureMapArgument
                                 completionHandler:^(NSError * _Nullable err) {
                                     NSLog(@"write the default values to optional global attribute: FeatureMap Error: %@", err);

                                     VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                                     NextTest();
                                 }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsBackOptionalGlobalAttributeFeatureMap_9()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeFeatureMapWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"reads back optional global attribute: FeatureMap Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("FeatureMap", actualValue, 1UL));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
};

class Test_TC_OO_2_1 : public TestCommandBridge {
public:
    Test_TC_OO_2_1()
        : TestCommandBridge("Test_TC_OO_2_1")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_OO_2_1() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_OO_2_1\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_OO_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : read the mandatory attribute: OnOff\n");
            err = TestReadTheMandatoryAttributeOnOff_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : read LT attribute: GlobalSceneControl\n");
            err = TestReadLtAttributeGlobalSceneControl_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : read LT attribute: OnTime\n");
            err = TestReadLtAttributeOnTime_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : read LT attribute: OffWaitTime\n");
            err = TestReadLtAttributeOffWaitTime_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : read LT attribute: StartUpOnOff\n");
            err = TestReadLtAttributeStartUpOnOff_5();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 6;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheMandatoryAttributeOnOff_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOnOffWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read the mandatory attribute: OnOff Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("onOff", "", "bool"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadLtAttributeGlobalSceneControl_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeGlobalSceneControlWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read LT attribute: GlobalSceneControl Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("globalSceneControl", "", "bool"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadLtAttributeOnTime_3()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOnTimeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read LT attribute: OnTime Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("onTime", "", "uint16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadLtAttributeOffWaitTime_4()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOffWaitTimeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read LT attribute: OffWaitTime Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("offWaitTime", "", "uint16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadLtAttributeStartUpOnOff_5()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeStartUpOnOffWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read LT attribute: StartUpOnOff Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("startUpOnOff", "", "enum8"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
};

class Test_TC_OO_2_2 : public TestCommandBridge {
public:
    Test_TC_OO_2_2()
        : TestCommandBridge("Test_TC_OO_2_2")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_OO_2_2() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_OO_2_2\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_OO_2_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Send Off Command\n");
            err = TestSendOffCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Send On Command\n");
            err = TestSendOnCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Send On Command\n");
            err = TestSendOnCommand_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Send Off Command\n");
            err = TestSendOffCommand_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Send Off Command\n");
            err = TestSendOffCommand_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : Send Toggle Command\n");
            err = TestSendToggleCommand_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : Wait 1000ms\n");
            err = TestWait1000ms_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : Check on/off attribute value is true after toggle command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterToggleCommand_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : Send Toggle Command\n");
            err = TestSendToggleCommand_14();
            break;
        case 15:
            ChipLogProgress(chipTool, " ***** Test Step 15 : Wait 1000ms\n");
            err = TestWait1000ms_15();
            break;
        case 16:
            ChipLogProgress(chipTool, " ***** Test Step 16 : Check on/off attribute value is false after toggle command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterToggleCommand_16();
            break;
        case 17:
            ChipLogProgress(chipTool, " ***** Test Step 17 : User prompt Set OnOff attribute manually to on\n");
            err = TestUserPromptSetOnOffAttributeManuallyToOn_17();
            break;
        case 18:
            ChipLogProgress(chipTool, " ***** Test Step 18 : User prompt Set OnOff attribute manually to off\n");
            err = TestUserPromptSetOnOffAttributeManuallyToOff_18();
            break;
        case 19:
            ChipLogProgress(chipTool, " ***** Test Step 19 : Reset Off Command\n");
            err = TestResetOffCommand_19();
            break;
        case 20:
            ChipLogProgress(chipTool, " ***** Test Step 20 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_20();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 21;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSendOffCommand_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster offWithCompletionHandler:^(NSError * _Nullable err) {
            NSLog(@"Send Off Command Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOnOffWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Check on/off attribute value is false after off command Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("OnOff", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSendOnCommand_3()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster onWithCompletionHandler:^(NSError * _Nullable err) {
            NSLog(@"Send On Command Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_4()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOnOffWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Check on/off attribute value is true after on command Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("OnOff", actualValue, 1));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSendOnCommand_5()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster onWithCompletionHandler:^(NSError * _Nullable err) {
            NSLog(@"Send On Command Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_6()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOnOffWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Check on/off attribute value is true after on command Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("OnOff", actualValue, 1));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSendOffCommand_7()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster offWithCompletionHandler:^(NSError * _Nullable err) {
            NSLog(@"Send Off Command Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_8()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOnOffWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Check on/off attribute value is false after off command Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("OnOff", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSendOffCommand_9()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster offWithCompletionHandler:^(NSError * _Nullable err) {
            NSLog(@"Send Off Command Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_10()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOnOffWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Check on/off attribute value is false after off command Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("OnOff", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSendToggleCommand_11()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster toggleWithCompletionHandler:^(NSError * _Nullable err) {
            NSLog(@"Send Toggle Command Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWait1000ms_12()
    {
        WaitForMs(1000);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterToggleCommand_13()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOnOffWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Check on/off attribute value is true after toggle command Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("OnOff", actualValue, 1));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSendToggleCommand_14()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster toggleWithCompletionHandler:^(NSError * _Nullable err) {
            NSLog(@"Send Toggle Command Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWait1000ms_15()
    {
        WaitForMs(1000);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterToggleCommand_16()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOnOffWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Check on/off attribute value is false after toggle command Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("OnOff", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestUserPromptSetOnOffAttributeManuallyToOn_17()
    {
        UserPrompt(@"Operate on device to set OnOff attribute manually to on");
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestUserPromptSetOnOffAttributeManuallyToOff_18()
    {
        UserPrompt(@"Operate on device to set OnOff attribute manually to off");
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestResetOffCommand_19()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster offWithCompletionHandler:^(NSError * _Nullable err) {
            NSLog(@"Reset Off Command Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_20()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOnOffWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Check on/off attribute value is false after off command Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("OnOff", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
};

class Test_TC_OO_2_3 : public TestCommandBridge {
public:
    Test_TC_OO_2_3()
        : TestCommandBridge("Test_TC_OO_2_3")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_OO_2_3() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_OO_2_3\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_OO_2_3\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Send On Command\n");
            if (ShouldSkip("CR_ON")) {
                NextTest();
                return;
            }
            err = TestSendOnCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Wait 1000ms\n");
            err = TestWait1000ms_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Reads OnOff attribute from DUT\n");
            if (ShouldSkip("A_ONOFF")) {
                NextTest();
                return;
            }
            err = TestReadsOnOffAttributeFromDut_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Reads GlobalSceneControl attribute from DUT\n");
            if (ShouldSkip("A_GLOBALSCENECONTROL")) {
                NextTest();
                return;
            }
            err = TestReadsGlobalSceneControlAttributeFromDut_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Send On Command\n");
            if (ShouldSkip("CR_ON")) {
                NextTest();
                return;
            }
            err = TestSendOnCommand_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Wait 1000ms\n");
            err = TestWait1000ms_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Reads OnOff attribute from DUT\n");
            if (ShouldSkip("A_ONOFF")) {
                NextTest();
                return;
            }
            err = TestReadsOnOffAttributeFromDut_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Reads GlobalSceneControl attribute from DUT\n");
            if (ShouldSkip("A_GLOBALSCENECONTROL")) {
                NextTest();
                return;
            }
            err = TestReadsGlobalSceneControlAttributeFromDut_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Send On Command\n");
            if (ShouldSkip("CR_ON")) {
                NextTest();
                return;
            }
            err = TestSendOnCommand_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Wait 1000ms\n");
            err = TestWait1000ms_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : Reads OnOff attribute from DUT\n");
            if (ShouldSkip("A_ONOFF")) {
                NextTest();
                return;
            }
            err = TestReadsOnOffAttributeFromDut_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : Reads GlobalSceneControl attribute from DUT\n");
            if (ShouldSkip("A_GLOBALSCENECONTROL")) {
                NextTest();
                return;
            }
            err = TestReadsGlobalSceneControlAttributeFromDut_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : Reads OnTime attribute from DUT\n");
            if (ShouldSkip("A_ONTIME")) {
                NextTest();
                return;
            }
            err = TestReadsOnTimeAttributeFromDut_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : Reads OffWaitTime attribute from DUT\n");
            if (ShouldSkip("A_OFFWAITTIME")) {
                NextTest();
                return;
            }
            err = TestReadsOffWaitTimeAttributeFromDut_14();
            break;
        case 15:
            ChipLogProgress(chipTool, " ***** Test Step 15 : Send On Command\n");
            if (ShouldSkip("CR_ON")) {
                NextTest();
                return;
            }
            err = TestSendOnCommand_15();
            break;
        case 16:
            ChipLogProgress(chipTool, " ***** Test Step 16 : Reads OnOff attribute from DUT\n");
            if (ShouldSkip("A_ONOFF")) {
                NextTest();
                return;
            }
            err = TestReadsOnOffAttributeFromDut_16();
            break;
        case 17:
            ChipLogProgress(chipTool, " ***** Test Step 17 : Reads OnTime attribute from DUT\n");
            if (ShouldSkip("A_ONTIME")) {
                NextTest();
                return;
            }
            err = TestReadsOnTimeAttributeFromDut_17();
            break;
        case 18:
            ChipLogProgress(chipTool, " ***** Test Step 18 : Reads OffWaitTime attribute from DUT\n");
            if (ShouldSkip("A_OFFWAITTIME")) {
                NextTest();
                return;
            }
            err = TestReadsOffWaitTimeAttributeFromDut_18();
            break;
        case 19:
            ChipLogProgress(chipTool, " ***** Test Step 19 : Send Off Command\n");
            if (ShouldSkip("CR_OFF")) {
                NextTest();
                return;
            }
            err = TestSendOffCommand_19();
            break;
        case 20:
            ChipLogProgress(chipTool, " ***** Test Step 20 : Reads OnOff attribute from DUT\n");
            if (ShouldSkip("A_ONOFF")) {
                NextTest();
                return;
            }
            err = TestReadsOnOffAttributeFromDut_20();
            break;
        case 21:
            ChipLogProgress(chipTool, " ***** Test Step 21 : Reads OnTime attribute from DUT\n");
            if (ShouldSkip("A_ONTIME")) {
                NextTest();
                return;
            }
            err = TestReadsOnTimeAttributeFromDut_21();
            break;
        case 22:
            ChipLogProgress(chipTool, " ***** Test Step 22 : Reads OnOff attribute from DUT\n");
            if (ShouldSkip("A_ONOFF")) {
                NextTest();
                return;
            }
            err = TestReadsOnOffAttributeFromDut_22();
            break;
        case 23:
            ChipLogProgress(chipTool, " ***** Test Step 23 : Reads OnTime attribute from DUT\n");
            if (ShouldSkip("A_ONTIME")) {
                NextTest();
                return;
            }
            err = TestReadsOnTimeAttributeFromDut_23();
            break;
        case 24:
            ChipLogProgress(chipTool, " ***** Test Step 24 : Reads OffWaitTime attribute from DUT\n");
            if (ShouldSkip("A_OFFWAITTIME")) {
                NextTest();
                return;
            }
            err = TestReadsOffWaitTimeAttributeFromDut_24();
            break;
        case 25:
            ChipLogProgress(chipTool, " ***** Test Step 25 : Send On Command\n");
            if (ShouldSkip("CR_ON")) {
                NextTest();
                return;
            }
            err = TestSendOnCommand_25();
            break;
        case 26:
            ChipLogProgress(chipTool, " ***** Test Step 26 : Reads OnTime attribute from DUT\n");
            if (ShouldSkip("A_ONTIME")) {
                NextTest();
                return;
            }
            err = TestReadsOnTimeAttributeFromDut_26();
            break;
        case 27:
            ChipLogProgress(chipTool, " ***** Test Step 27 : Reads OffWaitTime attribute from DUT\n");
            if (ShouldSkip("A_OFFWAITTIME")) {
                NextTest();
                return;
            }
            err = TestReadsOffWaitTimeAttributeFromDut_27();
            break;
        case 28:
            ChipLogProgress(chipTool, " ***** Test Step 28 : Send Off Command\n");
            if (ShouldSkip("CR_OFF")) {
                NextTest();
                return;
            }
            err = TestSendOffCommand_28();
            break;
        case 29:
            ChipLogProgress(chipTool, " ***** Test Step 29 : Reads OnOff attribute from DUT\n");
            if (ShouldSkip("A_ONOFF")) {
                NextTest();
                return;
            }
            err = TestReadsOnOffAttributeFromDut_29();
            break;
        case 30:
            ChipLogProgress(chipTool, " ***** Test Step 30 : Reads OnTime attribute from DUT\n");
            if (ShouldSkip("A_ONTIME")) {
                NextTest();
                return;
            }
            err = TestReadsOnTimeAttributeFromDut_30();
            break;
        case 31:
            ChipLogProgress(chipTool, " ***** Test Step 31 : Reads OnOff attribute from DUT\n");
            if (ShouldSkip("A_ONOFF")) {
                NextTest();
                return;
            }
            err = TestReadsOnOffAttributeFromDut_31();
            break;
        case 32:
            ChipLogProgress(chipTool, " ***** Test Step 32 : Reads OnTime attribute from DUT\n");
            if (ShouldSkip("A_ONTIME")) {
                NextTest();
                return;
            }
            err = TestReadsOnTimeAttributeFromDut_32();
            break;
        case 33:
            ChipLogProgress(chipTool, " ***** Test Step 33 : Send On Command\n");
            if (ShouldSkip("CR_ON")) {
                NextTest();
                return;
            }
            err = TestSendOnCommand_33();
            break;
        case 34:
            ChipLogProgress(chipTool, " ***** Test Step 34 : Reads OnOff attribute from DUT\n");
            if (ShouldSkip("A_ONOFF")) {
                NextTest();
                return;
            }
            err = TestReadsOnOffAttributeFromDut_34();
            break;
        case 35:
            ChipLogProgress(chipTool, " ***** Test Step 35 : Reads OnTime attribute from DUT\n");
            if (ShouldSkip("A_ONTIME")) {
                NextTest();
                return;
            }
            err = TestReadsOnTimeAttributeFromDut_35();
            break;
        case 36:
            ChipLogProgress(chipTool, " ***** Test Step 36 : Reads OffWaitTime attribute from DUT\n");
            if (ShouldSkip("A_OFFWAITTIME")) {
                NextTest();
                return;
            }
            err = TestReadsOffWaitTimeAttributeFromDut_36();
            break;
        case 37:
            ChipLogProgress(chipTool, " ***** Test Step 37 : Send Off Command\n");
            if (ShouldSkip("CR_OFF")) {
                NextTest();
                return;
            }
            err = TestSendOffCommand_37();
            break;
        case 38:
            ChipLogProgress(chipTool, " ***** Test Step 38 : Reads OnOff attribute from DUT\n");
            if (ShouldSkip("A_ONOFF")) {
                NextTest();
                return;
            }
            err = TestReadsOnOffAttributeFromDut_38();
            break;
        case 39:
            ChipLogProgress(chipTool, " ***** Test Step 39 : Reads OnTime attribute from DUT\n");
            if (ShouldSkip("A_ONTIME")) {
                NextTest();
                return;
            }
            err = TestReadsOnTimeAttributeFromDut_39();
            break;
        case 40:
            ChipLogProgress(chipTool, " ***** Test Step 40 : Reads OnOff attribute from DUT\n");
            if (ShouldSkip("A_ONOFF")) {
                NextTest();
                return;
            }
            err = TestReadsOnOffAttributeFromDut_40();
            break;
        case 41:
            ChipLogProgress(chipTool, " ***** Test Step 41 : Reads OnTime attribute from DUT\n");
            if (ShouldSkip("A_ONTIME")) {
                NextTest();
                return;
            }
            err = TestReadsOnTimeAttributeFromDut_41();
            break;
        case 42:
            ChipLogProgress(chipTool, " ***** Test Step 42 : Reads OffWaitTime attribute from DUT\n");
            if (ShouldSkip("A_OFFWAITTIME")) {
                NextTest();
                return;
            }
            err = TestReadsOffWaitTimeAttributeFromDut_42();
            break;
        case 43:
            ChipLogProgress(chipTool, " ***** Test Step 43 : Reads OnOff attribute from DUT\n");
            if (ShouldSkip("A_ONOFF")) {
                NextTest();
                return;
            }
            err = TestReadsOnOffAttributeFromDut_43();
            break;
        case 44:
            ChipLogProgress(chipTool, " ***** Test Step 44 : Reads OnTime attribute from DUT\n");
            if (ShouldSkip("A_ONTIME")) {
                NextTest();
                return;
            }
            err = TestReadsOnTimeAttributeFromDut_44();
            break;
        case 45:
            ChipLogProgress(chipTool, " ***** Test Step 45 : Reads OffWaitTime attribute from DUT\n");
            if (ShouldSkip("A_OFFWAITTIME")) {
                NextTest();
                return;
            }
            err = TestReadsOffWaitTimeAttributeFromDut_45();
            break;
        case 46:
            ChipLogProgress(chipTool, " ***** Test Step 46 : Send Off Command\n");
            if (ShouldSkip("CR_OFF")) {
                NextTest();
                return;
            }
            err = TestSendOffCommand_46();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 47;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSendOnCommand_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster onWithCompletionHandler:^(NSError * _Nullable err) {
            NSLog(@"Send On Command Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWait1000ms_2()
    {
        WaitForMs(1000);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsOnOffAttributeFromDut_3()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOnOffWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads OnOff attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("OnOff", actualValue, 1));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsGlobalSceneControlAttributeFromDut_4()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeGlobalSceneControlWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads GlobalSceneControl attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("GlobalSceneControl", actualValue, 1));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSendOnCommand_5()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster onWithCompletionHandler:^(NSError * _Nullable err) {
            NSLog(@"Send On Command Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWait1000ms_6()
    {
        WaitForMs(1000);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsOnOffAttributeFromDut_7()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOnOffWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads OnOff attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("OnOff", actualValue, 1));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsGlobalSceneControlAttributeFromDut_8()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeGlobalSceneControlWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads GlobalSceneControl attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("GlobalSceneControl", actualValue, 1));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSendOnCommand_9()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster onWithCompletionHandler:^(NSError * _Nullable err) {
            NSLog(@"Send On Command Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWait1000ms_10()
    {
        WaitForMs(1000);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsOnOffAttributeFromDut_11()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOnOffWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads OnOff attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("OnOff", actualValue, 1));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsGlobalSceneControlAttributeFromDut_12()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeGlobalSceneControlWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads GlobalSceneControl attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("GlobalSceneControl", actualValue, 1));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsOnTimeAttributeFromDut_13()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOnTimeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads OnTime attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("OnTime", actualValue, 0U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsOffWaitTimeAttributeFromDut_14()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOffWaitTimeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads OffWaitTime attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("OffWaitTime", actualValue, 0U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSendOnCommand_15()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster onWithCompletionHandler:^(NSError * _Nullable err) {
            NSLog(@"Send On Command Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsOnOffAttributeFromDut_16()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOnOffWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads OnOff attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("OnOff", actualValue, 1));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsOnTimeAttributeFromDut_17()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOnTimeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads OnTime attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("OnTime", actualValue, 0U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsOffWaitTimeAttributeFromDut_18()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOffWaitTimeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads OffWaitTime attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("OffWaitTime", actualValue, 0U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSendOffCommand_19()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster offWithCompletionHandler:^(NSError * _Nullable err) {
            NSLog(@"Send Off Command Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsOnOffAttributeFromDut_20()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOnOffWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads OnOff attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("OnOff", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsOnTimeAttributeFromDut_21()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOnTimeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads OnTime attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("OnTime", actualValue, 0U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsOnOffAttributeFromDut_22()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOnOffWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads OnOff attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("OnOff", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsOnTimeAttributeFromDut_23()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOnTimeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads OnTime attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("OnTime", actualValue, 0U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsOffWaitTimeAttributeFromDut_24()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOffWaitTimeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads OffWaitTime attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("OffWaitTime", actualValue, 0U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSendOnCommand_25()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster onWithCompletionHandler:^(NSError * _Nullable err) {
            NSLog(@"Send On Command Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsOnTimeAttributeFromDut_26()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOnTimeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads OnTime attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("OnTime", actualValue, 0U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsOffWaitTimeAttributeFromDut_27()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOffWaitTimeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads OffWaitTime attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("OffWaitTime", actualValue, 0U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSendOffCommand_28()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster offWithCompletionHandler:^(NSError * _Nullable err) {
            NSLog(@"Send Off Command Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsOnOffAttributeFromDut_29()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOnOffWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads OnOff attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("OnOff", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsOnTimeAttributeFromDut_30()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOnTimeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads OnTime attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("OnTime", actualValue, 0U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsOnOffAttributeFromDut_31()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOnOffWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads OnOff attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("OnOff", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsOnTimeAttributeFromDut_32()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOnTimeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads OnTime attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("OnTime", actualValue, 0U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSendOnCommand_33()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster onWithCompletionHandler:^(NSError * _Nullable err) {
            NSLog(@"Send On Command Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsOnOffAttributeFromDut_34()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOnOffWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads OnOff attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("OnOff", actualValue, 1));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsOnTimeAttributeFromDut_35()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOnTimeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads OnTime attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("OnTime", actualValue, 0U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsOffWaitTimeAttributeFromDut_36()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOffWaitTimeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads OffWaitTime attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("OffWaitTime", actualValue, 0U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSendOffCommand_37()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster offWithCompletionHandler:^(NSError * _Nullable err) {
            NSLog(@"Send Off Command Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsOnOffAttributeFromDut_38()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOnOffWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads OnOff attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("OnOff", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsOnTimeAttributeFromDut_39()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOnTimeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads OnTime attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("OnTime", actualValue, 0U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsOnOffAttributeFromDut_40()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOnOffWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads OnOff attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("OnOff", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsOnTimeAttributeFromDut_41()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOnTimeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads OnTime attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("OnTime", actualValue, 0U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsOffWaitTimeAttributeFromDut_42()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOffWaitTimeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads OffWaitTime attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("OffWaitTime", actualValue, 0U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsOnOffAttributeFromDut_43()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOnOffWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads OnOff attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("OnOff", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsOnTimeAttributeFromDut_44()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOnTimeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads OnTime attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("OnTime", actualValue, 0U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsOffWaitTimeAttributeFromDut_45()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOffWaitTimeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads OffWaitTime attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("OffWaitTime", actualValue, 0U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSendOffCommand_46()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster offWithCompletionHandler:^(NSError * _Nullable err) {
            NSLog(@"Send Off Command Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
};

class Test_TC_PS_1_1 : public TestCommandBridge {
public:
    Test_TC_PS_1_1()
        : TestCommandBridge("Test_TC_PS_1_1")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_PS_1_1() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_PS_1_1\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_PS_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : read the global attribute: ClusterRevision\n");
            err = TestReadTheGlobalAttributeClusterRevision_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read the global attribute constraints: ClusterRevision\n");
            err = TestReadTheGlobalAttributeConstraintsClusterRevision_2();
            break;
        case 3:
            ChipLogProgress(
                chipTool, " ***** Test Step 3 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : reads back global attribute: ClusterRevision\n");
            err = TestReadsBackGlobalAttributeClusterRevision_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Read the global attribute: AttributeList\n");
            err = TestReadTheGlobalAttributeAttributeList_5();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 6;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheGlobalAttributeClusterRevision_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestPowerSource * cluster = [[CHIPTestPowerSource alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read the global attribute: ClusterRevision Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("ClusterRevision", actualValue, 1U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheGlobalAttributeConstraintsClusterRevision_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestPowerSource * cluster = [[CHIPTestPowerSource alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read the global attribute constraints: ClusterRevision Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("clusterRevision", "", "uint16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_3()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestPowerSource * cluster = [[CHIPTestPowerSource alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id clusterRevisionArgument;
        clusterRevisionArgument = [NSNumber numberWithUnsignedShort:1U];
        [cluster
            writeAttributeClusterRevisionWithValue:clusterRevisionArgument
                                 completionHandler:^(NSError * _Nullable err) {
                                     NSLog(
                                         @"write the default values to mandatory global attribute: ClusterRevision Error: %@", err);

                                     VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                                     NextTest();
                                 }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsBackGlobalAttributeClusterRevision_4()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestPowerSource * cluster = [[CHIPTestPowerSource alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"reads back global attribute: ClusterRevision Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("ClusterRevision", actualValue, 1U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheGlobalAttributeAttributeList_5()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestPowerSource * cluster = [[CHIPTestPowerSource alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read the global attribute: AttributeList Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("attributeList", "", "list"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
};

class Test_TC_PRS_1_1 : public TestCommandBridge {
public:
    Test_TC_PRS_1_1()
        : TestCommandBridge("Test_TC_PRS_1_1")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_PRS_1_1() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_PRS_1_1\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_PRS_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read the global attribute constraints: ClusterRevision\n");
            err = TestReadTheGlobalAttributeConstraintsClusterRevision_1();
            break;
        case 2:
            ChipLogProgress(
                chipTool, " ***** Test Step 2 : Write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read the global attribute constraints: AttributeList\n");
            err = TestReadTheGlobalAttributeConstraintsAttributeList_3();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 4;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheGlobalAttributeConstraintsClusterRevision_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestPressureMeasurement * cluster = [[CHIPTestPressureMeasurement alloc] initWithDevice:device
                                                                                           endpoint:1
                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read the global attribute constraints: ClusterRevision Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("clusterRevision", "", "uint16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestPressureMeasurement * cluster = [[CHIPTestPressureMeasurement alloc] initWithDevice:device
                                                                                           endpoint:1
                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id clusterRevisionArgument;
        clusterRevisionArgument = [NSNumber numberWithUnsignedShort:3U];
        [cluster
            writeAttributeClusterRevisionWithValue:clusterRevisionArgument
                                 completionHandler:^(NSError * _Nullable err) {
                                     NSLog(
                                         @"Write the default values to mandatory global attribute: ClusterRevision Error: %@", err);

                                     VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                                     NextTest();
                                 }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheGlobalAttributeConstraintsAttributeList_3()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestPressureMeasurement * cluster = [[CHIPTestPressureMeasurement alloc] initWithDevice:device
                                                                                           endpoint:1
                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read the global attribute constraints: AttributeList Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("attributeList", "", "list"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
};

class Test_TC_PRS_2_1 : public TestCommandBridge {
public:
    Test_TC_PRS_2_1()
        : TestCommandBridge("Test_TC_PRS_2_1")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_PRS_2_1() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_PRS_2_1\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_PRS_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read the mandatory attribute constraints: MeasuredValue\n");
            err = TestReadTheMandatoryAttributeConstraintsMeasuredValue_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Write the default values to mandatory attribute: MeasuredValue\n");
            err = TestWriteTheDefaultValuesToMandatoryAttributeMeasuredValue_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Reads back mandatory attribute: MeasuredValue\n");
            err = TestReadsBackMandatoryAttributeMeasuredValue_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Read the mandatory attribute constraints: MinMeasuredValue\n");
            err = TestReadTheMandatoryAttributeConstraintsMinMeasuredValue_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Write the default values to mandatory attribute: MinMeasuredValue\n");
            err = TestWriteTheDefaultValuesToMandatoryAttributeMinMeasuredValue_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Reads back mandatory attribute: MinMeasuredValue\n");
            err = TestReadsBackMandatoryAttributeMinMeasuredValue_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Read the mandatory attribute constraints: MaxMeasuredValue\n");
            err = TestReadTheMandatoryAttributeConstraintsMaxMeasuredValue_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Write the default values to mandatory attribute: MaxMeasuredValue\n");
            err = TestWriteTheDefaultValuesToMandatoryAttributeMaxMeasuredValue_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Reads back mandatory attribute: MaxMeasuredValue\n");
            err = TestReadsBackMandatoryAttributeMaxMeasuredValue_9();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 10;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheMandatoryAttributeConstraintsMeasuredValue_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestPressureMeasurement * cluster = [[CHIPTestPressureMeasurement alloc] initWithDevice:device
                                                                                           endpoint:1
                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeMeasuredValueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read the mandatory attribute constraints: MeasuredValue Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("measuredValue", "", "int16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryAttributeMeasuredValue_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestPressureMeasurement * cluster = [[CHIPTestPressureMeasurement alloc] initWithDevice:device
                                                                                           endpoint:1
                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id measuredValueArgument;
        measuredValueArgument = [NSNumber numberWithShort:0];
        [cluster writeAttributeMeasuredValueWithValue:measuredValueArgument
                                    completionHandler:^(NSError * _Nullable err) {
                                        NSLog(@"Write the default values to mandatory attribute: MeasuredValue Error: %@", err);

                                        VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                                        NextTest();
                                    }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsBackMandatoryAttributeMeasuredValue_3()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestPressureMeasurement * cluster = [[CHIPTestPressureMeasurement alloc] initWithDevice:device
                                                                                           endpoint:1
                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeMeasuredValueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads back mandatory attribute: MeasuredValue Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNonNull("MeasuredValue", actualValue));
                VerifyOrReturn(CheckValue("MeasuredValue", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheMandatoryAttributeConstraintsMinMeasuredValue_4()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestPressureMeasurement * cluster = [[CHIPTestPressureMeasurement alloc] initWithDevice:device
                                                                                           endpoint:1
                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeMinMeasuredValueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read the mandatory attribute constraints: MinMeasuredValue Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("minMeasuredValue", "", "int16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryAttributeMinMeasuredValue_5()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestPressureMeasurement * cluster = [[CHIPTestPressureMeasurement alloc] initWithDevice:device
                                                                                           endpoint:1
                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id minMeasuredValueArgument;
        minMeasuredValueArgument = [NSNumber numberWithShort:0];
        [cluster
            writeAttributeMinMeasuredValueWithValue:minMeasuredValueArgument
                                  completionHandler:^(NSError * _Nullable err) {
                                      NSLog(@"Write the default values to mandatory attribute: MinMeasuredValue Error: %@", err);

                                      VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                                      NextTest();
                                  }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsBackMandatoryAttributeMinMeasuredValue_6()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestPressureMeasurement * cluster = [[CHIPTestPressureMeasurement alloc] initWithDevice:device
                                                                                           endpoint:1
                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeMinMeasuredValueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads back mandatory attribute: MinMeasuredValue Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNonNull("MinMeasuredValue", actualValue));
                VerifyOrReturn(CheckValue("MinMeasuredValue", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheMandatoryAttributeConstraintsMaxMeasuredValue_7()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestPressureMeasurement * cluster = [[CHIPTestPressureMeasurement alloc] initWithDevice:device
                                                                                           endpoint:1
                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeMaxMeasuredValueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read the mandatory attribute constraints: MaxMeasuredValue Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("maxMeasuredValue", "", "int16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryAttributeMaxMeasuredValue_8()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestPressureMeasurement * cluster = [[CHIPTestPressureMeasurement alloc] initWithDevice:device
                                                                                           endpoint:1
                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id maxMeasuredValueArgument;
        maxMeasuredValueArgument = [NSNumber numberWithShort:0];
        [cluster
            writeAttributeMaxMeasuredValueWithValue:maxMeasuredValueArgument
                                  completionHandler:^(NSError * _Nullable err) {
                                      NSLog(@"Write the default values to mandatory attribute: MaxMeasuredValue Error: %@", err);

                                      VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                                      NextTest();
                                  }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsBackMandatoryAttributeMaxMeasuredValue_9()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestPressureMeasurement * cluster = [[CHIPTestPressureMeasurement alloc] initWithDevice:device
                                                                                           endpoint:1
                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeMaxMeasuredValueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads back mandatory attribute: MaxMeasuredValue Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNonNull("MaxMeasuredValue", actualValue));
                VerifyOrReturn(CheckValue("MaxMeasuredValue", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
};

class Test_TC_PCC_1_1 : public TestCommandBridge {
public:
    Test_TC_PCC_1_1()
        : TestCommandBridge("Test_TC_PCC_1_1")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_PCC_1_1() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_PCC_1_1\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_PCC_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read the global attribute constraints: ClusterRevision\n");
            err = TestReadTheGlobalAttributeConstraintsClusterRevision_1();
            break;
        case 2:
            ChipLogProgress(
                chipTool, " ***** Test Step 2 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read the global attribute: AttributeList\n");
            err = TestReadTheGlobalAttributeAttributeList_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : read the optional global attribute: FeatureMap\n");
            err = TestReadTheOptionalGlobalAttributeFeatureMap_4();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 5;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheGlobalAttributeConstraintsClusterRevision_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestPumpConfigurationAndControl * cluster = [[CHIPTestPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                           endpoint:1
                                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read the global attribute constraints: ClusterRevision Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("clusterRevision", "", "uint16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestPumpConfigurationAndControl * cluster = [[CHIPTestPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                           endpoint:1
                                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id clusterRevisionArgument;
        clusterRevisionArgument = [NSNumber numberWithUnsignedShort:3U];
        [cluster
            writeAttributeClusterRevisionWithValue:clusterRevisionArgument
                                 completionHandler:^(NSError * _Nullable err) {
                                     NSLog(
                                         @"write the default values to mandatory global attribute: ClusterRevision Error: %@", err);

                                     VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                                     NextTest();
                                 }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheGlobalAttributeAttributeList_3()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestPumpConfigurationAndControl * cluster = [[CHIPTestPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                           endpoint:1
                                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read the global attribute: AttributeList Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("attributeList", "", "list"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheOptionalGlobalAttributeFeatureMap_4()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestPumpConfigurationAndControl * cluster = [[CHIPTestPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                           endpoint:1
                                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeFeatureMapWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read the optional global attribute: FeatureMap Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("featureMap", "", "map32"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
};

class Test_TC_PCC_2_1 : public TestCommandBridge {
public:
    Test_TC_PCC_2_1()
        : TestCommandBridge("Test_TC_PCC_2_1")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_PCC_2_1() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_PCC_2_1\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_PCC_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : read the mandatory attribute: MaxPressure\n");
            err = TestReadTheMandatoryAttributeMaxPressure_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : read the mandatory attribute: MaxSpeed\n");
            err = TestReadTheMandatoryAttributeMaxSpeed_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : read the mandatory attribute: MaxFlow\n");
            err = TestReadTheMandatoryAttributeMaxFlow_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : read the mandatory attribute: EffectiveOperationMode\n");
            err = TestReadTheMandatoryAttributeEffectiveOperationMode_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : read the mandatory attribute: EffectiveControlMode\n");
            err = TestReadTheMandatoryAttributeEffectiveControlMode_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : read the mandatory attribute: Capacity\n");
            err = TestReadTheMandatoryAttributeCapacity_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : read the mandatory attribute: MaxPressure\n");
            err = TestReadTheMandatoryAttributeMaxPressure_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : read the mandatory attribute: MaxSpeed\n");
            err = TestReadTheMandatoryAttributeMaxSpeed_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : read the mandatory attribute: MaxFlow\n");
            err = TestReadTheMandatoryAttributeMaxFlow_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : read the mandatory attribute: EffectiveOperationMode\n");
            err = TestReadTheMandatoryAttributeEffectiveOperationMode_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : read the mandatory attribute: EffectiveControlMode\n");
            err = TestReadTheMandatoryAttributeEffectiveControlMode_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : read the mandatory attribute: Capacity\n");
            err = TestReadTheMandatoryAttributeCapacity_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : read the optional attribute: MinConstPressure\n");
            err = TestReadTheOptionalAttributeMinConstPressure_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : read the optional attribute: MaxConstPressure\n");
            err = TestReadTheOptionalAttributeMaxConstPressure_14();
            break;
        case 15:
            ChipLogProgress(chipTool, " ***** Test Step 15 : read the optional attribute: MinCompPressure\n");
            err = TestReadTheOptionalAttributeMinCompPressure_15();
            break;
        case 16:
            ChipLogProgress(chipTool, " ***** Test Step 16 : read the optional attribute: MaxCompPressure\n");
            err = TestReadTheOptionalAttributeMaxCompPressure_16();
            break;
        case 17:
            ChipLogProgress(chipTool, " ***** Test Step 17 : read the optional attribute: MinConstSpeed\n");
            err = TestReadTheOptionalAttributeMinConstSpeed_17();
            break;
        case 18:
            ChipLogProgress(chipTool, " ***** Test Step 18 : read the optional attribute: MaxConstSpeed\n");
            err = TestReadTheOptionalAttributeMaxConstSpeed_18();
            break;
        case 19:
            ChipLogProgress(chipTool, " ***** Test Step 19 : read the optional attribute: MinConstFlow\n");
            err = TestReadTheOptionalAttributeMinConstFlow_19();
            break;
        case 20:
            ChipLogProgress(chipTool, " ***** Test Step 20 : read the optional attribute: MaxConstFlow\n");
            err = TestReadTheOptionalAttributeMaxConstFlow_20();
            break;
        case 21:
            ChipLogProgress(chipTool, " ***** Test Step 21 : read the optional attribute: MinConstTemp\n");
            err = TestReadTheOptionalAttributeMinConstTemp_21();
            break;
        case 22:
            ChipLogProgress(chipTool, " ***** Test Step 22 : read the optional attribute: MaxConstTemp\n");
            err = TestReadTheOptionalAttributeMaxConstTemp_22();
            break;
        case 23:
            ChipLogProgress(chipTool, " ***** Test Step 23 : read the optional attribute: PumpStatus\n");
            err = TestReadTheOptionalAttributePumpStatus_23();
            break;
        case 24:
            ChipLogProgress(chipTool, " ***** Test Step 24 : read the optional attribute: PumpStatus\n");
            err = TestReadTheOptionalAttributePumpStatus_24();
            break;
        case 25:
            ChipLogProgress(chipTool, " ***** Test Step 25 : read the optional attribute: Speed\n");
            err = TestReadTheOptionalAttributeSpeed_25();
            break;
        case 26:
            ChipLogProgress(chipTool, " ***** Test Step 26 : read the optional attribute: LifetimeRunningHours\n");
            err = TestReadTheOptionalAttributeLifetimeRunningHours_26();
            break;
        case 27:
            ChipLogProgress(chipTool, " ***** Test Step 27 : read the optional attribute: LifetimeRunningHours\n");
            err = TestReadTheOptionalAttributeLifetimeRunningHours_27();
            break;
        case 28:
            ChipLogProgress(chipTool, " ***** Test Step 28 : read the optional attribute: Power\n");
            err = TestReadTheOptionalAttributePower_28();
            break;
        case 29:
            ChipLogProgress(chipTool, " ***** Test Step 29 : read the optional attribute: LifetimeEnergyConsumed\n");
            err = TestReadTheOptionalAttributeLifetimeEnergyConsumed_29();
            break;
        case 30:
            ChipLogProgress(chipTool, " ***** Test Step 30 : read the optional attribute: LifetimeEnergyConsumed\n");
            err = TestReadTheOptionalAttributeLifetimeEnergyConsumed_30();
            break;
        case 31:
            ChipLogProgress(chipTool, " ***** Test Step 31 : write to the optional attribute: LifetimeEnergyConsumed\n");
            err = TestWriteToTheOptionalAttributeLifetimeEnergyConsumed_31();
            break;
        case 32:
            ChipLogProgress(chipTool, " ***** Test Step 32 : read the optional attribute: MinConstPressure\n");
            err = TestReadTheOptionalAttributeMinConstPressure_32();
            break;
        case 33:
            ChipLogProgress(chipTool, " ***** Test Step 33 : read the optional attribute: MaxConstPressure\n");
            err = TestReadTheOptionalAttributeMaxConstPressure_33();
            break;
        case 34:
            ChipLogProgress(chipTool, " ***** Test Step 34 : read the optional attribute: MinCompPressure\n");
            err = TestReadTheOptionalAttributeMinCompPressure_34();
            break;
        case 35:
            ChipLogProgress(chipTool, " ***** Test Step 35 : read the optional attribute: MaxCompPressure\n");
            err = TestReadTheOptionalAttributeMaxCompPressure_35();
            break;
        case 36:
            ChipLogProgress(chipTool, " ***** Test Step 36 : read the optional attribute: MinConstSpeed\n");
            err = TestReadTheOptionalAttributeMinConstSpeed_36();
            break;
        case 37:
            ChipLogProgress(chipTool, " ***** Test Step 37 : read the optional attribute: MaxConstSpeed\n");
            err = TestReadTheOptionalAttributeMaxConstSpeed_37();
            break;
        case 38:
            ChipLogProgress(chipTool, " ***** Test Step 38 : read the optional attribute: MinConstFlow\n");
            err = TestReadTheOptionalAttributeMinConstFlow_38();
            break;
        case 39:
            ChipLogProgress(chipTool, " ***** Test Step 39 : read the optional attribute: MaxConstFlow\n");
            err = TestReadTheOptionalAttributeMaxConstFlow_39();
            break;
        case 40:
            ChipLogProgress(chipTool, " ***** Test Step 40 : read the optional attribute: MinConstTemp\n");
            err = TestReadTheOptionalAttributeMinConstTemp_40();
            break;
        case 41:
            ChipLogProgress(chipTool, " ***** Test Step 41 : read the optional attribute: MaxConstTemp\n");
            err = TestReadTheOptionalAttributeMaxConstTemp_41();
            break;
        case 42:
            ChipLogProgress(chipTool, " ***** Test Step 42 : read the optional attribute: PumpStatus\n");
            err = TestReadTheOptionalAttributePumpStatus_42();
            break;
        case 43:
            ChipLogProgress(chipTool, " ***** Test Step 43 : read the optional attribute: PumpStatus\n");
            err = TestReadTheOptionalAttributePumpStatus_43();
            break;
        case 44:
            ChipLogProgress(chipTool, " ***** Test Step 44 : read the optional attribute: Speed\n");
            err = TestReadTheOptionalAttributeSpeed_44();
            break;
        case 45:
            ChipLogProgress(chipTool, " ***** Test Step 45 : read the optional attribute: LifetimeRunningHours\n");
            err = TestReadTheOptionalAttributeLifetimeRunningHours_45();
            break;
        case 46:
            ChipLogProgress(chipTool, " ***** Test Step 46 : read the optional attribute: LifetimeRunningHours\n");
            err = TestReadTheOptionalAttributeLifetimeRunningHours_46();
            break;
        case 47:
            ChipLogProgress(chipTool, " ***** Test Step 47 : read the optional attribute: Power\n");
            err = TestReadTheOptionalAttributePower_47();
            break;
        case 48:
            ChipLogProgress(chipTool, " ***** Test Step 48 : read the optional attribute: LifetimeEnergyConsumed\n");
            err = TestReadTheOptionalAttributeLifetimeEnergyConsumed_48();
            break;
        case 49:
            ChipLogProgress(chipTool, " ***** Test Step 49 : read the optional attribute: LifetimeEnergyConsumed\n");
            err = TestReadTheOptionalAttributeLifetimeEnergyConsumed_49();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 50;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheMandatoryAttributeMaxPressure_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestPumpConfigurationAndControl * cluster = [[CHIPTestPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                           endpoint:1
                                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeMaxPressureWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read the mandatory attribute: MaxPressure Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("maxPressure", "", "int16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheMandatoryAttributeMaxSpeed_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestPumpConfigurationAndControl * cluster = [[CHIPTestPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                           endpoint:1
                                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeMaxSpeedWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read the mandatory attribute: MaxSpeed Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("maxSpeed", "", "uint16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheMandatoryAttributeMaxFlow_3()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestPumpConfigurationAndControl * cluster = [[CHIPTestPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                           endpoint:1
                                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeMaxFlowWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read the mandatory attribute: MaxFlow Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("maxFlow", "", "uint16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheMandatoryAttributeEffectiveOperationMode_4()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestPumpConfigurationAndControl * cluster = [[CHIPTestPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                           endpoint:1
                                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeEffectiveOperationModeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read the mandatory attribute: EffectiveOperationMode Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("effectiveOperationMode", "", "enum8"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheMandatoryAttributeEffectiveControlMode_5()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestPumpConfigurationAndControl * cluster = [[CHIPTestPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                           endpoint:1
                                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeEffectiveControlModeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read the mandatory attribute: EffectiveControlMode Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("effectiveControlMode", "", "enum8"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheMandatoryAttributeCapacity_6()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestPumpConfigurationAndControl * cluster = [[CHIPTestPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                           endpoint:1
                                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeCapacityWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read the mandatory attribute: Capacity Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("capacity", "", "int16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheMandatoryAttributeMaxPressure_7()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestPumpConfigurationAndControl * cluster = [[CHIPTestPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                           endpoint:1
                                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeMaxPressureWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read the mandatory attribute: MaxPressure Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("maxPressure", "", "int16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheMandatoryAttributeMaxSpeed_8()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestPumpConfigurationAndControl * cluster = [[CHIPTestPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                           endpoint:1
                                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeMaxSpeedWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read the mandatory attribute: MaxSpeed Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("maxSpeed", "", "uint16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheMandatoryAttributeMaxFlow_9()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestPumpConfigurationAndControl * cluster = [[CHIPTestPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                           endpoint:1
                                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeMaxFlowWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read the mandatory attribute: MaxFlow Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("maxFlow", "", "uint16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheMandatoryAttributeEffectiveOperationMode_10()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestPumpConfigurationAndControl * cluster = [[CHIPTestPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                           endpoint:1
                                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeEffectiveOperationModeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read the mandatory attribute: EffectiveOperationMode Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("effectiveOperationMode", "", "enum8"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheMandatoryAttributeEffectiveControlMode_11()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestPumpConfigurationAndControl * cluster = [[CHIPTestPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                           endpoint:1
                                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeEffectiveControlModeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read the mandatory attribute: EffectiveControlMode Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("effectiveControlMode", "", "enum8"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheMandatoryAttributeCapacity_12()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestPumpConfigurationAndControl * cluster = [[CHIPTestPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                           endpoint:1
                                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeCapacityWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read the mandatory attribute: Capacity Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("capacity", "", "int16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheOptionalAttributeMinConstPressure_13()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestPumpConfigurationAndControl * cluster = [[CHIPTestPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                           endpoint:1
                                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeMinConstPressureWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read the optional attribute: MinConstPressure Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("minConstPressure", "", "int16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheOptionalAttributeMaxConstPressure_14()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestPumpConfigurationAndControl * cluster = [[CHIPTestPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                           endpoint:1
                                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeMaxConstPressureWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read the optional attribute: MaxConstPressure Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("maxConstPressure", "", "int16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheOptionalAttributeMinCompPressure_15()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestPumpConfigurationAndControl * cluster = [[CHIPTestPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                           endpoint:1
                                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeMinCompPressureWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read the optional attribute: MinCompPressure Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("minCompPressure", "", "int16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheOptionalAttributeMaxCompPressure_16()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestPumpConfigurationAndControl * cluster = [[CHIPTestPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                           endpoint:1
                                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeMaxCompPressureWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read the optional attribute: MaxCompPressure Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("maxCompPressure", "", "int16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheOptionalAttributeMinConstSpeed_17()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestPumpConfigurationAndControl * cluster = [[CHIPTestPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                           endpoint:1
                                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeMinConstSpeedWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read the optional attribute: MinConstSpeed Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("minConstSpeed", "", "uint16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheOptionalAttributeMaxConstSpeed_18()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestPumpConfigurationAndControl * cluster = [[CHIPTestPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                           endpoint:1
                                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeMaxConstSpeedWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read the optional attribute: MaxConstSpeed Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("maxConstSpeed", "", "uint16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheOptionalAttributeMinConstFlow_19()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestPumpConfigurationAndControl * cluster = [[CHIPTestPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                           endpoint:1
                                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeMinConstFlowWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read the optional attribute: MinConstFlow Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("minConstFlow", "", "uint16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheOptionalAttributeMaxConstFlow_20()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestPumpConfigurationAndControl * cluster = [[CHIPTestPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                           endpoint:1
                                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeMaxConstFlowWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read the optional attribute: MaxConstFlow Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("maxConstFlow", "", "uint16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheOptionalAttributeMinConstTemp_21()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestPumpConfigurationAndControl * cluster = [[CHIPTestPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                           endpoint:1
                                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeMinConstTempWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read the optional attribute: MinConstTemp Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("minConstTemp", "", "int16"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<int16_t>("minConstTemp", [value shortValue], -27315));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheOptionalAttributeMaxConstTemp_22()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestPumpConfigurationAndControl * cluster = [[CHIPTestPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                           endpoint:1
                                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeMaxConstTempWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read the optional attribute: MaxConstTemp Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("maxConstTemp", "", "int16"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<int16_t>("maxConstTemp", [value shortValue], -27315));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheOptionalAttributePumpStatus_23()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestPumpConfigurationAndControl * cluster = [[CHIPTestPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                           endpoint:1
                                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributePumpStatusWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read the optional attribute: PumpStatus Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("PumpStatus", actualValue, 0U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheOptionalAttributePumpStatus_24()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestPumpConfigurationAndControl * cluster = [[CHIPTestPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                           endpoint:1
                                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributePumpStatusWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read the optional attribute: PumpStatus Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("pumpStatus", "", "map16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheOptionalAttributeSpeed_25()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestPumpConfigurationAndControl * cluster = [[CHIPTestPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                           endpoint:1
                                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeSpeedWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read the optional attribute: Speed Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("speed", "", "uint16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheOptionalAttributeLifetimeRunningHours_26()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestPumpConfigurationAndControl * cluster = [[CHIPTestPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                           endpoint:1
                                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeLifetimeRunningHoursWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read the optional attribute: LifetimeRunningHours Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNonNull("LifetimeRunningHours", actualValue));
                VerifyOrReturn(CheckValue("LifetimeRunningHours", actualValue, 0UL));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheOptionalAttributeLifetimeRunningHours_27()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestPumpConfigurationAndControl * cluster = [[CHIPTestPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                           endpoint:1
                                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeLifetimeRunningHoursWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read the optional attribute: LifetimeRunningHours Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("lifetimeRunningHours", "", "uint24"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheOptionalAttributePower_28()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestPumpConfigurationAndControl * cluster = [[CHIPTestPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                           endpoint:1
                                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributePowerWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read the optional attribute: Power Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("power", "", "uint24"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheOptionalAttributeLifetimeEnergyConsumed_29()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestPumpConfigurationAndControl * cluster = [[CHIPTestPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                           endpoint:1
                                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeLifetimeEnergyConsumedWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read the optional attribute: LifetimeEnergyConsumed Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNonNull("LifetimeEnergyConsumed", actualValue));
                VerifyOrReturn(CheckValue("LifetimeEnergyConsumed", actualValue, 0UL));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheOptionalAttributeLifetimeEnergyConsumed_30()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestPumpConfigurationAndControl * cluster = [[CHIPTestPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                           endpoint:1
                                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeLifetimeEnergyConsumedWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read the optional attribute: LifetimeEnergyConsumed Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("lifetimeEnergyConsumed", "", "uint32"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteToTheOptionalAttributeLifetimeEnergyConsumed_31()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestPumpConfigurationAndControl * cluster = [[CHIPTestPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                           endpoint:1
                                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id lifetimeEnergyConsumedArgument;
        lifetimeEnergyConsumedArgument = [NSNumber numberWithUnsignedInt:0UL];
        [cluster writeAttributeLifetimeEnergyConsumedWithValue:lifetimeEnergyConsumedArgument
                                             completionHandler:^(NSError * _Nullable err) {
                                                 NSLog(@"write to the optional attribute: LifetimeEnergyConsumed Error: %@", err);

                                                 if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                                                     NextTest();
                                                     return;
                                                 }

                                                 VerifyOrReturn(CheckValue("status", err, 0));

                                                 NextTest();
                                             }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheOptionalAttributeMinConstPressure_32()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestPumpConfigurationAndControl * cluster = [[CHIPTestPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                           endpoint:1
                                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeMinConstPressureWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read the optional attribute: MinConstPressure Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("minConstPressure", "", "int16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheOptionalAttributeMaxConstPressure_33()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestPumpConfigurationAndControl * cluster = [[CHIPTestPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                           endpoint:1
                                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeMaxConstPressureWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read the optional attribute: MaxConstPressure Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("maxConstPressure", "", "int16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheOptionalAttributeMinCompPressure_34()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestPumpConfigurationAndControl * cluster = [[CHIPTestPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                           endpoint:1
                                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeMinCompPressureWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read the optional attribute: MinCompPressure Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("minCompPressure", "", "int16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheOptionalAttributeMaxCompPressure_35()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestPumpConfigurationAndControl * cluster = [[CHIPTestPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                           endpoint:1
                                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeMaxCompPressureWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read the optional attribute: MaxCompPressure Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("maxCompPressure", "", "int16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheOptionalAttributeMinConstSpeed_36()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestPumpConfigurationAndControl * cluster = [[CHIPTestPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                           endpoint:1
                                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeMinConstSpeedWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read the optional attribute: MinConstSpeed Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("minConstSpeed", "", "uint16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheOptionalAttributeMaxConstSpeed_37()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestPumpConfigurationAndControl * cluster = [[CHIPTestPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                           endpoint:1
                                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeMaxConstSpeedWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read the optional attribute: MaxConstSpeed Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("maxConstSpeed", "", "uint16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheOptionalAttributeMinConstFlow_38()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestPumpConfigurationAndControl * cluster = [[CHIPTestPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                           endpoint:1
                                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeMinConstFlowWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read the optional attribute: MinConstFlow Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("minConstFlow", "", "uint16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheOptionalAttributeMaxConstFlow_39()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestPumpConfigurationAndControl * cluster = [[CHIPTestPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                           endpoint:1
                                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeMaxConstFlowWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read the optional attribute: MaxConstFlow Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("maxConstFlow", "", "uint16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheOptionalAttributeMinConstTemp_40()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestPumpConfigurationAndControl * cluster = [[CHIPTestPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                           endpoint:1
                                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeMinConstTempWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read the optional attribute: MinConstTemp Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("minConstTemp", "", "int16"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<int16_t>("minConstTemp", [value shortValue], -27315));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheOptionalAttributeMaxConstTemp_41()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestPumpConfigurationAndControl * cluster = [[CHIPTestPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                           endpoint:1
                                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeMaxConstTempWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read the optional attribute: MaxConstTemp Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("maxConstTemp", "", "int16"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<int16_t>("maxConstTemp", [value shortValue], -27315));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheOptionalAttributePumpStatus_42()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestPumpConfigurationAndControl * cluster = [[CHIPTestPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                           endpoint:1
                                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributePumpStatusWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read the optional attribute: PumpStatus Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("PumpStatus", actualValue, 0U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheOptionalAttributePumpStatus_43()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestPumpConfigurationAndControl * cluster = [[CHIPTestPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                           endpoint:1
                                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributePumpStatusWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read the optional attribute: PumpStatus Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("pumpStatus", "", "map16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheOptionalAttributeSpeed_44()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestPumpConfigurationAndControl * cluster = [[CHIPTestPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                           endpoint:1
                                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeSpeedWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read the optional attribute: Speed Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("speed", "", "uint16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheOptionalAttributeLifetimeRunningHours_45()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestPumpConfigurationAndControl * cluster = [[CHIPTestPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                           endpoint:1
                                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeLifetimeRunningHoursWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read the optional attribute: LifetimeRunningHours Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNonNull("LifetimeRunningHours", actualValue));
                VerifyOrReturn(CheckValue("LifetimeRunningHours", actualValue, 0UL));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheOptionalAttributeLifetimeRunningHours_46()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestPumpConfigurationAndControl * cluster = [[CHIPTestPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                           endpoint:1
                                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeLifetimeRunningHoursWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read the optional attribute: LifetimeRunningHours Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("lifetimeRunningHours", "", "uint24"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheOptionalAttributePower_47()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestPumpConfigurationAndControl * cluster = [[CHIPTestPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                           endpoint:1
                                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributePowerWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read the optional attribute: Power Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("power", "", "uint24"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheOptionalAttributeLifetimeEnergyConsumed_48()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestPumpConfigurationAndControl * cluster = [[CHIPTestPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                           endpoint:1
                                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeLifetimeEnergyConsumedWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read the optional attribute: LifetimeEnergyConsumed Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNonNull("LifetimeEnergyConsumed", actualValue));
                VerifyOrReturn(CheckValue("LifetimeEnergyConsumed", actualValue, 0UL));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheOptionalAttributeLifetimeEnergyConsumed_49()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestPumpConfigurationAndControl * cluster = [[CHIPTestPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                           endpoint:1
                                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeLifetimeEnergyConsumedWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read the optional attribute: LifetimeEnergyConsumed Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("lifetimeEnergyConsumed", "", "uint32"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
};

class Test_TC_PCC_2_2 : public TestCommandBridge {
public:
    Test_TC_PCC_2_2()
        : TestCommandBridge("Test_TC_PCC_2_2")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_PCC_2_2() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_PCC_2_2\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_PCC_2_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Write 1 to the OperationMode attribute to DUT: OperationMode\n");
            if (ShouldSkip("A_OPERATIONMODE")) {
                NextTest();
                return;
            }
            err = TestWrite1ToTheOperationModeAttributeToDutOperationMode_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Write 2 to the OperationMode attribute to DUT: OperationMode\n");
            if (ShouldSkip("A_OPERATIONMODE")) {
                NextTest();
                return;
            }
            err = TestWrite2ToTheOperationModeAttributeToDutOperationMode_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Write 3 to the OperationMode attribute to DUT: OperationMode\n");
            if (ShouldSkip("A_OPERATIONMODE")) {
                NextTest();
                return;
            }
            err = TestWrite3ToTheOperationModeAttributeToDutOperationMode_3();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 4;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWrite1ToTheOperationModeAttributeToDutOperationMode_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestPumpConfigurationAndControl * cluster = [[CHIPTestPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                           endpoint:1
                                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id operationModeArgument;
        operationModeArgument = [NSNumber numberWithUnsignedChar:1];
        [cluster writeAttributeOperationModeWithValue:operationModeArgument
                                    completionHandler:^(NSError * _Nullable err) {
                                        NSLog(@"Write 1 to the OperationMode attribute to DUT: OperationMode Error: %@", err);

                                        VerifyOrReturn(CheckValue("status", err, 0));

                                        NextTest();
                                    }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWrite2ToTheOperationModeAttributeToDutOperationMode_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestPumpConfigurationAndControl * cluster = [[CHIPTestPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                           endpoint:1
                                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id operationModeArgument;
        operationModeArgument = [NSNumber numberWithUnsignedChar:2];
        [cluster writeAttributeOperationModeWithValue:operationModeArgument
                                    completionHandler:^(NSError * _Nullable err) {
                                        NSLog(@"Write 2 to the OperationMode attribute to DUT: OperationMode Error: %@", err);

                                        VerifyOrReturn(CheckValue("status", err, 0));

                                        NextTest();
                                    }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWrite3ToTheOperationModeAttributeToDutOperationMode_3()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestPumpConfigurationAndControl * cluster = [[CHIPTestPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                           endpoint:1
                                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id operationModeArgument;
        operationModeArgument = [NSNumber numberWithUnsignedChar:3];
        [cluster writeAttributeOperationModeWithValue:operationModeArgument
                                    completionHandler:^(NSError * _Nullable err) {
                                        NSLog(@"Write 3 to the OperationMode attribute to DUT: OperationMode Error: %@", err);

                                        VerifyOrReturn(CheckValue("status", err, 0));

                                        NextTest();
                                    }];

        return CHIP_NO_ERROR;
    }
};

class Test_TC_PCC_2_3 : public TestCommandBridge {
public:
    Test_TC_PCC_2_3()
        : TestCommandBridge("Test_TC_PCC_2_3")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_PCC_2_3() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_PCC_2_3\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_PCC_2_3\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Write 0 to the OperationMode attribute to DUT\n");
            if (ShouldSkip("A_OPERATIONMODE")) {
                NextTest();
                return;
            }
            err = TestWrite0ToTheOperationModeAttributeToDut_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Reads the attribute: EffectiveOperationMode\n");
            if (ShouldSkip("A_EFFECTIVEOPERATIONMODE")) {
                NextTest();
                return;
            }
            err = TestReadsTheAttributeEffectiveOperationMode_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Write 0 to the ControlMode attribute to DUT\n");
            if (ShouldSkip("A_CONTROLMODE")) {
                NextTest();
                return;
            }
            err = TestWrite0ToTheControlModeAttributeToDut_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Reads the attribute: EffectiveControlMode\n");
            if (ShouldSkip("A_EFFECTIVECONTROLMODE")) {
                NextTest();
                return;
            }
            err = TestReadsTheAttributeEffectiveControlMode_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Write 1 to the ControlMode attribute to DUT\n");
            if (ShouldSkip("A_CONTROLMODE")) {
                NextTest();
                return;
            }
            err = TestWrite1ToTheControlModeAttributeToDut_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Write 2 to the ControlMode attribute to DUT\n");
            if (ShouldSkip("A_CONTROLMODE")) {
                NextTest();
                return;
            }
            err = TestWrite2ToTheControlModeAttributeToDut_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Write 3 to the ControlMode attribute to DUT\n");
            if (ShouldSkip("A_CONTROLMODE")) {
                NextTest();
                return;
            }
            err = TestWrite3ToTheControlModeAttributeToDut_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Write 5 to the ControlMode attribute to DUT\n");
            if (ShouldSkip("A_CONTROLMODE")) {
                NextTest();
                return;
            }
            err = TestWrite5ToTheControlModeAttributeToDut_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Write 7 to the ControlMode attribute to DUT\n");
            if (ShouldSkip("A_CONTROLMODE")) {
                NextTest();
                return;
            }
            err = TestWrite7ToTheControlModeAttributeToDut_9();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 10;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWrite0ToTheOperationModeAttributeToDut_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestPumpConfigurationAndControl * cluster = [[CHIPTestPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                           endpoint:1
                                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id operationModeArgument;
        operationModeArgument = [NSNumber numberWithUnsignedChar:0];
        [cluster writeAttributeOperationModeWithValue:operationModeArgument
                                    completionHandler:^(NSError * _Nullable err) {
                                        NSLog(@"Write 0 to the OperationMode attribute to DUT Error: %@", err);

                                        VerifyOrReturn(CheckValue("status", err, 0));

                                        NextTest();
                                    }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsTheAttributeEffectiveOperationMode_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestPumpConfigurationAndControl * cluster = [[CHIPTestPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                           endpoint:1
                                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeEffectiveOperationModeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads the attribute: EffectiveOperationMode Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("EffectiveOperationMode", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWrite0ToTheControlModeAttributeToDut_3()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestPumpConfigurationAndControl * cluster = [[CHIPTestPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                           endpoint:1
                                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id controlModeArgument;
        controlModeArgument = [NSNumber numberWithUnsignedChar:0];
        [cluster writeAttributeControlModeWithValue:controlModeArgument
                                  completionHandler:^(NSError * _Nullable err) {
                                      NSLog(@"Write 0 to the ControlMode attribute to DUT Error: %@", err);

                                      VerifyOrReturn(CheckValue("status", err, 0));

                                      NextTest();
                                  }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsTheAttributeEffectiveControlMode_4()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestPumpConfigurationAndControl * cluster = [[CHIPTestPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                           endpoint:1
                                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeEffectiveControlModeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads the attribute: EffectiveControlMode Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("EffectiveControlMode", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWrite1ToTheControlModeAttributeToDut_5()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestPumpConfigurationAndControl * cluster = [[CHIPTestPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                           endpoint:1
                                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id controlModeArgument;
        controlModeArgument = [NSNumber numberWithUnsignedChar:1];
        [cluster writeAttributeControlModeWithValue:controlModeArgument
                                  completionHandler:^(NSError * _Nullable err) {
                                      NSLog(@"Write 1 to the ControlMode attribute to DUT Error: %@", err);

                                      VerifyOrReturn(CheckValue("status", err, 0));

                                      NextTest();
                                  }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWrite2ToTheControlModeAttributeToDut_6()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestPumpConfigurationAndControl * cluster = [[CHIPTestPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                           endpoint:1
                                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id controlModeArgument;
        controlModeArgument = [NSNumber numberWithUnsignedChar:2];
        [cluster writeAttributeControlModeWithValue:controlModeArgument
                                  completionHandler:^(NSError * _Nullable err) {
                                      NSLog(@"Write 2 to the ControlMode attribute to DUT Error: %@", err);

                                      VerifyOrReturn(CheckValue("status", err, 0));

                                      NextTest();
                                  }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWrite3ToTheControlModeAttributeToDut_7()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestPumpConfigurationAndControl * cluster = [[CHIPTestPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                           endpoint:1
                                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id controlModeArgument;
        controlModeArgument = [NSNumber numberWithUnsignedChar:3];
        [cluster writeAttributeControlModeWithValue:controlModeArgument
                                  completionHandler:^(NSError * _Nullable err) {
                                      NSLog(@"Write 3 to the ControlMode attribute to DUT Error: %@", err);

                                      VerifyOrReturn(CheckValue("status", err, 0));

                                      NextTest();
                                  }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWrite5ToTheControlModeAttributeToDut_8()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestPumpConfigurationAndControl * cluster = [[CHIPTestPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                           endpoint:1
                                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id controlModeArgument;
        controlModeArgument = [NSNumber numberWithUnsignedChar:5];
        [cluster writeAttributeControlModeWithValue:controlModeArgument
                                  completionHandler:^(NSError * _Nullable err) {
                                      NSLog(@"Write 5 to the ControlMode attribute to DUT Error: %@", err);

                                      VerifyOrReturn(CheckValue("status", err, 0));

                                      NextTest();
                                  }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWrite7ToTheControlModeAttributeToDut_9()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestPumpConfigurationAndControl * cluster = [[CHIPTestPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                           endpoint:1
                                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id controlModeArgument;
        controlModeArgument = [NSNumber numberWithUnsignedChar:7];
        [cluster writeAttributeControlModeWithValue:controlModeArgument
                                  completionHandler:^(NSError * _Nullable err) {
                                      NSLog(@"Write 7 to the ControlMode attribute to DUT Error: %@", err);

                                      VerifyOrReturn(CheckValue("status", err, 0));

                                      NextTest();
                                  }];

        return CHIP_NO_ERROR;
    }
};

class Test_TC_RH_1_1 : public TestCommandBridge {
public:
    Test_TC_RH_1_1()
        : TestCommandBridge("Test_TC_RH_1_1")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_RH_1_1() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_RH_1_1\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_RH_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read the global attribute constraints: ClusterRevision\n");
            err = TestReadTheGlobalAttributeConstraintsClusterRevision_1();
            break;
        case 2:
            ChipLogProgress(
                chipTool, " ***** Test Step 2 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read the global attribute: AttributeList\n");
            err = TestReadTheGlobalAttributeAttributeList_3();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 4;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheGlobalAttributeConstraintsClusterRevision_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestRelativeHumidityMeasurement * cluster = [[CHIPTestRelativeHumidityMeasurement alloc] initWithDevice:device
                                                                                                           endpoint:1
                                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read the global attribute constraints: ClusterRevision Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("clusterRevision", "", "uint16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestRelativeHumidityMeasurement * cluster = [[CHIPTestRelativeHumidityMeasurement alloc] initWithDevice:device
                                                                                                           endpoint:1
                                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id clusterRevisionArgument;
        clusterRevisionArgument = [NSNumber numberWithUnsignedShort:1U];
        [cluster
            writeAttributeClusterRevisionWithValue:clusterRevisionArgument
                                 completionHandler:^(NSError * _Nullable err) {
                                     NSLog(
                                         @"write the default values to mandatory global attribute: ClusterRevision Error: %@", err);

                                     VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                                     NextTest();
                                 }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheGlobalAttributeAttributeList_3()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestRelativeHumidityMeasurement * cluster = [[CHIPTestRelativeHumidityMeasurement alloc] initWithDevice:device
                                                                                                           endpoint:1
                                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read the global attribute: AttributeList Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("attributeList", "", "list"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
};

class Test_TC_RH_2_1 : public TestCommandBridge {
public:
    Test_TC_RH_2_1()
        : TestCommandBridge("Test_TC_RH_2_1")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_RH_2_1() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_RH_2_1\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_RH_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Reads constraints of attribute: MeasuredValue\n");
            err = TestReadsConstraintsOfAttributeMeasuredValue_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Reads constraints of attribute: MinMeasuredValue\n");
            err = TestReadsConstraintsOfAttributeMinMeasuredValue_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Reads the optional attribute: Tolerance\n");
            err = TestReadsTheOptionalAttributeTolerance_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Reads constraints of attribute: Tolerance\n");
            err = TestReadsConstraintsOfAttributeTolerance_4();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 5;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsConstraintsOfAttributeMeasuredValue_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestRelativeHumidityMeasurement * cluster = [[CHIPTestRelativeHumidityMeasurement alloc] initWithDevice:device
                                                                                                           endpoint:1
                                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeMeasuredValueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads constraints of attribute: MeasuredValue Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("measuredValue", "", "uint16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsConstraintsOfAttributeMinMeasuredValue_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestRelativeHumidityMeasurement * cluster = [[CHIPTestRelativeHumidityMeasurement alloc] initWithDevice:device
                                                                                                           endpoint:1
                                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeMinMeasuredValueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads constraints of attribute: MinMeasuredValue Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("minMeasuredValue", "", "uint16"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("minMeasuredValue", [value unsignedShortValue], 0U));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("minMeasuredValue", [value unsignedShortValue], 9999U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsTheOptionalAttributeTolerance_3()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestRelativeHumidityMeasurement * cluster = [[CHIPTestRelativeHumidityMeasurement alloc] initWithDevice:device
                                                                                                           endpoint:1
                                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeToleranceWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads the optional attribute: Tolerance Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("tolerance", actualValue, 0U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsConstraintsOfAttributeTolerance_4()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestRelativeHumidityMeasurement * cluster = [[CHIPTestRelativeHumidityMeasurement alloc] initWithDevice:device
                                                                                                           endpoint:1
                                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeToleranceWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads constraints of attribute: Tolerance Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("tolerance", "", "uint16"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("tolerance", [value unsignedShortValue], 0U));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("tolerance", [value unsignedShortValue], 2048U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
};

class Test_TC_RH_2_2 : public TestCommandBridge {
public:
    Test_TC_RH_2_2()
        : TestCommandBridge("Test_TC_RH_2_2")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_RH_2_2() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_RH_2_2\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_RH_2_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Reads MeasuredValue attribute from DUT\n");
            if (ShouldSkip("A_RELATIVEHUMIDITY")) {
                NextTest();
                return;
            }
            err = TestReadsMeasuredValueAttributeFromDut_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read the mandatory attribute: MeasuredValue\n");
            if (ShouldSkip("A_RELATIVEHUMIDITY")) {
                NextTest();
                return;
            }
            err = TestReadTheMandatoryAttributeMeasuredValue_2();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 3;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsMeasuredValueAttributeFromDut_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestRelativeHumidityMeasurement * cluster = [[CHIPTestRelativeHumidityMeasurement alloc] initWithDevice:device
                                                                                                           endpoint:1
                                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeMeasuredValueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads MeasuredValue attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("measuredValue", "", "uint16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheMandatoryAttributeMeasuredValue_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestRelativeHumidityMeasurement * cluster = [[CHIPTestRelativeHumidityMeasurement alloc] initWithDevice:device
                                                                                                           endpoint:1
                                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeMeasuredValueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read the mandatory attribute: MeasuredValue Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("measuredValue", "", "uint16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
};

class Test_TC_SWTCH_2_1 : public TestCommandBridge {
public:
    Test_TC_SWTCH_2_1()
        : TestCommandBridge("Test_TC_SWTCH_2_1")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_SWTCH_2_1() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_SWTCH_2_1\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_SWTCH_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read NumberOfPositions attribute\n");
            err = TestReadNumberOfPositionsAttribute_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read NumberOfPositions attribute\n");
            err = TestReadNumberOfPositionsAttribute_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read CurrentPosition attribute\n");
            err = TestReadCurrentPositionAttribute_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Read CurrentPosition attribute\n");
            err = TestReadCurrentPositionAttribute_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Read MultiPressMax attribute\n");
            err = TestReadMultiPressMaxAttribute_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Read MultiPressMax attribute\n");
            err = TestReadMultiPressMaxAttribute_6();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 7;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadNumberOfPositionsAttribute_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestSwitch * cluster = [[CHIPTestSwitch alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNumberOfPositionsWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read NumberOfPositions attribute Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("number of positions", actualValue, 2));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadNumberOfPositionsAttribute_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestSwitch * cluster = [[CHIPTestSwitch alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNumberOfPositionsWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read NumberOfPositions attribute Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("numberOfPositions", "", "uint8"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<uint8_t>("numberOfPositions", [value unsignedCharValue], 2));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadCurrentPositionAttribute_3()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestSwitch * cluster = [[CHIPTestSwitch alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeCurrentPositionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read CurrentPosition attribute Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("current position", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadCurrentPositionAttribute_4()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestSwitch * cluster = [[CHIPTestSwitch alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeCurrentPositionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read CurrentPosition attribute Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("currentPosition", "", "uint8"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<uint8_t>("currentPosition", [value unsignedCharValue], 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadMultiPressMaxAttribute_5()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestSwitch * cluster = [[CHIPTestSwitch alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeMultiPressMaxWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read MultiPressMax attribute Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("multi press max", actualValue, 2));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadMultiPressMaxAttribute_6()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestSwitch * cluster = [[CHIPTestSwitch alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeMultiPressMaxWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read MultiPressMax attribute Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("multiPressMax", "", "uint8"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<uint8_t>("multiPressMax", [value unsignedCharValue], 2));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
};

class Test_TC_SWTCH_2_2 : public TestCommandBridge {
public:
    Test_TC_SWTCH_2_2()
        : TestCommandBridge("Test_TC_SWTCH_2_2")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_SWTCH_2_2() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_SWTCH_2_2\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_SWTCH_2_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : User interaction needed\n");
            err = TestUserInteractionNeeded_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : User interaction needed\n");
            err = TestUserInteractionNeeded_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read CurrentPosition attribute\n");
            err = TestReadCurrentPositionAttribute_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : User interaction needed\n");
            err = TestUserInteractionNeeded_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : User interaction needed\n");
            err = TestUserInteractionNeeded_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : User interaction needed\n");
            err = TestUserInteractionNeeded_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Read CurrentPosition attribute\n");
            err = TestReadCurrentPositionAttribute_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : User interaction needed\n");
            err = TestUserInteractionNeeded_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : User interaction needed\n");
            err = TestUserInteractionNeeded_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : User interaction needed\n");
            err = TestUserInteractionNeeded_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : User interaction needed\n");
            err = TestUserInteractionNeeded_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : User interaction needed\n");
            err = TestUserInteractionNeeded_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : User interaction needed\n");
            err = TestUserInteractionNeeded_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : User interaction needed\n");
            err = TestUserInteractionNeeded_14();
            break;
        case 15:
            ChipLogProgress(chipTool, " ***** Test Step 15 : Wait 3000ms\n");
            err = TestWait3000ms_15();
            break;
        case 16:
            ChipLogProgress(chipTool, " ***** Test Step 16 : User interaction needed\n");
            err = TestUserInteractionNeeded_16();
            break;
        case 17:
            ChipLogProgress(chipTool, " ***** Test Step 17 : User interaction needed\n");
            err = TestUserInteractionNeeded_17();
            break;
        case 18:
            ChipLogProgress(chipTool, " ***** Test Step 18 : User interaction needed\n");
            err = TestUserInteractionNeeded_18();
            break;
        case 19:
            ChipLogProgress(chipTool, " ***** Test Step 19 : User interaction needed\n");
            err = TestUserInteractionNeeded_19();
            break;
        case 20:
            ChipLogProgress(chipTool, " ***** Test Step 20 : User interaction needed\n");
            err = TestUserInteractionNeeded_20();
            break;
        case 21:
            ChipLogProgress(chipTool, " ***** Test Step 21 : User interaction needed\n");
            err = TestUserInteractionNeeded_21();
            break;
        case 22:
            ChipLogProgress(chipTool, " ***** Test Step 22 : Wait 3000ms\n");
            err = TestWait3000ms_22();
            break;
        case 23:
            ChipLogProgress(chipTool, " ***** Test Step 23 : User interaction needed\n");
            err = TestUserInteractionNeeded_23();
            break;
        case 24:
            ChipLogProgress(chipTool, " ***** Test Step 24 : User interaction needed\n");
            err = TestUserInteractionNeeded_24();
            break;
        case 25:
            ChipLogProgress(chipTool, " ***** Test Step 25 : User interaction needed\n");
            err = TestUserInteractionNeeded_25();
            break;
        case 26:
            ChipLogProgress(chipTool, " ***** Test Step 26 : User interaction needed\n");
            err = TestUserInteractionNeeded_26();
            break;
        case 27:
            ChipLogProgress(chipTool, " ***** Test Step 27 : User interaction needed\n");
            err = TestUserInteractionNeeded_27();
            break;
        case 28:
            ChipLogProgress(chipTool, " ***** Test Step 28 : User interaction needed\n");
            err = TestUserInteractionNeeded_28();
            break;
        case 29:
            ChipLogProgress(chipTool, " ***** Test Step 29 : User interaction needed\n");
            err = TestUserInteractionNeeded_29();
            break;
        case 30:
            ChipLogProgress(chipTool, " ***** Test Step 30 : User interaction needed\n");
            err = TestUserInteractionNeeded_30();
            break;
        case 31:
            ChipLogProgress(chipTool, " ***** Test Step 31 : User interaction needed\n");
            err = TestUserInteractionNeeded_31();
            break;
        case 32:
            ChipLogProgress(chipTool, " ***** Test Step 32 : User interaction needed\n");
            err = TestUserInteractionNeeded_32();
            break;
        case 33:
            ChipLogProgress(chipTool, " ***** Test Step 33 : User interaction needed\n");
            err = TestUserInteractionNeeded_33();
            break;
        case 34:
            ChipLogProgress(chipTool, " ***** Test Step 34 : User interaction needed\n");
            err = TestUserInteractionNeeded_34();
            break;
        case 35:
            ChipLogProgress(chipTool, " ***** Test Step 35 : User interaction needed\n");
            err = TestUserInteractionNeeded_35();
            break;
        case 36:
            ChipLogProgress(chipTool, " ***** Test Step 36 : User interaction needed\n");
            err = TestUserInteractionNeeded_36();
            break;
        case 37:
            ChipLogProgress(chipTool, " ***** Test Step 37 : User interaction needed\n");
            err = TestUserInteractionNeeded_37();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 38;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestUserInteractionNeeded_1()
    {
        UserPrompt(@"Set up subscription to SwitchLatched event");
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestUserInteractionNeeded_2()
    {
        UserPrompt(@"Operator sets switch to first position");
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadCurrentPositionAttribute_3()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestSwitch * cluster = [[CHIPTestSwitch alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeCurrentPositionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read CurrentPosition attribute Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("current position", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestUserInteractionNeeded_4()
    {
        UserPrompt(@"Operator sets switch to second position");
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestUserInteractionNeeded_5()
    {
        UserPrompt(@"Set up subscription to InitialPress event");
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestUserInteractionNeeded_6()
    {
        UserPrompt(@"Operator does not operate switch");
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadCurrentPositionAttribute_7()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestSwitch * cluster = [[CHIPTestSwitch alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeCurrentPositionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read CurrentPosition attribute Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("current position", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestUserInteractionNeeded_8()
    {
        UserPrompt(@"Operator sets switch to second position");
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestUserInteractionNeeded_9()
    {
        UserPrompt(@"Operator does not operate switch (release switch)");
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestUserInteractionNeeded_10()
    {
        UserPrompt(@"Set up subscription to InitialPress and ShortRelease events");
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestUserInteractionNeeded_11()
    {
        UserPrompt(@"Operator does not operate switch");
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestUserInteractionNeeded_12()
    {
        UserPrompt(@"Operator operates switch (press briefly)");
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestUserInteractionNeeded_13()
    {
        UserPrompt(@"Operator releases switch");
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestUserInteractionNeeded_14()
    {
        UserPrompt(@"Operator operates switch for 5 seconds");
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWait3000ms_15()
    {
        WaitForMs(3000);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestUserInteractionNeeded_16()
    {
        UserPrompt(@"Operator releases switch");
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestUserInteractionNeeded_17()
    {
        UserPrompt(@"Set up subscription to InitialPress, LongPress, ShortRelease, LongRelease events");
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestUserInteractionNeeded_18()
    {
        UserPrompt(@"Operator does not operate switch");
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestUserInteractionNeeded_19()
    {
        UserPrompt(@"Operator operates switch (press briefly)");
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestUserInteractionNeeded_20()
    {
        UserPrompt(@"Operator releases switch");
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestUserInteractionNeeded_21()
    {
        UserPrompt(@"Operator operates switch for 5 seconds");
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWait3000ms_22()
    {
        WaitForMs(3000);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestUserInteractionNeeded_23()
    {
        UserPrompt(@"Operator releases switch");
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestUserInteractionNeeded_24()
    {
        UserPrompt(@"Set up subscription to InitialPress, ShortRelease, MultiPressOngoing, MultiPressComplete events");
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestUserInteractionNeeded_25()
    {
        UserPrompt(@"Operator does not operate switch");
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestUserInteractionNeeded_26()
    {
        UserPrompt(@"Operator operates switch (press briefly)");
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestUserInteractionNeeded_27()
    {
        UserPrompt(@"Operator releases switch");
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestUserInteractionNeeded_28()
    {
        UserPrompt(@"Operator operates switch (press briefly)");
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestUserInteractionNeeded_29()
    {
        UserPrompt(@"Operator releases switch");
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestUserInteractionNeeded_30()
    {
        UserPrompt(@"Operator operates switch again (press briefly)");
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestUserInteractionNeeded_31()
    {
        UserPrompt(@"Operator releases switch");
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestUserInteractionNeeded_32()
    {
        UserPrompt(@"Operator operates switch again (press briefly)");
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestUserInteractionNeeded_33()
    {
        UserPrompt(@"Operator releases switch");
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestUserInteractionNeeded_34()
    {
        UserPrompt(@"Operator operates switch again (press briefly)");
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestUserInteractionNeeded_35()
    {
        UserPrompt(@"Operator releases switch");
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestUserInteractionNeeded_36()
    {
        UserPrompt(@"Operator operates switch again (press briefly)");
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestUserInteractionNeeded_37()
    {
        UserPrompt(@"Operator releases switch");
        return CHIP_NO_ERROR;
    }
};

class Test_TC_TM_1_1 : public TestCommandBridge {
public:
    Test_TC_TM_1_1()
        : TestCommandBridge("Test_TC_TM_1_1")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_TM_1_1() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_TM_1_1\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_TM_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read the global attribute constraints: ClusterRevision\n");
            err = TestReadTheGlobalAttributeConstraintsClusterRevision_1();
            break;
        case 2:
            ChipLogProgress(
                chipTool, " ***** Test Step 2 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read the global attribute: AttributeList\n");
            err = TestReadTheGlobalAttributeAttributeList_3();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 4;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheGlobalAttributeConstraintsClusterRevision_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTemperatureMeasurement * cluster = [[CHIPTestTemperatureMeasurement alloc] initWithDevice:device
                                                                                                 endpoint:1
                                                                                                    queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read the global attribute constraints: ClusterRevision Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("clusterRevision", "", "uint16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTemperatureMeasurement * cluster = [[CHIPTestTemperatureMeasurement alloc] initWithDevice:device
                                                                                                 endpoint:1
                                                                                                    queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id clusterRevisionArgument;
        clusterRevisionArgument = [NSNumber numberWithUnsignedShort:4U];
        [cluster
            writeAttributeClusterRevisionWithValue:clusterRevisionArgument
                                 completionHandler:^(NSError * _Nullable err) {
                                     NSLog(
                                         @"write the default values to mandatory global attribute: ClusterRevision Error: %@", err);

                                     VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                                     NextTest();
                                 }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheGlobalAttributeAttributeList_3()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTemperatureMeasurement * cluster = [[CHIPTestTemperatureMeasurement alloc] initWithDevice:device
                                                                                                 endpoint:1
                                                                                                    queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read the global attribute: AttributeList Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("attributeList", "", "list"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
};

class Test_TC_TM_2_1 : public TestCommandBridge {
public:
    Test_TC_TM_2_1()
        : TestCommandBridge("Test_TC_TM_2_1")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_TM_2_1() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_TM_2_1\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_TM_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : read the mandatory attribute: MeasuredValue\n");
            err = TestReadTheMandatoryAttributeMeasuredValue_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : read the optional attribute: Tolerance\n");
            err = TestReadTheOptionalAttributeTolerance_2();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 3;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheMandatoryAttributeMeasuredValue_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTemperatureMeasurement * cluster = [[CHIPTestTemperatureMeasurement alloc] initWithDevice:device
                                                                                                 endpoint:1
                                                                                                    queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeMeasuredValueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read the mandatory attribute: MeasuredValue Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("measuredValue", "", "int16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheOptionalAttributeTolerance_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTemperatureMeasurement * cluster = [[CHIPTestTemperatureMeasurement alloc] initWithDevice:device
                                                                                                 endpoint:1
                                                                                                    queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeToleranceWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read the optional attribute: Tolerance Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("tolerance", "", "uint16"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("tolerance", [value unsignedShortValue], 0U));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("tolerance", [value unsignedShortValue], 2048U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
};

class Test_TC_TM_2_2 : public TestCommandBridge {
public:
    Test_TC_TM_2_2()
        : TestCommandBridge("Test_TC_TM_2_2")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_TM_2_2() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_TM_2_2\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_TM_2_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Reads MeasuredValue attribute from DUT\n");
            if (ShouldSkip("A_TEMPERATURE")) {
                NextTest();
                return;
            }
            err = TestReadsMeasuredValueAttributeFromDut_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read the mandatory attribute: MeasuredValue\n");
            if (ShouldSkip("A_TEMPERATURE")) {
                NextTest();
                return;
            }
            err = TestReadTheMandatoryAttributeMeasuredValue_2();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 3;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsMeasuredValueAttributeFromDut_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTemperatureMeasurement * cluster = [[CHIPTestTemperatureMeasurement alloc] initWithDevice:device
                                                                                                 endpoint:1
                                                                                                    queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeMeasuredValueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads MeasuredValue attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("measuredValue", "", "uint16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheMandatoryAttributeMeasuredValue_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTemperatureMeasurement * cluster = [[CHIPTestTemperatureMeasurement alloc] initWithDevice:device
                                                                                                 endpoint:1
                                                                                                    queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeMeasuredValueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read the mandatory attribute: MeasuredValue Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("measuredValue", "", "uint16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
};

class Test_TC_TSTAT_1_1 : public TestCommandBridge {
public:
    Test_TC_TSTAT_1_1()
        : TestCommandBridge("Test_TC_TSTAT_1_1")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_TSTAT_1_1() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_TSTAT_1_1\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_TSTAT_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read the global attribute constraints: ClusterRevision\n");
            err = TestReadTheGlobalAttributeConstraintsClusterRevision_1();
            break;
        case 2:
            ChipLogProgress(
                chipTool, " ***** Test Step 2 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read the global attribute: AttributeList\n");
            err = TestReadTheGlobalAttributeAttributeList_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Read the optional global attribute constraints: FeatureMap\n");
            err = TestReadTheOptionalGlobalAttributeConstraintsFeatureMap_4();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 5;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheGlobalAttributeConstraintsClusterRevision_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read the global attribute constraints: ClusterRevision Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("clusterRevision", "", "uint16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id clusterRevisionArgument;
        clusterRevisionArgument = [NSNumber numberWithUnsignedShort:5U];
        [cluster
            writeAttributeClusterRevisionWithValue:clusterRevisionArgument
                                 completionHandler:^(NSError * _Nullable err) {
                                     NSLog(
                                         @"write the default values to mandatory global attribute: ClusterRevision Error: %@", err);

                                     VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                                     NextTest();
                                 }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheGlobalAttributeAttributeList_3()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read the global attribute: AttributeList Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("attributeList", "", "list"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheOptionalGlobalAttributeConstraintsFeatureMap_4()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeFeatureMapWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read the optional global attribute constraints: FeatureMap Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("featureMap", "", "map32"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
};

class Test_TC_TSTAT_2_1 : public TestCommandBridge {
public:
    Test_TC_TSTAT_2_1()
        : TestCommandBridge("Test_TC_TSTAT_2_1")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_TSTAT_2_1() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_TSTAT_2_1\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_TSTAT_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(
                chipTool, " ***** Test Step 1 : Reads constraints of mandatory attributes from DUT: LocalTemperature\n");
            err = TestReadsConstraintsOfMandatoryAttributesFromDutLocalTemperature_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Reads mandatory attributes from DUT: AbsMinHeatSetpointLimit\n");
            err = TestReadsMandatoryAttributesFromDutAbsMinHeatSetpointLimit_2();
            break;
        case 3:
            ChipLogProgress(
                chipTool, " ***** Test Step 3 : Reads constraints of mandatory attributes from DUT: AbsMinHeatSetpointLimit\n");
            err = TestReadsConstraintsOfMandatoryAttributesFromDutAbsMinHeatSetpointLimit_3();
            break;
        case 4:
            ChipLogProgress(chipTool,
                " ***** Test Step 4 : Writes the respective default value to mandatory attributes to DUT: "
                "AbsMinHeatSetpointLimit\n");
            err = TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutAbsMinHeatSetpointLimit_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Read back mandatory attributes from DUT: AbsMinHeatSetpointLimit\n");
            err = TestReadBackMandatoryAttributesFromDutAbsMinHeatSetpointLimit_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Reads mandatory attributes from DUT: AbsMaxHeatSetpointLimit\n");
            err = TestReadsMandatoryAttributesFromDutAbsMaxHeatSetpointLimit_6();
            break;
        case 7:
            ChipLogProgress(
                chipTool, " ***** Test Step 7 : Reads constraints of mandatory attributes from DUT: AbsMaxHeatSetpointLimit\n");
            err = TestReadsConstraintsOfMandatoryAttributesFromDutAbsMaxHeatSetpointLimit_7();
            break;
        case 8:
            ChipLogProgress(chipTool,
                " ***** Test Step 8 : Writes the respective default value to mandatory attributes to DUT: "
                "AbsMaxHeatSetpointLimit\n");
            err = TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutAbsMaxHeatSetpointLimit_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Read back mandatory attributes from DUT: AbsMaxHeatSetpointLimit\n");
            err = TestReadBackMandatoryAttributesFromDutAbsMaxHeatSetpointLimit_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Reads mandatory attributes from DUT: AbsMinCoolSetpointLimit\n");
            err = TestReadsMandatoryAttributesFromDutAbsMinCoolSetpointLimit_10();
            break;
        case 11:
            ChipLogProgress(
                chipTool, " ***** Test Step 11 : Reads constraints of mandatory attributes from DUT: AbsMinCoolSetpointLimit\n");
            err = TestReadsConstraintsOfMandatoryAttributesFromDutAbsMinCoolSetpointLimit_11();
            break;
        case 12:
            ChipLogProgress(chipTool,
                " ***** Test Step 12 : Writes the respective default value to mandatory attributes to DUT: "
                "AbsMinCoolSetpointLimit\n");
            err = TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutAbsMinCoolSetpointLimit_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : Read back mandatory attributes from DUT: AbsMinCoolSetpointLimit\n");
            err = TestReadBackMandatoryAttributesFromDutAbsMinCoolSetpointLimit_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : Reads mandatory attributes from DUT: AbsMaxCoolSetpointLimit\n");
            err = TestReadsMandatoryAttributesFromDutAbsMaxCoolSetpointLimit_14();
            break;
        case 15:
            ChipLogProgress(
                chipTool, " ***** Test Step 15 : Reads constraints of mandatory attributes from DUT: AbsMaxCoolSetpointLimit\n");
            err = TestReadsConstraintsOfMandatoryAttributesFromDutAbsMaxCoolSetpointLimit_15();
            break;
        case 16:
            ChipLogProgress(chipTool,
                " ***** Test Step 16 : Writes the respective default value to mandatory attributes to DUT: "
                "AbsMaxCoolSetpointLimit\n");
            err = TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutAbsMaxCoolSetpointLimit_16();
            break;
        case 17:
            ChipLogProgress(chipTool, " ***** Test Step 17 : Read back mandatory attributes from DUT: AbsMaxCoolSetpointLimit\n");
            err = TestReadBackMandatoryAttributesFromDutAbsMaxCoolSetpointLimit_17();
            break;
        case 18:
            ChipLogProgress(chipTool, " ***** Test Step 18 : Reads mandatory attributes from DUT: OccupiedCoolingSetpoint\n");
            err = TestReadsMandatoryAttributesFromDutOccupiedCoolingSetpoint_18();
            break;
        case 19:
            ChipLogProgress(
                chipTool, " ***** Test Step 19 : Reads constraints of mandatory attributes from DUT: OccupiedCoolingSetpoint\n");
            err = TestReadsConstraintsOfMandatoryAttributesFromDutOccupiedCoolingSetpoint_19();
            break;
        case 20:
            ChipLogProgress(chipTool,
                " ***** Test Step 20 : Writes the respective default value to mandatory attributes to DUT: "
                "OccupiedCoolingSetpoint\n");
            err = TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutOccupiedCoolingSetpoint_20();
            break;
        case 21:
            ChipLogProgress(chipTool, " ***** Test Step 21 : Read back mandatory attributes from DUT: OccupiedCoolingSetpoint\n");
            err = TestReadBackMandatoryAttributesFromDutOccupiedCoolingSetpoint_21();
            break;
        case 22:
            ChipLogProgress(chipTool, " ***** Test Step 22 : Reads mandatory attributes from DUT: OccupiedHeatingSetpoint\n");
            err = TestReadsMandatoryAttributesFromDutOccupiedHeatingSetpoint_22();
            break;
        case 23:
            ChipLogProgress(
                chipTool, " ***** Test Step 23 : Reads constraints of mandatory attributes from DUT: OccupiedHeatingSetpoint\n");
            err = TestReadsConstraintsOfMandatoryAttributesFromDutOccupiedHeatingSetpoint_23();
            break;
        case 24:
            ChipLogProgress(chipTool,
                " ***** Test Step 24 : Writes the respective default value to mandatory attributes to DUT: "
                "OccupiedHeatingSetpoint\n");
            err = TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutOccupiedHeatingSetpoint_24();
            break;
        case 25:
            ChipLogProgress(chipTool, " ***** Test Step 25 : Read back mandatory attributes from DUT: OccupiedHeatingSetpoint\n");
            err = TestReadBackMandatoryAttributesFromDutOccupiedHeatingSetpoint_25();
            break;
        case 26:
            ChipLogProgress(chipTool, " ***** Test Step 26 : Reads mandatory attributes from DUT: MinHeatSetpointLimit\n");
            err = TestReadsMandatoryAttributesFromDutMinHeatSetpointLimit_26();
            break;
        case 27:
            ChipLogProgress(
                chipTool, " ***** Test Step 27 : Reads constraints of mandatory attributes from DUT: MinHeatSetpointLimit\n");
            err = TestReadsConstraintsOfMandatoryAttributesFromDutMinHeatSetpointLimit_27();
            break;
        case 28:
            ChipLogProgress(chipTool,
                " ***** Test Step 28 : Writes the respective default value to mandatory attributes to DUT: MinHeatSetpointLimit\n");
            err = TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutMinHeatSetpointLimit_28();
            break;
        case 29:
            ChipLogProgress(chipTool, " ***** Test Step 29 : Read back mandatory attributes from DUT: MinHeatSetpointLimit\n");
            err = TestReadBackMandatoryAttributesFromDutMinHeatSetpointLimit_29();
            break;
        case 30:
            ChipLogProgress(chipTool, " ***** Test Step 30 : Reads mandatory attributes from DUT: MaxHeatSetpointLimit\n");
            err = TestReadsMandatoryAttributesFromDutMaxHeatSetpointLimit_30();
            break;
        case 31:
            ChipLogProgress(
                chipTool, " ***** Test Step 31 : Reads constraints of mandatory attributes from DUT: MaxHeatSetpointLimit\n");
            err = TestReadsConstraintsOfMandatoryAttributesFromDutMaxHeatSetpointLimit_31();
            break;
        case 32:
            ChipLogProgress(chipTool,
                " ***** Test Step 32 : Writes the respective default value to mandatory attributes to DUT: MaxHeatSetpointLimit\n");
            err = TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutMaxHeatSetpointLimit_32();
            break;
        case 33:
            ChipLogProgress(chipTool, " ***** Test Step 33 : Read back mandatory attributes from DUT: MaxHeatSetpointLimit\n");
            err = TestReadBackMandatoryAttributesFromDutMaxHeatSetpointLimit_33();
            break;
        case 34:
            ChipLogProgress(chipTool, " ***** Test Step 34 : Reads mandatory attributes from DUT: MinCoolSetpointLimit\n");
            err = TestReadsMandatoryAttributesFromDutMinCoolSetpointLimit_34();
            break;
        case 35:
            ChipLogProgress(
                chipTool, " ***** Test Step 35 : Reads constraints of mandatory attributes from DUT: MinCoolSetpointLimit\n");
            err = TestReadsConstraintsOfMandatoryAttributesFromDutMinCoolSetpointLimit_35();
            break;
        case 36:
            ChipLogProgress(chipTool,
                " ***** Test Step 36 : Writes the respective default value to mandatory attributes to DUT: MinCoolSetpointLimit\n");
            err = TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutMinCoolSetpointLimit_36();
            break;
        case 37:
            ChipLogProgress(chipTool, " ***** Test Step 37 : Read back mandatory attributes from DUT: MinCoolSetpointLimit\n");
            err = TestReadBackMandatoryAttributesFromDutMinCoolSetpointLimit_37();
            break;
        case 38:
            ChipLogProgress(chipTool, " ***** Test Step 38 : Reads mandatory attributes from DUT: MaxCoolSetpointLimit\n");
            err = TestReadsMandatoryAttributesFromDutMaxCoolSetpointLimit_38();
            break;
        case 39:
            ChipLogProgress(
                chipTool, " ***** Test Step 39 : Reads constraints of mandatory attributes from DUT: MaxCoolSetpointLimit\n");
            err = TestReadsConstraintsOfMandatoryAttributesFromDutMaxCoolSetpointLimit_39();
            break;
        case 40:
            ChipLogProgress(chipTool,
                " ***** Test Step 40 : Writes the respective default value to mandatory attributes to DUT: MaxCoolSetpointLimit\n");
            err = TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutMaxCoolSetpointLimit_40();
            break;
        case 41:
            ChipLogProgress(chipTool, " ***** Test Step 41 : Read back mandatory attributes from DUT: MaxCoolSetpointLimit\n");
            err = TestReadBackMandatoryAttributesFromDutMaxCoolSetpointLimit_41();
            break;
        case 42:
            ChipLogProgress(chipTool, " ***** Test Step 42 : Reads mandatory attributes from DUT: ControlSequenceOfOperation\n");
            err = TestReadsMandatoryAttributesFromDutControlSequenceOfOperation_42();
            break;
        case 43:
            ChipLogProgress(
                chipTool, " ***** Test Step 43 : Reads constraints of mandatory attributes from DUT: ControlSequenceOfOperation\n");
            err = TestReadsConstraintsOfMandatoryAttributesFromDutControlSequenceOfOperation_43();
            break;
        case 44:
            ChipLogProgress(chipTool,
                " ***** Test Step 44 : Writes the respective default value to mandatory attributes to DUT: "
                "ControlSequenceOfOperation\n");
            err = TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutControlSequenceOfOperation_44();
            break;
        case 45:
            ChipLogProgress(
                chipTool, " ***** Test Step 45 : Read back mandatory attributes from DUT: ControlSequenceOfOperation\n");
            err = TestReadBackMandatoryAttributesFromDutControlSequenceOfOperation_45();
            break;
        case 46:
            ChipLogProgress(chipTool, " ***** Test Step 46 : Reads mandatory attributes from DUT: SystemMode\n");
            err = TestReadsMandatoryAttributesFromDutSystemMode_46();
            break;
        case 47:
            ChipLogProgress(chipTool, " ***** Test Step 47 : Reads constraints of mandatory attributes from DUT: SystemMode\n");
            err = TestReadsConstraintsOfMandatoryAttributesFromDutSystemMode_47();
            break;
        case 48:
            ChipLogProgress(
                chipTool, " ***** Test Step 48 : Writes the respective default value to mandatory attributes to DUT: SystemMode\n");
            err = TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutSystemMode_48();
            break;
        case 49:
            ChipLogProgress(chipTool, " ***** Test Step 49 : Read back mandatory attributes from DUT: SystemMode\n");
            err = TestReadBackMandatoryAttributesFromDutSystemMode_49();
            break;
        case 50:
            ChipLogProgress(chipTool, " ***** Test Step 50 : Reads optional attributes from DUT: MinSetpointDeadBand\n");
            err = TestReadsOptionalAttributesFromDutMinSetpointDeadBand_50();
            break;
        case 51:
            ChipLogProgress(
                chipTool, " ***** Test Step 51 : Reads constraints of optional attributes from DUT: MinSetpointDeadBand\n");
            err = TestReadsConstraintsOfOptionalAttributesFromDutMinSetpointDeadBand_51();
            break;
        case 52:
            ChipLogProgress(chipTool,
                " ***** Test Step 52 : Writes the respective default value to optional attributes to DUT: MinSetpointDeadBand\n");
            err = TestWritesTheRespectiveDefaultValueToOptionalAttributesToDutMinSetpointDeadBand_52();
            break;
        case 53:
            ChipLogProgress(chipTool, " ***** Test Step 53 : Read back optional attributes from DUT: MinSetpointDeadBand\n");
            err = TestReadBackOptionalAttributesFromDutMinSetpointDeadBand_53();
            break;
        case 54:
            ChipLogProgress(chipTool, " ***** Test Step 54 : Reads constraints of optional attributes from DUT: StartOfWeek\n");
            err = TestReadsConstraintsOfOptionalAttributesFromDutStartOfWeek_54();
            break;
        case 55:
            ChipLogProgress(
                chipTool, " ***** Test Step 55 : Writes the respective default value to optional attributes to DUT: StartOfWeek\n");
            err = TestWritesTheRespectiveDefaultValueToOptionalAttributesToDutStartOfWeek_55();
            break;
        case 56:
            ChipLogProgress(chipTool, " ***** Test Step 56 : Read back optional attributes from DUT: StartOfWeek\n");
            err = TestReadBackOptionalAttributesFromDutStartOfWeek_56();
            break;
        case 57:
            ChipLogProgress(
                chipTool, " ***** Test Step 57 : Reads constraints of optional attributes from DUT: NumberOfWeeklyTransitions\n");
            err = TestReadsConstraintsOfOptionalAttributesFromDutNumberOfWeeklyTransitions_57();
            break;
        case 58:
            ChipLogProgress(chipTool,
                " ***** Test Step 58 : Writes the respective default value to optional attributes to DUT: "
                "NumberOfWeeklyTransitions\n");
            err = TestWritesTheRespectiveDefaultValueToOptionalAttributesToDutNumberOfWeeklyTransitions_58();
            break;
        case 59:
            ChipLogProgress(
                chipTool, " ***** Test Step 59 : Reads constraints of optional attributes from DUT: NumberOfDailyTransitions\n");
            err = TestReadsConstraintsOfOptionalAttributesFromDutNumberOfDailyTransitions_59();
            break;
        case 60:
            ChipLogProgress(chipTool,
                " ***** Test Step 60 : Writes the respective default value to optional attributes to DUT: "
                "NumberOfDailyTransitions\n");
            err = TestWritesTheRespectiveDefaultValueToOptionalAttributesToDutNumberOfDailyTransitions_60();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 61;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsConstraintsOfMandatoryAttributesFromDutLocalTemperature_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeLocalTemperatureWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads constraints of mandatory attributes from DUT: LocalTemperature Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("localTemperature", "", "int16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsMandatoryAttributesFromDutAbsMinHeatSetpointLimit_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeAbsMinHeatSetpointLimitWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads mandatory attributes from DUT: AbsMinHeatSetpointLimit Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("abs min heat setpoint limit", actualValue, 700));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsConstraintsOfMandatoryAttributesFromDutAbsMinHeatSetpointLimit_3()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeAbsMinHeatSetpointLimitWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads constraints of mandatory attributes from DUT: AbsMinHeatSetpointLimit Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("absMinHeatSetpointLimit", "", "int16"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<int16_t>("absMinHeatSetpointLimit", [value shortValue], 700));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<int16_t>("absMinHeatSetpointLimit", [value shortValue], 3000));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutAbsMinHeatSetpointLimit_4()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id absMinHeatSetpointLimitArgument;
        absMinHeatSetpointLimitArgument = [NSNumber numberWithShort:700];
        [cluster writeAttributeAbsMinHeatSetpointLimitWithValue:absMinHeatSetpointLimitArgument
                                              completionHandler:^(NSError * _Nullable err) {
                                                  NSLog(@"Writes the respective default value to mandatory attributes to DUT: "
                                                        @"AbsMinHeatSetpointLimit Error: %@",
                                                      err);

                                                  VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                                                  NextTest();
                                              }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadBackMandatoryAttributesFromDutAbsMinHeatSetpointLimit_5()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeAbsMinHeatSetpointLimitWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read back mandatory attributes from DUT: AbsMinHeatSetpointLimit Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("abs min heat setpoint limit", actualValue, 700));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsMandatoryAttributesFromDutAbsMaxHeatSetpointLimit_6()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeAbsMaxHeatSetpointLimitWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads mandatory attributes from DUT: AbsMaxHeatSetpointLimit Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("abs max heat setpoint limit", actualValue, 3000));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsConstraintsOfMandatoryAttributesFromDutAbsMaxHeatSetpointLimit_7()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeAbsMaxHeatSetpointLimitWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads constraints of mandatory attributes from DUT: AbsMaxHeatSetpointLimit Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("absMaxHeatSetpointLimit", "", "int16"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<int16_t>("absMaxHeatSetpointLimit", [value shortValue], 700));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<int16_t>("absMaxHeatSetpointLimit", [value shortValue], 3000));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutAbsMaxHeatSetpointLimit_8()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id absMaxHeatSetpointLimitArgument;
        absMaxHeatSetpointLimitArgument = [NSNumber numberWithShort:3000];
        [cluster writeAttributeAbsMaxHeatSetpointLimitWithValue:absMaxHeatSetpointLimitArgument
                                              completionHandler:^(NSError * _Nullable err) {
                                                  NSLog(@"Writes the respective default value to mandatory attributes to DUT: "
                                                        @"AbsMaxHeatSetpointLimit Error: %@",
                                                      err);

                                                  VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                                                  NextTest();
                                              }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadBackMandatoryAttributesFromDutAbsMaxHeatSetpointLimit_9()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeAbsMaxHeatSetpointLimitWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read back mandatory attributes from DUT: AbsMaxHeatSetpointLimit Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("abs max heat setpoint limit", actualValue, 3000));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsMandatoryAttributesFromDutAbsMinCoolSetpointLimit_10()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeAbsMinCoolSetpointLimitWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads mandatory attributes from DUT: AbsMinCoolSetpointLimit Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("abs min cool setpoint limit", actualValue, 1600));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsConstraintsOfMandatoryAttributesFromDutAbsMinCoolSetpointLimit_11()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeAbsMinCoolSetpointLimitWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads constraints of mandatory attributes from DUT: AbsMinCoolSetpointLimit Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("absMinCoolSetpointLimit", "", "int16"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<int16_t>("absMinCoolSetpointLimit", [value shortValue], 1600));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<int16_t>("absMinCoolSetpointLimit", [value shortValue], 3200));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutAbsMinCoolSetpointLimit_12()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id absMinCoolSetpointLimitArgument;
        absMinCoolSetpointLimitArgument = [NSNumber numberWithShort:1600];
        [cluster writeAttributeAbsMinCoolSetpointLimitWithValue:absMinCoolSetpointLimitArgument
                                              completionHandler:^(NSError * _Nullable err) {
                                                  NSLog(@"Writes the respective default value to mandatory attributes to DUT: "
                                                        @"AbsMinCoolSetpointLimit Error: %@",
                                                      err);

                                                  VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                                                  NextTest();
                                              }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadBackMandatoryAttributesFromDutAbsMinCoolSetpointLimit_13()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeAbsMinCoolSetpointLimitWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read back mandatory attributes from DUT: AbsMinCoolSetpointLimit Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("abs min cool setpoint limit", actualValue, 1600));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsMandatoryAttributesFromDutAbsMaxCoolSetpointLimit_14()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeAbsMaxCoolSetpointLimitWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads mandatory attributes from DUT: AbsMaxCoolSetpointLimit Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("abs max cool setpoint limit", actualValue, 3200));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsConstraintsOfMandatoryAttributesFromDutAbsMaxCoolSetpointLimit_15()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeAbsMaxCoolSetpointLimitWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads constraints of mandatory attributes from DUT: AbsMaxCoolSetpointLimit Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("absMaxCoolSetpointLimit", "", "int16"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<int16_t>("absMaxCoolSetpointLimit", [value shortValue], 1600));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<int16_t>("absMaxCoolSetpointLimit", [value shortValue], 3200));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutAbsMaxCoolSetpointLimit_16()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id absMaxCoolSetpointLimitArgument;
        absMaxCoolSetpointLimitArgument = [NSNumber numberWithShort:3200];
        [cluster writeAttributeAbsMaxCoolSetpointLimitWithValue:absMaxCoolSetpointLimitArgument
                                              completionHandler:^(NSError * _Nullable err) {
                                                  NSLog(@"Writes the respective default value to mandatory attributes to DUT: "
                                                        @"AbsMaxCoolSetpointLimit Error: %@",
                                                      err);

                                                  VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                                                  NextTest();
                                              }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadBackMandatoryAttributesFromDutAbsMaxCoolSetpointLimit_17()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeAbsMaxCoolSetpointLimitWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read back mandatory attributes from DUT: AbsMaxCoolSetpointLimit Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("abs max cool setpoint limit", actualValue, 3200));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsMandatoryAttributesFromDutOccupiedCoolingSetpoint_18()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOccupiedCoolingSetpointWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads mandatory attributes from DUT: OccupiedCoolingSetpoint Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("occupied cooling setpoint", actualValue, 2600));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsConstraintsOfMandatoryAttributesFromDutOccupiedCoolingSetpoint_19()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOccupiedCoolingSetpointWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads constraints of mandatory attributes from DUT: OccupiedCoolingSetpoint Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("occupiedCoolingSetpoint", "", "int16"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<int16_t>("occupiedCoolingSetpoint", [value shortValue], 1600));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<int16_t>("occupiedCoolingSetpoint", [value shortValue], 2600));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutOccupiedCoolingSetpoint_20()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id occupiedCoolingSetpointArgument;
        occupiedCoolingSetpointArgument = [NSNumber numberWithShort:2600];
        [cluster writeAttributeOccupiedCoolingSetpointWithValue:occupiedCoolingSetpointArgument
                                              completionHandler:^(NSError * _Nullable err) {
                                                  NSLog(@"Writes the respective default value to mandatory attributes to DUT: "
                                                        @"OccupiedCoolingSetpoint Error: %@",
                                                      err);

                                                  VerifyOrReturn(CheckValue("status", err, 0));

                                                  NextTest();
                                              }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadBackMandatoryAttributesFromDutOccupiedCoolingSetpoint_21()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOccupiedCoolingSetpointWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read back mandatory attributes from DUT: OccupiedCoolingSetpoint Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("occupied cooling setpoint", actualValue, 2600));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsMandatoryAttributesFromDutOccupiedHeatingSetpoint_22()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOccupiedHeatingSetpointWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads mandatory attributes from DUT: OccupiedHeatingSetpoint Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("occupied heating setpoint", actualValue, 2000));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsConstraintsOfMandatoryAttributesFromDutOccupiedHeatingSetpoint_23()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOccupiedHeatingSetpointWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads constraints of mandatory attributes from DUT: OccupiedHeatingSetpoint Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("occupiedHeatingSetpoint", "", "int16"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<int16_t>("occupiedHeatingSetpoint", [value shortValue], 700));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<int16_t>("occupiedHeatingSetpoint", [value shortValue], 2600));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutOccupiedHeatingSetpoint_24()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id occupiedHeatingSetpointArgument;
        occupiedHeatingSetpointArgument = [NSNumber numberWithShort:2000];
        [cluster writeAttributeOccupiedHeatingSetpointWithValue:occupiedHeatingSetpointArgument
                                              completionHandler:^(NSError * _Nullable err) {
                                                  NSLog(@"Writes the respective default value to mandatory attributes to DUT: "
                                                        @"OccupiedHeatingSetpoint Error: %@",
                                                      err);

                                                  VerifyOrReturn(CheckValue("status", err, 0));

                                                  NextTest();
                                              }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadBackMandatoryAttributesFromDutOccupiedHeatingSetpoint_25()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOccupiedHeatingSetpointWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read back mandatory attributes from DUT: OccupiedHeatingSetpoint Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("occupied heating setpoint", actualValue, 2000));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsMandatoryAttributesFromDutMinHeatSetpointLimit_26()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeMinHeatSetpointLimitWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads mandatory attributes from DUT: MinHeatSetpointLimit Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("min heat setpoint limit", actualValue, 700));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsConstraintsOfMandatoryAttributesFromDutMinHeatSetpointLimit_27()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeMinHeatSetpointLimitWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads constraints of mandatory attributes from DUT: MinHeatSetpointLimit Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("minHeatSetpointLimit", "", "int16"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<int16_t>("minHeatSetpointLimit", [value shortValue], 700));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<int16_t>("minHeatSetpointLimit", [value shortValue], 3000));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutMinHeatSetpointLimit_28()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id minHeatSetpointLimitArgument;
        minHeatSetpointLimitArgument = [NSNumber numberWithShort:700];
        [cluster writeAttributeMinHeatSetpointLimitWithValue:minHeatSetpointLimitArgument
                                           completionHandler:^(NSError * _Nullable err) {
                                               NSLog(@"Writes the respective default value to mandatory attributes to DUT: "
                                                     @"MinHeatSetpointLimit Error: %@",
                                                   err);

                                               VerifyOrReturn(CheckValue("status", err, 0));

                                               NextTest();
                                           }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadBackMandatoryAttributesFromDutMinHeatSetpointLimit_29()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeMinHeatSetpointLimitWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read back mandatory attributes from DUT: MinHeatSetpointLimit Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("min heat setpoint limit", actualValue, 700));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsMandatoryAttributesFromDutMaxHeatSetpointLimit_30()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeMaxHeatSetpointLimitWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads mandatory attributes from DUT: MaxHeatSetpointLimit Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("max heat setpoint limit", actualValue, 3000));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsConstraintsOfMandatoryAttributesFromDutMaxHeatSetpointLimit_31()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeMaxHeatSetpointLimitWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads constraints of mandatory attributes from DUT: MaxHeatSetpointLimit Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("maxHeatSetpointLimit", "", "int16"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<int16_t>("maxHeatSetpointLimit", [value shortValue], 700));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<int16_t>("maxHeatSetpointLimit", [value shortValue], 3000));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutMaxHeatSetpointLimit_32()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id maxHeatSetpointLimitArgument;
        maxHeatSetpointLimitArgument = [NSNumber numberWithShort:3000];
        [cluster writeAttributeMaxHeatSetpointLimitWithValue:maxHeatSetpointLimitArgument
                                           completionHandler:^(NSError * _Nullable err) {
                                               NSLog(@"Writes the respective default value to mandatory attributes to DUT: "
                                                     @"MaxHeatSetpointLimit Error: %@",
                                                   err);

                                               VerifyOrReturn(CheckValue("status", err, 0));

                                               NextTest();
                                           }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadBackMandatoryAttributesFromDutMaxHeatSetpointLimit_33()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeMaxHeatSetpointLimitWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read back mandatory attributes from DUT: MaxHeatSetpointLimit Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("max heat setpoint limit", actualValue, 3000));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsMandatoryAttributesFromDutMinCoolSetpointLimit_34()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeMinCoolSetpointLimitWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads mandatory attributes from DUT: MinCoolSetpointLimit Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("min cool setpoint limit", actualValue, 1600));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsConstraintsOfMandatoryAttributesFromDutMinCoolSetpointLimit_35()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeMinCoolSetpointLimitWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads constraints of mandatory attributes from DUT: MinCoolSetpointLimit Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("minCoolSetpointLimit", "", "int16"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<int16_t>("minCoolSetpointLimit", [value shortValue], 1600));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<int16_t>("minCoolSetpointLimit", [value shortValue], 3200));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutMinCoolSetpointLimit_36()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id minCoolSetpointLimitArgument;
        minCoolSetpointLimitArgument = [NSNumber numberWithShort:1600];
        [cluster writeAttributeMinCoolSetpointLimitWithValue:minCoolSetpointLimitArgument
                                           completionHandler:^(NSError * _Nullable err) {
                                               NSLog(@"Writes the respective default value to mandatory attributes to DUT: "
                                                     @"MinCoolSetpointLimit Error: %@",
                                                   err);

                                               VerifyOrReturn(CheckValue("status", err, 0));

                                               NextTest();
                                           }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadBackMandatoryAttributesFromDutMinCoolSetpointLimit_37()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeMinCoolSetpointLimitWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read back mandatory attributes from DUT: MinCoolSetpointLimit Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("min cool setpoint limit", actualValue, 1600));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsMandatoryAttributesFromDutMaxCoolSetpointLimit_38()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeMaxCoolSetpointLimitWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads mandatory attributes from DUT: MaxCoolSetpointLimit Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("max cool setpoint limit", actualValue, 3200));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsConstraintsOfMandatoryAttributesFromDutMaxCoolSetpointLimit_39()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeMaxCoolSetpointLimitWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads constraints of mandatory attributes from DUT: MaxCoolSetpointLimit Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("maxCoolSetpointLimit", "", "int16"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<int16_t>("maxCoolSetpointLimit", [value shortValue], 1600));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<int16_t>("maxCoolSetpointLimit", [value shortValue], 3200));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutMaxCoolSetpointLimit_40()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id maxCoolSetpointLimitArgument;
        maxCoolSetpointLimitArgument = [NSNumber numberWithShort:3200];
        [cluster writeAttributeMaxCoolSetpointLimitWithValue:maxCoolSetpointLimitArgument
                                           completionHandler:^(NSError * _Nullable err) {
                                               NSLog(@"Writes the respective default value to mandatory attributes to DUT: "
                                                     @"MaxCoolSetpointLimit Error: %@",
                                                   err);

                                               VerifyOrReturn(CheckValue("status", err, 0));

                                               NextTest();
                                           }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadBackMandatoryAttributesFromDutMaxCoolSetpointLimit_41()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeMaxCoolSetpointLimitWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read back mandatory attributes from DUT: MaxCoolSetpointLimit Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("max cool setpoint limit", actualValue, 3200));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsMandatoryAttributesFromDutControlSequenceOfOperation_42()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster
            readAttributeControlSequenceOfOperationWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
                NSLog(@"Reads mandatory attributes from DUT: ControlSequenceOfOperation Error: %@", err);

                VerifyOrReturn(CheckValue("status", err, 0));

                {
                    id actualValue = value;
                    VerifyOrReturn(CheckValue("control sequence of operation", actualValue, 4));
                }

                NextTest();
            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsConstraintsOfMandatoryAttributesFromDutControlSequenceOfOperation_43()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster
            readAttributeControlSequenceOfOperationWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
                NSLog(@"Reads constraints of mandatory attributes from DUT: ControlSequenceOfOperation Error: %@", err);

                VerifyOrReturn(CheckValue("status", err, 0));

                VerifyOrReturn(CheckConstraintType("controlSequenceOfOperation", "", "enum8"));
                if (value != nil) {
                    VerifyOrReturn(CheckConstraintMinValue<uint8_t>("controlSequenceOfOperation", [value unsignedCharValue], 0));
                }
                if (value != nil) {
                    VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("controlSequenceOfOperation", [value unsignedCharValue], 5));
                }

                NextTest();
            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutControlSequenceOfOperation_44()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id controlSequenceOfOperationArgument;
        controlSequenceOfOperationArgument = [NSNumber numberWithUnsignedChar:4];
        [cluster writeAttributeControlSequenceOfOperationWithValue:controlSequenceOfOperationArgument
                                                 completionHandler:^(NSError * _Nullable err) {
                                                     NSLog(@"Writes the respective default value to mandatory attributes to DUT: "
                                                           @"ControlSequenceOfOperation Error: %@",
                                                         err);

                                                     VerifyOrReturn(CheckValue("status", err, 0));

                                                     NextTest();
                                                 }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadBackMandatoryAttributesFromDutControlSequenceOfOperation_45()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster
            readAttributeControlSequenceOfOperationWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
                NSLog(@"Read back mandatory attributes from DUT: ControlSequenceOfOperation Error: %@", err);

                VerifyOrReturn(CheckValue("status", err, 0));

                {
                    id actualValue = value;
                    VerifyOrReturn(CheckValue("control sequence of operation", actualValue, 4));
                }

                NextTest();
            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsMandatoryAttributesFromDutSystemMode_46()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeSystemModeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads mandatory attributes from DUT: SystemMode Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("system mode", actualValue, 1));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsConstraintsOfMandatoryAttributesFromDutSystemMode_47()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeSystemModeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads constraints of mandatory attributes from DUT: SystemMode Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("systemMode", "", "enum8"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<uint8_t>("systemMode", [value unsignedCharValue], 0));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("systemMode", [value unsignedCharValue], 9));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutSystemMode_48()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id systemModeArgument;
        systemModeArgument = [NSNumber numberWithUnsignedChar:1];
        [cluster
            writeAttributeSystemModeWithValue:systemModeArgument
                            completionHandler:^(NSError * _Nullable err) {
                                NSLog(@"Writes the respective default value to mandatory attributes to DUT: SystemMode Error: %@",
                                    err);

                                VerifyOrReturn(CheckValue("status", err, 0));

                                NextTest();
                            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadBackMandatoryAttributesFromDutSystemMode_49()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeSystemModeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read back mandatory attributes from DUT: SystemMode Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("system mode", actualValue, 1));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsOptionalAttributesFromDutMinSetpointDeadBand_50()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeMinSetpointDeadBandWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads optional attributes from DUT: MinSetpointDeadBand Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("min setpoint dead band", actualValue, 25));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsConstraintsOfOptionalAttributesFromDutMinSetpointDeadBand_51()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeMinSetpointDeadBandWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads constraints of optional attributes from DUT: MinSetpointDeadBand Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("minSetpointDeadBand", "", "int8"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<int8_t>("minSetpointDeadBand", [value charValue], 0));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<int8_t>("minSetpointDeadBand", [value charValue], 25));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWritesTheRespectiveDefaultValueToOptionalAttributesToDutMinSetpointDeadBand_52()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id minSetpointDeadBandArgument;
        minSetpointDeadBandArgument = [NSNumber numberWithChar:25];
        [cluster writeAttributeMinSetpointDeadBandWithValue:minSetpointDeadBandArgument
                                          completionHandler:^(NSError * _Nullable err) {
                                              NSLog(@"Writes the respective default value to optional attributes to DUT: "
                                                    @"MinSetpointDeadBand Error: %@",
                                                  err);

                                              if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                                                  NextTest();
                                                  return;
                                              }

                                              VerifyOrReturn(CheckValue("status", err, 0));

                                              NextTest();
                                          }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadBackOptionalAttributesFromDutMinSetpointDeadBand_53()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeMinSetpointDeadBandWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read back optional attributes from DUT: MinSetpointDeadBand Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("min setpoint dead band", actualValue, 25));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsConstraintsOfOptionalAttributesFromDutStartOfWeek_54()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeStartOfWeekWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads constraints of optional attributes from DUT: StartOfWeek Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("startOfWeek", "", "enum8"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<uint8_t>("startOfWeek", [value unsignedCharValue], 0));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("startOfWeek", [value unsignedCharValue], 6));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWritesTheRespectiveDefaultValueToOptionalAttributesToDutStartOfWeek_55()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id startOfWeekArgument;
        startOfWeekArgument = [NSNumber numberWithUnsignedChar:0];
        [cluster
            writeAttributeStartOfWeekWithValue:startOfWeekArgument
                             completionHandler:^(NSError * _Nullable err) {
                                 NSLog(@"Writes the respective default value to optional attributes to DUT: StartOfWeek Error: %@",
                                     err);

                                 if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                                     NextTest();
                                     return;
                                 }

                                 VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                                 NextTest();
                             }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadBackOptionalAttributesFromDutStartOfWeek_56()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeStartOfWeekWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read back optional attributes from DUT: StartOfWeek Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("start of week", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsConstraintsOfOptionalAttributesFromDutNumberOfWeeklyTransitions_57()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster
            readAttributeNumberOfWeeklyTransitionsWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
                NSLog(@"Reads constraints of optional attributes from DUT: NumberOfWeeklyTransitions Error: %@", err);

                if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                    NextTest();
                    return;
                }

                VerifyOrReturn(CheckValue("status", err, 0));

                VerifyOrReturn(CheckConstraintType("numberOfWeeklyTransitions", "", "uint8"));
                NextTest();
            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWritesTheRespectiveDefaultValueToOptionalAttributesToDutNumberOfWeeklyTransitions_58()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id numberOfWeeklyTransitionsArgument;
        numberOfWeeklyTransitionsArgument = [NSNumber numberWithUnsignedChar:0];
        [cluster writeAttributeNumberOfWeeklyTransitionsWithValue:numberOfWeeklyTransitionsArgument
                                                completionHandler:^(NSError * _Nullable err) {
                                                    NSLog(@"Writes the respective default value to optional attributes to DUT: "
                                                          @"NumberOfWeeklyTransitions Error: %@",
                                                        err);

                                                    if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                                                        NextTest();
                                                        return;
                                                    }

                                                    VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                                                    NextTest();
                                                }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsConstraintsOfOptionalAttributesFromDutNumberOfDailyTransitions_59()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNumberOfDailyTransitionsWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads constraints of optional attributes from DUT: NumberOfDailyTransitions Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("numberOfDailyTransitions", "", "uint8"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWritesTheRespectiveDefaultValueToOptionalAttributesToDutNumberOfDailyTransitions_60()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id numberOfDailyTransitionsArgument;
        numberOfDailyTransitionsArgument = [NSNumber numberWithUnsignedChar:0];
        [cluster writeAttributeNumberOfDailyTransitionsWithValue:numberOfDailyTransitionsArgument
                                               completionHandler:^(NSError * _Nullable err) {
                                                   NSLog(@"Writes the respective default value to optional attributes to DUT: "
                                                         @"NumberOfDailyTransitions Error: %@",
                                                       err);

                                                   if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                                                       NextTest();
                                                       return;
                                                   }

                                                   VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                                                   NextTest();
                                               }];

        return CHIP_NO_ERROR;
    }
};

class Test_TC_TSTAT_2_2 : public TestCommandBridge {
public:
    Test_TC_TSTAT_2_2()
        : TestCommandBridge("Test_TC_TSTAT_2_2")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_TSTAT_2_2() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_TSTAT_2_2\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_TSTAT_2_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool,
                " ***** Test Step 1 : Reads OccupiedCoolingSetpoint attribute from Server DUT and verifies that the value is "
                "within range\n");
            if (ShouldSkip("A_OCCUPIEDCOOLINGSETPOINT")) {
                NextTest();
                return;
            }
            err = TestReadsOccupiedCoolingSetpointAttributeFromServerDutAndVerifiesThatTheValueIsWithinRange_1();
            break;
        case 2:
            ChipLogProgress(chipTool,
                " ***** Test Step 2 : Writes a value back that is different but valid for OccupiedCoolingSetpoint attribute\n");
            if (ShouldSkip("A_OCCUPIEDCOOLINGSETPOINT")) {
                NextTest();
                return;
            }
            err = TestWritesAValueBackThatIsDifferentButValidForOccupiedCoolingSetpointAttribute_2();
            break;
        case 3:
            ChipLogProgress(chipTool,
                " ***** Test Step 3 : Reads it back again to confirm the successful write of OccupiedCoolingSetpoint attribute\n");
            if (ShouldSkip("A_OCCUPIEDCOOLINGSETPOINT")) {
                NextTest();
                return;
            }
            err = TestReadsItBackAgainToConfirmTheSuccessfulWriteOfOccupiedCoolingSetpointAttribute_3();
            break;
        case 4:
            ChipLogProgress(
                chipTool, " ***** Test Step 4 : Writes the limit of MinCoolSetpointLimit to OccupiedCoolingSetpoint attribute\n");
            if (ShouldSkip("A_OCCUPIEDCOOLINGSETPOINT")) {
                NextTest();
                return;
            }
            err = TestWritesTheLimitOfMinCoolSetpointLimitToOccupiedCoolingSetpointAttribute_4();
            break;
        case 5:
            ChipLogProgress(
                chipTool, " ***** Test Step 5 : Writes the limit of MaxCoolSetpointLimit to OccupiedCoolingSetpoint attribute\n");
            if (ShouldSkip("A_OCCUPIEDCOOLINGSETPOINT")) {
                NextTest();
                return;
            }
            err = TestWritesTheLimitOfMaxCoolSetpointLimitToOccupiedCoolingSetpointAttribute_5();
            break;
        case 6:
            ChipLogProgress(chipTool,
                " ***** Test Step 6 : Reads OccupiedHeatingSetpoint attribute from Server DUT and verifies that the value is "
                "within range\n");
            if (ShouldSkip("A_OCCUPIEDHEATINGSETPOINT")) {
                NextTest();
                return;
            }
            err = TestReadsOccupiedHeatingSetpointAttributeFromServerDutAndVerifiesThatTheValueIsWithinRange_6();
            break;
        case 7:
            ChipLogProgress(chipTool,
                " ***** Test Step 7 : Writes a value back that is different but valid for OccupiedHeatingSetpoint attribute\n");
            if (ShouldSkip("A_OCCUPIEDHEATINGSETPOINT")) {
                NextTest();
                return;
            }
            err = TestWritesAValueBackThatIsDifferentButValidForOccupiedHeatingSetpointAttribute_7();
            break;
        case 8:
            ChipLogProgress(chipTool,
                " ***** Test Step 8 : Reads it back again to confirm the successful write of OccupiedHeatingSetpoint attribute\n");
            if (ShouldSkip("A_OCCUPIEDHEATINGSETPOINT")) {
                NextTest();
                return;
            }
            err = TestReadsItBackAgainToConfirmTheSuccessfulWriteOfOccupiedHeatingSetpointAttribute_8();
            break;
        case 9:
            ChipLogProgress(
                chipTool, " ***** Test Step 9 : Writes the limit of MinHeatSetpointLimit to OccupiedHeatingSetpoint attribute\n");
            if (ShouldSkip("A_OCCUPIEDHEATINGSETPOINT")) {
                NextTest();
                return;
            }
            err = TestWritesTheLimitOfMinHeatSetpointLimitToOccupiedHeatingSetpointAttribute_9();
            break;
        case 10:
            ChipLogProgress(
                chipTool, " ***** Test Step 10 : Writes the limit of MaxHeatSetpointLimit to OccupiedHeatingSetpoint attribute\n");
            if (ShouldSkip("A_OCCUPIEDHEATINGSETPOINT")) {
                NextTest();
                return;
            }
            err = TestWritesTheLimitOfMaxHeatSetpointLimitToOccupiedHeatingSetpointAttribute_10();
            break;
        case 11:
            ChipLogProgress(chipTool,
                " ***** Test Step 11 : Reads MinHeatSetpointLimit attribute from Server DUT and verifies that the value is within "
                "range\n");
            if (ShouldSkip("A_MINHEATSETPOINTLIMIT")) {
                NextTest();
                return;
            }
            err = TestReadsMinHeatSetpointLimitAttributeFromServerDutAndVerifiesThatTheValueIsWithinRange_11();
            break;
        case 12:
            ChipLogProgress(chipTool,
                " ***** Test Step 12 : Writes a value back that is different but valid for MinHeatSetpointLimit attribute\n");
            if (ShouldSkip("A_MINHEATSETPOINTLIMIT")) {
                NextTest();
                return;
            }
            err = TestWritesAValueBackThatIsDifferentButValidForMinHeatSetpointLimitAttribute_12();
            break;
        case 13:
            ChipLogProgress(chipTool,
                " ***** Test Step 13 : Reads it back again to confirm the successful write of MinHeatSetpointLimit attribute\n");
            if (ShouldSkip("A_MINHEATSETPOINTLIMIT")) {
                NextTest();
                return;
            }
            err = TestReadsItBackAgainToConfirmTheSuccessfulWriteOfMinHeatSetpointLimitAttribute_13();
            break;
        case 14:
            ChipLogProgress(
                chipTool, " ***** Test Step 14 : Writes the limit of AbsMinHeatSetpointLimit to MinHeatSetpointLimit attribute\n");
            if (ShouldSkip("A_MINHEATSETPOINTLIMIT")) {
                NextTest();
                return;
            }
            err = TestWritesTheLimitOfAbsMinHeatSetpointLimitToMinHeatSetpointLimitAttribute_14();
            break;
        case 15:
            ChipLogProgress(
                chipTool, " ***** Test Step 15 : Writes the limit of AbsMaxHeatSetpointLimit to MinHeatSetpointLimit attribute\n");
            if (ShouldSkip("A_MINHEATSETPOINTLIMIT")) {
                NextTest();
                return;
            }
            err = TestWritesTheLimitOfAbsMaxHeatSetpointLimitToMinHeatSetpointLimitAttribute_15();
            break;
        case 16:
            ChipLogProgress(chipTool,
                " ***** Test Step 16 : Reads MaxHeatSetpointLimit attribute from Server DUT and verifies that the value is within "
                "range\n");
            if (ShouldSkip("A_MAXHEATSETPOINTLIMIT")) {
                NextTest();
                return;
            }
            err = TestReadsMaxHeatSetpointLimitAttributeFromServerDutAndVerifiesThatTheValueIsWithinRange_16();
            break;
        case 17:
            ChipLogProgress(chipTool,
                " ***** Test Step 17 : Writes a value back that is different but valid for MaxHeatSetpointLimit attribute\n");
            if (ShouldSkip("A_MAXHEATSETPOINTLIMIT")) {
                NextTest();
                return;
            }
            err = TestWritesAValueBackThatIsDifferentButValidForMaxHeatSetpointLimitAttribute_17();
            break;
        case 18:
            ChipLogProgress(chipTool,
                " ***** Test Step 18 : Reads it back again to confirm the successful write of MaxHeatSetpointLimit attribute\n");
            if (ShouldSkip("A_MAXHEATSETPOINTLIMIT")) {
                NextTest();
                return;
            }
            err = TestReadsItBackAgainToConfirmTheSuccessfulWriteOfMaxHeatSetpointLimitAttribute_18();
            break;
        case 19:
            ChipLogProgress(
                chipTool, " ***** Test Step 19 : Writes the limit of AbsMinHeatSetpointLimit to MaxHeatSetpointLimit attribute\n");
            if (ShouldSkip("A_MAXHEATSETPOINTLIMIT")) {
                NextTest();
                return;
            }
            err = TestWritesTheLimitOfAbsMinHeatSetpointLimitToMaxHeatSetpointLimitAttribute_19();
            break;
        case 20:
            ChipLogProgress(
                chipTool, " ***** Test Step 20 : Writes the limit of AbsMaxHeatSetpointLimit to MaxHeatSetpointLimit attribute\n");
            if (ShouldSkip("A_MAXHEATSETPOINTLIMIT")) {
                NextTest();
                return;
            }
            err = TestWritesTheLimitOfAbsMaxHeatSetpointLimitToMaxHeatSetpointLimitAttribute_20();
            break;
        case 21:
            ChipLogProgress(chipTool,
                " ***** Test Step 21 : Reads MinCoolSetpointLimit attribute from Server DUT and verifies that the value is within "
                "range\n");
            if (ShouldSkip("A_MINCOOLSETPOINTLIMIT")) {
                NextTest();
                return;
            }
            err = TestReadsMinCoolSetpointLimitAttributeFromServerDutAndVerifiesThatTheValueIsWithinRange_21();
            break;
        case 22:
            ChipLogProgress(chipTool,
                " ***** Test Step 22 : Writes a value back that is different but valid for MinCoolSetpointLimit attribute\n");
            if (ShouldSkip("A_MINCOOLSETPOINTLIMIT")) {
                NextTest();
                return;
            }
            err = TestWritesAValueBackThatIsDifferentButValidForMinCoolSetpointLimitAttribute_22();
            break;
        case 23:
            ChipLogProgress(chipTool,
                " ***** Test Step 23 : Reads it back again to confirm the successful write of MinCoolSetpointLimit attribute\n");
            if (ShouldSkip("A_MINCOOLSETPOINTLIMIT")) {
                NextTest();
                return;
            }
            err = TestReadsItBackAgainToConfirmTheSuccessfulWriteOfMinCoolSetpointLimitAttribute_23();
            break;
        case 24:
            ChipLogProgress(
                chipTool, " ***** Test Step 24 : Writes the limit of AbsMinCoolSetpointLimit to MinCoolSetpointLimit attribute\n");
            if (ShouldSkip("A_MINCOOLSETPOINTLIMIT")) {
                NextTest();
                return;
            }
            err = TestWritesTheLimitOfAbsMinCoolSetpointLimitToMinCoolSetpointLimitAttribute_24();
            break;
        case 25:
            ChipLogProgress(
                chipTool, " ***** Test Step 25 : Writes the limit of MaxCoolSetpointLimit to MinCoolSetpointLimit attribute\n");
            if (ShouldSkip("A_MINCOOLSETPOINTLIMIT")) {
                NextTest();
                return;
            }
            err = TestWritesTheLimitOfMaxCoolSetpointLimitToMinCoolSetpointLimitAttribute_25();
            break;
        case 26:
            ChipLogProgress(chipTool,
                " ***** Test Step 26 : Reads MaxCoolSetpointLimit attribute from Server DUT and verifies that the value is within "
                "range\n");
            if (ShouldSkip("A_MAXCOOLSETPOINTLIMIT")) {
                NextTest();
                return;
            }
            err = TestReadsMaxCoolSetpointLimitAttributeFromServerDutAndVerifiesThatTheValueIsWithinRange_26();
            break;
        case 27:
            ChipLogProgress(chipTool,
                " ***** Test Step 27 : Writes a value back that is different but valid for MaxCoolSetpointLimit attribute\n");
            if (ShouldSkip("A_MAXCOOLSETPOINTLIMIT")) {
                NextTest();
                return;
            }
            err = TestWritesAValueBackThatIsDifferentButValidForMaxCoolSetpointLimitAttribute_27();
            break;
        case 28:
            ChipLogProgress(chipTool,
                " ***** Test Step 28 : Reads it back again to confirm the successful write of MaxCoolSetpointLimit attribute\n");
            if (ShouldSkip("A_MAXCOOLSETPOINTLIMIT")) {
                NextTest();
                return;
            }
            err = TestReadsItBackAgainToConfirmTheSuccessfulWriteOfMaxCoolSetpointLimitAttribute_28();
            break;
        case 29:
            ChipLogProgress(
                chipTool, " ***** Test Step 29 : Writes the limit of AbsMinCoolSetpointLimit to MaxCoolSetpointLimit attribute\n");
            if (ShouldSkip("A_MAXCOOLSETPOINTLIMIT")) {
                NextTest();
                return;
            }
            err = TestWritesTheLimitOfAbsMinCoolSetpointLimitToMaxCoolSetpointLimitAttribute_29();
            break;
        case 30:
            ChipLogProgress(
                chipTool, " ***** Test Step 30 : Writes the limit of MaxCoolSetpointLimit to MaxCoolSetpointLimit attribute\n");
            if (ShouldSkip("A_MAXCOOLSETPOINTLIMIT")) {
                NextTest();
                return;
            }
            err = TestWritesTheLimitOfMaxCoolSetpointLimitToMaxCoolSetpointLimitAttribute_30();
            break;
        case 31:
            ChipLogProgress(chipTool,
                " ***** Test Step 31 : Writes (sets back) the limit of MinHeatSetpointLimit to MinHeatSetpointLimit attribute\n");
            if (ShouldSkip("A_MINHEATSETPOINTLIMIT")) {
                NextTest();
                return;
            }
            err = TestWritesSetsBackTheLimitOfMinHeatSetpointLimitToMinHeatSetpointLimitAttribute_31();
            break;
        case 32:
            ChipLogProgress(chipTool,
                " ***** Test Step 32 : Writes (sets back) the limit of MaxHeatSetpointLimit to MinHeatSetpointLimit attribute\n");
            if (ShouldSkip("A_MINHEATSETPOINTLIMIT")) {
                NextTest();
                return;
            }
            err = TestWritesSetsBackTheLimitOfMaxHeatSetpointLimitToMinHeatSetpointLimitAttribute_32();
            break;
        case 33:
            ChipLogProgress(chipTool,
                " ***** Test Step 33 : Writes (sets back) the limit of MinHeatSetpointLimit to MaxHeatSetpointLimit attribute\n");
            if (ShouldSkip("A_MINHEATSETPOINTLIMIT")) {
                NextTest();
                return;
            }
            err = TestWritesSetsBackTheLimitOfMinHeatSetpointLimitToMaxHeatSetpointLimitAttribute_33();
            break;
        case 34:
            ChipLogProgress(chipTool,
                " ***** Test Step 34 : Writes (sets back) the limit of MaxHeatSetpointLimit to MaxHeatSetpointLimit attribute\n");
            if (ShouldSkip("A_MINHEATSETPOINTLIMIT")) {
                NextTest();
                return;
            }
            err = TestWritesSetsBackTheLimitOfMaxHeatSetpointLimitToMaxHeatSetpointLimitAttribute_34();
            break;
        case 35:
            ChipLogProgress(chipTool,
                " ***** Test Step 35 : Writes (sets back) the limit of MinCoolSetpointLimit to MinCoolSetpointLimit attribute\n");
            if (ShouldSkip("A_MINCOOLSETPOINTLIMIT")) {
                NextTest();
                return;
            }
            err = TestWritesSetsBackTheLimitOfMinCoolSetpointLimitToMinCoolSetpointLimitAttribute_35();
            break;
        case 36:
            ChipLogProgress(chipTool,
                " ***** Test Step 36 : Writes (sets back) the limit of MaxCoolSetpointLimit to MinCoolSetpointLimit attribute\n");
            if (ShouldSkip("A_MINCOOLSETPOINTLIMIT")) {
                NextTest();
                return;
            }
            err = TestWritesSetsBackTheLimitOfMaxCoolSetpointLimitToMinCoolSetpointLimitAttribute_36();
            break;
        case 37:
            ChipLogProgress(chipTool,
                " ***** Test Step 37 : Writes (sets back) the limit of MinCoolSetpointLimit to MaxCoolSetpointLimit attribute\n");
            if (ShouldSkip("A_MAXCOOLSETPOINTLIMIT")) {
                NextTest();
                return;
            }
            err = TestWritesSetsBackTheLimitOfMinCoolSetpointLimitToMaxCoolSetpointLimitAttribute_37();
            break;
        case 38:
            ChipLogProgress(chipTool,
                " ***** Test Step 38 : Writes (sets back) the limit of MaxCoolSetpointLimit to MaxCoolSetpointLimit attribute\n");
            if (ShouldSkip("A_MAXCOOLSETPOINTLIMIT")) {
                NextTest();
                return;
            }
            err = TestWritesSetsBackTheLimitOfMaxCoolSetpointLimitToMaxCoolSetpointLimitAttribute_38();
            break;
        case 39:
            ChipLogProgress(chipTool,
                " ***** Test Step 39 : Reads ControlSequenceOfOperation from Server DUT and verifies that the value is valid\n");
            if (ShouldSkip("A_CONTROLSEQUENCEOFOPERATION")) {
                NextTest();
                return;
            }
            err = TestReadsControlSequenceOfOperationFromServerDutAndVerifiesThatTheValueIsValid_39();
            break;
        case 40:
            ChipLogProgress(
                chipTool, " ***** Test Step 40 : Write Attribute command for ControlSequenceOfOperation with a new valid value\n");
            if (ShouldSkip("A_CONTROLSEQUENCEOFOPERATION")) {
                NextTest();
                return;
            }
            err = TestWriteAttributeCommandForControlSequenceOfOperationWithANewValidValue_40();
            break;
        case 41:
            ChipLogProgress(chipTool, " ***** Test Step 41 : Read it back again to confirm the successful write\n");
            if (ShouldSkip("A_CONTROLSEQUENCEOFOPERATION")) {
                NextTest();
                return;
            }
            err = TestReadItBackAgainToConfirmTheSuccessfulWrite_41();
            break;
        case 42:
            ChipLogProgress(chipTool, " ***** Test Step 42 : Sets OccupiedHeatingSetpoint to default value\n");
            if (ShouldSkip("A_OCCUPIEDHEATINGSETPOINT")) {
                NextTest();
                return;
            }
            err = TestSetsOccupiedHeatingSetpointToDefaultValue_42();
            break;
        case 43:
            ChipLogProgress(chipTool, " ***** Test Step 43 : Sets OccupiedHeatingSetpoint to default value\n");
            if (ShouldSkip("A_OCCUPIEDHEATINGSETPOINT")) {
                NextTest();
                return;
            }
            err = TestSetsOccupiedHeatingSetpointToDefaultValue_43();
            break;
        case 44:
            ChipLogProgress(chipTool, " ***** Test Step 44 : Sets OccupiedCoolingSetpoint to default value\n");
            if (ShouldSkip("A_OCCUPIEDCOOLINGSETPOINT")) {
                NextTest();
                return;
            }
            err = TestSetsOccupiedCoolingSetpointToDefaultValue_44();
            break;
        case 45:
            ChipLogProgress(chipTool, " ***** Test Step 45 : Sets OccupiedCoolingSetpoint to default value\n");
            if (ShouldSkip("A_OCCUPIEDCOOLINGSETPOINT")) {
                NextTest();
                return;
            }
            err = TestSetsOccupiedCoolingSetpointToDefaultValue_45();
            break;
        case 46:
            ChipLogProgress(chipTool, " ***** Test Step 46 : Sets OccupiedCoolingSetpoint to default value\n");
            if (ShouldSkip("A_OCCUPIEDCOOLINGSETPOINT")) {
                NextTest();
                return;
            }
            err = TestSetsOccupiedCoolingSetpointToDefaultValue_46();
            break;
        case 47:
            ChipLogProgress(chipTool, " ***** Test Step 47 : Sets OccupiedHeatingSetpoint to default value\n");
            if (ShouldSkip("A_OCCUPIEDHEATINGSETPOINT")) {
                NextTest();
                return;
            }
            err = TestSetsOccupiedHeatingSetpointToDefaultValue_47();
            break;
        case 48:
            ChipLogProgress(chipTool, " ***** Test Step 48 : Sets OccupiedCoolingSetpoint to default value\n");
            if (ShouldSkip("A_OCCUPIEDCOOLINGSETPOINT")) {
                NextTest();
                return;
            }
            err = TestSetsOccupiedCoolingSetpointToDefaultValue_48();
            break;
        case 49:
            ChipLogProgress(chipTool, " ***** Test Step 49 : Sets OccupiedHeatingSetpoint to default value\n");
            if (ShouldSkip("A_OCCUPIEDHEATINGSETPOINT")) {
                NextTest();
                return;
            }
            err = TestSetsOccupiedHeatingSetpointToDefaultValue_49();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 50;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsOccupiedCoolingSetpointAttributeFromServerDutAndVerifiesThatTheValueIsWithinRange_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOccupiedCoolingSetpointWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads OccupiedCoolingSetpoint attribute from Server DUT and verifies that the value is within range Error: %@",
                err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("occupied cooling setpoint", actualValue, 2600));
            }

            VerifyOrReturn(CheckConstraintType("occupiedCoolingSetpoint", "", "int16"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<int16_t>("occupiedCoolingSetpoint", [value shortValue], 1600));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<int16_t>("occupiedCoolingSetpoint", [value shortValue], 2600));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWritesAValueBackThatIsDifferentButValidForOccupiedCoolingSetpointAttribute_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id occupiedCoolingSetpointArgument;
        occupiedCoolingSetpointArgument = [NSNumber numberWithShort:2000];
        [cluster writeAttributeOccupiedCoolingSetpointWithValue:occupiedCoolingSetpointArgument
                                              completionHandler:^(NSError * _Nullable err) {
                                                  NSLog(@"Writes a value back that is different but valid for "
                                                        @"OccupiedCoolingSetpoint attribute Error: %@",
                                                      err);

                                                  VerifyOrReturn(CheckValue("status", err, 0));

                                                  NextTest();
                                              }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsItBackAgainToConfirmTheSuccessfulWriteOfOccupiedCoolingSetpointAttribute_3()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOccupiedCoolingSetpointWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads it back again to confirm the successful write of OccupiedCoolingSetpoint attribute Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("occupied cooling setpoint", actualValue, 2000));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWritesTheLimitOfMinCoolSetpointLimitToOccupiedCoolingSetpointAttribute_4()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id occupiedCoolingSetpointArgument;
        occupiedCoolingSetpointArgument = [NSNumber numberWithShort:1600];
        [cluster writeAttributeOccupiedCoolingSetpointWithValue:occupiedCoolingSetpointArgument
                                              completionHandler:^(NSError * _Nullable err) {
                                                  NSLog(@"Writes the limit of MinCoolSetpointLimit to OccupiedCoolingSetpoint "
                                                        @"attribute Error: %@",
                                                      err);

                                                  VerifyOrReturn(CheckValue("status", err, 0));

                                                  NextTest();
                                              }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWritesTheLimitOfMaxCoolSetpointLimitToOccupiedCoolingSetpointAttribute_5()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id occupiedCoolingSetpointArgument;
        occupiedCoolingSetpointArgument = [NSNumber numberWithShort:2600];
        [cluster writeAttributeOccupiedCoolingSetpointWithValue:occupiedCoolingSetpointArgument
                                              completionHandler:^(NSError * _Nullable err) {
                                                  NSLog(@"Writes the limit of MaxCoolSetpointLimit to OccupiedCoolingSetpoint "
                                                        @"attribute Error: %@",
                                                      err);

                                                  VerifyOrReturn(CheckValue("status", err, 0));

                                                  NextTest();
                                              }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsOccupiedHeatingSetpointAttributeFromServerDutAndVerifiesThatTheValueIsWithinRange_6()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOccupiedHeatingSetpointWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads OccupiedHeatingSetpoint attribute from Server DUT and verifies that the value is within range Error: %@",
                err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("occupied heating setpoint", actualValue, 2000));
            }

            VerifyOrReturn(CheckConstraintType("occupiedHeatingSetpoint", "", "int16"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<int16_t>("occupiedHeatingSetpoint", [value shortValue], 700));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<int16_t>("occupiedHeatingSetpoint", [value shortValue], 3000));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWritesAValueBackThatIsDifferentButValidForOccupiedHeatingSetpointAttribute_7()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id occupiedHeatingSetpointArgument;
        occupiedHeatingSetpointArgument = [NSNumber numberWithShort:2100];
        [cluster writeAttributeOccupiedHeatingSetpointWithValue:occupiedHeatingSetpointArgument
                                              completionHandler:^(NSError * _Nullable err) {
                                                  NSLog(@"Writes a value back that is different but valid for "
                                                        @"OccupiedHeatingSetpoint attribute Error: %@",
                                                      err);

                                                  VerifyOrReturn(CheckValue("status", err, 0));

                                                  NextTest();
                                              }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsItBackAgainToConfirmTheSuccessfulWriteOfOccupiedHeatingSetpointAttribute_8()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOccupiedHeatingSetpointWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads it back again to confirm the successful write of OccupiedHeatingSetpoint attribute Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("occupied heating setpoint", actualValue, 2100));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWritesTheLimitOfMinHeatSetpointLimitToOccupiedHeatingSetpointAttribute_9()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id occupiedHeatingSetpointArgument;
        occupiedHeatingSetpointArgument = [NSNumber numberWithShort:700];
        [cluster writeAttributeOccupiedHeatingSetpointWithValue:occupiedHeatingSetpointArgument
                                              completionHandler:^(NSError * _Nullable err) {
                                                  NSLog(@"Writes the limit of MinHeatSetpointLimit to OccupiedHeatingSetpoint "
                                                        @"attribute Error: %@",
                                                      err);

                                                  VerifyOrReturn(CheckValue("status", err, 0));

                                                  NextTest();
                                              }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWritesTheLimitOfMaxHeatSetpointLimitToOccupiedHeatingSetpointAttribute_10()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id occupiedHeatingSetpointArgument;
        occupiedHeatingSetpointArgument = [NSNumber numberWithShort:3000];
        [cluster writeAttributeOccupiedHeatingSetpointWithValue:occupiedHeatingSetpointArgument
                                              completionHandler:^(NSError * _Nullable err) {
                                                  NSLog(@"Writes the limit of MaxHeatSetpointLimit to OccupiedHeatingSetpoint "
                                                        @"attribute Error: %@",
                                                      err);

                                                  VerifyOrReturn(CheckValue("status", err, 0));

                                                  NextTest();
                                              }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsMinHeatSetpointLimitAttributeFromServerDutAndVerifiesThatTheValueIsWithinRange_11()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeMinHeatSetpointLimitWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(
                @"Reads MinHeatSetpointLimit attribute from Server DUT and verifies that the value is within range Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("min heat setpoint limit", actualValue, 700));
            }

            VerifyOrReturn(CheckConstraintType("minHeatSetpointLimit", "", "int16"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<int16_t>("minHeatSetpointLimit", [value shortValue], 700));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<int16_t>("minHeatSetpointLimit", [value shortValue], 3000));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWritesAValueBackThatIsDifferentButValidForMinHeatSetpointLimitAttribute_12()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id minHeatSetpointLimitArgument;
        minHeatSetpointLimitArgument = [NSNumber numberWithShort:2000];
        [cluster writeAttributeMinHeatSetpointLimitWithValue:minHeatSetpointLimitArgument
                                           completionHandler:^(NSError * _Nullable err) {
                                               NSLog(@"Writes a value back that is different but valid for MinHeatSetpointLimit "
                                                     @"attribute Error: %@",
                                                   err);

                                               VerifyOrReturn(CheckValue("status", err, 0));

                                               NextTest();
                                           }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsItBackAgainToConfirmTheSuccessfulWriteOfMinHeatSetpointLimitAttribute_13()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeMinHeatSetpointLimitWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads it back again to confirm the successful write of MinHeatSetpointLimit attribute Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("min heat setpoint limit", actualValue, 2000));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWritesTheLimitOfAbsMinHeatSetpointLimitToMinHeatSetpointLimitAttribute_14()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id minHeatSetpointLimitArgument;
        minHeatSetpointLimitArgument = [NSNumber numberWithShort:700];
        [cluster writeAttributeMinHeatSetpointLimitWithValue:minHeatSetpointLimitArgument
                                           completionHandler:^(NSError * _Nullable err) {
                                               NSLog(@"Writes the limit of AbsMinHeatSetpointLimit to MinHeatSetpointLimit "
                                                     @"attribute Error: %@",
                                                   err);

                                               VerifyOrReturn(CheckValue("status", err, 0));

                                               NextTest();
                                           }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWritesTheLimitOfAbsMaxHeatSetpointLimitToMinHeatSetpointLimitAttribute_15()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id minHeatSetpointLimitArgument;
        minHeatSetpointLimitArgument = [NSNumber numberWithShort:3000];
        [cluster writeAttributeMinHeatSetpointLimitWithValue:minHeatSetpointLimitArgument
                                           completionHandler:^(NSError * _Nullable err) {
                                               NSLog(@"Writes the limit of AbsMaxHeatSetpointLimit to MinHeatSetpointLimit "
                                                     @"attribute Error: %@",
                                                   err);

                                               VerifyOrReturn(CheckValue("status", err, 0));

                                               NextTest();
                                           }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsMaxHeatSetpointLimitAttributeFromServerDutAndVerifiesThatTheValueIsWithinRange_16()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeMaxHeatSetpointLimitWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(
                @"Reads MaxHeatSetpointLimit attribute from Server DUT and verifies that the value is within range Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("max heat setpoint limit", actualValue, 3000));
            }

            VerifyOrReturn(CheckConstraintType("maxHeatSetpointLimit", "", "int16"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<int16_t>("maxHeatSetpointLimit", [value shortValue], 700));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<int16_t>("maxHeatSetpointLimit", [value shortValue], 3000));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWritesAValueBackThatIsDifferentButValidForMaxHeatSetpointLimitAttribute_17()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id maxHeatSetpointLimitArgument;
        maxHeatSetpointLimitArgument = [NSNumber numberWithShort:2000];
        [cluster writeAttributeMaxHeatSetpointLimitWithValue:maxHeatSetpointLimitArgument
                                           completionHandler:^(NSError * _Nullable err) {
                                               NSLog(@"Writes a value back that is different but valid for MaxHeatSetpointLimit "
                                                     @"attribute Error: %@",
                                                   err);

                                               VerifyOrReturn(CheckValue("status", err, 0));

                                               NextTest();
                                           }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsItBackAgainToConfirmTheSuccessfulWriteOfMaxHeatSetpointLimitAttribute_18()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeMaxHeatSetpointLimitWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads it back again to confirm the successful write of MaxHeatSetpointLimit attribute Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("max heat setpoint limit", actualValue, 2000));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWritesTheLimitOfAbsMinHeatSetpointLimitToMaxHeatSetpointLimitAttribute_19()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id maxHeatSetpointLimitArgument;
        maxHeatSetpointLimitArgument = [NSNumber numberWithShort:700];
        [cluster writeAttributeMaxHeatSetpointLimitWithValue:maxHeatSetpointLimitArgument
                                           completionHandler:^(NSError * _Nullable err) {
                                               NSLog(@"Writes the limit of AbsMinHeatSetpointLimit to MaxHeatSetpointLimit "
                                                     @"attribute Error: %@",
                                                   err);

                                               VerifyOrReturn(CheckValue("status", err, 0));

                                               NextTest();
                                           }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWritesTheLimitOfAbsMaxHeatSetpointLimitToMaxHeatSetpointLimitAttribute_20()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id maxHeatSetpointLimitArgument;
        maxHeatSetpointLimitArgument = [NSNumber numberWithShort:3000];
        [cluster writeAttributeMaxHeatSetpointLimitWithValue:maxHeatSetpointLimitArgument
                                           completionHandler:^(NSError * _Nullable err) {
                                               NSLog(@"Writes the limit of AbsMaxHeatSetpointLimit to MaxHeatSetpointLimit "
                                                     @"attribute Error: %@",
                                                   err);

                                               VerifyOrReturn(CheckValue("status", err, 0));

                                               NextTest();
                                           }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsMinCoolSetpointLimitAttributeFromServerDutAndVerifiesThatTheValueIsWithinRange_21()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeMinCoolSetpointLimitWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(
                @"Reads MinCoolSetpointLimit attribute from Server DUT and verifies that the value is within range Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("min cool setpoint limit", actualValue, 1600));
            }

            VerifyOrReturn(CheckConstraintType("minCoolSetpointLimit", "", "int16"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<int16_t>("minCoolSetpointLimit", [value shortValue], 1600));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<int16_t>("minCoolSetpointLimit", [value shortValue], 3200));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWritesAValueBackThatIsDifferentButValidForMinCoolSetpointLimitAttribute_22()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id minCoolSetpointLimitArgument;
        minCoolSetpointLimitArgument = [NSNumber numberWithShort:2000];
        [cluster writeAttributeMinCoolSetpointLimitWithValue:minCoolSetpointLimitArgument
                                           completionHandler:^(NSError * _Nullable err) {
                                               NSLog(@"Writes a value back that is different but valid for MinCoolSetpointLimit "
                                                     @"attribute Error: %@",
                                                   err);

                                               VerifyOrReturn(CheckValue("status", err, 0));

                                               NextTest();
                                           }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsItBackAgainToConfirmTheSuccessfulWriteOfMinCoolSetpointLimitAttribute_23()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeMinCoolSetpointLimitWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads it back again to confirm the successful write of MinCoolSetpointLimit attribute Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("min cool setpoint limit", actualValue, 2000));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWritesTheLimitOfAbsMinCoolSetpointLimitToMinCoolSetpointLimitAttribute_24()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id minCoolSetpointLimitArgument;
        minCoolSetpointLimitArgument = [NSNumber numberWithShort:1600];
        [cluster writeAttributeMinCoolSetpointLimitWithValue:minCoolSetpointLimitArgument
                                           completionHandler:^(NSError * _Nullable err) {
                                               NSLog(@"Writes the limit of AbsMinCoolSetpointLimit to MinCoolSetpointLimit "
                                                     @"attribute Error: %@",
                                                   err);

                                               VerifyOrReturn(CheckValue("status", err, 0));

                                               NextTest();
                                           }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWritesTheLimitOfMaxCoolSetpointLimitToMinCoolSetpointLimitAttribute_25()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id minCoolSetpointLimitArgument;
        minCoolSetpointLimitArgument = [NSNumber numberWithShort:3200];
        [cluster writeAttributeMinCoolSetpointLimitWithValue:minCoolSetpointLimitArgument
                                           completionHandler:^(NSError * _Nullable err) {
                                               NSLog(@"Writes the limit of MaxCoolSetpointLimit to MinCoolSetpointLimit attribute "
                                                     @"Error: %@",
                                                   err);

                                               VerifyOrReturn(CheckValue("status", err, 0));

                                               NextTest();
                                           }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsMaxCoolSetpointLimitAttributeFromServerDutAndVerifiesThatTheValueIsWithinRange_26()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeMaxCoolSetpointLimitWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(
                @"Reads MaxCoolSetpointLimit attribute from Server DUT and verifies that the value is within range Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("max cool setpoint limit", actualValue, 3200));
            }

            VerifyOrReturn(CheckConstraintType("maxCoolSetpointLimit", "", "int16"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<int16_t>("maxCoolSetpointLimit", [value shortValue], 1600));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<int16_t>("maxCoolSetpointLimit", [value shortValue], 3200));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWritesAValueBackThatIsDifferentButValidForMaxCoolSetpointLimitAttribute_27()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id maxCoolSetpointLimitArgument;
        maxCoolSetpointLimitArgument = [NSNumber numberWithShort:2000];
        [cluster writeAttributeMaxCoolSetpointLimitWithValue:maxCoolSetpointLimitArgument
                                           completionHandler:^(NSError * _Nullable err) {
                                               NSLog(@"Writes a value back that is different but valid for MaxCoolSetpointLimit "
                                                     @"attribute Error: %@",
                                                   err);

                                               VerifyOrReturn(CheckValue("status", err, 0));

                                               NextTest();
                                           }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsItBackAgainToConfirmTheSuccessfulWriteOfMaxCoolSetpointLimitAttribute_28()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeMaxCoolSetpointLimitWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads it back again to confirm the successful write of MaxCoolSetpointLimit attribute Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("max cool setpoint limit", actualValue, 2000));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWritesTheLimitOfAbsMinCoolSetpointLimitToMaxCoolSetpointLimitAttribute_29()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id maxCoolSetpointLimitArgument;
        maxCoolSetpointLimitArgument = [NSNumber numberWithShort:1600];
        [cluster writeAttributeMaxCoolSetpointLimitWithValue:maxCoolSetpointLimitArgument
                                           completionHandler:^(NSError * _Nullable err) {
                                               NSLog(@"Writes the limit of AbsMinCoolSetpointLimit to MaxCoolSetpointLimit "
                                                     @"attribute Error: %@",
                                                   err);

                                               VerifyOrReturn(CheckValue("status", err, 0));

                                               NextTest();
                                           }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWritesTheLimitOfMaxCoolSetpointLimitToMaxCoolSetpointLimitAttribute_30()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id maxCoolSetpointLimitArgument;
        maxCoolSetpointLimitArgument = [NSNumber numberWithShort:3200];
        [cluster writeAttributeMaxCoolSetpointLimitWithValue:maxCoolSetpointLimitArgument
                                           completionHandler:^(NSError * _Nullable err) {
                                               NSLog(@"Writes the limit of MaxCoolSetpointLimit to MaxCoolSetpointLimit attribute "
                                                     @"Error: %@",
                                                   err);

                                               VerifyOrReturn(CheckValue("status", err, 0));

                                               NextTest();
                                           }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWritesSetsBackTheLimitOfMinHeatSetpointLimitToMinHeatSetpointLimitAttribute_31()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id minHeatSetpointLimitArgument;
        minHeatSetpointLimitArgument = [NSNumber numberWithShort:700];
        [cluster writeAttributeMinHeatSetpointLimitWithValue:minHeatSetpointLimitArgument
                                           completionHandler:^(NSError * _Nullable err) {
                                               NSLog(@"Writes (sets back) the limit of MinHeatSetpointLimit to "
                                                     @"MinHeatSetpointLimit attribute Error: %@",
                                                   err);

                                               VerifyOrReturn(CheckValue("status", err, 0));

                                               NextTest();
                                           }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWritesSetsBackTheLimitOfMaxHeatSetpointLimitToMinHeatSetpointLimitAttribute_32()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id minHeatSetpointLimitArgument;
        minHeatSetpointLimitArgument = [NSNumber numberWithShort:3000];
        [cluster writeAttributeMinHeatSetpointLimitWithValue:minHeatSetpointLimitArgument
                                           completionHandler:^(NSError * _Nullable err) {
                                               NSLog(@"Writes (sets back) the limit of MaxHeatSetpointLimit to "
                                                     @"MinHeatSetpointLimit attribute Error: %@",
                                                   err);

                                               VerifyOrReturn(CheckValue("status", err, 0));

                                               NextTest();
                                           }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWritesSetsBackTheLimitOfMinHeatSetpointLimitToMaxHeatSetpointLimitAttribute_33()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id maxHeatSetpointLimitArgument;
        maxHeatSetpointLimitArgument = [NSNumber numberWithShort:700];
        [cluster writeAttributeMaxHeatSetpointLimitWithValue:maxHeatSetpointLimitArgument
                                           completionHandler:^(NSError * _Nullable err) {
                                               NSLog(@"Writes (sets back) the limit of MinHeatSetpointLimit to "
                                                     @"MaxHeatSetpointLimit attribute Error: %@",
                                                   err);

                                               VerifyOrReturn(CheckValue("status", err, 0));

                                               NextTest();
                                           }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWritesSetsBackTheLimitOfMaxHeatSetpointLimitToMaxHeatSetpointLimitAttribute_34()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id maxHeatSetpointLimitArgument;
        maxHeatSetpointLimitArgument = [NSNumber numberWithShort:3000];
        [cluster writeAttributeMaxHeatSetpointLimitWithValue:maxHeatSetpointLimitArgument
                                           completionHandler:^(NSError * _Nullable err) {
                                               NSLog(@"Writes (sets back) the limit of MaxHeatSetpointLimit to "
                                                     @"MaxHeatSetpointLimit attribute Error: %@",
                                                   err);

                                               VerifyOrReturn(CheckValue("status", err, 0));

                                               NextTest();
                                           }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWritesSetsBackTheLimitOfMinCoolSetpointLimitToMinCoolSetpointLimitAttribute_35()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id minCoolSetpointLimitArgument;
        minCoolSetpointLimitArgument = [NSNumber numberWithShort:1600];
        [cluster writeAttributeMinCoolSetpointLimitWithValue:minCoolSetpointLimitArgument
                                           completionHandler:^(NSError * _Nullable err) {
                                               NSLog(@"Writes (sets back) the limit of MinCoolSetpointLimit to "
                                                     @"MinCoolSetpointLimit attribute Error: %@",
                                                   err);

                                               VerifyOrReturn(CheckValue("status", err, 0));

                                               NextTest();
                                           }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWritesSetsBackTheLimitOfMaxCoolSetpointLimitToMinCoolSetpointLimitAttribute_36()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id minCoolSetpointLimitArgument;
        minCoolSetpointLimitArgument = [NSNumber numberWithShort:3200];
        [cluster writeAttributeMinCoolSetpointLimitWithValue:minCoolSetpointLimitArgument
                                           completionHandler:^(NSError * _Nullable err) {
                                               NSLog(@"Writes (sets back) the limit of MaxCoolSetpointLimit to "
                                                     @"MinCoolSetpointLimit attribute Error: %@",
                                                   err);

                                               VerifyOrReturn(CheckValue("status", err, 0));

                                               NextTest();
                                           }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWritesSetsBackTheLimitOfMinCoolSetpointLimitToMaxCoolSetpointLimitAttribute_37()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id maxCoolSetpointLimitArgument;
        maxCoolSetpointLimitArgument = [NSNumber numberWithShort:1600];
        [cluster writeAttributeMaxCoolSetpointLimitWithValue:maxCoolSetpointLimitArgument
                                           completionHandler:^(NSError * _Nullable err) {
                                               NSLog(@"Writes (sets back) the limit of MinCoolSetpointLimit to "
                                                     @"MaxCoolSetpointLimit attribute Error: %@",
                                                   err);

                                               VerifyOrReturn(CheckValue("status", err, 0));

                                               NextTest();
                                           }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWritesSetsBackTheLimitOfMaxCoolSetpointLimitToMaxCoolSetpointLimitAttribute_38()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id maxCoolSetpointLimitArgument;
        maxCoolSetpointLimitArgument = [NSNumber numberWithShort:3200];
        [cluster writeAttributeMaxCoolSetpointLimitWithValue:maxCoolSetpointLimitArgument
                                           completionHandler:^(NSError * _Nullable err) {
                                               NSLog(@"Writes (sets back) the limit of MaxCoolSetpointLimit to "
                                                     @"MaxCoolSetpointLimit attribute Error: %@",
                                                   err);

                                               VerifyOrReturn(CheckValue("status", err, 0));

                                               NextTest();
                                           }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsControlSequenceOfOperationFromServerDutAndVerifiesThatTheValueIsValid_39()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster
            readAttributeControlSequenceOfOperationWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
                NSLog(@"Reads ControlSequenceOfOperation from Server DUT and verifies that the value is valid Error: %@", err);

                VerifyOrReturn(CheckValue("status", err, 0));

                {
                    id actualValue = value;
                    VerifyOrReturn(CheckValue("control sequence of operation", actualValue, 4));
                }

                VerifyOrReturn(CheckConstraintType("controlSequenceOfOperation", "", "enum8"));
                if (value != nil) {
                    VerifyOrReturn(CheckConstraintMinValue<uint8_t>("controlSequenceOfOperation", [value unsignedCharValue], 0));
                }
                if (value != nil) {
                    VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("controlSequenceOfOperation", [value unsignedCharValue], 5));
                }

                NextTest();
            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeCommandForControlSequenceOfOperationWithANewValidValue_40()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id controlSequenceOfOperationArgument;
        controlSequenceOfOperationArgument = [NSNumber numberWithUnsignedChar:2];
        [cluster writeAttributeControlSequenceOfOperationWithValue:controlSequenceOfOperationArgument
                                                 completionHandler:^(NSError * _Nullable err) {
                                                     NSLog(@"Write Attribute command for ControlSequenceOfOperation with a new "
                                                           @"valid value Error: %@",
                                                         err);

                                                     VerifyOrReturn(CheckValue("status", err, 0));

                                                     NextTest();
                                                 }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadItBackAgainToConfirmTheSuccessfulWrite_41()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster
            readAttributeControlSequenceOfOperationWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
                NSLog(@"Read it back again to confirm the successful write Error: %@", err);

                VerifyOrReturn(CheckValue("status", err, 0));

                {
                    id actualValue = value;
                    VerifyOrReturn(CheckValue("control sequence of operation", actualValue, 2));
                }

                NextTest();
            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSetsOccupiedHeatingSetpointToDefaultValue_42()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id occupiedHeatingSetpointArgument;
        occupiedHeatingSetpointArgument = [NSNumber numberWithShort:2000];
        [cluster writeAttributeOccupiedHeatingSetpointWithValue:occupiedHeatingSetpointArgument
                                              completionHandler:^(NSError * _Nullable err) {
                                                  NSLog(@"Sets OccupiedHeatingSetpoint to default value Error: %@", err);

                                                  VerifyOrReturn(CheckValue("status", err, 0));

                                                  NextTest();
                                              }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSetsOccupiedHeatingSetpointToDefaultValue_43()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id occupiedHeatingSetpointArgument;
        occupiedHeatingSetpointArgument = [NSNumber numberWithShort:2000];
        [cluster writeAttributeOccupiedHeatingSetpointWithValue:occupiedHeatingSetpointArgument
                                              completionHandler:^(NSError * _Nullable err) {
                                                  NSLog(@"Sets OccupiedHeatingSetpoint to default value Error: %@", err);

                                                  VerifyOrReturn(CheckValue("status", err, 0));

                                                  NextTest();
                                              }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSetsOccupiedCoolingSetpointToDefaultValue_44()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id occupiedCoolingSetpointArgument;
        occupiedCoolingSetpointArgument = [NSNumber numberWithShort:2600];
        [cluster writeAttributeOccupiedCoolingSetpointWithValue:occupiedCoolingSetpointArgument
                                              completionHandler:^(NSError * _Nullable err) {
                                                  NSLog(@"Sets OccupiedCoolingSetpoint to default value Error: %@", err);

                                                  VerifyOrReturn(CheckValue("status", err, 0));

                                                  NextTest();
                                              }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSetsOccupiedCoolingSetpointToDefaultValue_45()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id occupiedCoolingSetpointArgument;
        occupiedCoolingSetpointArgument = [NSNumber numberWithShort:2600];
        [cluster writeAttributeOccupiedCoolingSetpointWithValue:occupiedCoolingSetpointArgument
                                              completionHandler:^(NSError * _Nullable err) {
                                                  NSLog(@"Sets OccupiedCoolingSetpoint to default value Error: %@", err);

                                                  VerifyOrReturn(CheckValue("status", err, 0));

                                                  NextTest();
                                              }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSetsOccupiedCoolingSetpointToDefaultValue_46()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id occupiedCoolingSetpointArgument;
        occupiedCoolingSetpointArgument = [NSNumber numberWithShort:2600];
        [cluster writeAttributeOccupiedCoolingSetpointWithValue:occupiedCoolingSetpointArgument
                                              completionHandler:^(NSError * _Nullable err) {
                                                  NSLog(@"Sets OccupiedCoolingSetpoint to default value Error: %@", err);

                                                  VerifyOrReturn(CheckValue("status", err, 0));

                                                  NextTest();
                                              }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSetsOccupiedHeatingSetpointToDefaultValue_47()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id occupiedHeatingSetpointArgument;
        occupiedHeatingSetpointArgument = [NSNumber numberWithShort:2000];
        [cluster writeAttributeOccupiedHeatingSetpointWithValue:occupiedHeatingSetpointArgument
                                              completionHandler:^(NSError * _Nullable err) {
                                                  NSLog(@"Sets OccupiedHeatingSetpoint to default value Error: %@", err);

                                                  VerifyOrReturn(CheckValue("status", err, 0));

                                                  NextTest();
                                              }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSetsOccupiedCoolingSetpointToDefaultValue_48()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id occupiedCoolingSetpointArgument;
        occupiedCoolingSetpointArgument = [NSNumber numberWithShort:2600];
        [cluster writeAttributeOccupiedCoolingSetpointWithValue:occupiedCoolingSetpointArgument
                                              completionHandler:^(NSError * _Nullable err) {
                                                  NSLog(@"Sets OccupiedCoolingSetpoint to default value Error: %@", err);

                                                  VerifyOrReturn(CheckValue("status", err, 0));

                                                  NextTest();
                                              }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSetsOccupiedHeatingSetpointToDefaultValue_49()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostat * cluster = [[CHIPTestThermostat alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id occupiedHeatingSetpointArgument;
        occupiedHeatingSetpointArgument = [NSNumber numberWithShort:2000];
        [cluster writeAttributeOccupiedHeatingSetpointWithValue:occupiedHeatingSetpointArgument
                                              completionHandler:^(NSError * _Nullable err) {
                                                  NSLog(@"Sets OccupiedHeatingSetpoint to default value Error: %@", err);

                                                  VerifyOrReturn(CheckValue("status", err, 0));

                                                  NextTest();
                                              }];

        return CHIP_NO_ERROR;
    }
};

class Test_TC_TSUIC_1_1 : public TestCommandBridge {
public:
    Test_TC_TSUIC_1_1()
        : TestCommandBridge("Test_TC_TSUIC_1_1")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_TSUIC_1_1() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_TSUIC_1_1\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_TSUIC_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read the global attribute constraints: ClusterRevision\n");
            err = TestReadTheGlobalAttributeConstraintsClusterRevision_1();
            break;
        case 2:
            ChipLogProgress(
                chipTool, " ***** Test Step 2 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read the global attribute: AttributeList\n");
            err = TestReadTheGlobalAttributeAttributeList_3();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 4;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheGlobalAttributeConstraintsClusterRevision_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostatUserInterfaceConfiguration * cluster =
            [[CHIPTestThermostatUserInterfaceConfiguration alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read the global attribute constraints: ClusterRevision Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("clusterRevision", "", "uint16"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostatUserInterfaceConfiguration * cluster =
            [[CHIPTestThermostatUserInterfaceConfiguration alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id clusterRevisionArgument;
        clusterRevisionArgument = [NSNumber numberWithUnsignedShort:2U];
        [cluster
            writeAttributeClusterRevisionWithValue:clusterRevisionArgument
                                 completionHandler:^(NSError * _Nullable err) {
                                     NSLog(
                                         @"write the default values to mandatory global attribute: ClusterRevision Error: %@", err);

                                     VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                                     NextTest();
                                 }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheGlobalAttributeAttributeList_3()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostatUserInterfaceConfiguration * cluster =
            [[CHIPTestThermostatUserInterfaceConfiguration alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read the global attribute: AttributeList Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("attributeList", "", "list"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
};

class Test_TC_TSUIC_2_1 : public TestCommandBridge {
public:
    Test_TC_TSUIC_2_1()
        : TestCommandBridge("Test_TC_TSUIC_2_1")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_TSUIC_2_1() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_TSUIC_2_1\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_TSUIC_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : read the mandatory attribute: TemperatureDisplayMode\n");
            err = TestReadTheMandatoryAttributeTemperatureDisplayMode_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : read the mandatory attribute: TemperatureDisplayMode\n");
            err = TestReadTheMandatoryAttributeTemperatureDisplayMode_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : write to the mandatory attribute: TemperatureDisplayMode\n");
            err = TestWriteToTheMandatoryAttributeTemperatureDisplayMode_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : read the mandatory attribute: TemperatureDisplayMode\n");
            err = TestReadTheMandatoryAttributeTemperatureDisplayMode_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : read the mandatory attribute: TemperatureDisplayMode\n");
            err = TestReadTheMandatoryAttributeTemperatureDisplayMode_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : read the mandatory attribute: KeypadLockout\n");
            err = TestReadTheMandatoryAttributeKeypadLockout_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : read the mandatory attribute: KeypadLockout\n");
            err = TestReadTheMandatoryAttributeKeypadLockout_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : write to the mandatory attribute: KeypadLockout\n");
            err = TestWriteToTheMandatoryAttributeKeypadLockout_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : read the mandatory attribute: KeypadLockout\n");
            err = TestReadTheMandatoryAttributeKeypadLockout_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : read the mandatory attribute: KeypadLockout\n");
            err = TestReadTheMandatoryAttributeKeypadLockout_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : read the optional attribute: ScheduleProgrammingVisibility\n");
            err = TestReadTheOptionalAttributeScheduleProgrammingVisibility_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : read the optional attribute: ScheduleProgrammingVisibility\n");
            err = TestReadTheOptionalAttributeScheduleProgrammingVisibility_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : write to the mandatory attribute: ScheduleProgrammingVisibility\n");
            err = TestWriteToTheMandatoryAttributeScheduleProgrammingVisibility_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : read the optional attribute: ScheduleProgrammingVisibility\n");
            err = TestReadTheOptionalAttributeScheduleProgrammingVisibility_14();
            break;
        case 15:
            ChipLogProgress(chipTool, " ***** Test Step 15 : read the optional attribute: ScheduleProgrammingVisibility\n");
            err = TestReadTheOptionalAttributeScheduleProgrammingVisibility_15();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 16;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheMandatoryAttributeTemperatureDisplayMode_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostatUserInterfaceConfiguration * cluster =
            [[CHIPTestThermostatUserInterfaceConfiguration alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeTemperatureDisplayModeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read the mandatory attribute: TemperatureDisplayMode Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("temperature display mode", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheMandatoryAttributeTemperatureDisplayMode_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostatUserInterfaceConfiguration * cluster =
            [[CHIPTestThermostatUserInterfaceConfiguration alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeTemperatureDisplayModeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read the mandatory attribute: TemperatureDisplayMode Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("temperatureDisplayMode", "", "enum8"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteToTheMandatoryAttributeTemperatureDisplayMode_3()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostatUserInterfaceConfiguration * cluster =
            [[CHIPTestThermostatUserInterfaceConfiguration alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id temperatureDisplayModeArgument;
        temperatureDisplayModeArgument = [NSNumber numberWithUnsignedChar:0];
        [cluster writeAttributeTemperatureDisplayModeWithValue:temperatureDisplayModeArgument
                                             completionHandler:^(NSError * _Nullable err) {
                                                 NSLog(@"write to the mandatory attribute: TemperatureDisplayMode Error: %@", err);

                                                 VerifyOrReturn(CheckValue("status", err, 0));

                                                 NextTest();
                                             }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheMandatoryAttributeTemperatureDisplayMode_4()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostatUserInterfaceConfiguration * cluster =
            [[CHIPTestThermostatUserInterfaceConfiguration alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeTemperatureDisplayModeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read the mandatory attribute: TemperatureDisplayMode Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("temperature display mode", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheMandatoryAttributeTemperatureDisplayMode_5()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostatUserInterfaceConfiguration * cluster =
            [[CHIPTestThermostatUserInterfaceConfiguration alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeTemperatureDisplayModeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read the mandatory attribute: TemperatureDisplayMode Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("temperatureDisplayMode", "", "enum8"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheMandatoryAttributeKeypadLockout_6()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostatUserInterfaceConfiguration * cluster =
            [[CHIPTestThermostatUserInterfaceConfiguration alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeKeypadLockoutWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read the mandatory attribute: KeypadLockout Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("keypad lockout", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheMandatoryAttributeKeypadLockout_7()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostatUserInterfaceConfiguration * cluster =
            [[CHIPTestThermostatUserInterfaceConfiguration alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeKeypadLockoutWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read the mandatory attribute: KeypadLockout Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("keypadLockout", "", "enum8"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteToTheMandatoryAttributeKeypadLockout_8()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostatUserInterfaceConfiguration * cluster =
            [[CHIPTestThermostatUserInterfaceConfiguration alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id keypadLockoutArgument;
        keypadLockoutArgument = [NSNumber numberWithUnsignedChar:0];
        [cluster writeAttributeKeypadLockoutWithValue:keypadLockoutArgument
                                    completionHandler:^(NSError * _Nullable err) {
                                        NSLog(@"write to the mandatory attribute: KeypadLockout Error: %@", err);

                                        VerifyOrReturn(CheckValue("status", err, 0));

                                        NextTest();
                                    }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheMandatoryAttributeKeypadLockout_9()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostatUserInterfaceConfiguration * cluster =
            [[CHIPTestThermostatUserInterfaceConfiguration alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeKeypadLockoutWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read the mandatory attribute: KeypadLockout Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("keypad lockout", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheMandatoryAttributeKeypadLockout_10()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostatUserInterfaceConfiguration * cluster =
            [[CHIPTestThermostatUserInterfaceConfiguration alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeKeypadLockoutWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read the mandatory attribute: KeypadLockout Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("keypadLockout", "", "enum8"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheOptionalAttributeScheduleProgrammingVisibility_11()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostatUserInterfaceConfiguration * cluster =
            [[CHIPTestThermostatUserInterfaceConfiguration alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster
            readAttributeScheduleProgrammingVisibilityWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
                NSLog(@"read the optional attribute: ScheduleProgrammingVisibility Error: %@", err);

                VerifyOrReturn(CheckValue("status", err, 0));

                {
                    id actualValue = value;
                    VerifyOrReturn(CheckValue("schedule programming visibility", actualValue, 0));
                }

                NextTest();
            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheOptionalAttributeScheduleProgrammingVisibility_12()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostatUserInterfaceConfiguration * cluster =
            [[CHIPTestThermostatUserInterfaceConfiguration alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster
            readAttributeScheduleProgrammingVisibilityWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
                NSLog(@"read the optional attribute: ScheduleProgrammingVisibility Error: %@", err);

                VerifyOrReturn(CheckValue("status", err, 0));

                VerifyOrReturn(CheckConstraintType("scheduleProgrammingVisibility", "", "enum8"));
                NextTest();
            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteToTheMandatoryAttributeScheduleProgrammingVisibility_13()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostatUserInterfaceConfiguration * cluster =
            [[CHIPTestThermostatUserInterfaceConfiguration alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id scheduleProgrammingVisibilityArgument;
        scheduleProgrammingVisibilityArgument = [NSNumber numberWithUnsignedChar:0];
        [cluster
            writeAttributeScheduleProgrammingVisibilityWithValue:scheduleProgrammingVisibilityArgument
                                               completionHandler:^(NSError * _Nullable err) {
                                                   NSLog(
                                                       @"write to the mandatory attribute: ScheduleProgrammingVisibility Error: %@",
                                                       err);

                                                   VerifyOrReturn(CheckValue("status", err, 0));

                                                   NextTest();
                                               }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheOptionalAttributeScheduleProgrammingVisibility_14()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostatUserInterfaceConfiguration * cluster =
            [[CHIPTestThermostatUserInterfaceConfiguration alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster
            readAttributeScheduleProgrammingVisibilityWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
                NSLog(@"read the optional attribute: ScheduleProgrammingVisibility Error: %@", err);

                VerifyOrReturn(CheckValue("status", err, 0));

                {
                    id actualValue = value;
                    VerifyOrReturn(CheckValue("schedule programming visibility", actualValue, 0));
                }

                NextTest();
            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheOptionalAttributeScheduleProgrammingVisibility_15()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostatUserInterfaceConfiguration * cluster =
            [[CHIPTestThermostatUserInterfaceConfiguration alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster
            readAttributeScheduleProgrammingVisibilityWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
                NSLog(@"read the optional attribute: ScheduleProgrammingVisibility Error: %@", err);

                VerifyOrReturn(CheckValue("status", err, 0));

                VerifyOrReturn(CheckConstraintType("scheduleProgrammingVisibility", "", "enum8"));
                NextTest();
            }];

        return CHIP_NO_ERROR;
    }
};

class Test_TC_TSUIC_2_2 : public TestCommandBridge {
public:
    Test_TC_TSUIC_2_2()
        : TestCommandBridge("Test_TC_TSUIC_2_2")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_TSUIC_2_2() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_TSUIC_2_2\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_TSUIC_2_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Writes a value of 0 to TemperatureDisplayMode attribute of DUT\n");
            if (ShouldSkip("A_TEMPERATURE_DISPLAY_MODE")) {
                NextTest();
                return;
            }
            err = TestWritesAValueOf0ToTemperatureDisplayModeAttributeOfDut_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Writes a value of 1 to TemperatureDisplayMode attribute of DUT\n");
            if (ShouldSkip("A_TEMPERATURE_DISPLAY_MODE")) {
                NextTest();
                return;
            }
            err = TestWritesAValueOf1ToTemperatureDisplayModeAttributeOfDut_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Writes a value of 0 to KeypadLockout attribute of DUT\n");
            if (ShouldSkip("A_KEYPAD_LOCKOUT")) {
                NextTest();
                return;
            }
            err = TestWritesAValueOf0ToKeypadLockoutAttributeOfDut_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Writes a value of 1 to KeypadLockout attribute of DUT\n");
            if (ShouldSkip("A_KEYPAD_LOCKOUT")) {
                NextTest();
                return;
            }
            err = TestWritesAValueOf1ToKeypadLockoutAttributeOfDut_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Writes a value of 2 to KeypadLockout attribute of DUT\n");
            if (ShouldSkip("A_KEYPAD_LOCKOUT")) {
                NextTest();
                return;
            }
            err = TestWritesAValueOf2ToKeypadLockoutAttributeOfDut_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Writes a value of 3 to KeypadLockout attribute of DUT\n");
            if (ShouldSkip("A_KEYPAD_LOCKOUT")) {
                NextTest();
                return;
            }
            err = TestWritesAValueOf3ToKeypadLockoutAttributeOfDut_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Writes a value of 4 to KeypadLockout attribute of DUT\n");
            if (ShouldSkip("A_KEYPAD_LOCKOUT")) {
                NextTest();
                return;
            }
            err = TestWritesAValueOf4ToKeypadLockoutAttributeOfDut_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Writes a value of 5 to KeypadLockout attribute of DUT\n");
            if (ShouldSkip("A_KEYPAD_LOCKOUT")) {
                NextTest();
                return;
            }
            err = TestWritesAValueOf5ToKeypadLockoutAttributeOfDut_8();
            break;
        case 9:
            ChipLogProgress(
                chipTool, " ***** Test Step 9 : Writes a value of 0 to ScheduleProgrammingVisibility attribute of DUT\n");
            if (ShouldSkip("A_SCHEDULE_PROGRAMMING_VISIBILITY")) {
                NextTest();
                return;
            }
            err = TestWritesAValueOf0ToScheduleProgrammingVisibilityAttributeOfDut_9();
            break;
        case 10:
            ChipLogProgress(
                chipTool, " ***** Test Step 10 : Writes a value of 1 to ScheduleProgrammingVisibility attribute of DUT\n");
            if (ShouldSkip("A_SCHEDULE_PROGRAMMING_VISIBILITY")) {
                NextTest();
                return;
            }
            err = TestWritesAValueOf1ToScheduleProgrammingVisibilityAttributeOfDut_10();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 11;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWritesAValueOf0ToTemperatureDisplayModeAttributeOfDut_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostatUserInterfaceConfiguration * cluster =
            [[CHIPTestThermostatUserInterfaceConfiguration alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id temperatureDisplayModeArgument;
        temperatureDisplayModeArgument = [NSNumber numberWithUnsignedChar:0];
        [cluster
            writeAttributeTemperatureDisplayModeWithValue:temperatureDisplayModeArgument
                                        completionHandler:^(NSError * _Nullable err) {
                                            NSLog(@"Writes a value of 0 to TemperatureDisplayMode attribute of DUT Error: %@", err);

                                            VerifyOrReturn(CheckValue("status", err, 0));

                                            NextTest();
                                        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWritesAValueOf1ToTemperatureDisplayModeAttributeOfDut_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostatUserInterfaceConfiguration * cluster =
            [[CHIPTestThermostatUserInterfaceConfiguration alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id temperatureDisplayModeArgument;
        temperatureDisplayModeArgument = [NSNumber numberWithUnsignedChar:1];
        [cluster
            writeAttributeTemperatureDisplayModeWithValue:temperatureDisplayModeArgument
                                        completionHandler:^(NSError * _Nullable err) {
                                            NSLog(@"Writes a value of 1 to TemperatureDisplayMode attribute of DUT Error: %@", err);

                                            VerifyOrReturn(CheckValue("status", err, 0));

                                            NextTest();
                                        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWritesAValueOf0ToKeypadLockoutAttributeOfDut_3()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostatUserInterfaceConfiguration * cluster =
            [[CHIPTestThermostatUserInterfaceConfiguration alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id keypadLockoutArgument;
        keypadLockoutArgument = [NSNumber numberWithUnsignedChar:0];
        [cluster writeAttributeKeypadLockoutWithValue:keypadLockoutArgument
                                    completionHandler:^(NSError * _Nullable err) {
                                        NSLog(@"Writes a value of 0 to KeypadLockout attribute of DUT Error: %@", err);

                                        VerifyOrReturn(CheckValue("status", err, 0));

                                        NextTest();
                                    }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWritesAValueOf1ToKeypadLockoutAttributeOfDut_4()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostatUserInterfaceConfiguration * cluster =
            [[CHIPTestThermostatUserInterfaceConfiguration alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id keypadLockoutArgument;
        keypadLockoutArgument = [NSNumber numberWithUnsignedChar:1];
        [cluster writeAttributeKeypadLockoutWithValue:keypadLockoutArgument
                                    completionHandler:^(NSError * _Nullable err) {
                                        NSLog(@"Writes a value of 1 to KeypadLockout attribute of DUT Error: %@", err);

                                        VerifyOrReturn(CheckValue("status", err, 0));

                                        NextTest();
                                    }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWritesAValueOf2ToKeypadLockoutAttributeOfDut_5()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostatUserInterfaceConfiguration * cluster =
            [[CHIPTestThermostatUserInterfaceConfiguration alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id keypadLockoutArgument;
        keypadLockoutArgument = [NSNumber numberWithUnsignedChar:2];
        [cluster writeAttributeKeypadLockoutWithValue:keypadLockoutArgument
                                    completionHandler:^(NSError * _Nullable err) {
                                        NSLog(@"Writes a value of 2 to KeypadLockout attribute of DUT Error: %@", err);

                                        VerifyOrReturn(CheckValue("status", err, 0));

                                        NextTest();
                                    }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWritesAValueOf3ToKeypadLockoutAttributeOfDut_6()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostatUserInterfaceConfiguration * cluster =
            [[CHIPTestThermostatUserInterfaceConfiguration alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id keypadLockoutArgument;
        keypadLockoutArgument = [NSNumber numberWithUnsignedChar:3];
        [cluster writeAttributeKeypadLockoutWithValue:keypadLockoutArgument
                                    completionHandler:^(NSError * _Nullable err) {
                                        NSLog(@"Writes a value of 3 to KeypadLockout attribute of DUT Error: %@", err);

                                        VerifyOrReturn(CheckValue("status", err, 0));

                                        NextTest();
                                    }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWritesAValueOf4ToKeypadLockoutAttributeOfDut_7()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostatUserInterfaceConfiguration * cluster =
            [[CHIPTestThermostatUserInterfaceConfiguration alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id keypadLockoutArgument;
        keypadLockoutArgument = [NSNumber numberWithUnsignedChar:4];
        [cluster writeAttributeKeypadLockoutWithValue:keypadLockoutArgument
                                    completionHandler:^(NSError * _Nullable err) {
                                        NSLog(@"Writes a value of 4 to KeypadLockout attribute of DUT Error: %@", err);

                                        VerifyOrReturn(CheckValue("status", err, 0));

                                        NextTest();
                                    }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWritesAValueOf5ToKeypadLockoutAttributeOfDut_8()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostatUserInterfaceConfiguration * cluster =
            [[CHIPTestThermostatUserInterfaceConfiguration alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id keypadLockoutArgument;
        keypadLockoutArgument = [NSNumber numberWithUnsignedChar:5];
        [cluster writeAttributeKeypadLockoutWithValue:keypadLockoutArgument
                                    completionHandler:^(NSError * _Nullable err) {
                                        NSLog(@"Writes a value of 5 to KeypadLockout attribute of DUT Error: %@", err);

                                        VerifyOrReturn(CheckValue("status", err, 0));

                                        NextTest();
                                    }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWritesAValueOf0ToScheduleProgrammingVisibilityAttributeOfDut_9()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostatUserInterfaceConfiguration * cluster =
            [[CHIPTestThermostatUserInterfaceConfiguration alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id scheduleProgrammingVisibilityArgument;
        scheduleProgrammingVisibilityArgument = [NSNumber numberWithUnsignedChar:0];
        [cluster writeAttributeScheduleProgrammingVisibilityWithValue:scheduleProgrammingVisibilityArgument
                                                    completionHandler:^(NSError * _Nullable err) {
                                                        NSLog(@"Writes a value of 0 to ScheduleProgrammingVisibility attribute of "
                                                              @"DUT Error: %@",
                                                            err);

                                                        VerifyOrReturn(CheckValue("status", err, 0));

                                                        NextTest();
                                                    }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWritesAValueOf1ToScheduleProgrammingVisibilityAttributeOfDut_10()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThermostatUserInterfaceConfiguration * cluster =
            [[CHIPTestThermostatUserInterfaceConfiguration alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id scheduleProgrammingVisibilityArgument;
        scheduleProgrammingVisibilityArgument = [NSNumber numberWithUnsignedChar:1];
        [cluster writeAttributeScheduleProgrammingVisibilityWithValue:scheduleProgrammingVisibilityArgument
                                                    completionHandler:^(NSError * _Nullable err) {
                                                        NSLog(@"Writes a value of 1 to ScheduleProgrammingVisibility attribute of "
                                                              @"DUT Error: %@",
                                                            err);

                                                        VerifyOrReturn(CheckValue("status", err, 0));

                                                        NextTest();
                                                    }];

        return CHIP_NO_ERROR;
    }
};

class Test_TC_DIAG_TH_NW_1_1 : public TestCommandBridge {
public:
    Test_TC_DIAG_TH_NW_1_1()
        : TestCommandBridge("Test_TC_DIAG_TH_NW_1_1")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_DIAG_TH_NW_1_1() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_DIAG_TH_NW_1_1\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_DIAG_TH_NW_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Sends ResetCounts command\n");
            err = TestSendsResetCountsCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read the Overruncount attribute\n");
            err = TestReadTheOverruncountAttribute_2();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 3;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSendsResetCountsCommand_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThreadNetworkDiagnostics * cluster = [[CHIPTestThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                                     endpoint:0
                                                                                                        queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster resetCountsWithCompletionHandler:^(NSError * _Nullable err) {
            NSLog(@"Sends ResetCounts command Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheOverruncountAttribute_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestThreadNetworkDiagnostics * cluster = [[CHIPTestThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                                     endpoint:0
                                                                                                        queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOverrunCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read the Overruncount attribute Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("OverrunCount", actualValue, 0ULL));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
};

class Test_TC_WIFIDIAG_1_1 : public TestCommandBridge {
public:
    Test_TC_WIFIDIAG_1_1()
        : TestCommandBridge("Test_TC_WIFIDIAG_1_1")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_WIFIDIAG_1_1() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_WIFIDIAG_1_1\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_WIFIDIAG_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Reads NetworkInterface structure attribute from DUT\n");
            err = TestReadsNetworkInterfaceStructureAttributeFromDut_1();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 2;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsNetworkInterfaceStructureAttributeFromDut_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestGeneralDiagnostics * cluster = [[CHIPTestGeneralDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:0
                                                                                            queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNetworkInterfacesWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads NetworkInterface structure attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("networkInterfaces", "", "list"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
};

class Test_TC_WIFIDIAG_3_1 : public TestCommandBridge {
public:
    Test_TC_WIFIDIAG_3_1()
        : TestCommandBridge("Test_TC_WIFIDIAG_3_1")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_WIFIDIAG_3_1() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_WIFIDIAG_3_1\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_WIFIDIAG_3_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }
};

class Test_TC_WNCV_1_1 : public TestCommandBridge {
public:
    Test_TC_WNCV_1_1()
        : TestCommandBridge("Test_TC_WNCV_1_1")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_WNCV_1_1() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_WNCV_1_1\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_WNCV_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : 2: read the global attribute: ClusterRevision\n");
            err = Test2ReadTheGlobalAttributeClusterRevision_1();
            break;
        case 2:
            ChipLogProgress(
                chipTool, " ***** Test Step 2 : 3a: write a value into the RO mandatory global attribute: ClusterRevision\n");
            err = Test3aWriteAValueIntoTheRoMandatoryGlobalAttributeClusterRevision_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : 3b: reads back global attribute: ClusterRevision\n");
            err = Test3bReadsBackGlobalAttributeClusterRevision_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Read the global attribute: AttributeList\n");
            err = TestReadTheGlobalAttributeAttributeList_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : 2: read the global attribute: FeatureMap\n");
            err = Test2ReadTheGlobalAttributeFeatureMap_5();
            break;
        case 6:
            ChipLogProgress(
                chipTool, " ***** Test Step 6 : 3a: write the default value to optional global attribute: FeatureMap\n");
            err = Test3aWriteTheDefaultValueToOptionalGlobalAttributeFeatureMap_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : 3b: reads back global attribute: FeatureMap\n");
            err = Test3bReadsBackGlobalAttributeFeatureMap_7();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 8;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR Test2ReadTheGlobalAttributeClusterRevision_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"2: read the global attribute: ClusterRevision Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("clusterRevision", "", "uint16"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("clusterRevision", [value unsignedShortValue], 5U));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("clusterRevision", [value unsignedShortValue], 200U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR Test3aWriteAValueIntoTheRoMandatoryGlobalAttributeClusterRevision_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id clusterRevisionArgument;
        clusterRevisionArgument = [NSNumber numberWithUnsignedShort:201U];
        [cluster
            writeAttributeClusterRevisionWithValue:clusterRevisionArgument
                                 completionHandler:^(NSError * _Nullable err) {
                                     NSLog(@"3a: write a value into the RO mandatory global attribute: ClusterRevision Error: %@",
                                         err);

                                     VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                                     NextTest();
                                 }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR Test3bReadsBackGlobalAttributeClusterRevision_3()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"3b: reads back global attribute: ClusterRevision Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("clusterRevision", "", "uint16"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintNotValue("clusterRevision", value, 201U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadTheGlobalAttributeAttributeList_4()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read the global attribute: AttributeList Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("attributeList", "", "list"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR Test2ReadTheGlobalAttributeFeatureMap_5()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeFeatureMapWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"2: read the global attribute: FeatureMap Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("featureMap", "", "uint32"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<uint32_t>("featureMap", [value unsignedIntValue], 0UL));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<uint32_t>("featureMap", [value unsignedIntValue], 32768UL));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR Test3aWriteTheDefaultValueToOptionalGlobalAttributeFeatureMap_6()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id featureMapArgument;
        featureMapArgument = [NSNumber numberWithUnsignedInt:32769UL];
        [cluster writeAttributeFeatureMapWithValue:featureMapArgument
                                 completionHandler:^(NSError * _Nullable err) {
                                     NSLog(@"3a: write the default value to optional global attribute: FeatureMap Error: %@", err);

                                     VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                                     NextTest();
                                 }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR Test3bReadsBackGlobalAttributeFeatureMap_7()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeFeatureMapWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"3b: reads back global attribute: FeatureMap Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("featureMap", "", "uint32"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintNotValue("featureMap", value, 32769UL));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
};

class Test_TC_WNCV_2_1 : public TestCommandBridge {
public:
    Test_TC_WNCV_2_1()
        : TestCommandBridge("Test_TC_WNCV_2_1")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_WNCV_2_1() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_WNCV_2_1\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_WNCV_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : 2: read the RO mandatory attribute default: Type\n");
            err = Test2ReadTheRoMandatoryAttributeDefaultType_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : 3a: write a value into the RO mandatory attribute: Type\n");
            err = Test3aWriteAValueIntoTheRoMandatoryAttributeType_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : 3b: reads back the RO mandatory attribute: Type\n");
            err = Test3bReadsBackTheRoMandatoryAttributeType_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : 2: read the RO mandatory attribute default: ConfigStatus\n");
            err = Test2ReadTheRoMandatoryAttributeDefaultConfigStatus_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : 3a: write a value into the RO mandatory attribute: ConfigStatus\n");
            err = Test3aWriteAValueIntoTheRoMandatoryAttributeConfigStatus_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : 3b: reads back the RO mandatory attribute: ConfigStatus\n");
            err = Test3bReadsBackTheRoMandatoryAttributeConfigStatus_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : 2: read the RO mandatory attribute default: OperationalStatus\n");
            err = Test2ReadTheRoMandatoryAttributeDefaultOperationalStatus_7();
            break;
        case 8:
            ChipLogProgress(
                chipTool, " ***** Test Step 8 : 3a: write a value into the RO mandatory attribute: OperationalStatus\n");
            err = Test3aWriteAValueIntoTheRoMandatoryAttributeOperationalStatus_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : 3b: reads back the RO mandatory attribute: OperationalStatus\n");
            err = Test3bReadsBackTheRoMandatoryAttributeOperationalStatus_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : 2: read the RO mandatory attribute default: EndProductType\n");
            err = Test2ReadTheRoMandatoryAttributeDefaultEndProductType_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : 3a: write a value into the RO mandatory attribute: EndProductType\n");
            err = Test3aWriteAValueIntoTheRoMandatoryAttributeEndProductType_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : 3b: reads back the RO mandatory attribute: EndProductType\n");
            err = Test3bReadsBackTheRoMandatoryAttributeEndProductType_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : 2: read the RW mandatory attribute default: Mode\n");
            err = Test2ReadTheRwMandatoryAttributeDefaultMode_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : 3a: write a value into the RW mandatory attribute:: Mode\n");
            err = Test3aWriteAValueIntoTheRwMandatoryAttributeMode_14();
            break;
        case 15:
            ChipLogProgress(chipTool, " ***** Test Step 15 : 3b: reads back the RW mandatory attribute: Mode\n");
            err = Test3bReadsBackTheRwMandatoryAttributeMode_15();
            break;
        case 16:
            ChipLogProgress(
                chipTool, " ***** Test Step 16 : 2: read the RO optional attribute default: TargetPositionLiftPercent100ths\n");
            err = Test2ReadTheRoOptionalAttributeDefaultTargetPositionLiftPercent100ths_16();
            break;
        case 17:
            ChipLogProgress(chipTool,
                " ***** Test Step 17 : 3a: write a value into the RO optional attribute: TargetPositionLiftPercent100ths\n");
            err = Test3aWriteAValueIntoTheRoOptionalAttributeTargetPositionLiftPercent100ths_17();
            break;
        case 18:
            ChipLogProgress(
                chipTool, " ***** Test Step 18 : 3b: reads back the RO optional attribute: TargetPositionLiftPercent100ths\n");
            err = Test3bReadsBackTheRoOptionalAttributeTargetPositionLiftPercent100ths_18();
            break;
        case 19:
            ChipLogProgress(
                chipTool, " ***** Test Step 19 : 2: read the RO optional attribute default: TargetPositionTiltPercent100ths\n");
            err = Test2ReadTheRoOptionalAttributeDefaultTargetPositionTiltPercent100ths_19();
            break;
        case 20:
            ChipLogProgress(chipTool,
                " ***** Test Step 20 : 3a: write a value into the RO optional attribute: TargetPositionTiltPercent100ths\n");
            err = Test3aWriteAValueIntoTheRoOptionalAttributeTargetPositionTiltPercent100ths_20();
            break;
        case 21:
            ChipLogProgress(
                chipTool, " ***** Test Step 21 : 3b: reads back the RO optional attribute: TargetPositionTiltPercent100ths\n");
            err = Test3bReadsBackTheRoOptionalAttributeTargetPositionTiltPercent100ths_21();
            break;
        case 22:
            ChipLogProgress(
                chipTool, " ***** Test Step 22 : 2: read the RO optional attribute default: CurrentPositionLiftPercent100ths\n");
            err = Test2ReadTheRoOptionalAttributeDefaultCurrentPositionLiftPercent100ths_22();
            break;
        case 23:
            ChipLogProgress(chipTool,
                " ***** Test Step 23 : 3a: write a value into the RO optional attribute: CurrentPositionLiftPercent100ths\n");
            err = Test3aWriteAValueIntoTheRoOptionalAttributeCurrentPositionLiftPercent100ths_23();
            break;
        case 24:
            ChipLogProgress(
                chipTool, " ***** Test Step 24 : 3b: reads back the RO optional attribute: CurrentPositionLiftPercent100ths\n");
            err = Test3bReadsBackTheRoOptionalAttributeCurrentPositionLiftPercent100ths_24();
            break;
        case 25:
            ChipLogProgress(
                chipTool, " ***** Test Step 25 : 2: read the RO optional attribute default: CurrentPositionTiltPercent100ths\n");
            err = Test2ReadTheRoOptionalAttributeDefaultCurrentPositionTiltPercent100ths_25();
            break;
        case 26:
            ChipLogProgress(chipTool,
                " ***** Test Step 26 : 3a: write a value into the RO optional attribute: CurrentPositionTiltPercent100ths\n");
            err = Test3aWriteAValueIntoTheRoOptionalAttributeCurrentPositionTiltPercent100ths_26();
            break;
        case 27:
            ChipLogProgress(
                chipTool, " ***** Test Step 27 : 3b: reads back the RO optional attribute: CurrentPositionTiltPercent100ths\n");
            err = Test3bReadsBackTheRoOptionalAttributeCurrentPositionTiltPercent100ths_27();
            break;
        case 28:
            ChipLogProgress(chipTool, " ***** Test Step 28 : 2: read the RO optional attribute default: InstalledOpenLimitLift\n");
            err = Test2ReadTheRoOptionalAttributeDefaultInstalledOpenLimitLift_28();
            break;
        case 29:
            ChipLogProgress(
                chipTool, " ***** Test Step 29 : 3a: write a value into the RO optional attribute: InstalledOpenLimitLift\n");
            err = Test3aWriteAValueIntoTheRoOptionalAttributeInstalledOpenLimitLift_29();
            break;
        case 30:
            ChipLogProgress(chipTool, " ***** Test Step 30 : 3b: reads back the RO optional attribute: InstalledOpenLimitLift\n");
            err = Test3bReadsBackTheRoOptionalAttributeInstalledOpenLimitLift_30();
            break;
        case 31:
            ChipLogProgress(
                chipTool, " ***** Test Step 31 : 2: read the RO optional attribute default: InstalledClosedLimitLift\n");
            err = Test2ReadTheRoOptionalAttributeDefaultInstalledClosedLimitLift_31();
            break;
        case 32:
            ChipLogProgress(
                chipTool, " ***** Test Step 32 : 3a: write a value into the RO optional attribute: InstalledClosedLimitLift\n");
            err = Test3aWriteAValueIntoTheRoOptionalAttributeInstalledClosedLimitLift_32();
            break;
        case 33:
            ChipLogProgress(chipTool, " ***** Test Step 33 : 3b: reads back the RO optional attribute: InstalledClosedLimitLift\n");
            err = Test3bReadsBackTheRoOptionalAttributeInstalledClosedLimitLift_33();
            break;
        case 34:
            ChipLogProgress(chipTool, " ***** Test Step 34 : 2: read the RO optional attribute default: InstalledOpenLimitTilt\n");
            err = Test2ReadTheRoOptionalAttributeDefaultInstalledOpenLimitTilt_34();
            break;
        case 35:
            ChipLogProgress(
                chipTool, " ***** Test Step 35 : 3a: write a value into the RO optional attribute: InstalledOpenLimitTilt\n");
            err = Test3aWriteAValueIntoTheRoOptionalAttributeInstalledOpenLimitTilt_35();
            break;
        case 36:
            ChipLogProgress(chipTool, " ***** Test Step 36 : 3b: reads back the RO optional attribute: InstalledOpenLimitTilt\n");
            err = Test3bReadsBackTheRoOptionalAttributeInstalledOpenLimitTilt_36();
            break;
        case 37:
            ChipLogProgress(
                chipTool, " ***** Test Step 37 : 2: read the RO optional attribute default: InstalledClosedLimitTilt\n");
            err = Test2ReadTheRoOptionalAttributeDefaultInstalledClosedLimitTilt_37();
            break;
        case 38:
            ChipLogProgress(
                chipTool, " ***** Test Step 38 : 3a: write a value into the RO optional attribute: InstalledClosedLimitTilt\n");
            err = Test3aWriteAValueIntoTheRoOptionalAttributeInstalledClosedLimitTilt_38();
            break;
        case 39:
            ChipLogProgress(chipTool, " ***** Test Step 39 : 3b: reads back the RO optional attribute: InstalledClosedLimitTilt\n");
            err = Test3bReadsBackTheRoOptionalAttributeInstalledClosedLimitTilt_39();
            break;
        case 40:
            ChipLogProgress(chipTool, " ***** Test Step 40 : 4: read the RO mandatory attribute default: SafetyStatus\n");
            err = Test4ReadTheRoMandatoryAttributeDefaultSafetyStatus_40();
            break;
        case 41:
            ChipLogProgress(chipTool, " ***** Test Step 41 : 5a: write a value into the RO mandatory attribute: SafetyStatus\n");
            err = Test5aWriteAValueIntoTheRoMandatoryAttributeSafetyStatus_41();
            break;
        case 42:
            ChipLogProgress(chipTool, " ***** Test Step 42 : 5b: reads back the RO mandatory attribute: SafetyStatus\n");
            err = Test5bReadsBackTheRoMandatoryAttributeSafetyStatus_42();
            break;
        case 43:
            ChipLogProgress(chipTool, " ***** Test Step 43 : 4: read the RO optional attribute default: CurrentPositionLift\n");
            err = Test4ReadTheRoOptionalAttributeDefaultCurrentPositionLift_43();
            break;
        case 44:
            ChipLogProgress(
                chipTool, " ***** Test Step 44 : 5a: write a value into the RO optional attribute: CurrentPositionLift\n");
            err = Test5aWriteAValueIntoTheRoOptionalAttributeCurrentPositionLift_44();
            break;
        case 45:
            ChipLogProgress(chipTool, " ***** Test Step 45 : 5b: reads back the RO optional attribute: CurrentPositionLift\n");
            err = Test5bReadsBackTheRoOptionalAttributeCurrentPositionLift_45();
            break;
        case 46:
            ChipLogProgress(chipTool, " ***** Test Step 46 : 4: read the RO optional attribute default: CurrentPositionTilt\n");
            err = Test4ReadTheRoOptionalAttributeDefaultCurrentPositionTilt_46();
            break;
        case 47:
            ChipLogProgress(
                chipTool, " ***** Test Step 47 : 5a: write a value into the RO optional attribute: CurrentPositionTilt\n");
            err = Test5aWriteAValueIntoTheRoOptionalAttributeCurrentPositionTilt_47();
            break;
        case 48:
            ChipLogProgress(chipTool, " ***** Test Step 48 : 5b: reads back the RO optional attribute: CurrentPositionTilt\n");
            err = Test5bReadsBackTheRoOptionalAttributeCurrentPositionTilt_48();
            break;
        case 49:
            ChipLogProgress(
                chipTool, " ***** Test Step 49 : 4: read the RO optional attribute default: CurrentPositionLiftPercentage\n");
            err = Test4ReadTheRoOptionalAttributeDefaultCurrentPositionLiftPercentage_49();
            break;
        case 50:
            ChipLogProgress(chipTool,
                " ***** Test Step 50 : 5a: write a value into the RO optional attribute: CurrentPositionLiftPercentage\n");
            err = Test5aWriteAValueIntoTheRoOptionalAttributeCurrentPositionLiftPercentage_50();
            break;
        case 51:
            ChipLogProgress(
                chipTool, " ***** Test Step 51 : 5b: reads back the RO optional attribute: CurrentPositionLiftPercentage\n");
            err = Test5bReadsBackTheRoOptionalAttributeCurrentPositionLiftPercentage_51();
            break;
        case 52:
            ChipLogProgress(
                chipTool, " ***** Test Step 52 : 4: read the RO optional attribute default: CurrentPositionTiltPercentage\n");
            err = Test4ReadTheRoOptionalAttributeDefaultCurrentPositionTiltPercentage_52();
            break;
        case 53:
            ChipLogProgress(chipTool,
                " ***** Test Step 53 : 5a: write a value into the RO optional attribute: CurrentPositionTiltPercentage\n");
            err = Test5aWriteAValueIntoTheRoOptionalAttributeCurrentPositionTiltPercentage_53();
            break;
        case 54:
            ChipLogProgress(
                chipTool, " ***** Test Step 54 : 5b: reads back the RO optional attribute: CurrentPositionTiltPercentage\n");
            err = Test5bReadsBackTheRoOptionalAttributeCurrentPositionTiltPercentage_54();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 55;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR Test2ReadTheRoMandatoryAttributeDefaultType_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeTypeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"2: read the RO mandatory attribute default: Type Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("type", "", "enum8"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<uint8_t>("type", [value unsignedCharValue], 0));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("type", [value unsignedCharValue], 9));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR Test3aWriteAValueIntoTheRoMandatoryAttributeType_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id typeArgument;
        typeArgument = [NSNumber numberWithUnsignedChar:250];
        [cluster writeAttributeTypeWithValue:typeArgument
                           completionHandler:^(NSError * _Nullable err) {
                               NSLog(@"3a: write a value into the RO mandatory attribute: Type Error: %@", err);

                               VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                               NextTest();
                           }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR Test3bReadsBackTheRoMandatoryAttributeType_3()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeTypeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"3b: reads back the RO mandatory attribute: Type Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("type", "", "enum8"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintNotValue("type", value, 250));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR Test2ReadTheRoMandatoryAttributeDefaultConfigStatus_4()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeConfigStatusWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"2: read the RO mandatory attribute default: ConfigStatus Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("configStatus", "", "map8"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<uint8_t>("configStatus", [value unsignedCharValue], 0));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("configStatus", [value unsignedCharValue], 63));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR Test3aWriteAValueIntoTheRoMandatoryAttributeConfigStatus_5()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id configStatusArgument;
        configStatusArgument = [NSNumber numberWithUnsignedChar:128];
        [cluster writeAttributeConfigStatusWithValue:configStatusArgument
                                   completionHandler:^(NSError * _Nullable err) {
                                       NSLog(@"3a: write a value into the RO mandatory attribute: ConfigStatus Error: %@", err);

                                       VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                                       NextTest();
                                   }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR Test3bReadsBackTheRoMandatoryAttributeConfigStatus_6()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeConfigStatusWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"3b: reads back the RO mandatory attribute: ConfigStatus Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("configStatus", "", "map8"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintNotValue("configStatus", value, 128));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR Test2ReadTheRoMandatoryAttributeDefaultOperationalStatus_7()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOperationalStatusWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"2: read the RO mandatory attribute default: OperationalStatus Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("operationalStatus", "", "map8"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<uint8_t>("operationalStatus", [value unsignedCharValue], 0));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("operationalStatus", [value unsignedCharValue], 63));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR Test3aWriteAValueIntoTheRoMandatoryAttributeOperationalStatus_8()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id operationalStatusArgument;
        operationalStatusArgument = [NSNumber numberWithUnsignedChar:128];
        [cluster writeAttributeOperationalStatusWithValue:operationalStatusArgument
                                        completionHandler:^(NSError * _Nullable err) {
                                            NSLog(@"3a: write a value into the RO mandatory attribute: OperationalStatus Error: %@",
                                                err);

                                            VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                                            NextTest();
                                        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR Test3bReadsBackTheRoMandatoryAttributeOperationalStatus_9()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOperationalStatusWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"3b: reads back the RO mandatory attribute: OperationalStatus Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("operationalStatus", "", "map8"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintNotValue("operationalStatus", value, 128));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR Test2ReadTheRoMandatoryAttributeDefaultEndProductType_10()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeEndProductTypeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"2: read the RO mandatory attribute default: EndProductType Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("endProductType", "", "enum8"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<uint8_t>("endProductType", [value unsignedCharValue], 0));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("endProductType", [value unsignedCharValue], 23));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR Test3aWriteAValueIntoTheRoMandatoryAttributeEndProductType_11()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id endProductTypeArgument;
        endProductTypeArgument = [NSNumber numberWithUnsignedChar:250];
        [cluster writeAttributeEndProductTypeWithValue:endProductTypeArgument
                                     completionHandler:^(NSError * _Nullable err) {
                                         NSLog(@"3a: write a value into the RO mandatory attribute: EndProductType Error: %@", err);

                                         VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                                         NextTest();
                                     }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR Test3bReadsBackTheRoMandatoryAttributeEndProductType_12()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeEndProductTypeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"3b: reads back the RO mandatory attribute: EndProductType Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("endProductType", "", "enum8"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintNotValue("endProductType", value, 250));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR Test2ReadTheRwMandatoryAttributeDefaultMode_13()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeModeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"2: read the RW mandatory attribute default: Mode Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("mode", "", "map8"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<uint8_t>("mode", [value unsignedCharValue], 0));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("mode", [value unsignedCharValue], 15));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR Test3aWriteAValueIntoTheRwMandatoryAttributeMode_14()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id modeArgument;
        modeArgument = [NSNumber numberWithUnsignedChar:8];
        [cluster writeAttributeModeWithValue:modeArgument
                           completionHandler:^(NSError * _Nullable err) {
                               NSLog(@"3a: write a value into the RW mandatory attribute:: Mode Error: %@", err);

                               VerifyOrReturn(CheckValue("status", err, 0));

                               NextTest();
                           }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR Test3bReadsBackTheRwMandatoryAttributeMode_15()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeModeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"3b: reads back the RW mandatory attribute: Mode Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("Mode", actualValue, 8));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR Test2ReadTheRoOptionalAttributeDefaultTargetPositionLiftPercent100ths_16()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeTargetPositionLiftPercent100thsWithCompletionHandler:^(
            NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"2: read the RO optional attribute default: TargetPositionLiftPercent100ths Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("targetPositionLiftPercent100ths", "", "Percent100ths"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<chip::Percent100ths>(
                    "targetPositionLiftPercent100ths", [value unsignedShortValue], 0U));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<chip::Percent100ths>(
                    "targetPositionLiftPercent100ths", [value unsignedShortValue], 10000U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR Test3aWriteAValueIntoTheRoOptionalAttributeTargetPositionLiftPercent100ths_17()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id targetPositionLiftPercent100thsArgument;
        targetPositionLiftPercent100thsArgument = [NSNumber numberWithUnsignedShort:20000U];
        [cluster
            writeAttributeTargetPositionLiftPercent100thsWithValue:targetPositionLiftPercent100thsArgument
                                                 completionHandler:^(NSError * _Nullable err) {
                                                     NSLog(@"3a: write a value into the RO optional attribute: "
                                                           @"TargetPositionLiftPercent100ths Error: %@",
                                                         err);

                                                     VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                                                     NextTest();
                                                 }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR Test3bReadsBackTheRoOptionalAttributeTargetPositionLiftPercent100ths_18()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeTargetPositionLiftPercent100thsWithCompletionHandler:^(
            NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"3b: reads back the RO optional attribute: TargetPositionLiftPercent100ths Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("targetPositionLiftPercent100ths", "", "Percent100ths"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintNotValue("targetPositionLiftPercent100ths", value, 20000U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR Test2ReadTheRoOptionalAttributeDefaultTargetPositionTiltPercent100ths_19()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeTargetPositionTiltPercent100thsWithCompletionHandler:^(
            NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"2: read the RO optional attribute default: TargetPositionTiltPercent100ths Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("targetPositionTiltPercent100ths", "", "Percent100ths"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<chip::Percent100ths>(
                    "targetPositionTiltPercent100ths", [value unsignedShortValue], 0U));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<chip::Percent100ths>(
                    "targetPositionTiltPercent100ths", [value unsignedShortValue], 10000U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR Test3aWriteAValueIntoTheRoOptionalAttributeTargetPositionTiltPercent100ths_20()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id targetPositionTiltPercent100thsArgument;
        targetPositionTiltPercent100thsArgument = [NSNumber numberWithUnsignedShort:20000U];
        [cluster
            writeAttributeTargetPositionTiltPercent100thsWithValue:targetPositionTiltPercent100thsArgument
                                                 completionHandler:^(NSError * _Nullable err) {
                                                     NSLog(@"3a: write a value into the RO optional attribute: "
                                                           @"TargetPositionTiltPercent100ths Error: %@",
                                                         err);

                                                     VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                                                     NextTest();
                                                 }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR Test3bReadsBackTheRoOptionalAttributeTargetPositionTiltPercent100ths_21()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeTargetPositionTiltPercent100thsWithCompletionHandler:^(
            NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"3b: reads back the RO optional attribute: TargetPositionTiltPercent100ths Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("targetPositionTiltPercent100ths", "", "Percent100ths"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintNotValue("targetPositionTiltPercent100ths", value, 20000U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR Test2ReadTheRoOptionalAttributeDefaultCurrentPositionLiftPercent100ths_22()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeCurrentPositionLiftPercent100thsWithCompletionHandler:^(
            NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"2: read the RO optional attribute default: CurrentPositionLiftPercent100ths Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("currentPositionLiftPercent100ths", "", "Percent100ths"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<chip::Percent100ths>(
                    "currentPositionLiftPercent100ths", [value unsignedShortValue], 0U));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<chip::Percent100ths>(
                    "currentPositionLiftPercent100ths", [value unsignedShortValue], 10000U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR Test3aWriteAValueIntoTheRoOptionalAttributeCurrentPositionLiftPercent100ths_23()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id currentPositionLiftPercent100thsArgument;
        currentPositionLiftPercent100thsArgument = [NSNumber numberWithUnsignedShort:20000U];
        [cluster
            writeAttributeCurrentPositionLiftPercent100thsWithValue:currentPositionLiftPercent100thsArgument
                                                  completionHandler:^(NSError * _Nullable err) {
                                                      NSLog(@"3a: write a value into the RO optional attribute: "
                                                            @"CurrentPositionLiftPercent100ths Error: %@",
                                                          err);

                                                      VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                                                      NextTest();
                                                  }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR Test3bReadsBackTheRoOptionalAttributeCurrentPositionLiftPercent100ths_24()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeCurrentPositionLiftPercent100thsWithCompletionHandler:^(
            NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"3b: reads back the RO optional attribute: CurrentPositionLiftPercent100ths Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("currentPositionLiftPercent100ths", "", "Percent100ths"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintNotValue("currentPositionLiftPercent100ths", value, 20000U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR Test2ReadTheRoOptionalAttributeDefaultCurrentPositionTiltPercent100ths_25()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeCurrentPositionTiltPercent100thsWithCompletionHandler:^(
            NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"2: read the RO optional attribute default: CurrentPositionTiltPercent100ths Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("currentPositionTiltPercent100ths", "", "Percent100ths"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<chip::Percent100ths>(
                    "currentPositionTiltPercent100ths", [value unsignedShortValue], 0U));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<chip::Percent100ths>(
                    "currentPositionTiltPercent100ths", [value unsignedShortValue], 10000U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR Test3aWriteAValueIntoTheRoOptionalAttributeCurrentPositionTiltPercent100ths_26()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id currentPositionTiltPercent100thsArgument;
        currentPositionTiltPercent100thsArgument = [NSNumber numberWithUnsignedShort:20000U];
        [cluster
            writeAttributeCurrentPositionTiltPercent100thsWithValue:currentPositionTiltPercent100thsArgument
                                                  completionHandler:^(NSError * _Nullable err) {
                                                      NSLog(@"3a: write a value into the RO optional attribute: "
                                                            @"CurrentPositionTiltPercent100ths Error: %@",
                                                          err);

                                                      VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                                                      NextTest();
                                                  }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR Test3bReadsBackTheRoOptionalAttributeCurrentPositionTiltPercent100ths_27()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeCurrentPositionTiltPercent100thsWithCompletionHandler:^(
            NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"3b: reads back the RO optional attribute: CurrentPositionTiltPercent100ths Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("currentPositionTiltPercent100ths", "", "Percent100ths"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintNotValue("currentPositionTiltPercent100ths", value, 20000U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR Test2ReadTheRoOptionalAttributeDefaultInstalledOpenLimitLift_28()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeInstalledOpenLimitLiftWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"2: read the RO optional attribute default: InstalledOpenLimitLift Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("installedOpenLimitLift", "", "uint16"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("installedOpenLimitLift", [value unsignedShortValue], 0U));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("installedOpenLimitLift", [value unsignedShortValue], 65535U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR Test3aWriteAValueIntoTheRoOptionalAttributeInstalledOpenLimitLift_29()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id installedOpenLimitLiftArgument;
        installedOpenLimitLiftArgument = [NSNumber numberWithUnsignedShort:255U];
        [cluster writeAttributeInstalledOpenLimitLiftWithValue:installedOpenLimitLiftArgument
                                             completionHandler:^(NSError * _Nullable err) {
                                                 NSLog(@"3a: write a value into the RO optional attribute: InstalledOpenLimitLift "
                                                       @"Error: %@",
                                                     err);

                                                 VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                                                 NextTest();
                                             }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR Test3bReadsBackTheRoOptionalAttributeInstalledOpenLimitLift_30()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeInstalledOpenLimitLiftWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"3b: reads back the RO optional attribute: InstalledOpenLimitLift Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("installedOpenLimitLift", "", "uint16"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("installedOpenLimitLift", [value unsignedShortValue], 0U));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("installedOpenLimitLift", [value unsignedShortValue], 65535U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR Test2ReadTheRoOptionalAttributeDefaultInstalledClosedLimitLift_31()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeInstalledClosedLimitLiftWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"2: read the RO optional attribute default: InstalledClosedLimitLift Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("installedClosedLimitLift", "", "uint16"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("installedClosedLimitLift", [value unsignedShortValue], 0U));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("installedClosedLimitLift", [value unsignedShortValue], 65535U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR Test3aWriteAValueIntoTheRoOptionalAttributeInstalledClosedLimitLift_32()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id installedClosedLimitLiftArgument;
        installedClosedLimitLiftArgument = [NSNumber numberWithUnsignedShort:255U];
        [cluster writeAttributeInstalledClosedLimitLiftWithValue:installedClosedLimitLiftArgument
                                               completionHandler:^(NSError * _Nullable err) {
                                                   NSLog(@"3a: write a value into the RO optional attribute: "
                                                         @"InstalledClosedLimitLift Error: %@",
                                                       err);

                                                   VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                                                   NextTest();
                                               }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR Test3bReadsBackTheRoOptionalAttributeInstalledClosedLimitLift_33()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeInstalledClosedLimitLiftWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"3b: reads back the RO optional attribute: InstalledClosedLimitLift Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("installedClosedLimitLift", "", "uint16"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("installedClosedLimitLift", [value unsignedShortValue], 0U));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("installedClosedLimitLift", [value unsignedShortValue], 65535U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR Test2ReadTheRoOptionalAttributeDefaultInstalledOpenLimitTilt_34()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeInstalledOpenLimitTiltWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"2: read the RO optional attribute default: InstalledOpenLimitTilt Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("installedOpenLimitTilt", "", "uint16"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("installedOpenLimitTilt", [value unsignedShortValue], 0U));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("installedOpenLimitTilt", [value unsignedShortValue], 65535U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR Test3aWriteAValueIntoTheRoOptionalAttributeInstalledOpenLimitTilt_35()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id installedOpenLimitTiltArgument;
        installedOpenLimitTiltArgument = [NSNumber numberWithUnsignedShort:255U];
        [cluster writeAttributeInstalledOpenLimitTiltWithValue:installedOpenLimitTiltArgument
                                             completionHandler:^(NSError * _Nullable err) {
                                                 NSLog(@"3a: write a value into the RO optional attribute: InstalledOpenLimitTilt "
                                                       @"Error: %@",
                                                     err);

                                                 VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                                                 NextTest();
                                             }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR Test3bReadsBackTheRoOptionalAttributeInstalledOpenLimitTilt_36()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeInstalledOpenLimitTiltWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"3b: reads back the RO optional attribute: InstalledOpenLimitTilt Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("installedOpenLimitTilt", "", "uint16"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("installedOpenLimitTilt", [value unsignedShortValue], 0U));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("installedOpenLimitTilt", [value unsignedShortValue], 65535U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR Test2ReadTheRoOptionalAttributeDefaultInstalledClosedLimitTilt_37()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeInstalledClosedLimitTiltWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"2: read the RO optional attribute default: InstalledClosedLimitTilt Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("installedClosedLimitTilt", "", "uint16"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("installedClosedLimitTilt", [value unsignedShortValue], 0U));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("installedClosedLimitTilt", [value unsignedShortValue], 65535U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR Test3aWriteAValueIntoTheRoOptionalAttributeInstalledClosedLimitTilt_38()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id installedClosedLimitTiltArgument;
        installedClosedLimitTiltArgument = [NSNumber numberWithUnsignedShort:255U];
        [cluster writeAttributeInstalledClosedLimitTiltWithValue:installedClosedLimitTiltArgument
                                               completionHandler:^(NSError * _Nullable err) {
                                                   NSLog(@"3a: write a value into the RO optional attribute: "
                                                         @"InstalledClosedLimitTilt Error: %@",
                                                       err);

                                                   VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                                                   NextTest();
                                               }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR Test3bReadsBackTheRoOptionalAttributeInstalledClosedLimitTilt_39()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeInstalledClosedLimitTiltWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"3b: reads back the RO optional attribute: InstalledClosedLimitTilt Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("installedClosedLimitTilt", "", "uint16"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("installedClosedLimitTilt", [value unsignedShortValue], 0U));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("installedClosedLimitTilt", [value unsignedShortValue], 65535U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR Test4ReadTheRoMandatoryAttributeDefaultSafetyStatus_40()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeSafetyStatusWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"4: read the RO mandatory attribute default: SafetyStatus Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("safetyStatus", "", "map16"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("safetyStatus", [value unsignedShortValue], 0U));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("safetyStatus", [value unsignedShortValue], 2047U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR Test5aWriteAValueIntoTheRoMandatoryAttributeSafetyStatus_41()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id safetyStatusArgument;
        safetyStatusArgument = [NSNumber numberWithUnsignedShort:4096U];
        [cluster writeAttributeSafetyStatusWithValue:safetyStatusArgument
                                   completionHandler:^(NSError * _Nullable err) {
                                       NSLog(@"5a: write a value into the RO mandatory attribute: SafetyStatus Error: %@", err);

                                       VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                                       NextTest();
                                   }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR Test5bReadsBackTheRoMandatoryAttributeSafetyStatus_42()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeSafetyStatusWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"5b: reads back the RO mandatory attribute: SafetyStatus Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("safetyStatus", "", "map16"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintNotValue("safetyStatus", value, 4096U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR Test4ReadTheRoOptionalAttributeDefaultCurrentPositionLift_43()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeCurrentPositionLiftWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"4: read the RO optional attribute default: CurrentPositionLift Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("currentPositionLift", "", "uint16"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("currentPositionLift", [value unsignedShortValue], 0U));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("currentPositionLift", [value unsignedShortValue], 65535U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR Test5aWriteAValueIntoTheRoOptionalAttributeCurrentPositionLift_44()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id currentPositionLiftArgument;
        currentPositionLiftArgument = [NSNumber numberWithUnsignedShort:255U];
        [cluster
            writeAttributeCurrentPositionLiftWithValue:currentPositionLiftArgument
                                     completionHandler:^(NSError * _Nullable err) {
                                         NSLog(@"5a: write a value into the RO optional attribute: CurrentPositionLift Error: %@",
                                             err);

                                         VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                                         NextTest();
                                     }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR Test5bReadsBackTheRoOptionalAttributeCurrentPositionLift_45()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeCurrentPositionLiftWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"5b: reads back the RO optional attribute: CurrentPositionLift Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("currentPositionLift", "", "uint16"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("currentPositionLift", [value unsignedShortValue], 0U));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("currentPositionLift", [value unsignedShortValue], 65535U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR Test4ReadTheRoOptionalAttributeDefaultCurrentPositionTilt_46()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeCurrentPositionTiltWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"4: read the RO optional attribute default: CurrentPositionTilt Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("currentPositionTilt", "", "uint16"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("currentPositionTilt", [value unsignedShortValue], 0U));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("currentPositionTilt", [value unsignedShortValue], 65535U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR Test5aWriteAValueIntoTheRoOptionalAttributeCurrentPositionTilt_47()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id currentPositionTiltArgument;
        currentPositionTiltArgument = [NSNumber numberWithUnsignedShort:255U];
        [cluster
            writeAttributeCurrentPositionTiltWithValue:currentPositionTiltArgument
                                     completionHandler:^(NSError * _Nullable err) {
                                         NSLog(@"5a: write a value into the RO optional attribute: CurrentPositionTilt Error: %@",
                                             err);

                                         VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                                         NextTest();
                                     }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR Test5bReadsBackTheRoOptionalAttributeCurrentPositionTilt_48()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeCurrentPositionTiltWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"5b: reads back the RO optional attribute: CurrentPositionTilt Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("currentPositionTilt", "", "uint16"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("currentPositionTilt", [value unsignedShortValue], 0U));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("currentPositionTilt", [value unsignedShortValue], 65535U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR Test4ReadTheRoOptionalAttributeDefaultCurrentPositionLiftPercentage_49()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster
            readAttributeCurrentPositionLiftPercentageWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
                NSLog(@"4: read the RO optional attribute default: CurrentPositionLiftPercentage Error: %@", err);

                VerifyOrReturn(CheckValue("status", err, 0));

                VerifyOrReturn(CheckConstraintType("currentPositionLiftPercentage", "", "Percent"));
                if (value != nil) {
                    VerifyOrReturn(
                        CheckConstraintMinValue<chip::Percent>("currentPositionLiftPercentage", [value unsignedCharValue], 0));
                }
                if (value != nil) {
                    VerifyOrReturn(
                        CheckConstraintMaxValue<chip::Percent>("currentPositionLiftPercentage", [value unsignedCharValue], 100));
                }

                NextTest();
            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR Test5aWriteAValueIntoTheRoOptionalAttributeCurrentPositionLiftPercentage_50()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id currentPositionLiftPercentageArgument;
        currentPositionLiftPercentageArgument = [NSNumber numberWithUnsignedChar:200];
        [cluster
            writeAttributeCurrentPositionLiftPercentageWithValue:currentPositionLiftPercentageArgument
                                               completionHandler:^(NSError * _Nullable err) {
                                                   NSLog(@"5a: write a value into the RO optional attribute: "
                                                         @"CurrentPositionLiftPercentage Error: %@",
                                                       err);

                                                   VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                                                   NextTest();
                                               }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR Test5bReadsBackTheRoOptionalAttributeCurrentPositionLiftPercentage_51()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster
            readAttributeCurrentPositionLiftPercentageWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
                NSLog(@"5b: reads back the RO optional attribute: CurrentPositionLiftPercentage Error: %@", err);

                VerifyOrReturn(CheckValue("status", err, 0));

                VerifyOrReturn(CheckConstraintType("currentPositionLiftPercentage", "", "Percent"));
                if (value != nil) {
                    VerifyOrReturn(CheckConstraintNotValue("currentPositionLiftPercentage", value, 200));
                }

                NextTest();
            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR Test4ReadTheRoOptionalAttributeDefaultCurrentPositionTiltPercentage_52()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster
            readAttributeCurrentPositionTiltPercentageWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
                NSLog(@"4: read the RO optional attribute default: CurrentPositionTiltPercentage Error: %@", err);

                VerifyOrReturn(CheckValue("status", err, 0));

                VerifyOrReturn(CheckConstraintType("currentPositionTiltPercentage", "", "Percent"));
                if (value != nil) {
                    VerifyOrReturn(
                        CheckConstraintMinValue<chip::Percent>("currentPositionTiltPercentage", [value unsignedCharValue], 0));
                }
                if (value != nil) {
                    VerifyOrReturn(
                        CheckConstraintMaxValue<chip::Percent>("currentPositionTiltPercentage", [value unsignedCharValue], 100));
                }

                NextTest();
            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR Test5aWriteAValueIntoTheRoOptionalAttributeCurrentPositionTiltPercentage_53()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id currentPositionTiltPercentageArgument;
        currentPositionTiltPercentageArgument = [NSNumber numberWithUnsignedChar:200];
        [cluster
            writeAttributeCurrentPositionTiltPercentageWithValue:currentPositionTiltPercentageArgument
                                               completionHandler:^(NSError * _Nullable err) {
                                                   NSLog(@"5a: write a value into the RO optional attribute: "
                                                         @"CurrentPositionTiltPercentage Error: %@",
                                                       err);

                                                   VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
                                                   NextTest();
                                               }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR Test5bReadsBackTheRoOptionalAttributeCurrentPositionTiltPercentage_54()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster
            readAttributeCurrentPositionTiltPercentageWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
                NSLog(@"5b: reads back the RO optional attribute: CurrentPositionTiltPercentage Error: %@", err);

                VerifyOrReturn(CheckValue("status", err, 0));

                VerifyOrReturn(CheckConstraintType("currentPositionTiltPercentage", "", "Percent"));
                if (value != nil) {
                    VerifyOrReturn(CheckConstraintNotValue("currentPositionTiltPercentage", value, 200));
                }

                NextTest();
            }];

        return CHIP_NO_ERROR;
    }
};

class Test_TC_WNCV_2_2 : public TestCommandBridge {
public:
    Test_TC_WNCV_2_2()
        : TestCommandBridge("Test_TC_WNCV_2_2")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_WNCV_2_2() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_WNCV_2_2\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_WNCV_2_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }
};

class Test_TC_WNCV_2_4 : public TestCommandBridge {
public:
    Test_TC_WNCV_2_4()
        : TestCommandBridge("Test_TC_WNCV_2_4")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_WNCV_2_4() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_WNCV_2_4\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_WNCV_2_4\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Reads Type attribute from DUT\n");
            if (ShouldSkip("A_TYPE")) {
                NextTest();
                return;
            }
            err = TestReadsTypeAttributeFromDut_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Reads Type attribute constraints\n");
            if (ShouldSkip("A_TYPE")) {
                NextTest();
                return;
            }
            err = TestReadsTypeAttributeConstraints_2();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 3;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsTypeAttributeFromDut_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeTypeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads Type attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("Type", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsTypeAttributeConstraints_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeTypeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads Type attribute constraints Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("type", "", "enum8"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<uint8_t>("type", [value unsignedCharValue], 0));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("type", [value unsignedCharValue], 9));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
};

class Test_TC_WNCV_2_5 : public TestCommandBridge {
public:
    Test_TC_WNCV_2_5()
        : TestCommandBridge("Test_TC_WNCV_2_5")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_WNCV_2_5() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_WNCV_2_5\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_WNCV_2_5\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Reads EndProductType attribute from DUT\n");
            if (ShouldSkip("A_ENDPRODUCTTYPE")) {
                NextTest();
                return;
            }
            err = TestReadsEndProductTypeAttributeFromDut_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Reads EndProductType attribute constraints from DUT\n");
            if (ShouldSkip("A_ENDPRODUCTTYPE")) {
                NextTest();
                return;
            }
            err = TestReadsEndProductTypeAttributeConstraintsFromDut_2();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 3;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsEndProductTypeAttributeFromDut_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeEndProductTypeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads EndProductType attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("EndProductType", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsEndProductTypeAttributeConstraintsFromDut_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeEndProductTypeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads EndProductType attribute constraints from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("endProductType", "", "enum8"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<uint8_t>("endProductType", [value unsignedCharValue], 0));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("endProductType", [value unsignedCharValue], 23));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
};

class Test_TC_WNCV_3_4 : public TestCommandBridge {
public:
    Test_TC_WNCV_3_4()
        : TestCommandBridge("Test_TC_WNCV_3_4")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("fastMotionDuration", 0, UINT16_MAX, &mFastMotionDuration);
        AddArgument("fullMotionDuration", 0, UINT16_MAX, &mFullMotionDuration);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_WNCV_3_4() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_WNCV_3_4\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_WNCV_3_4\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : 0: Wait for the commissioned device to be retrieved\n");
            err = Test0WaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool,
                " ***** Test Step 1 : 1a: TH sends DownOrClose command to preposition the DUT in the opposite direction\n");
            err = Test1aThSendsDownOrCloseCommandToPrepositionTheDutInTheOppositeDirection_1();
            break;
        case 2:
            ChipLogProgress(
                chipTool, " ***** Test Step 2 : 1b: TH Waits for fastMotionDuration seconds movement(s) on the device\n");
            err = Test1bThWaitsForFastMotionDurationSecondsMovementsOnTheDevice_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : 2a: TH sends UpOrOpen command to DUT\n");
            err = Test2aThSendsUpOrOpenCommandToDut_3();
            break;
        case 4:
            ChipLogProgress(
                chipTool, " ***** Test Step 4 : 2b: TH Waits for fullMotionDuration seconds movement(s) on the device\n");
            err = Test2bThWaitsForFullMotionDurationSecondsMovementsOnTheDevice_4();
            break;
        case 5:
            ChipLogProgress(
                chipTool, " ***** Test Step 5 : 3a: If (PA & LF) TH reads CurrentPositionLiftPercent100ths attribute from DUT\n");
            if (ShouldSkip("WNCV_LF && WNCV_PA_LF")) {
                NextTest();
                return;
            }
            err = Test3aIfPaLfThReadsCurrentPositionLiftPercent100thsAttributeFromDut_5();
            break;
        case 6:
            ChipLogProgress(chipTool,
                " ***** Test Step 6 : 3b: If (PA & LF) TH reads CurrentPositionLiftPercentage optional attribute from DUT\n");
            if (ShouldSkip("WNCV_LF && WNCV_PA_LF && A_CURRENTPOSITIONLIFTPERCENTAGE")) {
                NextTest();
                return;
            }
            err = Test3bIfPaLfThReadsCurrentPositionLiftPercentageOptionalAttributeFromDut_6();
            break;
        case 7:
            ChipLogProgress(
                chipTool, " ***** Test Step 7 : 3c: If (PA & TL) TH reads CurrentPositionTiltPercent100ths attribute from DUT\n");
            if (ShouldSkip("WNCV_TL && WNCV_PA_TL")) {
                NextTest();
                return;
            }
            err = Test3cIfPaTlThReadsCurrentPositionTiltPercent100thsAttributeFromDut_7();
            break;
        case 8:
            ChipLogProgress(chipTool,
                " ***** Test Step 8 : 3d: If (PA & TL) TH reads CurrentPositionTiltPercentage optional attribute from DUT\n");
            if (ShouldSkip("WNCV_TL && WNCV_PA_TL && A_CURRENTPOSITIONLIFTPERCENTAGE")) {
                NextTest();
                return;
            }
            err = Test3dIfPaTlThReadsCurrentPositionTiltPercentageOptionalAttributeFromDut_8();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 9;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mFastMotionDuration;
    chip::Optional<uint16_t> mFullMotionDuration;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR Test0WaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR Test1aThSendsDownOrCloseCommandToPrepositionTheDutInTheOppositeDirection_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster downOrCloseWithCompletionHandler:^(NSError * _Nullable err) {
            NSLog(@"1a: TH sends DownOrClose command to preposition the DUT in the opposite direction Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR Test1bThWaitsForFastMotionDurationSecondsMovementsOnTheDevice_2()
    {
        WaitForMs(mFastMotionDuration.HasValue() ? mFastMotionDuration.Value() : 3000U);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR Test2aThSendsUpOrOpenCommandToDut_3()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster upOrOpenWithCompletionHandler:^(NSError * _Nullable err) {
            NSLog(@"2a: TH sends UpOrOpen command to DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR Test2bThWaitsForFullMotionDurationSecondsMovementsOnTheDevice_4()
    {
        WaitForMs(mFullMotionDuration.HasValue() ? mFullMotionDuration.Value() : 6000U);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR Test3aIfPaLfThReadsCurrentPositionLiftPercent100thsAttributeFromDut_5()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeCurrentPositionLiftPercent100thsWithCompletionHandler:^(
            NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"3a: If (PA & LF) TH reads CurrentPositionLiftPercent100ths attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNonNull("CurrentPositionLiftPercent100ths", actualValue));
                VerifyOrReturn(CheckValue("CurrentPositionLiftPercent100ths", actualValue, 0U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR Test3bIfPaLfThReadsCurrentPositionLiftPercentageOptionalAttributeFromDut_6()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster
            readAttributeCurrentPositionLiftPercentageWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
                NSLog(@"3b: If (PA & LF) TH reads CurrentPositionLiftPercentage optional attribute from DUT Error: %@", err);

                VerifyOrReturn(CheckValue("status", err, 0));

                {
                    id actualValue = value;
                    VerifyOrReturn(CheckValueNonNull("CurrentPositionLiftPercentage", actualValue));
                    VerifyOrReturn(CheckValue("CurrentPositionLiftPercentage", actualValue, 0));
                }

                NextTest();
            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR Test3cIfPaTlThReadsCurrentPositionTiltPercent100thsAttributeFromDut_7()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeCurrentPositionTiltPercent100thsWithCompletionHandler:^(
            NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"3c: If (PA & TL) TH reads CurrentPositionTiltPercent100ths attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNonNull("CurrentPositionTiltPercent100ths", actualValue));
                VerifyOrReturn(CheckValue("CurrentPositionTiltPercent100ths", actualValue, 0U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR Test3dIfPaTlThReadsCurrentPositionTiltPercentageOptionalAttributeFromDut_8()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster
            readAttributeCurrentPositionTiltPercentageWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
                NSLog(@"3d: If (PA & TL) TH reads CurrentPositionTiltPercentage optional attribute from DUT Error: %@", err);

                VerifyOrReturn(CheckValue("status", err, 0));

                {
                    id actualValue = value;
                    VerifyOrReturn(CheckValueNonNull("CurrentPositionTiltPercentage", actualValue));
                    VerifyOrReturn(CheckValue("CurrentPositionTiltPercentage", actualValue, 0));
                }

                NextTest();
            }];

        return CHIP_NO_ERROR;
    }
};

class Test_TC_WNCV_3_5 : public TestCommandBridge {
public:
    Test_TC_WNCV_3_5()
        : TestCommandBridge("Test_TC_WNCV_3_5")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("fastMotionDuration", 0, UINT16_MAX, &mFastMotionDuration);
        AddArgument("fullMotionDuration", 0, UINT16_MAX, &mFullMotionDuration);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_WNCV_3_5() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_WNCV_3_5\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_WNCV_3_5\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : 0: Wait for the commissioned device to be retrieved\n");
            err = Test0WaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(
                chipTool, " ***** Test Step 1 : 1a: TH sends UpOrOpen command to preposition the DUT in the opposite direction\n");
            err = Test1aThSendsUpOrOpenCommandToPrepositionTheDutInTheOppositeDirection_1();
            break;
        case 2:
            ChipLogProgress(
                chipTool, " ***** Test Step 2 : 1b: TH Waits for fastMotionDuration seconds movement(s) on the device\n");
            err = Test1bThWaitsForFastMotionDurationSecondsMovementsOnTheDevice_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : 2a: TH sends DownOrClose command to DUT\n");
            err = Test2aThSendsDownOrCloseCommandToDut_3();
            break;
        case 4:
            ChipLogProgress(
                chipTool, " ***** Test Step 4 : 2b: TH Waits for fullMotionDuration seconds movement(s) on the device\n");
            err = Test2bThWaitsForFullMotionDurationSecondsMovementsOnTheDevice_4();
            break;
        case 5:
            ChipLogProgress(
                chipTool, " ***** Test Step 5 : 3a: If (PA & LF) TH reads CurrentPositionLiftPercent100ths attribute from DUT\n");
            if (ShouldSkip("WNCV_LF && WNCV_PA_LF")) {
                NextTest();
                return;
            }
            err = Test3aIfPaLfThReadsCurrentPositionLiftPercent100thsAttributeFromDut_5();
            break;
        case 6:
            ChipLogProgress(chipTool,
                " ***** Test Step 6 : 3b: If (PA & LF) TH reads CurrentPositionLiftPercentage optional attribute from DUT\n");
            if (ShouldSkip("WNCV_LF && WNCV_PA_LF && A_CURRENTPOSITIONLIFTPERCENTAGE")) {
                NextTest();
                return;
            }
            err = Test3bIfPaLfThReadsCurrentPositionLiftPercentageOptionalAttributeFromDut_6();
            break;
        case 7:
            ChipLogProgress(
                chipTool, " ***** Test Step 7 : 3c: If (PA & TL) TH reads CurrentPositionTiltPercent100ths attribute from DUT\n");
            if (ShouldSkip("WNCV_TL && WNCV_PA_TL")) {
                NextTest();
                return;
            }
            err = Test3cIfPaTlThReadsCurrentPositionTiltPercent100thsAttributeFromDut_7();
            break;
        case 8:
            ChipLogProgress(chipTool,
                " ***** Test Step 8 : 3d: If (PA & TL) TH reads CurrentPositionTiltPercentage optional attribute from DUT\n");
            if (ShouldSkip("WNCV_TL && WNCV_PA_TL && A_CURRENTPOSITIONLIFTPERCENTAGE")) {
                NextTest();
                return;
            }
            err = Test3dIfPaTlThReadsCurrentPositionTiltPercentageOptionalAttributeFromDut_8();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 9;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mFastMotionDuration;
    chip::Optional<uint16_t> mFullMotionDuration;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR Test0WaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR Test1aThSendsUpOrOpenCommandToPrepositionTheDutInTheOppositeDirection_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster upOrOpenWithCompletionHandler:^(NSError * _Nullable err) {
            NSLog(@"1a: TH sends UpOrOpen command to preposition the DUT in the opposite direction Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR Test1bThWaitsForFastMotionDurationSecondsMovementsOnTheDevice_2()
    {
        WaitForMs(mFastMotionDuration.HasValue() ? mFastMotionDuration.Value() : 3000U);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR Test2aThSendsDownOrCloseCommandToDut_3()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster downOrCloseWithCompletionHandler:^(NSError * _Nullable err) {
            NSLog(@"2a: TH sends DownOrClose command to DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR Test2bThWaitsForFullMotionDurationSecondsMovementsOnTheDevice_4()
    {
        WaitForMs(mFullMotionDuration.HasValue() ? mFullMotionDuration.Value() : 6000U);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR Test3aIfPaLfThReadsCurrentPositionLiftPercent100thsAttributeFromDut_5()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeCurrentPositionLiftPercent100thsWithCompletionHandler:^(
            NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"3a: If (PA & LF) TH reads CurrentPositionLiftPercent100ths attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNonNull("CurrentPositionLiftPercent100ths", actualValue));
                VerifyOrReturn(CheckValue("CurrentPositionLiftPercent100ths", actualValue, 10000U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR Test3bIfPaLfThReadsCurrentPositionLiftPercentageOptionalAttributeFromDut_6()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster
            readAttributeCurrentPositionLiftPercentageWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
                NSLog(@"3b: If (PA & LF) TH reads CurrentPositionLiftPercentage optional attribute from DUT Error: %@", err);

                VerifyOrReturn(CheckValue("status", err, 0));

                {
                    id actualValue = value;
                    VerifyOrReturn(CheckValueNonNull("CurrentPositionLiftPercentage", actualValue));
                    VerifyOrReturn(CheckValue("CurrentPositionLiftPercentage", actualValue, 100));
                }

                NextTest();
            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR Test3cIfPaTlThReadsCurrentPositionTiltPercent100thsAttributeFromDut_7()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeCurrentPositionTiltPercent100thsWithCompletionHandler:^(
            NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"3c: If (PA & TL) TH reads CurrentPositionTiltPercent100ths attribute from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNonNull("CurrentPositionTiltPercent100ths", actualValue));
                VerifyOrReturn(CheckValue("CurrentPositionTiltPercent100ths", actualValue, 10000U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR Test3dIfPaTlThReadsCurrentPositionTiltPercentageOptionalAttributeFromDut_8()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster
            readAttributeCurrentPositionTiltPercentageWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
                NSLog(@"3d: If (PA & TL) TH reads CurrentPositionTiltPercentage optional attribute from DUT Error: %@", err);

                VerifyOrReturn(CheckValue("status", err, 0));

                {
                    id actualValue = value;
                    VerifyOrReturn(CheckValueNonNull("CurrentPositionTiltPercentage", actualValue));
                    VerifyOrReturn(CheckValue("CurrentPositionTiltPercentage", actualValue, 100));
                }

                NextTest();
            }];

        return CHIP_NO_ERROR;
    }
};

class Test_TC_WNCV_4_3 : public TestCommandBridge {
public:
    Test_TC_WNCV_4_3()
        : TestCommandBridge("Test_TC_WNCV_4_3")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_WNCV_4_3() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_WNCV_4_3\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_WNCV_4_3\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : 0: Wait for the commissioned device to be retrieved\n");
            err = Test0WaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(
                chipTool, " ***** Test Step 1 : 1a: If (PA_LF & LF) TH reads CurrentPositionLiftPercent100ths from DUT\n");
            if (ShouldSkip("WNCV_LF && WNCV_PA_LF")) {
                NextTest();
                return;
            }
            err = Test1aIfPaLfLfThReadsCurrentPositionLiftPercent100thsFromDut_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : 1b: If (PA_LF & LF) TH reads CurrentPositionLiftPercentage from DUT\n");
            if (ShouldSkip("WNCV_LF && WNCV_PA_LF && A_CURRENTPOSITIONLIFTPERCENTAGE")) {
                NextTest();
                return;
            }
            err = Test1bIfPaLfLfThReadsCurrentPositionLiftPercentageFromDut_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : 2b: TH sends GoToLiftPercentage command with BadParam to DUT\n");
            if (ShouldSkip("WNCV_LF && WNCV_PA_LF || WNCV_LF && PICS_CR_GOTOLIFTPERCENTAGE")) {
                NextTest();
                return;
            }
            err = Test2bThSendsGoToLiftPercentageCommandWithBadParamToDut_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : 3a: TH sends GoToLiftPercentage command with 10001 to DUT\n");
            if (ShouldSkip("WNCV_LF && WNCV_PA_LF || WNCV_LF && PICS_CR_GOTOLIFTPERCENTAGE")) {
                NextTest();
                return;
            }
            err = Test3aThSendsGoToLiftPercentageCommandWith10001ToDut_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : 4a: TH sends GoToLiftPercentage command with 0xFFFF to DUT\n");
            if (ShouldSkip("WNCV_LF && WNCV_PA_LF || WNCV_LF && PICS_CR_GOTOLIFTPERCENTAGE")) {
                NextTest();
                return;
            }
            err = Test4aThSendsGoToLiftPercentageCommandWith0xFFFFToDut_5();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 6;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR Test0WaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }
    NSNumber * _Nullable attrCurrentPositionLiftPercent100ths;

    CHIP_ERROR Test1aIfPaLfLfThReadsCurrentPositionLiftPercent100thsFromDut_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeCurrentPositionLiftPercent100thsWithCompletionHandler:^(
            NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"1a: If (PA_LF & LF) TH reads CurrentPositionLiftPercent100ths from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<chip::Percent100ths>(
                    "currentPositionLiftPercent100ths", [value unsignedShortValue], 0U));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<chip::Percent100ths>(
                    "currentPositionLiftPercent100ths", [value unsignedShortValue], 10000U));
            }
            {
                attrCurrentPositionLiftPercent100ths = value;
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
    NSNumber * _Nullable attrCurrentPositionLiftPercentage;

    CHIP_ERROR Test1bIfPaLfLfThReadsCurrentPositionLiftPercentageFromDut_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster
            readAttributeCurrentPositionLiftPercentageWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
                NSLog(@"1b: If (PA_LF & LF) TH reads CurrentPositionLiftPercentage from DUT Error: %@", err);

                VerifyOrReturn(CheckValue("status", err, 0));

                if (value != nil) {
                    VerifyOrReturn(
                        CheckConstraintMinValue<chip::Percent>("currentPositionLiftPercentage", [value unsignedCharValue], 0));
                }
                if (value != nil) {
                    VerifyOrReturn(
                        CheckConstraintMaxValue<chip::Percent>("currentPositionLiftPercentage", [value unsignedCharValue], 100));
                }
                {
                    attrCurrentPositionLiftPercentage = value;
                }

                NextTest();
            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR Test2bThSendsGoToLiftPercentageCommandWithBadParamToDut_3()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPWindowCoveringClusterGoToLiftPercentageParams alloc] init];
        params.liftPercentageValue = [NSNumber numberWithUnsignedChar:63];
        params.liftPercent100thsValue = [NSNumber numberWithUnsignedShort:12288U];
        [cluster goToLiftPercentageWithParams:params
                            completionHandler:^(NSError * _Nullable err) {
                                NSLog(@"2b: TH sends GoToLiftPercentage command with BadParam to DUT Error: %@", err);

                                VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
                                NextTest();
                            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR Test3aThSendsGoToLiftPercentageCommandWith10001ToDut_4()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPWindowCoveringClusterGoToLiftPercentageParams alloc] init];
        params.liftPercentageValue = [NSNumber numberWithUnsignedChar:100];
        params.liftPercent100thsValue = [NSNumber numberWithUnsignedShort:10001U];
        [cluster goToLiftPercentageWithParams:params
                            completionHandler:^(NSError * _Nullable err) {
                                NSLog(@"3a: TH sends GoToLiftPercentage command with 10001 to DUT Error: %@", err);

                                VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
                                NextTest();
                            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR Test4aThSendsGoToLiftPercentageCommandWith0xFFFFToDut_5()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPWindowCoveringClusterGoToLiftPercentageParams alloc] init];
        params.liftPercentageValue = [NSNumber numberWithUnsignedChar:255];
        params.liftPercent100thsValue = [NSNumber numberWithUnsignedShort:65535U];
        [cluster goToLiftPercentageWithParams:params
                            completionHandler:^(NSError * _Nullable err) {
                                NSLog(@"4a: TH sends GoToLiftPercentage command with 0xFFFF to DUT Error: %@", err);

                                VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
                                NextTest();
                            }];

        return CHIP_NO_ERROR;
    }
};

class Test_TC_WNCV_4_4 : public TestCommandBridge {
public:
    Test_TC_WNCV_4_4()
        : TestCommandBridge("Test_TC_WNCV_4_4")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_WNCV_4_4() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_WNCV_4_4\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_WNCV_4_4\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : 0: Wait for the commissioned device to be retrieved\n");
            err = Test0WaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(
                chipTool, " ***** Test Step 1 : 1a: If (PA_TL & TL) TH reads CurrentPositionTiltPercent100ths from DUT\n");
            if (ShouldSkip("WNCV_TL && WNCV_PA_TL")) {
                NextTest();
                return;
            }
            err = Test1aIfPaTlTlThReadsCurrentPositionTiltPercent100thsFromDut_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : 1b: If (PA_TL & TL) TH reads CurrentPositionTiltPercentage from DUT\n");
            if (ShouldSkip("WNCV_TL && WNCV_PA_TL && A_CURRENTPOSITIONTILTPERCENTAGE")) {
                NextTest();
                return;
            }
            err = Test1bIfPaTlTlThReadsCurrentPositionTiltPercentageFromDut_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : 2b: TH sends GoToTiltPercentage command with BadParam to DUT\n");
            if (ShouldSkip("WNCV_TL && WNCV_PA_TL || WNCV_TL && PICS_CR_GOTOTILTPERCENTAGE")) {
                NextTest();
                return;
            }
            err = Test2bThSendsGoToTiltPercentageCommandWithBadParamToDut_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : 3a: TH sends GoToTiltPercentage command with 10001 to DUT\n");
            if (ShouldSkip("WNCV_TL && WNCV_PA_TL || WNCV_TL && PICS_CR_GOTOTILTPERCENTAGE")) {
                NextTest();
                return;
            }
            err = Test3aThSendsGoToTiltPercentageCommandWith10001ToDut_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : 4a: TH sends GoToTiltPercentage command with 0xFFFF to DUT\n");
            if (ShouldSkip("WNCV_TL && WNCV_PA_TL || WNCV_TL && PICS_CR_GOTOTILTPERCENTAGE")) {
                NextTest();
                return;
            }
            err = Test4aThSendsGoToTiltPercentageCommandWith0xFFFFToDut_5();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 6;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR Test0WaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }
    NSNumber * _Nullable attrCurrentPositionTiltPercent100ths;

    CHIP_ERROR Test1aIfPaTlTlThReadsCurrentPositionTiltPercent100thsFromDut_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeCurrentPositionTiltPercent100thsWithCompletionHandler:^(
            NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"1a: If (PA_TL & TL) TH reads CurrentPositionTiltPercent100ths from DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<chip::Percent100ths>(
                    "currentPositionTiltPercent100ths", [value unsignedShortValue], 0U));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<chip::Percent100ths>(
                    "currentPositionTiltPercent100ths", [value unsignedShortValue], 10000U));
            }
            {
                attrCurrentPositionTiltPercent100ths = value;
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
    NSNumber * _Nullable attrCurrentPositionTiltPercentage;

    CHIP_ERROR Test1bIfPaTlTlThReadsCurrentPositionTiltPercentageFromDut_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster
            readAttributeCurrentPositionTiltPercentageWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
                NSLog(@"1b: If (PA_TL & TL) TH reads CurrentPositionTiltPercentage from DUT Error: %@", err);

                VerifyOrReturn(CheckValue("status", err, 0));

                if (value != nil) {
                    VerifyOrReturn(
                        CheckConstraintMinValue<chip::Percent>("currentPositionTiltPercentage", [value unsignedCharValue], 0));
                }
                if (value != nil) {
                    VerifyOrReturn(
                        CheckConstraintMaxValue<chip::Percent>("currentPositionTiltPercentage", [value unsignedCharValue], 100));
                }
                {
                    attrCurrentPositionTiltPercentage = value;
                }

                NextTest();
            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR Test2bThSendsGoToTiltPercentageCommandWithBadParamToDut_3()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPWindowCoveringClusterGoToTiltPercentageParams alloc] init];
        params.tiltPercentageValue = [NSNumber numberWithUnsignedChar:63];
        params.tiltPercent100thsValue = [NSNumber numberWithUnsignedShort:12288U];
        [cluster goToTiltPercentageWithParams:params
                            completionHandler:^(NSError * _Nullable err) {
                                NSLog(@"2b: TH sends GoToTiltPercentage command with BadParam to DUT Error: %@", err);

                                VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
                                NextTest();
                            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR Test3aThSendsGoToTiltPercentageCommandWith10001ToDut_4()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPWindowCoveringClusterGoToTiltPercentageParams alloc] init];
        params.tiltPercentageValue = [NSNumber numberWithUnsignedChar:100];
        params.tiltPercent100thsValue = [NSNumber numberWithUnsignedShort:10001U];
        [cluster goToTiltPercentageWithParams:params
                            completionHandler:^(NSError * _Nullable err) {
                                NSLog(@"3a: TH sends GoToTiltPercentage command with 10001 to DUT Error: %@", err);

                                VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
                                NextTest();
                            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR Test4aThSendsGoToTiltPercentageCommandWith0xFFFFToDut_5()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestWindowCovering * cluster = [[CHIPTestWindowCovering alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPWindowCoveringClusterGoToTiltPercentageParams alloc] init];
        params.tiltPercentageValue = [NSNumber numberWithUnsignedChar:255];
        params.tiltPercent100thsValue = [NSNumber numberWithUnsignedShort:65535U];
        [cluster goToTiltPercentageWithParams:params
                            completionHandler:^(NSError * _Nullable err) {
                                NSLog(@"4a: TH sends GoToTiltPercentage command with 0xFFFF to DUT Error: %@", err);

                                VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
                                NextTest();
                            }];

        return CHIP_NO_ERROR;
    }
};

class TestCluster : public TestCommandBridge {
public:
    TestCluster()
        : TestCommandBridge("TestCluster")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~TestCluster() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: TestCluster\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: TestCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Send Test Command\n");
            err = TestSendTestCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Send Test Not Handled Command\n");
            err = TestSendTestNotHandledCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Send Test Specific Command\n");
            err = TestSendTestSpecificCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Send Test Add Arguments Command\n");
            err = TestSendTestAddArgumentsCommand_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Send failing Test Add Arguments Command\n");
            err = TestSendFailingTestAddArgumentsCommand_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Read attribute BOOLEAN Default Value\n");
            err = TestReadAttributeBooleanDefaultValue_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Write attribute BOOLEAN True\n");
            err = TestWriteAttributeBooleanTrue_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Read attribute BOOLEAN True\n");
            err = TestReadAttributeBooleanTrue_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Write attribute BOOLEAN False\n");
            err = TestWriteAttributeBooleanFalse_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Read attribute BOOLEAN False\n");
            err = TestReadAttributeBooleanFalse_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : Read attribute BITMAP8 Default Value\n");
            err = TestReadAttributeBitmap8DefaultValue_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : Write attribute BITMAP8 Max Value\n");
            err = TestWriteAttributeBitmap8MaxValue_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : Read attribute BITMAP8 Max Value\n");
            err = TestReadAttributeBitmap8MaxValue_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : Write attribute BITMAP8 Min Value\n");
            err = TestWriteAttributeBitmap8MinValue_14();
            break;
        case 15:
            ChipLogProgress(chipTool, " ***** Test Step 15 : Read attribute BITMAP8 Min Value\n");
            err = TestReadAttributeBitmap8MinValue_15();
            break;
        case 16:
            ChipLogProgress(chipTool, " ***** Test Step 16 : Read attribute BITMAP16 Default Value\n");
            err = TestReadAttributeBitmap16DefaultValue_16();
            break;
        case 17:
            ChipLogProgress(chipTool, " ***** Test Step 17 : Write attribute BITMAP16 Max Value\n");
            err = TestWriteAttributeBitmap16MaxValue_17();
            break;
        case 18:
            ChipLogProgress(chipTool, " ***** Test Step 18 : Read attribute BITMAP16 Max Value\n");
            err = TestReadAttributeBitmap16MaxValue_18();
            break;
        case 19:
            ChipLogProgress(chipTool, " ***** Test Step 19 : Write attribute BITMAP16 Min Value\n");
            err = TestWriteAttributeBitmap16MinValue_19();
            break;
        case 20:
            ChipLogProgress(chipTool, " ***** Test Step 20 : Read attribute BITMAP16 Min Value\n");
            err = TestReadAttributeBitmap16MinValue_20();
            break;
        case 21:
            ChipLogProgress(chipTool, " ***** Test Step 21 : Read attribute BITMAP32 Default Value\n");
            err = TestReadAttributeBitmap32DefaultValue_21();
            break;
        case 22:
            ChipLogProgress(chipTool, " ***** Test Step 22 : Write attribute BITMAP32 Max Value\n");
            err = TestWriteAttributeBitmap32MaxValue_22();
            break;
        case 23:
            ChipLogProgress(chipTool, " ***** Test Step 23 : Read attribute BITMAP32 Max Value\n");
            err = TestReadAttributeBitmap32MaxValue_23();
            break;
        case 24:
            ChipLogProgress(chipTool, " ***** Test Step 24 : Write attribute BITMAP32 Min Value\n");
            err = TestWriteAttributeBitmap32MinValue_24();
            break;
        case 25:
            ChipLogProgress(chipTool, " ***** Test Step 25 : Read attribute BITMAP32 Min Value\n");
            err = TestReadAttributeBitmap32MinValue_25();
            break;
        case 26:
            ChipLogProgress(chipTool, " ***** Test Step 26 : Read attribute BITMAP64 Default Value\n");
            err = TestReadAttributeBitmap64DefaultValue_26();
            break;
        case 27:
            ChipLogProgress(chipTool, " ***** Test Step 27 : Write attribute BITMAP64 Max Value\n");
            err = TestWriteAttributeBitmap64MaxValue_27();
            break;
        case 28:
            ChipLogProgress(chipTool, " ***** Test Step 28 : Read attribute BITMAP64 Max Value\n");
            err = TestReadAttributeBitmap64MaxValue_28();
            break;
        case 29:
            ChipLogProgress(chipTool, " ***** Test Step 29 : Write attribute BITMAP64 Min Value\n");
            err = TestWriteAttributeBitmap64MinValue_29();
            break;
        case 30:
            ChipLogProgress(chipTool, " ***** Test Step 30 : Read attribute BITMAP64 Min Value\n");
            err = TestReadAttributeBitmap64MinValue_30();
            break;
        case 31:
            ChipLogProgress(chipTool, " ***** Test Step 31 : Read attribute INT8U Default Value\n");
            err = TestReadAttributeInt8uDefaultValue_31();
            break;
        case 32:
            ChipLogProgress(chipTool, " ***** Test Step 32 : Write attribute INT8U Max Value\n");
            err = TestWriteAttributeInt8uMaxValue_32();
            break;
        case 33:
            ChipLogProgress(chipTool, " ***** Test Step 33 : Read attribute INT8U Max Value\n");
            err = TestReadAttributeInt8uMaxValue_33();
            break;
        case 34:
            ChipLogProgress(chipTool, " ***** Test Step 34 : Write attribute INT8U Min Value\n");
            err = TestWriteAttributeInt8uMinValue_34();
            break;
        case 35:
            ChipLogProgress(chipTool, " ***** Test Step 35 : Read attribute INT8U Min Value\n");
            err = TestReadAttributeInt8uMinValue_35();
            break;
        case 36:
            ChipLogProgress(chipTool, " ***** Test Step 36 : Read attribute INT16U Default Value\n");
            err = TestReadAttributeInt16uDefaultValue_36();
            break;
        case 37:
            ChipLogProgress(chipTool, " ***** Test Step 37 : Write attribute INT16U Max Value\n");
            err = TestWriteAttributeInt16uMaxValue_37();
            break;
        case 38:
            ChipLogProgress(chipTool, " ***** Test Step 38 : Read attribute INT16U Max Value\n");
            err = TestReadAttributeInt16uMaxValue_38();
            break;
        case 39:
            ChipLogProgress(chipTool, " ***** Test Step 39 : Write attribute INT16U Min Value\n");
            err = TestWriteAttributeInt16uMinValue_39();
            break;
        case 40:
            ChipLogProgress(chipTool, " ***** Test Step 40 : Read attribute INT16U Min Value\n");
            err = TestReadAttributeInt16uMinValue_40();
            break;
        case 41:
            ChipLogProgress(chipTool, " ***** Test Step 41 : Read attribute INT32U Default Value\n");
            err = TestReadAttributeInt32uDefaultValue_41();
            break;
        case 42:
            ChipLogProgress(chipTool, " ***** Test Step 42 : Write attribute INT32U Max Value\n");
            err = TestWriteAttributeInt32uMaxValue_42();
            break;
        case 43:
            ChipLogProgress(chipTool, " ***** Test Step 43 : Read attribute INT32U Max Value\n");
            err = TestReadAttributeInt32uMaxValue_43();
            break;
        case 44:
            ChipLogProgress(chipTool, " ***** Test Step 44 : Write attribute INT32U Min Value\n");
            err = TestWriteAttributeInt32uMinValue_44();
            break;
        case 45:
            ChipLogProgress(chipTool, " ***** Test Step 45 : Read attribute INT32U Min Value\n");
            err = TestReadAttributeInt32uMinValue_45();
            break;
        case 46:
            ChipLogProgress(chipTool, " ***** Test Step 46 : Read attribute INT64U Default Value\n");
            err = TestReadAttributeInt64uDefaultValue_46();
            break;
        case 47:
            ChipLogProgress(chipTool, " ***** Test Step 47 : Write attribute INT64U Max Value\n");
            err = TestWriteAttributeInt64uMaxValue_47();
            break;
        case 48:
            ChipLogProgress(chipTool, " ***** Test Step 48 : Read attribute INT64U Max Value\n");
            err = TestReadAttributeInt64uMaxValue_48();
            break;
        case 49:
            ChipLogProgress(chipTool, " ***** Test Step 49 : Write attribute INT64U Min Value\n");
            err = TestWriteAttributeInt64uMinValue_49();
            break;
        case 50:
            ChipLogProgress(chipTool, " ***** Test Step 50 : Read attribute INT64U Min Value\n");
            err = TestReadAttributeInt64uMinValue_50();
            break;
        case 51:
            ChipLogProgress(chipTool, " ***** Test Step 51 : Read attribute INT8S Default Value\n");
            err = TestReadAttributeInt8sDefaultValue_51();
            break;
        case 52:
            ChipLogProgress(chipTool, " ***** Test Step 52 : Write attribute INT8S Max Value\n");
            err = TestWriteAttributeInt8sMaxValue_52();
            break;
        case 53:
            ChipLogProgress(chipTool, " ***** Test Step 53 : Read attribute INT8S Max Value\n");
            err = TestReadAttributeInt8sMaxValue_53();
            break;
        case 54:
            ChipLogProgress(chipTool, " ***** Test Step 54 : Write attribute INT8S Min Value\n");
            err = TestWriteAttributeInt8sMinValue_54();
            break;
        case 55:
            ChipLogProgress(chipTool, " ***** Test Step 55 : Read attribute INT8S Min Value\n");
            err = TestReadAttributeInt8sMinValue_55();
            break;
        case 56:
            ChipLogProgress(chipTool, " ***** Test Step 56 : Write attribute INT8S Default Value\n");
            err = TestWriteAttributeInt8sDefaultValue_56();
            break;
        case 57:
            ChipLogProgress(chipTool, " ***** Test Step 57 : Read attribute INT8S Default Value\n");
            err = TestReadAttributeInt8sDefaultValue_57();
            break;
        case 58:
            ChipLogProgress(chipTool, " ***** Test Step 58 : Read attribute INT16S Default Value\n");
            err = TestReadAttributeInt16sDefaultValue_58();
            break;
        case 59:
            ChipLogProgress(chipTool, " ***** Test Step 59 : Write attribute INT16S Max Value\n");
            err = TestWriteAttributeInt16sMaxValue_59();
            break;
        case 60:
            ChipLogProgress(chipTool, " ***** Test Step 60 : Read attribute INT16S Max Value\n");
            err = TestReadAttributeInt16sMaxValue_60();
            break;
        case 61:
            ChipLogProgress(chipTool, " ***** Test Step 61 : Write attribute INT16S Min Value\n");
            err = TestWriteAttributeInt16sMinValue_61();
            break;
        case 62:
            ChipLogProgress(chipTool, " ***** Test Step 62 : Read attribute INT16S Min Value\n");
            err = TestReadAttributeInt16sMinValue_62();
            break;
        case 63:
            ChipLogProgress(chipTool, " ***** Test Step 63 : Write attribute INT16S Default Value\n");
            err = TestWriteAttributeInt16sDefaultValue_63();
            break;
        case 64:
            ChipLogProgress(chipTool, " ***** Test Step 64 : Read attribute INT16S Default Value\n");
            err = TestReadAttributeInt16sDefaultValue_64();
            break;
        case 65:
            ChipLogProgress(chipTool, " ***** Test Step 65 : Read attribute INT32S Default Value\n");
            err = TestReadAttributeInt32sDefaultValue_65();
            break;
        case 66:
            ChipLogProgress(chipTool, " ***** Test Step 66 : Write attribute INT32S Max Value\n");
            err = TestWriteAttributeInt32sMaxValue_66();
            break;
        case 67:
            ChipLogProgress(chipTool, " ***** Test Step 67 : Read attribute INT32S Max Value\n");
            err = TestReadAttributeInt32sMaxValue_67();
            break;
        case 68:
            ChipLogProgress(chipTool, " ***** Test Step 68 : Write attribute INT32S Min Value\n");
            err = TestWriteAttributeInt32sMinValue_68();
            break;
        case 69:
            ChipLogProgress(chipTool, " ***** Test Step 69 : Read attribute INT32S Min Value\n");
            err = TestReadAttributeInt32sMinValue_69();
            break;
        case 70:
            ChipLogProgress(chipTool, " ***** Test Step 70 : Write attribute INT32S Default Value\n");
            err = TestWriteAttributeInt32sDefaultValue_70();
            break;
        case 71:
            ChipLogProgress(chipTool, " ***** Test Step 71 : Read attribute INT32S Default Value\n");
            err = TestReadAttributeInt32sDefaultValue_71();
            break;
        case 72:
            ChipLogProgress(chipTool, " ***** Test Step 72 : Read attribute INT64S Default Value\n");
            err = TestReadAttributeInt64sDefaultValue_72();
            break;
        case 73:
            ChipLogProgress(chipTool, " ***** Test Step 73 : Write attribute INT64S Max Value\n");
            err = TestWriteAttributeInt64sMaxValue_73();
            break;
        case 74:
            ChipLogProgress(chipTool, " ***** Test Step 74 : Read attribute INT64S Max Value\n");
            err = TestReadAttributeInt64sMaxValue_74();
            break;
        case 75:
            ChipLogProgress(chipTool, " ***** Test Step 75 : Write attribute INT64S Min Value\n");
            err = TestWriteAttributeInt64sMinValue_75();
            break;
        case 76:
            ChipLogProgress(chipTool, " ***** Test Step 76 : Read attribute INT64S Min Value\n");
            err = TestReadAttributeInt64sMinValue_76();
            break;
        case 77:
            ChipLogProgress(chipTool, " ***** Test Step 77 : Write attribute INT64S Default Value\n");
            err = TestWriteAttributeInt64sDefaultValue_77();
            break;
        case 78:
            ChipLogProgress(chipTool, " ***** Test Step 78 : Read attribute INT64S Default Value\n");
            err = TestReadAttributeInt64sDefaultValue_78();
            break;
        case 79:
            ChipLogProgress(chipTool, " ***** Test Step 79 : Read attribute SINGLE Default Value\n");
            err = TestReadAttributeSingleDefaultValue_79();
            break;
        case 80:
            ChipLogProgress(chipTool, " ***** Test Step 80 : Write attribute SINGLE medium Value\n");
            err = TestWriteAttributeSingleMediumValue_80();
            break;
        case 81:
            ChipLogProgress(chipTool, " ***** Test Step 81 : Read attribute SINGLE medium Value\n");
            err = TestReadAttributeSingleMediumValue_81();
            break;
        case 82:
            ChipLogProgress(chipTool, " ***** Test Step 82 : Write attribute SINGLE large Value\n");
            err = TestWriteAttributeSingleLargeValue_82();
            break;
        case 83:
            ChipLogProgress(chipTool, " ***** Test Step 83 : Read attribute SINGLE large Value\n");
            err = TestReadAttributeSingleLargeValue_83();
            break;
        case 84:
            ChipLogProgress(chipTool, " ***** Test Step 84 : Write attribute SINGLE small Value\n");
            err = TestWriteAttributeSingleSmallValue_84();
            break;
        case 85:
            ChipLogProgress(chipTool, " ***** Test Step 85 : Read attribute SINGLE small Value\n");
            err = TestReadAttributeSingleSmallValue_85();
            break;
        case 86:
            ChipLogProgress(chipTool, " ***** Test Step 86 : Write attribute SINGLE Default Value\n");
            err = TestWriteAttributeSingleDefaultValue_86();
            break;
        case 87:
            ChipLogProgress(chipTool, " ***** Test Step 87 : Read attribute SINGLE Default Value\n");
            err = TestReadAttributeSingleDefaultValue_87();
            break;
        case 88:
            ChipLogProgress(chipTool, " ***** Test Step 88 : Read attribute DOUBLE Default Value\n");
            err = TestReadAttributeDoubleDefaultValue_88();
            break;
        case 89:
            ChipLogProgress(chipTool, " ***** Test Step 89 : Write attribute DOUBLE medium Value\n");
            err = TestWriteAttributeDoubleMediumValue_89();
            break;
        case 90:
            ChipLogProgress(chipTool, " ***** Test Step 90 : Read attribute DOUBLE medium Value\n");
            err = TestReadAttributeDoubleMediumValue_90();
            break;
        case 91:
            ChipLogProgress(chipTool, " ***** Test Step 91 : Write attribute DOUBLE large Value\n");
            err = TestWriteAttributeDoubleLargeValue_91();
            break;
        case 92:
            ChipLogProgress(chipTool, " ***** Test Step 92 : Read attribute DOUBLE large Value\n");
            err = TestReadAttributeDoubleLargeValue_92();
            break;
        case 93:
            ChipLogProgress(chipTool, " ***** Test Step 93 : Write attribute DOUBLE small Value\n");
            err = TestWriteAttributeDoubleSmallValue_93();
            break;
        case 94:
            ChipLogProgress(chipTool, " ***** Test Step 94 : Read attribute DOUBLE small Value\n");
            err = TestReadAttributeDoubleSmallValue_94();
            break;
        case 95:
            ChipLogProgress(chipTool, " ***** Test Step 95 : Write attribute DOUBLE Default Value\n");
            err = TestWriteAttributeDoubleDefaultValue_95();
            break;
        case 96:
            ChipLogProgress(chipTool, " ***** Test Step 96 : Read attribute DOUBLE Default Value\n");
            err = TestReadAttributeDoubleDefaultValue_96();
            break;
        case 97:
            ChipLogProgress(chipTool, " ***** Test Step 97 : Read attribute ENUM8 Default Value\n");
            err = TestReadAttributeEnum8DefaultValue_97();
            break;
        case 98:
            ChipLogProgress(chipTool, " ***** Test Step 98 : Write attribute ENUM8 Max Value\n");
            err = TestWriteAttributeEnum8MaxValue_98();
            break;
        case 99:
            ChipLogProgress(chipTool, " ***** Test Step 99 : Read attribute ENUM8 Max Value\n");
            err = TestReadAttributeEnum8MaxValue_99();
            break;
        case 100:
            ChipLogProgress(chipTool, " ***** Test Step 100 : Write attribute ENUM8 Min Value\n");
            err = TestWriteAttributeEnum8MinValue_100();
            break;
        case 101:
            ChipLogProgress(chipTool, " ***** Test Step 101 : Read attribute ENUM8 Min Value\n");
            err = TestReadAttributeEnum8MinValue_101();
            break;
        case 102:
            ChipLogProgress(chipTool, " ***** Test Step 102 : Read attribute ENUM16 Default Value\n");
            err = TestReadAttributeEnum16DefaultValue_102();
            break;
        case 103:
            ChipLogProgress(chipTool, " ***** Test Step 103 : Write attribute ENUM16 Max Value\n");
            err = TestWriteAttributeEnum16MaxValue_103();
            break;
        case 104:
            ChipLogProgress(chipTool, " ***** Test Step 104 : Read attribute ENUM16 Max Value\n");
            err = TestReadAttributeEnum16MaxValue_104();
            break;
        case 105:
            ChipLogProgress(chipTool, " ***** Test Step 105 : Write attribute ENUM16 Min Value\n");
            err = TestWriteAttributeEnum16MinValue_105();
            break;
        case 106:
            ChipLogProgress(chipTool, " ***** Test Step 106 : Read attribute ENUM16 Min Value\n");
            err = TestReadAttributeEnum16MinValue_106();
            break;
        case 107:
            ChipLogProgress(chipTool, " ***** Test Step 107 : Read attribute OCTET_STRING Default Value\n");
            err = TestReadAttributeOctetStringDefaultValue_107();
            break;
        case 108:
            ChipLogProgress(chipTool, " ***** Test Step 108 : Write attribute OCTET_STRING with embedded null\n");
            err = TestWriteAttributeOctetStringWithEmbeddedNull_108();
            break;
        case 109:
            ChipLogProgress(chipTool, " ***** Test Step 109 : Read attribute OCTET_STRING with embedded null\n");
            err = TestReadAttributeOctetStringWithEmbeddedNull_109();
            break;
        case 110:
            ChipLogProgress(chipTool, " ***** Test Step 110 : Write attribute OCTET_STRING with weird chars\n");
            err = TestWriteAttributeOctetStringWithWeirdChars_110();
            break;
        case 111:
            ChipLogProgress(chipTool, " ***** Test Step 111 : Read attribute OCTET_STRING with weird chars\n");
            err = TestReadAttributeOctetStringWithWeirdChars_111();
            break;
        case 112:
            ChipLogProgress(chipTool, " ***** Test Step 112 : Write attribute OCTET_STRING\n");
            err = TestWriteAttributeOctetString_112();
            break;
        case 113:
            ChipLogProgress(chipTool, " ***** Test Step 113 : Read attribute OCTET_STRING\n");
            err = TestReadAttributeOctetString_113();
            break;
        case 114:
            ChipLogProgress(chipTool, " ***** Test Step 114 : Write attribute OCTET_STRING\n");
            err = TestWriteAttributeOctetString_114();
            break;
        case 115:
            ChipLogProgress(chipTool, " ***** Test Step 115 : Read attribute OCTET_STRING\n");
            err = TestReadAttributeOctetString_115();
            break;
        case 116:
            ChipLogProgress(chipTool, " ***** Test Step 116 : Write attribute OCTET_STRING\n");
            err = TestWriteAttributeOctetString_116();
            break;
        case 117:
            ChipLogProgress(chipTool, " ***** Test Step 117 : Read attribute LONG_OCTET_STRING Default Value\n");
            err = TestReadAttributeLongOctetStringDefaultValue_117();
            break;
        case 118:
            ChipLogProgress(chipTool, " ***** Test Step 118 : Write attribute LONG_OCTET_STRING\n");
            err = TestWriteAttributeLongOctetString_118();
            break;
        case 119:
            ChipLogProgress(chipTool, " ***** Test Step 119 : Read attribute LONG_OCTET_STRING\n");
            err = TestReadAttributeLongOctetString_119();
            break;
        case 120:
            ChipLogProgress(chipTool, " ***** Test Step 120 : Write attribute LONG_OCTET_STRING\n");
            err = TestWriteAttributeLongOctetString_120();
            break;
        case 121:
            ChipLogProgress(chipTool, " ***** Test Step 121 : Read attribute CHAR_STRING Default Value\n");
            err = TestReadAttributeCharStringDefaultValue_121();
            break;
        case 122:
            ChipLogProgress(chipTool, " ***** Test Step 122 : Write attribute CHAR_STRING\n");
            err = TestWriteAttributeCharString_122();
            break;
        case 123:
            ChipLogProgress(chipTool, " ***** Test Step 123 : Read attribute CHAR_STRING\n");
            err = TestReadAttributeCharString_123();
            break;
        case 124:
            ChipLogProgress(chipTool, " ***** Test Step 124 : Write attribute CHAR_STRING - Value too long\n");
            err = TestWriteAttributeCharStringValueTooLong_124();
            break;
        case 125:
            ChipLogProgress(chipTool, " ***** Test Step 125 : Read attribute CHAR_STRING\n");
            err = TestReadAttributeCharString_125();
            break;
        case 126:
            ChipLogProgress(chipTool, " ***** Test Step 126 : Write attribute CHAR_STRING - Empty\n");
            err = TestWriteAttributeCharStringEmpty_126();
            break;
        case 127:
            ChipLogProgress(chipTool, " ***** Test Step 127 : Read attribute LONG_CHAR_STRING Default Value\n");
            err = TestReadAttributeLongCharStringDefaultValue_127();
            break;
        case 128:
            ChipLogProgress(chipTool, " ***** Test Step 128 : Write attribute LONG_CHAR_STRING\n");
            err = TestWriteAttributeLongCharString_128();
            break;
        case 129:
            ChipLogProgress(chipTool, " ***** Test Step 129 : Read attribute LONG_CHAR_STRING\n");
            err = TestReadAttributeLongCharString_129();
            break;
        case 130:
            ChipLogProgress(chipTool, " ***** Test Step 130 : Write attribute LONG_CHAR_STRING\n");
            err = TestWriteAttributeLongCharString_130();
            break;
        case 131:
            ChipLogProgress(chipTool, " ***** Test Step 131 : Read attribute LIST_LONG_OCTET_STRING (for chunked read)\n");
            err = TestReadAttributeListLongOctetStringForChunkedRead_131();
            break;
        case 132:
            ChipLogProgress(chipTool, " ***** Test Step 132 : Write attribute LIST_LONG_OCTET_STRING (for chunked write)\n");
            err = TestWriteAttributeListLongOctetStringForChunkedWrite_132();
            break;
        case 133:
            ChipLogProgress(chipTool, " ***** Test Step 133 : Read attribute LIST_LONG_OCTET_STRING (for chunked read)\n");
            err = TestReadAttributeListLongOctetStringForChunkedRead_133();
            break;
        case 134:
            ChipLogProgress(chipTool, " ***** Test Step 134 : Read attribute EPOCH_US Default Value\n");
            err = TestReadAttributeEpochUsDefaultValue_134();
            break;
        case 135:
            ChipLogProgress(chipTool, " ***** Test Step 135 : Write attribute EPOCH_US Max Value\n");
            err = TestWriteAttributeEpochUsMaxValue_135();
            break;
        case 136:
            ChipLogProgress(chipTool, " ***** Test Step 136 : Read attribute EPOCH_US Max Value\n");
            err = TestReadAttributeEpochUsMaxValue_136();
            break;
        case 137:
            ChipLogProgress(chipTool, " ***** Test Step 137 : Write attribute EPOCH_US Min Value\n");
            err = TestWriteAttributeEpochUsMinValue_137();
            break;
        case 138:
            ChipLogProgress(chipTool, " ***** Test Step 138 : Read attribute EPOCH_US Min Value\n");
            err = TestReadAttributeEpochUsMinValue_138();
            break;
        case 139:
            ChipLogProgress(chipTool, " ***** Test Step 139 : Read attribute EPOCH_S Default Value\n");
            err = TestReadAttributeEpochSDefaultValue_139();
            break;
        case 140:
            ChipLogProgress(chipTool, " ***** Test Step 140 : Write attribute EPOCH_S Max Value\n");
            err = TestWriteAttributeEpochSMaxValue_140();
            break;
        case 141:
            ChipLogProgress(chipTool, " ***** Test Step 141 : Read attribute EPOCH_S Max Value\n");
            err = TestReadAttributeEpochSMaxValue_141();
            break;
        case 142:
            ChipLogProgress(chipTool, " ***** Test Step 142 : Write attribute EPOCH_S Min Value\n");
            err = TestWriteAttributeEpochSMinValue_142();
            break;
        case 143:
            ChipLogProgress(chipTool, " ***** Test Step 143 : Read attribute EPOCH_S Min Value\n");
            err = TestReadAttributeEpochSMinValue_143();
            break;
        case 144:
            ChipLogProgress(chipTool, " ***** Test Step 144 : Read attribute UNSUPPORTED\n");
            err = TestReadAttributeUnsupported_144();
            break;
        case 145:
            ChipLogProgress(chipTool, " ***** Test Step 145 : Writeattribute UNSUPPORTED\n");
            err = TestWriteattributeUnsupported_145();
            break;
        case 146:
            ChipLogProgress(chipTool, " ***** Test Step 146 : Send Test Command to unsupported endpoint\n");
            err = TestSendTestCommandToUnsupportedEndpoint_146();
            break;
        case 147:
            ChipLogProgress(chipTool, " ***** Test Step 147 : Send Test Command to unsupported cluster\n");
            err = TestSendTestCommandToUnsupportedCluster_147();
            break;
        case 148:
            ChipLogProgress(chipTool, " ***** Test Step 148 : Read attribute vendor_id Default Value\n");
            err = TestReadAttributeVendorIdDefaultValue_148();
            break;
        case 149:
            ChipLogProgress(chipTool, " ***** Test Step 149 : Write attribute vendor_id\n");
            err = TestWriteAttributeVendorId_149();
            break;
        case 150:
            ChipLogProgress(chipTool, " ***** Test Step 150 : Read attribute vendor_id\n");
            err = TestReadAttributeVendorId_150();
            break;
        case 151:
            ChipLogProgress(chipTool, " ***** Test Step 151 : Restore attribute vendor_id\n");
            err = TestRestoreAttributeVendorId_151();
            break;
        case 152:
            ChipLogProgress(chipTool, " ***** Test Step 152 : Send a command with a vendor_id and enum\n");
            err = TestSendACommandWithAVendorIdAndEnum_152();
            break;
        case 153:
            ChipLogProgress(chipTool, " ***** Test Step 153 : Send Test Command With Struct Argument and arg1.b is true\n");
            err = TestSendTestCommandWithStructArgumentAndArg1bIsTrue_153();
            break;
        case 154:
            ChipLogProgress(chipTool, " ***** Test Step 154 : Send Test Command With Struct Argument and arg1.b is false\n");
            err = TestSendTestCommandWithStructArgumentAndArg1bIsFalse_154();
            break;
        case 155:
            ChipLogProgress(
                chipTool, " ***** Test Step 155 : Send Test Command With Nested Struct Argument and arg1.c.b is true\n");
            err = TestSendTestCommandWithNestedStructArgumentAndArg1cbIsTrue_155();
            break;
        case 156:
            ChipLogProgress(chipTool, " ***** Test Step 156 : Send Test Command With Nested Struct Argument arg1.c.b is false\n");
            err = TestSendTestCommandWithNestedStructArgumentArg1cbIsFalse_156();
            break;
        case 157:
            ChipLogProgress(chipTool,
                " ***** Test Step 157 : Send Test Command With Nested Struct List Argument and all fields b of arg1.d are true\n");
            err = TestSendTestCommandWithNestedStructListArgumentAndAllFieldsBOfArg1dAreTrue_157();
            break;
        case 158:
            ChipLogProgress(chipTool,
                " ***** Test Step 158 : Send Test Command With Nested Struct List Argument and some fields b of arg1.d are "
                "false\n");
            err = TestSendTestCommandWithNestedStructListArgumentAndSomeFieldsBOfArg1dAreFalse_158();
            break;
        case 159:
            ChipLogProgress(chipTool, " ***** Test Step 159 : Send Test Command With Struct Argument and see what we get back\n");
            err = TestSendTestCommandWithStructArgumentAndSeeWhatWeGetBack_159();
            break;
        case 160:
            ChipLogProgress(chipTool, " ***** Test Step 160 : Send Test Command With List of INT8U and none of them is set to 0\n");
            err = TestSendTestCommandWithListOfInt8uAndNoneOfThemIsSetTo0_160();
            break;
        case 161:
            ChipLogProgress(chipTool, " ***** Test Step 161 : Send Test Command With List of INT8U and one of them is set to 0\n");
            err = TestSendTestCommandWithListOfInt8uAndOneOfThemIsSetTo0_161();
            break;
        case 162:
            ChipLogProgress(chipTool, " ***** Test Step 162 : Send Test Command With List of INT8U and get it reversed\n");
            err = TestSendTestCommandWithListOfInt8uAndGetItReversed_162();
            break;
        case 163:
            ChipLogProgress(
                chipTool, " ***** Test Step 163 : Send Test Command With empty List of INT8U and get an empty list back\n");
            err = TestSendTestCommandWithEmptyListOfInt8uAndGetAnEmptyListBack_163();
            break;
        case 164:
            ChipLogProgress(chipTool,
                " ***** Test Step 164 : Send Test Command With List of Struct Argument and arg1.b of first item is true\n");
            err = TestSendTestCommandWithListOfStructArgumentAndArg1bOfFirstItemIsTrue_164();
            break;
        case 165:
            ChipLogProgress(chipTool,
                " ***** Test Step 165 : Send Test Command With List of Struct Argument and arg1.b of first item is false\n");
            err = TestSendTestCommandWithListOfStructArgumentAndArg1bOfFirstItemIsFalse_165();
            break;
        case 166:
            ChipLogProgress(chipTool,
                " ***** Test Step 166 : Send Test Command With List of Nested Struct List Argument and all fields b of elements of "
                "arg1.d are true\n");
            err = TestSendTestCommandWithListOfNestedStructListArgumentAndAllFieldsBOfElementsOfArg1dAreTrue_166();
            break;
        case 167:
            ChipLogProgress(chipTool,
                " ***** Test Step 167 : Send Test Command With Nested Struct List Argument and some fields b of elements of arg1.d "
                "are false\n");
            err = TestSendTestCommandWithNestedStructListArgumentAndSomeFieldsBOfElementsOfArg1dAreFalse_167();
            break;
        case 168:
            ChipLogProgress(
                chipTool, " ***** Test Step 168 : Write attribute LIST With List of INT8U and none of them is set to 0\n");
            err = TestWriteAttributeListWithListOfInt8uAndNoneOfThemIsSetTo0_168();
            break;
        case 169:
            ChipLogProgress(chipTool, " ***** Test Step 169 : Read attribute LIST With List of INT8U\n");
            err = TestReadAttributeListWithListOfInt8u_169();
            break;
        case 170:
            ChipLogProgress(chipTool, " ***** Test Step 170 : Write attribute LIST With List of OCTET_STRING\n");
            err = TestWriteAttributeListWithListOfOctetString_170();
            break;
        case 171:
            ChipLogProgress(chipTool, " ***** Test Step 171 : Read attribute LIST With List of OCTET_STRING\n");
            err = TestReadAttributeListWithListOfOctetString_171();
            break;
        case 172:
            ChipLogProgress(chipTool, " ***** Test Step 172 : Write attribute LIST With List of LIST_STRUCT_OCTET_STRING\n");
            err = TestWriteAttributeListWithListOfListStructOctetString_172();
            break;
        case 173:
            ChipLogProgress(chipTool, " ***** Test Step 173 : Read attribute LIST With List of LIST_STRUCT_OCTET_STRING\n");
            err = TestReadAttributeListWithListOfListStructOctetString_173();
            break;
        case 174:
            ChipLogProgress(chipTool, " ***** Test Step 174 : Send Test Command with optional arg set.\n");
            err = TestSendTestCommandWithOptionalArgSet_174();
            break;
        case 175:
            ChipLogProgress(chipTool, " ***** Test Step 175 : Send Test Command without its optional arg.\n");
            err = TestSendTestCommandWithoutItsOptionalArg_175();
            break;
        case 176:
            ChipLogProgress(chipTool, " ***** Test Step 176 : Read list of structs containing nullables and optionals\n");
            err = TestReadListOfStructsContainingNullablesAndOptionals_176();
            break;
        case 177:
            ChipLogProgress(chipTool, " ***** Test Step 177 : Write list of structs containing nullables and optionals\n");
            err = TestWriteListOfStructsContainingNullablesAndOptionals_177();
            break;
        case 178:
            ChipLogProgress(
                chipTool, " ***** Test Step 178 : Read list of structs containing nullables and optionals after writing\n");
            err = TestReadListOfStructsContainingNullablesAndOptionalsAfterWriting_178();
            break;
        case 179:
            ChipLogProgress(chipTool, " ***** Test Step 179 : Write attribute NULLABLE_BOOLEAN null\n");
            err = TestWriteAttributeNullableBooleanNull_179();
            break;
        case 180:
            ChipLogProgress(chipTool, " ***** Test Step 180 : Read attribute NULLABLE_BOOLEAN null\n");
            err = TestReadAttributeNullableBooleanNull_180();
            break;
        case 181:
            ChipLogProgress(chipTool, " ***** Test Step 181 : Write attribute NULLABLE_BOOLEAN True\n");
            err = TestWriteAttributeNullableBooleanTrue_181();
            break;
        case 182:
            ChipLogProgress(chipTool, " ***** Test Step 182 : Read attribute NULLABLE_BOOLEAN True\n");
            err = TestReadAttributeNullableBooleanTrue_182();
            break;
        case 183:
            ChipLogProgress(chipTool, " ***** Test Step 183 : Write attribute NULLABLE_BITMAP8 Max Value\n");
            err = TestWriteAttributeNullableBitmap8MaxValue_183();
            break;
        case 184:
            ChipLogProgress(chipTool, " ***** Test Step 184 : Read attribute NULLABLE_BITMAP8 Max Value\n");
            err = TestReadAttributeNullableBitmap8MaxValue_184();
            break;
        case 185:
            ChipLogProgress(chipTool, " ***** Test Step 185 : Write attribute NULLABLE_BITMAP8 Invalid Value\n");
            err = TestWriteAttributeNullableBitmap8InvalidValue_185();
            break;
        case 186:
            ChipLogProgress(chipTool, " ***** Test Step 186 : Read attribute NULLABLE_BITMAP8 unchanged Value\n");
            err = TestReadAttributeNullableBitmap8UnchangedValue_186();
            break;
        case 187:
            ChipLogProgress(chipTool, " ***** Test Step 187 : Write attribute NULLABLE_BITMAP8 null Value\n");
            err = TestWriteAttributeNullableBitmap8NullValue_187();
            break;
        case 188:
            ChipLogProgress(chipTool, " ***** Test Step 188 : Read attribute NULLABLE_BITMAP8 null Value\n");
            err = TestReadAttributeNullableBitmap8NullValue_188();
            break;
        case 189:
            ChipLogProgress(chipTool, " ***** Test Step 189 : Write attribute NULLABLE_BITMAP16 Max Value\n");
            err = TestWriteAttributeNullableBitmap16MaxValue_189();
            break;
        case 190:
            ChipLogProgress(chipTool, " ***** Test Step 190 : Read attribute NULLABLE_BITMAP16 Max Value\n");
            err = TestReadAttributeNullableBitmap16MaxValue_190();
            break;
        case 191:
            ChipLogProgress(chipTool, " ***** Test Step 191 : Write attribute NULLABLE_BITMAP16 Invalid Value\n");
            err = TestWriteAttributeNullableBitmap16InvalidValue_191();
            break;
        case 192:
            ChipLogProgress(chipTool, " ***** Test Step 192 : Read attribute NULLABLE_BITMAP16 unchanged Value\n");
            err = TestReadAttributeNullableBitmap16UnchangedValue_192();
            break;
        case 193:
            ChipLogProgress(chipTool, " ***** Test Step 193 : Write attribute NULLABLE_BITMAP16 null Value\n");
            err = TestWriteAttributeNullableBitmap16NullValue_193();
            break;
        case 194:
            ChipLogProgress(chipTool, " ***** Test Step 194 : Read attribute NULLABLE_BITMAP16 null Value\n");
            err = TestReadAttributeNullableBitmap16NullValue_194();
            break;
        case 195:
            ChipLogProgress(chipTool, " ***** Test Step 195 : Write attribute NULLABLE_BITMAP32 Max Value\n");
            err = TestWriteAttributeNullableBitmap32MaxValue_195();
            break;
        case 196:
            ChipLogProgress(chipTool, " ***** Test Step 196 : Read attribute NULLABLE_BITMAP32 Max Value\n");
            err = TestReadAttributeNullableBitmap32MaxValue_196();
            break;
        case 197:
            ChipLogProgress(chipTool, " ***** Test Step 197 : Write attribute NULLABLE_BITMAP32 Invalid Value\n");
            err = TestWriteAttributeNullableBitmap32InvalidValue_197();
            break;
        case 198:
            ChipLogProgress(chipTool, " ***** Test Step 198 : Read attribute NULLABLE_BITMAP32 unchanged Value\n");
            err = TestReadAttributeNullableBitmap32UnchangedValue_198();
            break;
        case 199:
            ChipLogProgress(chipTool, " ***** Test Step 199 : Write attribute NULLABLE_BITMAP32 null Value\n");
            err = TestWriteAttributeNullableBitmap32NullValue_199();
            break;
        case 200:
            ChipLogProgress(chipTool, " ***** Test Step 200 : Read attribute NULLABLE_BITMAP32 null Value\n");
            err = TestReadAttributeNullableBitmap32NullValue_200();
            break;
        case 201:
            ChipLogProgress(chipTool, " ***** Test Step 201 : Write attribute NULLABLE_BITMAP64 Max Value\n");
            err = TestWriteAttributeNullableBitmap64MaxValue_201();
            break;
        case 202:
            ChipLogProgress(chipTool, " ***** Test Step 202 : Read attribute NULLABLE_BITMAP64 Max Value\n");
            err = TestReadAttributeNullableBitmap64MaxValue_202();
            break;
        case 203:
            ChipLogProgress(chipTool, " ***** Test Step 203 : Write attribute NULLABLE_BITMAP64 Invalid Value\n");
            err = TestWriteAttributeNullableBitmap64InvalidValue_203();
            break;
        case 204:
            ChipLogProgress(chipTool, " ***** Test Step 204 : Read attribute NULLABLE_BITMAP64 unchanged Value\n");
            err = TestReadAttributeNullableBitmap64UnchangedValue_204();
            break;
        case 205:
            ChipLogProgress(chipTool, " ***** Test Step 205 : Write attribute NULLABLE_BITMAP64 null Value\n");
            err = TestWriteAttributeNullableBitmap64NullValue_205();
            break;
        case 206:
            ChipLogProgress(chipTool, " ***** Test Step 206 : Read attribute NULLABLE_BITMAP64 null Value\n");
            err = TestReadAttributeNullableBitmap64NullValue_206();
            break;
        case 207:
            ChipLogProgress(chipTool, " ***** Test Step 207 : Write attribute NULLABLE_INT8U Min Value\n");
            err = TestWriteAttributeNullableInt8uMinValue_207();
            break;
        case 208:
            ChipLogProgress(chipTool, " ***** Test Step 208 : Read attribute NULLABLE_INT8U Min Value\n");
            err = TestReadAttributeNullableInt8uMinValue_208();
            break;
        case 209:
            ChipLogProgress(chipTool, " ***** Test Step 209 : Write attribute NULLABLE_INT8U Max Value\n");
            err = TestWriteAttributeNullableInt8uMaxValue_209();
            break;
        case 210:
            ChipLogProgress(chipTool, " ***** Test Step 210 : Read attribute NULLABLE_INT8U Max Value\n");
            err = TestReadAttributeNullableInt8uMaxValue_210();
            break;
        case 211:
            ChipLogProgress(chipTool, " ***** Test Step 211 : Write attribute NULLABLE_INT8U Invalid Value\n");
            err = TestWriteAttributeNullableInt8uInvalidValue_211();
            break;
        case 212:
            ChipLogProgress(chipTool, " ***** Test Step 212 : Read attribute NULLABLE_INT8U unchanged Value\n");
            err = TestReadAttributeNullableInt8uUnchangedValue_212();
            break;
        case 213:
            ChipLogProgress(chipTool, " ***** Test Step 213 : Read attribute NULLABLE_INT8U unchanged Value with constraint\n");
            err = TestReadAttributeNullableInt8uUnchangedValueWithConstraint_213();
            break;
        case 214:
            ChipLogProgress(chipTool, " ***** Test Step 214 : Write attribute NULLABLE_INT8U null Value\n");
            err = TestWriteAttributeNullableInt8uNullValue_214();
            break;
        case 215:
            ChipLogProgress(chipTool, " ***** Test Step 215 : Read attribute NULLABLE_INT8U null Value\n");
            err = TestReadAttributeNullableInt8uNullValue_215();
            break;
        case 216:
            ChipLogProgress(chipTool, " ***** Test Step 216 : Read attribute NULLABLE_INT8U null Value & range\n");
            err = TestReadAttributeNullableInt8uNullValueRange_216();
            break;
        case 217:
            ChipLogProgress(chipTool, " ***** Test Step 217 : Read attribute NULLABLE_INT8U null Value & not\n");
            err = TestReadAttributeNullableInt8uNullValueNot_217();
            break;
        case 218:
            ChipLogProgress(chipTool, " ***** Test Step 218 : Write attribute NULLABLE_INT8U Value\n");
            err = TestWriteAttributeNullableInt8uValue_218();
            break;
        case 219:
            ChipLogProgress(chipTool, " ***** Test Step 219 : Read attribute NULLABLE_INT8U Value in range\n");
            err = TestReadAttributeNullableInt8uValueInRange_219();
            break;
        case 220:
            ChipLogProgress(chipTool, " ***** Test Step 220 : Read attribute NULLABLE_INT8U notValue OK\n");
            err = TestReadAttributeNullableInt8uNotValueOk_220();
            break;
        case 221:
            ChipLogProgress(chipTool, " ***** Test Step 221 : Write attribute NULLABLE_INT16U Min Value\n");
            err = TestWriteAttributeNullableInt16uMinValue_221();
            break;
        case 222:
            ChipLogProgress(chipTool, " ***** Test Step 222 : Read attribute NULLABLE_INT16U Min Value\n");
            err = TestReadAttributeNullableInt16uMinValue_222();
            break;
        case 223:
            ChipLogProgress(chipTool, " ***** Test Step 223 : Write attribute NULLABLE_INT16U Max Value\n");
            err = TestWriteAttributeNullableInt16uMaxValue_223();
            break;
        case 224:
            ChipLogProgress(chipTool, " ***** Test Step 224 : Read attribute NULLABLE_INT16U Max Value\n");
            err = TestReadAttributeNullableInt16uMaxValue_224();
            break;
        case 225:
            ChipLogProgress(chipTool, " ***** Test Step 225 : Write attribute NULLABLE_INT16U Invalid Value\n");
            err = TestWriteAttributeNullableInt16uInvalidValue_225();
            break;
        case 226:
            ChipLogProgress(chipTool, " ***** Test Step 226 : Read attribute NULLABLE_INT16U unchanged Value\n");
            err = TestReadAttributeNullableInt16uUnchangedValue_226();
            break;
        case 227:
            ChipLogProgress(chipTool, " ***** Test Step 227 : Write attribute NULLABLE_INT16U null Value\n");
            err = TestWriteAttributeNullableInt16uNullValue_227();
            break;
        case 228:
            ChipLogProgress(chipTool, " ***** Test Step 228 : Read attribute NULLABLE_INT16U null Value\n");
            err = TestReadAttributeNullableInt16uNullValue_228();
            break;
        case 229:
            ChipLogProgress(chipTool, " ***** Test Step 229 : Read attribute NULLABLE_INT16U null Value & range\n");
            err = TestReadAttributeNullableInt16uNullValueRange_229();
            break;
        case 230:
            ChipLogProgress(chipTool, " ***** Test Step 230 : Read attribute NULLABLE_INT16U null Value & not\n");
            err = TestReadAttributeNullableInt16uNullValueNot_230();
            break;
        case 231:
            ChipLogProgress(chipTool, " ***** Test Step 231 : Write attribute NULLABLE_INT16U Value\n");
            err = TestWriteAttributeNullableInt16uValue_231();
            break;
        case 232:
            ChipLogProgress(chipTool, " ***** Test Step 232 : Read attribute NULLABLE_INT16U Value in range\n");
            err = TestReadAttributeNullableInt16uValueInRange_232();
            break;
        case 233:
            ChipLogProgress(chipTool, " ***** Test Step 233 : Read attribute NULLABLE_INT16U notValue OK\n");
            err = TestReadAttributeNullableInt16uNotValueOk_233();
            break;
        case 234:
            ChipLogProgress(chipTool, " ***** Test Step 234 : Write attribute NULLABLE_INT32U Min Value\n");
            err = TestWriteAttributeNullableInt32uMinValue_234();
            break;
        case 235:
            ChipLogProgress(chipTool, " ***** Test Step 235 : Read attribute NULLABLE_INT32U Min Value\n");
            err = TestReadAttributeNullableInt32uMinValue_235();
            break;
        case 236:
            ChipLogProgress(chipTool, " ***** Test Step 236 : Write attribute NULLABLE_INT32U Max Value\n");
            err = TestWriteAttributeNullableInt32uMaxValue_236();
            break;
        case 237:
            ChipLogProgress(chipTool, " ***** Test Step 237 : Read attribute NULLABLE_INT32U Max Value\n");
            err = TestReadAttributeNullableInt32uMaxValue_237();
            break;
        case 238:
            ChipLogProgress(chipTool, " ***** Test Step 238 : Write attribute NULLABLE_INT32U Invalid Value\n");
            err = TestWriteAttributeNullableInt32uInvalidValue_238();
            break;
        case 239:
            ChipLogProgress(chipTool, " ***** Test Step 239 : Read attribute NULLABLE_INT32U unchanged Value\n");
            err = TestReadAttributeNullableInt32uUnchangedValue_239();
            break;
        case 240:
            ChipLogProgress(chipTool, " ***** Test Step 240 : Write attribute NULLABLE_INT32U null Value\n");
            err = TestWriteAttributeNullableInt32uNullValue_240();
            break;
        case 241:
            ChipLogProgress(chipTool, " ***** Test Step 241 : Read attribute NULLABLE_INT32U null Value\n");
            err = TestReadAttributeNullableInt32uNullValue_241();
            break;
        case 242:
            ChipLogProgress(chipTool, " ***** Test Step 242 : Read attribute NULLABLE_INT32U null Value & range\n");
            err = TestReadAttributeNullableInt32uNullValueRange_242();
            break;
        case 243:
            ChipLogProgress(chipTool, " ***** Test Step 243 : Read attribute NULLABLE_INT32U null Value & not\n");
            err = TestReadAttributeNullableInt32uNullValueNot_243();
            break;
        case 244:
            ChipLogProgress(chipTool, " ***** Test Step 244 : Write attribute NULLABLE_INT32U Value\n");
            err = TestWriteAttributeNullableInt32uValue_244();
            break;
        case 245:
            ChipLogProgress(chipTool, " ***** Test Step 245 : Read attribute NULLABLE_INT32U Value in range\n");
            err = TestReadAttributeNullableInt32uValueInRange_245();
            break;
        case 246:
            ChipLogProgress(chipTool, " ***** Test Step 246 : Read attribute NULLABLE_INT32U notValue OK\n");
            err = TestReadAttributeNullableInt32uNotValueOk_246();
            break;
        case 247:
            ChipLogProgress(chipTool, " ***** Test Step 247 : Write attribute NULLABLE_INT64U Min Value\n");
            err = TestWriteAttributeNullableInt64uMinValue_247();
            break;
        case 248:
            ChipLogProgress(chipTool, " ***** Test Step 248 : Read attribute NULLABLE_INT64U Min Value\n");
            err = TestReadAttributeNullableInt64uMinValue_248();
            break;
        case 249:
            ChipLogProgress(chipTool, " ***** Test Step 249 : Write attribute NULLABLE_INT64U Max Value\n");
            err = TestWriteAttributeNullableInt64uMaxValue_249();
            break;
        case 250:
            ChipLogProgress(chipTool, " ***** Test Step 250 : Read attribute NULLABLE_INT64U Max Value\n");
            err = TestReadAttributeNullableInt64uMaxValue_250();
            break;
        case 251:
            ChipLogProgress(chipTool, " ***** Test Step 251 : Write attribute NULLABLE_INT64U Invalid Value\n");
            err = TestWriteAttributeNullableInt64uInvalidValue_251();
            break;
        case 252:
            ChipLogProgress(chipTool, " ***** Test Step 252 : Read attribute NULLABLE_INT64U unchanged Value\n");
            err = TestReadAttributeNullableInt64uUnchangedValue_252();
            break;
        case 253:
            ChipLogProgress(chipTool, " ***** Test Step 253 : Write attribute NULLABLE_INT64U null Value\n");
            err = TestWriteAttributeNullableInt64uNullValue_253();
            break;
        case 254:
            ChipLogProgress(chipTool, " ***** Test Step 254 : Read attribute NULLABLE_INT64U null Value\n");
            err = TestReadAttributeNullableInt64uNullValue_254();
            break;
        case 255:
            ChipLogProgress(chipTool, " ***** Test Step 255 : Read attribute NULLABLE_INT64U null Value & range\n");
            err = TestReadAttributeNullableInt64uNullValueRange_255();
            break;
        case 256:
            ChipLogProgress(chipTool, " ***** Test Step 256 : Read attribute NULLABLE_INT64U null Value & not\n");
            err = TestReadAttributeNullableInt64uNullValueNot_256();
            break;
        case 257:
            ChipLogProgress(chipTool, " ***** Test Step 257 : Write attribute NULLABLE_INT64U Value\n");
            err = TestWriteAttributeNullableInt64uValue_257();
            break;
        case 258:
            ChipLogProgress(chipTool, " ***** Test Step 258 : Read attribute NULLABLE_INT64U Value in range\n");
            err = TestReadAttributeNullableInt64uValueInRange_258();
            break;
        case 259:
            ChipLogProgress(chipTool, " ***** Test Step 259 : Read attribute NULLABLE_INT64U notValue OK\n");
            err = TestReadAttributeNullableInt64uNotValueOk_259();
            break;
        case 260:
            ChipLogProgress(chipTool, " ***** Test Step 260 : Write attribute NULLABLE_INT8S Min Value\n");
            err = TestWriteAttributeNullableInt8sMinValue_260();
            break;
        case 261:
            ChipLogProgress(chipTool, " ***** Test Step 261 : Read attribute NULLABLE_INT8S Min Value\n");
            err = TestReadAttributeNullableInt8sMinValue_261();
            break;
        case 262:
            ChipLogProgress(chipTool, " ***** Test Step 262 : Write attribute NULLABLE_INT8S Invalid Value\n");
            err = TestWriteAttributeNullableInt8sInvalidValue_262();
            break;
        case 263:
            ChipLogProgress(chipTool, " ***** Test Step 263 : Read attribute NULLABLE_INT8S unchanged Value\n");
            err = TestReadAttributeNullableInt8sUnchangedValue_263();
            break;
        case 264:
            ChipLogProgress(chipTool, " ***** Test Step 264 : Write attribute NULLABLE_INT8S null Value\n");
            err = TestWriteAttributeNullableInt8sNullValue_264();
            break;
        case 265:
            ChipLogProgress(chipTool, " ***** Test Step 265 : Read attribute NULLABLE_INT8S null Value\n");
            err = TestReadAttributeNullableInt8sNullValue_265();
            break;
        case 266:
            ChipLogProgress(chipTool, " ***** Test Step 266 : Read attribute NULLABLE_INT8S null Value & range\n");
            err = TestReadAttributeNullableInt8sNullValueRange_266();
            break;
        case 267:
            ChipLogProgress(chipTool, " ***** Test Step 267 : Read attribute NULLABLE_INT8S null Value & not\n");
            err = TestReadAttributeNullableInt8sNullValueNot_267();
            break;
        case 268:
            ChipLogProgress(chipTool, " ***** Test Step 268 : Write attribute NULLABLE_INT8S Value\n");
            err = TestWriteAttributeNullableInt8sValue_268();
            break;
        case 269:
            ChipLogProgress(chipTool, " ***** Test Step 269 : Read attribute NULLABLE_INT8S Value in range\n");
            err = TestReadAttributeNullableInt8sValueInRange_269();
            break;
        case 270:
            ChipLogProgress(chipTool, " ***** Test Step 270 : Read attribute NULLABLE_INT8S notValue OK\n");
            err = TestReadAttributeNullableInt8sNotValueOk_270();
            break;
        case 271:
            ChipLogProgress(chipTool, " ***** Test Step 271 : Write attribute NULLABLE_INT16S Min Value\n");
            err = TestWriteAttributeNullableInt16sMinValue_271();
            break;
        case 272:
            ChipLogProgress(chipTool, " ***** Test Step 272 : Read attribute NULLABLE_INT16S Min Value\n");
            err = TestReadAttributeNullableInt16sMinValue_272();
            break;
        case 273:
            ChipLogProgress(chipTool, " ***** Test Step 273 : Write attribute NULLABLE_INT16S Invalid Value\n");
            err = TestWriteAttributeNullableInt16sInvalidValue_273();
            break;
        case 274:
            ChipLogProgress(chipTool, " ***** Test Step 274 : Read attribute NULLABLE_INT16S unchanged Value\n");
            err = TestReadAttributeNullableInt16sUnchangedValue_274();
            break;
        case 275:
            ChipLogProgress(chipTool, " ***** Test Step 275 : Write attribute NULLABLE_INT16S null Value\n");
            err = TestWriteAttributeNullableInt16sNullValue_275();
            break;
        case 276:
            ChipLogProgress(chipTool, " ***** Test Step 276 : Read attribute NULLABLE_INT16S null Value\n");
            err = TestReadAttributeNullableInt16sNullValue_276();
            break;
        case 277:
            ChipLogProgress(chipTool, " ***** Test Step 277 : Read attribute NULLABLE_INT16S null Value & range\n");
            err = TestReadAttributeNullableInt16sNullValueRange_277();
            break;
        case 278:
            ChipLogProgress(chipTool, " ***** Test Step 278 : Read attribute NULLABLE_INT16S null Value & not\n");
            err = TestReadAttributeNullableInt16sNullValueNot_278();
            break;
        case 279:
            ChipLogProgress(chipTool, " ***** Test Step 279 : Write attribute NULLABLE_INT16S Value\n");
            err = TestWriteAttributeNullableInt16sValue_279();
            break;
        case 280:
            ChipLogProgress(chipTool, " ***** Test Step 280 : Read attribute NULLABLE_INT16S Value in range\n");
            err = TestReadAttributeNullableInt16sValueInRange_280();
            break;
        case 281:
            ChipLogProgress(chipTool, " ***** Test Step 281 : Read attribute NULLABLE_INT16S notValue OK\n");
            err = TestReadAttributeNullableInt16sNotValueOk_281();
            break;
        case 282:
            ChipLogProgress(chipTool, " ***** Test Step 282 : Write attribute NULLABLE_INT32S Min Value\n");
            err = TestWriteAttributeNullableInt32sMinValue_282();
            break;
        case 283:
            ChipLogProgress(chipTool, " ***** Test Step 283 : Read attribute NULLABLE_INT32S Min Value\n");
            err = TestReadAttributeNullableInt32sMinValue_283();
            break;
        case 284:
            ChipLogProgress(chipTool, " ***** Test Step 284 : Write attribute NULLABLE_INT32S Invalid Value\n");
            err = TestWriteAttributeNullableInt32sInvalidValue_284();
            break;
        case 285:
            ChipLogProgress(chipTool, " ***** Test Step 285 : Read attribute NULLABLE_INT32S unchanged Value\n");
            err = TestReadAttributeNullableInt32sUnchangedValue_285();
            break;
        case 286:
            ChipLogProgress(chipTool, " ***** Test Step 286 : Write attribute NULLABLE_INT32S null Value\n");
            err = TestWriteAttributeNullableInt32sNullValue_286();
            break;
        case 287:
            ChipLogProgress(chipTool, " ***** Test Step 287 : Read attribute NULLABLE_INT32S null Value\n");
            err = TestReadAttributeNullableInt32sNullValue_287();
            break;
        case 288:
            ChipLogProgress(chipTool, " ***** Test Step 288 : Read attribute NULLABLE_INT32S null Value & range\n");
            err = TestReadAttributeNullableInt32sNullValueRange_288();
            break;
        case 289:
            ChipLogProgress(chipTool, " ***** Test Step 289 : Read attribute NULLABLE_INT32S null Value & not\n");
            err = TestReadAttributeNullableInt32sNullValueNot_289();
            break;
        case 290:
            ChipLogProgress(chipTool, " ***** Test Step 290 : Write attribute NULLABLE_INT32S Value\n");
            err = TestWriteAttributeNullableInt32sValue_290();
            break;
        case 291:
            ChipLogProgress(chipTool, " ***** Test Step 291 : Read attribute NULLABLE_INT32S Value in range\n");
            err = TestReadAttributeNullableInt32sValueInRange_291();
            break;
        case 292:
            ChipLogProgress(chipTool, " ***** Test Step 292 : Read attribute NULLABLE_INT32S notValue OK\n");
            err = TestReadAttributeNullableInt32sNotValueOk_292();
            break;
        case 293:
            ChipLogProgress(chipTool, " ***** Test Step 293 : Write attribute NULLABLE_INT64S Min Value\n");
            err = TestWriteAttributeNullableInt64sMinValue_293();
            break;
        case 294:
            ChipLogProgress(chipTool, " ***** Test Step 294 : Read attribute NULLABLE_INT64S Min Value\n");
            err = TestReadAttributeNullableInt64sMinValue_294();
            break;
        case 295:
            ChipLogProgress(chipTool, " ***** Test Step 295 : Write attribute NULLABLE_INT64S Invalid Value\n");
            err = TestWriteAttributeNullableInt64sInvalidValue_295();
            break;
        case 296:
            ChipLogProgress(chipTool, " ***** Test Step 296 : Read attribute NULLABLE_INT64S unchanged Value\n");
            err = TestReadAttributeNullableInt64sUnchangedValue_296();
            break;
        case 297:
            ChipLogProgress(chipTool, " ***** Test Step 297 : Write attribute NULLABLE_INT64S null Value\n");
            err = TestWriteAttributeNullableInt64sNullValue_297();
            break;
        case 298:
            ChipLogProgress(chipTool, " ***** Test Step 298 : Read attribute NULLABLE_INT64S null Value\n");
            err = TestReadAttributeNullableInt64sNullValue_298();
            break;
        case 299:
            ChipLogProgress(chipTool, " ***** Test Step 299 : Read attribute NULLABLE_INT64S null Value & range\n");
            err = TestReadAttributeNullableInt64sNullValueRange_299();
            break;
        case 300:
            ChipLogProgress(chipTool, " ***** Test Step 300 : Read attribute NULLABLE_INT64S null Value & not\n");
            err = TestReadAttributeNullableInt64sNullValueNot_300();
            break;
        case 301:
            ChipLogProgress(chipTool, " ***** Test Step 301 : Write attribute NULLABLE_INT64S Value\n");
            err = TestWriteAttributeNullableInt64sValue_301();
            break;
        case 302:
            ChipLogProgress(chipTool, " ***** Test Step 302 : Read attribute NULLABLE_INT64S Value in range\n");
            err = TestReadAttributeNullableInt64sValueInRange_302();
            break;
        case 303:
            ChipLogProgress(chipTool, " ***** Test Step 303 : Read attribute NULLABLE_INT64S notValue OK\n");
            err = TestReadAttributeNullableInt64sNotValueOk_303();
            break;
        case 304:
            ChipLogProgress(chipTool, " ***** Test Step 304 : Write attribute NULLABLE_SINGLE medium Value\n");
            err = TestWriteAttributeNullableSingleMediumValue_304();
            break;
        case 305:
            ChipLogProgress(chipTool, " ***** Test Step 305 : Read attribute NULLABLE_SINGLE medium Value\n");
            err = TestReadAttributeNullableSingleMediumValue_305();
            break;
        case 306:
            ChipLogProgress(chipTool, " ***** Test Step 306 : Write attribute NULLABLE_SINGLE largest Value\n");
            err = TestWriteAttributeNullableSingleLargestValue_306();
            break;
        case 307:
            ChipLogProgress(chipTool, " ***** Test Step 307 : Read attribute NULLABLE_SINGLE largest Value\n");
            err = TestReadAttributeNullableSingleLargestValue_307();
            break;
        case 308:
            ChipLogProgress(chipTool, " ***** Test Step 308 : Write attribute NULLABLE_SINGLE smallest Value\n");
            err = TestWriteAttributeNullableSingleSmallestValue_308();
            break;
        case 309:
            ChipLogProgress(chipTool, " ***** Test Step 309 : Read attribute NULLABLE_SINGLE smallest Value\n");
            err = TestReadAttributeNullableSingleSmallestValue_309();
            break;
        case 310:
            ChipLogProgress(chipTool, " ***** Test Step 310 : Write attribute NULLABLE_SINGLE null Value\n");
            err = TestWriteAttributeNullableSingleNullValue_310();
            break;
        case 311:
            ChipLogProgress(chipTool, " ***** Test Step 311 : Read attribute NULLABLE_SINGLE null Value\n");
            err = TestReadAttributeNullableSingleNullValue_311();
            break;
        case 312:
            ChipLogProgress(chipTool, " ***** Test Step 312 : Write attribute NULLABLE_SINGLE 0 Value\n");
            err = TestWriteAttributeNullableSingle0Value_312();
            break;
        case 313:
            ChipLogProgress(chipTool, " ***** Test Step 313 : Read attribute NULLABLE_SINGLE 0 Value\n");
            err = TestReadAttributeNullableSingle0Value_313();
            break;
        case 314:
            ChipLogProgress(chipTool, " ***** Test Step 314 : Write attribute NULLABLE_DOUBLE medium Value\n");
            err = TestWriteAttributeNullableDoubleMediumValue_314();
            break;
        case 315:
            ChipLogProgress(chipTool, " ***** Test Step 315 : Read attribute NULLABLE_DOUBLE medium Value\n");
            err = TestReadAttributeNullableDoubleMediumValue_315();
            break;
        case 316:
            ChipLogProgress(chipTool, " ***** Test Step 316 : Write attribute NULLABLE_DOUBLE largest Value\n");
            err = TestWriteAttributeNullableDoubleLargestValue_316();
            break;
        case 317:
            ChipLogProgress(chipTool, " ***** Test Step 317 : Read attribute NULLABLE_DOUBLE largest Value\n");
            err = TestReadAttributeNullableDoubleLargestValue_317();
            break;
        case 318:
            ChipLogProgress(chipTool, " ***** Test Step 318 : Write attribute NULLABLE_DOUBLE smallest Value\n");
            err = TestWriteAttributeNullableDoubleSmallestValue_318();
            break;
        case 319:
            ChipLogProgress(chipTool, " ***** Test Step 319 : Read attribute NULLABLE_DOUBLE smallest Value\n");
            err = TestReadAttributeNullableDoubleSmallestValue_319();
            break;
        case 320:
            ChipLogProgress(chipTool, " ***** Test Step 320 : Write attribute NULLABLE_DOUBLE null Value\n");
            err = TestWriteAttributeNullableDoubleNullValue_320();
            break;
        case 321:
            ChipLogProgress(chipTool, " ***** Test Step 321 : Read attribute NULLABLE_DOUBLE null Value\n");
            err = TestReadAttributeNullableDoubleNullValue_321();
            break;
        case 322:
            ChipLogProgress(chipTool, " ***** Test Step 322 : Write attribute NULLABLE_DOUBLE 0 Value\n");
            err = TestWriteAttributeNullableDouble0Value_322();
            break;
        case 323:
            ChipLogProgress(chipTool, " ***** Test Step 323 : Read attribute NULLABLE_DOUBLE 0 Value\n");
            err = TestReadAttributeNullableDouble0Value_323();
            break;
        case 324:
            ChipLogProgress(chipTool, " ***** Test Step 324 : Write attribute NULLABLE_ENUM8 Min Value\n");
            err = TestWriteAttributeNullableEnum8MinValue_324();
            break;
        case 325:
            ChipLogProgress(chipTool, " ***** Test Step 325 : Read attribute NULLABLE_ENUM8 Min Value\n");
            err = TestReadAttributeNullableEnum8MinValue_325();
            break;
        case 326:
            ChipLogProgress(chipTool, " ***** Test Step 326 : Write attribute NULLABLE_ENUM8 Max Value\n");
            err = TestWriteAttributeNullableEnum8MaxValue_326();
            break;
        case 327:
            ChipLogProgress(chipTool, " ***** Test Step 327 : Read attribute NULLABLE_ENUM8 Max Value\n");
            err = TestReadAttributeNullableEnum8MaxValue_327();
            break;
        case 328:
            ChipLogProgress(chipTool, " ***** Test Step 328 : Write attribute NULLABLE_ENUM8 Invalid Value\n");
            err = TestWriteAttributeNullableEnum8InvalidValue_328();
            break;
        case 329:
            ChipLogProgress(chipTool, " ***** Test Step 329 : Read attribute NULLABLE_ENUM8 unchanged Value\n");
            err = TestReadAttributeNullableEnum8UnchangedValue_329();
            break;
        case 330:
            ChipLogProgress(chipTool, " ***** Test Step 330 : Write attribute NULLABLE_ENUM8 null Value\n");
            err = TestWriteAttributeNullableEnum8NullValue_330();
            break;
        case 331:
            ChipLogProgress(chipTool, " ***** Test Step 331 : Read attribute NULLABLE_ENUM8 null Value\n");
            err = TestReadAttributeNullableEnum8NullValue_331();
            break;
        case 332:
            ChipLogProgress(chipTool, " ***** Test Step 332 : Write attribute NULLABLE_ENUM16 Min Value\n");
            err = TestWriteAttributeNullableEnum16MinValue_332();
            break;
        case 333:
            ChipLogProgress(chipTool, " ***** Test Step 333 : Read attribute NULLABLE_ENUM16 Min Value\n");
            err = TestReadAttributeNullableEnum16MinValue_333();
            break;
        case 334:
            ChipLogProgress(chipTool, " ***** Test Step 334 : Write attribute NULLABLE_ENUM16 Max Value\n");
            err = TestWriteAttributeNullableEnum16MaxValue_334();
            break;
        case 335:
            ChipLogProgress(chipTool, " ***** Test Step 335 : Read attribute NULLABLE_ENUM16 Max Value\n");
            err = TestReadAttributeNullableEnum16MaxValue_335();
            break;
        case 336:
            ChipLogProgress(chipTool, " ***** Test Step 336 : Write attribute NULLABLE_ENUM16 Invalid Value\n");
            err = TestWriteAttributeNullableEnum16InvalidValue_336();
            break;
        case 337:
            ChipLogProgress(chipTool, " ***** Test Step 337 : Read attribute NULLABLE_ENUM16 unchanged Value\n");
            err = TestReadAttributeNullableEnum16UnchangedValue_337();
            break;
        case 338:
            ChipLogProgress(chipTool, " ***** Test Step 338 : Write attribute NULLABLE_ENUM16 null Value\n");
            err = TestWriteAttributeNullableEnum16NullValue_338();
            break;
        case 339:
            ChipLogProgress(chipTool, " ***** Test Step 339 : Read attribute NULLABLE_ENUM16 null Value\n");
            err = TestReadAttributeNullableEnum16NullValue_339();
            break;
        case 340:
            ChipLogProgress(chipTool, " ***** Test Step 340 : Write attribute NULLABLE_SIMPLE_ENUM Min Value\n");
            err = TestWriteAttributeNullableSimpleEnumMinValue_340();
            break;
        case 341:
            ChipLogProgress(chipTool, " ***** Test Step 341 : Read attribute NULLABLE_SIMPLE_ENUM Min Value\n");
            err = TestReadAttributeNullableSimpleEnumMinValue_341();
            break;
        case 342:
            ChipLogProgress(chipTool, " ***** Test Step 342 : Write attribute NULLABLE_SIMPLE_ENUM Max Value\n");
            err = TestWriteAttributeNullableSimpleEnumMaxValue_342();
            break;
        case 343:
            ChipLogProgress(chipTool, " ***** Test Step 343 : Read attribute NULLABLE_SIMPLE_ENUM Max Value\n");
            err = TestReadAttributeNullableSimpleEnumMaxValue_343();
            break;
        case 344:
            ChipLogProgress(chipTool, " ***** Test Step 344 : Write attribute NULLABLE_SIMPLE_ENUM Invalid Value\n");
            err = TestWriteAttributeNullableSimpleEnumInvalidValue_344();
            break;
        case 345:
            ChipLogProgress(chipTool, " ***** Test Step 345 : Read attribute NULLABLE_SIMPLE_ENUM unchanged Value\n");
            err = TestReadAttributeNullableSimpleEnumUnchangedValue_345();
            break;
        case 346:
            ChipLogProgress(chipTool, " ***** Test Step 346 : Write attribute NULLABLE_SIMPLE_ENUM null Value\n");
            err = TestWriteAttributeNullableSimpleEnumNullValue_346();
            break;
        case 347:
            ChipLogProgress(chipTool, " ***** Test Step 347 : Read attribute NULLABLE_SIMPLE_ENUM null Value\n");
            err = TestReadAttributeNullableSimpleEnumNullValue_347();
            break;
        case 348:
            ChipLogProgress(chipTool, " ***** Test Step 348 : Read attribute NULLABLE_OCTET_STRING Default Value\n");
            err = TestReadAttributeNullableOctetStringDefaultValue_348();
            break;
        case 349:
            ChipLogProgress(chipTool, " ***** Test Step 349 : Write attribute NULLABLE_OCTET_STRING\n");
            err = TestWriteAttributeNullableOctetString_349();
            break;
        case 350:
            ChipLogProgress(chipTool, " ***** Test Step 350 : Read attribute NULLABLE_OCTET_STRING\n");
            err = TestReadAttributeNullableOctetString_350();
            break;
        case 351:
            ChipLogProgress(chipTool, " ***** Test Step 351 : Write attribute NULLABLE_OCTET_STRING\n");
            err = TestWriteAttributeNullableOctetString_351();
            break;
        case 352:
            ChipLogProgress(chipTool, " ***** Test Step 352 : Read attribute NULLABLE_OCTET_STRING\n");
            err = TestReadAttributeNullableOctetString_352();
            break;
        case 353:
            ChipLogProgress(chipTool, " ***** Test Step 353 : Write attribute NULLABLE_OCTET_STRING\n");
            err = TestWriteAttributeNullableOctetString_353();
            break;
        case 354:
            ChipLogProgress(chipTool, " ***** Test Step 354 : Read attribute NULLABLE_OCTET_STRING\n");
            err = TestReadAttributeNullableOctetString_354();
            break;
        case 355:
            ChipLogProgress(chipTool, " ***** Test Step 355 : Read attribute NULLABLE_CHAR_STRING Default Value\n");
            err = TestReadAttributeNullableCharStringDefaultValue_355();
            break;
        case 356:
            ChipLogProgress(chipTool, " ***** Test Step 356 : Write attribute NULLABLE_CHAR_STRING\n");
            err = TestWriteAttributeNullableCharString_356();
            break;
        case 357:
            ChipLogProgress(chipTool, " ***** Test Step 357 : Read attribute NULLABLE_CHAR_STRING\n");
            err = TestReadAttributeNullableCharString_357();
            break;
        case 358:
            ChipLogProgress(chipTool, " ***** Test Step 358 : Write attribute NULLABLE_CHAR_STRING - Value too long\n");
            err = TestWriteAttributeNullableCharStringValueTooLong_358();
            break;
        case 359:
            ChipLogProgress(chipTool, " ***** Test Step 359 : Read attribute NULLABLE_CHAR_STRING\n");
            err = TestReadAttributeNullableCharString_359();
            break;
        case 360:
            ChipLogProgress(chipTool, " ***** Test Step 360 : Write attribute NULLABLE_CHAR_STRING - Empty\n");
            err = TestWriteAttributeNullableCharStringEmpty_360();
            break;
        case 361:
            ChipLogProgress(chipTool, " ***** Test Step 361 : Read attribute NULLABLE_CHAR_STRING\n");
            err = TestReadAttributeNullableCharString_361();
            break;
        case 362:
            ChipLogProgress(chipTool, " ***** Test Step 362 : Read attribute from nonexistent endpoint.\n");
            err = TestReadAttributeFromNonexistentEndpoint_362();
            break;
        case 363:
            ChipLogProgress(chipTool, " ***** Test Step 363 : Read attribute from nonexistent cluster.\n");
            err = TestReadAttributeFromNonexistentCluster_363();
            break;
        case 364:
            ChipLogProgress(
                chipTool, " ***** Test Step 364 : Send a command that takes an optional parameter but do not set it.\n");
            err = TestSendACommandThatTakesAnOptionalParameterButDoNotSetIt_364();
            break;
        case 365:
            ChipLogProgress(
                chipTool, " ***** Test Step 365 : Send a command that takes an optional parameter but do not set it.\n");
            err = TestSendACommandThatTakesAnOptionalParameterButDoNotSetIt_365();
            break;
        case 366:
            ChipLogProgress(chipTool, " ***** Test Step 366 : Report: Subscribe to list attribute\n");
            err = TestReportSubscribeToListAttribute_366();
            break;
        case 367:
            ChipLogProgress(chipTool, " ***** Test Step 367 : Subscribe to list attribute\n");
            err = TestSubscribeToListAttribute_367();
            break;
        case 368:
            ChipLogProgress(chipTool, " ***** Test Step 368 : Write subscribed-to list attribute\n");
            err = TestWriteSubscribedToListAttribute_368();
            break;
        case 369:
            ChipLogProgress(chipTool, " ***** Test Step 369 : Check for list attribute report\n");
            err = TestCheckForListAttributeReport_369();
            break;
        case 370:
            ChipLogProgress(chipTool, " ***** Test Step 370 : Read range-restricted unsigned 8-bit integer\n");
            err = TestReadRangeRestrictedUnsigned8BitInteger_370();
            break;
        case 371:
            ChipLogProgress(chipTool, " ***** Test Step 371 : Write min value to a range-restricted unsigned 8-bit integer\n");
            err = TestWriteMinValueToARangeRestrictedUnsigned8BitInteger_371();
            break;
        case 372:
            ChipLogProgress(
                chipTool, " ***** Test Step 372 : Write just-below-range value to a range-restricted unsigned 8-bit integer\n");
            err = TestWriteJustBelowRangeValueToARangeRestrictedUnsigned8BitInteger_372();
            break;
        case 373:
            ChipLogProgress(
                chipTool, " ***** Test Step 373 : Write just-above-range value to a range-restricted unsigned 8-bit integer\n");
            err = TestWriteJustAboveRangeValueToARangeRestrictedUnsigned8BitInteger_373();
            break;
        case 374:
            ChipLogProgress(chipTool, " ***** Test Step 374 : Write max value to a range-restricted unsigned 8-bit integer\n");
            err = TestWriteMaxValueToARangeRestrictedUnsigned8BitInteger_374();
            break;
        case 375:
            ChipLogProgress(
                chipTool, " ***** Test Step 375 : Verify range-restricted unsigned 8-bit integer value has not changed\n");
            err = TestVerifyRangeRestrictedUnsigned8BitIntegerValueHasNotChanged_375();
            break;
        case 376:
            ChipLogProgress(
                chipTool, " ***** Test Step 376 : Write min valid value to a range-restricted unsigned 8-bit integer\n");
            err = TestWriteMinValidValueToARangeRestrictedUnsigned8BitInteger_376();
            break;
        case 377:
            ChipLogProgress(
                chipTool, " ***** Test Step 377 : Verify range-restricted unsigned 8-bit integer value is at min valid\n");
            err = TestVerifyRangeRestrictedUnsigned8BitIntegerValueIsAtMinValid_377();
            break;
        case 378:
            ChipLogProgress(
                chipTool, " ***** Test Step 378 : Write max valid value to a range-restricted unsigned 8-bit integer\n");
            err = TestWriteMaxValidValueToARangeRestrictedUnsigned8BitInteger_378();
            break;
        case 379:
            ChipLogProgress(
                chipTool, " ***** Test Step 379 : Verify range-restricted unsigned 8-bit integer value is at max valid\n");
            err = TestVerifyRangeRestrictedUnsigned8BitIntegerValueIsAtMaxValid_379();
            break;
        case 380:
            ChipLogProgress(
                chipTool, " ***** Test Step 380 : Write middle valid value to a range-restricted unsigned 8-bit integer\n");
            err = TestWriteMiddleValidValueToARangeRestrictedUnsigned8BitInteger_380();
            break;
        case 381:
            ChipLogProgress(
                chipTool, " ***** Test Step 381 : Verify range-restricted unsigned 8-bit integer value is at mid valid\n");
            err = TestVerifyRangeRestrictedUnsigned8BitIntegerValueIsAtMidValid_381();
            break;
        case 382:
            ChipLogProgress(chipTool, " ***** Test Step 382 : Read range-restricted unsigned 16-bit integer\n");
            err = TestReadRangeRestrictedUnsigned16BitInteger_382();
            break;
        case 383:
            ChipLogProgress(chipTool, " ***** Test Step 383 : Write min value to a range-restricted unsigned 16-bit integer\n");
            err = TestWriteMinValueToARangeRestrictedUnsigned16BitInteger_383();
            break;
        case 384:
            ChipLogProgress(
                chipTool, " ***** Test Step 384 : Write just-below-range value to a range-restricted unsigned 16-bit integer\n");
            err = TestWriteJustBelowRangeValueToARangeRestrictedUnsigned16BitInteger_384();
            break;
        case 385:
            ChipLogProgress(
                chipTool, " ***** Test Step 385 : Write just-above-range value to a range-restricted unsigned 16-bit integer\n");
            err = TestWriteJustAboveRangeValueToARangeRestrictedUnsigned16BitInteger_385();
            break;
        case 386:
            ChipLogProgress(chipTool, " ***** Test Step 386 : Write max value to a range-restricted unsigned 16-bit integer\n");
            err = TestWriteMaxValueToARangeRestrictedUnsigned16BitInteger_386();
            break;
        case 387:
            ChipLogProgress(
                chipTool, " ***** Test Step 387 : Verify range-restricted unsigned 16-bit integer value has not changed\n");
            err = TestVerifyRangeRestrictedUnsigned16BitIntegerValueHasNotChanged_387();
            break;
        case 388:
            ChipLogProgress(
                chipTool, " ***** Test Step 388 : Write min valid value to a range-restricted unsigned 16-bit integer\n");
            err = TestWriteMinValidValueToARangeRestrictedUnsigned16BitInteger_388();
            break;
        case 389:
            ChipLogProgress(
                chipTool, " ***** Test Step 389 : Verify range-restricted unsigned 16-bit integer value is at min valid\n");
            err = TestVerifyRangeRestrictedUnsigned16BitIntegerValueIsAtMinValid_389();
            break;
        case 390:
            ChipLogProgress(
                chipTool, " ***** Test Step 390 : Write max valid value to a range-restricted unsigned 16-bit integer\n");
            err = TestWriteMaxValidValueToARangeRestrictedUnsigned16BitInteger_390();
            break;
        case 391:
            ChipLogProgress(
                chipTool, " ***** Test Step 391 : Verify range-restricted unsigned 16-bit integer value is at max valid\n");
            err = TestVerifyRangeRestrictedUnsigned16BitIntegerValueIsAtMaxValid_391();
            break;
        case 392:
            ChipLogProgress(
                chipTool, " ***** Test Step 392 : Write middle valid value to a range-restricted unsigned 16-bit integer\n");
            err = TestWriteMiddleValidValueToARangeRestrictedUnsigned16BitInteger_392();
            break;
        case 393:
            ChipLogProgress(
                chipTool, " ***** Test Step 393 : Verify range-restricted unsigned 16-bit integer value is at mid valid\n");
            err = TestVerifyRangeRestrictedUnsigned16BitIntegerValueIsAtMidValid_393();
            break;
        case 394:
            ChipLogProgress(chipTool, " ***** Test Step 394 : Read range-restricted signed 8-bit integer\n");
            err = TestReadRangeRestrictedSigned8BitInteger_394();
            break;
        case 395:
            ChipLogProgress(chipTool, " ***** Test Step 395 : Write min value to a range-restricted signed 8-bit integer\n");
            err = TestWriteMinValueToARangeRestrictedSigned8BitInteger_395();
            break;
        case 396:
            ChipLogProgress(
                chipTool, " ***** Test Step 396 : Write just-below-range value to a range-restricted signed 8-bit integer\n");
            err = TestWriteJustBelowRangeValueToARangeRestrictedSigned8BitInteger_396();
            break;
        case 397:
            ChipLogProgress(
                chipTool, " ***** Test Step 397 : Write just-above-range value to a range-restricted signed 8-bit integer\n");
            err = TestWriteJustAboveRangeValueToARangeRestrictedSigned8BitInteger_397();
            break;
        case 398:
            ChipLogProgress(chipTool, " ***** Test Step 398 : Write max value to a range-restricted signed 8-bit integer\n");
            err = TestWriteMaxValueToARangeRestrictedSigned8BitInteger_398();
            break;
        case 399:
            ChipLogProgress(
                chipTool, " ***** Test Step 399 : Verify range-restricted signed 8-bit integer value has not changed\n");
            err = TestVerifyRangeRestrictedSigned8BitIntegerValueHasNotChanged_399();
            break;
        case 400:
            ChipLogProgress(chipTool, " ***** Test Step 400 : Write min valid value to a range-restricted signed 8-bit integer\n");
            err = TestWriteMinValidValueToARangeRestrictedSigned8BitInteger_400();
            break;
        case 401:
            ChipLogProgress(
                chipTool, " ***** Test Step 401 : Verify range-restricted signed 8-bit integer value is at min valid\n");
            err = TestVerifyRangeRestrictedSigned8BitIntegerValueIsAtMinValid_401();
            break;
        case 402:
            ChipLogProgress(chipTool, " ***** Test Step 402 : Write max valid value to a range-restricted signed 8-bit integer\n");
            err = TestWriteMaxValidValueToARangeRestrictedSigned8BitInteger_402();
            break;
        case 403:
            ChipLogProgress(
                chipTool, " ***** Test Step 403 : Verify range-restricted signed 8-bit integer value is at max valid\n");
            err = TestVerifyRangeRestrictedSigned8BitIntegerValueIsAtMaxValid_403();
            break;
        case 404:
            ChipLogProgress(
                chipTool, " ***** Test Step 404 : Write middle valid value to a range-restricted signed 8-bit integer\n");
            err = TestWriteMiddleValidValueToARangeRestrictedSigned8BitInteger_404();
            break;
        case 405:
            ChipLogProgress(
                chipTool, " ***** Test Step 405 : Verify range-restricted signed 8-bit integer value is at mid valid\n");
            err = TestVerifyRangeRestrictedSigned8BitIntegerValueIsAtMidValid_405();
            break;
        case 406:
            ChipLogProgress(chipTool, " ***** Test Step 406 : Read range-restricted signed 16-bit integer\n");
            err = TestReadRangeRestrictedSigned16BitInteger_406();
            break;
        case 407:
            ChipLogProgress(chipTool, " ***** Test Step 407 : Write min value to a range-restricted signed 16-bit integer\n");
            err = TestWriteMinValueToARangeRestrictedSigned16BitInteger_407();
            break;
        case 408:
            ChipLogProgress(
                chipTool, " ***** Test Step 408 : Write just-below-range value to a range-restricted signed 16-bit integer\n");
            err = TestWriteJustBelowRangeValueToARangeRestrictedSigned16BitInteger_408();
            break;
        case 409:
            ChipLogProgress(
                chipTool, " ***** Test Step 409 : Write just-above-range value to a range-restricted signed 16-bit integer\n");
            err = TestWriteJustAboveRangeValueToARangeRestrictedSigned16BitInteger_409();
            break;
        case 410:
            ChipLogProgress(chipTool, " ***** Test Step 410 : Write max value to a range-restricted signed 16-bit integer\n");
            err = TestWriteMaxValueToARangeRestrictedSigned16BitInteger_410();
            break;
        case 411:
            ChipLogProgress(
                chipTool, " ***** Test Step 411 : Verify range-restricted signed 16-bit integer value has not changed\n");
            err = TestVerifyRangeRestrictedSigned16BitIntegerValueHasNotChanged_411();
            break;
        case 412:
            ChipLogProgress(chipTool, " ***** Test Step 412 : Write min valid value to a range-restricted signed 16-bit integer\n");
            err = TestWriteMinValidValueToARangeRestrictedSigned16BitInteger_412();
            break;
        case 413:
            ChipLogProgress(
                chipTool, " ***** Test Step 413 : Verify range-restricted signed 16-bit integer value is at min valid\n");
            err = TestVerifyRangeRestrictedSigned16BitIntegerValueIsAtMinValid_413();
            break;
        case 414:
            ChipLogProgress(chipTool, " ***** Test Step 414 : Write max valid value to a range-restricted signed 16-bit integer\n");
            err = TestWriteMaxValidValueToARangeRestrictedSigned16BitInteger_414();
            break;
        case 415:
            ChipLogProgress(
                chipTool, " ***** Test Step 415 : Verify range-restricted signed 16-bit integer value is at max valid\n");
            err = TestVerifyRangeRestrictedSigned16BitIntegerValueIsAtMaxValid_415();
            break;
        case 416:
            ChipLogProgress(
                chipTool, " ***** Test Step 416 : Write middle valid value to a range-restricted signed 16-bit integer\n");
            err = TestWriteMiddleValidValueToARangeRestrictedSigned16BitInteger_416();
            break;
        case 417:
            ChipLogProgress(
                chipTool, " ***** Test Step 417 : Verify range-restricted signed 16-bit integer value is at mid valid\n");
            err = TestVerifyRangeRestrictedSigned16BitIntegerValueIsAtMidValid_417();
            break;
        case 418:
            ChipLogProgress(chipTool, " ***** Test Step 418 : Read nullable range-restricted unsigned 8-bit integer\n");
            err = TestReadNullableRangeRestrictedUnsigned8BitInteger_418();
            break;
        case 419:
            ChipLogProgress(
                chipTool, " ***** Test Step 419 : Write min value to a nullable range-restricted unsigned 8-bit integer\n");
            err = TestWriteMinValueToANullableRangeRestrictedUnsigned8BitInteger_419();
            break;
        case 420:
            ChipLogProgress(chipTool,
                " ***** Test Step 420 : Write just-below-range value to a nullable range-restricted unsigned 8-bit integer\n");
            err = TestWriteJustBelowRangeValueToANullableRangeRestrictedUnsigned8BitInteger_420();
            break;
        case 421:
            ChipLogProgress(chipTool,
                " ***** Test Step 421 : Write just-above-range value to a nullable range-restricted unsigned 8-bit integer\n");
            err = TestWriteJustAboveRangeValueToANullableRangeRestrictedUnsigned8BitInteger_421();
            break;
        case 422:
            ChipLogProgress(
                chipTool, " ***** Test Step 422 : Write max value to a nullable range-restricted unsigned 8-bit integer\n");
            err = TestWriteMaxValueToANullableRangeRestrictedUnsigned8BitInteger_422();
            break;
        case 423:
            ChipLogProgress(
                chipTool, " ***** Test Step 423 : Verify nullable range-restricted unsigned 8-bit integer value has not changed\n");
            err = TestVerifyNullableRangeRestrictedUnsigned8BitIntegerValueHasNotChanged_423();
            break;
        case 424:
            ChipLogProgress(
                chipTool, " ***** Test Step 424 : Write min valid value to a nullable range-restricted unsigned 8-bit integer\n");
            err = TestWriteMinValidValueToANullableRangeRestrictedUnsigned8BitInteger_424();
            break;
        case 425:
            ChipLogProgress(
                chipTool, " ***** Test Step 425 : Verify nullable range-restricted unsigned 8-bit integer value is at min valid\n");
            err = TestVerifyNullableRangeRestrictedUnsigned8BitIntegerValueIsAtMinValid_425();
            break;
        case 426:
            ChipLogProgress(
                chipTool, " ***** Test Step 426 : Write max valid value to a nullable range-restricted unsigned 8-bit integer\n");
            err = TestWriteMaxValidValueToANullableRangeRestrictedUnsigned8BitInteger_426();
            break;
        case 427:
            ChipLogProgress(
                chipTool, " ***** Test Step 427 : Verify nullable range-restricted unsigned 8-bit integer value is at max valid\n");
            err = TestVerifyNullableRangeRestrictedUnsigned8BitIntegerValueIsAtMaxValid_427();
            break;
        case 428:
            ChipLogProgress(chipTool,
                " ***** Test Step 428 : Write middle valid value to a nullable range-restricted unsigned 8-bit integer\n");
            err = TestWriteMiddleValidValueToANullableRangeRestrictedUnsigned8BitInteger_428();
            break;
        case 429:
            ChipLogProgress(
                chipTool, " ***** Test Step 429 : Verify nullable range-restricted unsigned 8-bit integer value is at mid valid\n");
            err = TestVerifyNullableRangeRestrictedUnsigned8BitIntegerValueIsAtMidValid_429();
            break;
        case 430:
            ChipLogProgress(
                chipTool, " ***** Test Step 430 : Write null value to a nullable range-restricted unsigned 8-bit integer\n");
            err = TestWriteNullValueToANullableRangeRestrictedUnsigned8BitInteger_430();
            break;
        case 431:
            ChipLogProgress(
                chipTool, " ***** Test Step 431 : Verify nullable range-restricted unsigned 8-bit integer value is null\n");
            err = TestVerifyNullableRangeRestrictedUnsigned8BitIntegerValueIsNull_431();
            break;
        case 432:
            ChipLogProgress(chipTool, " ***** Test Step 432 : Read nullable range-restricted unsigned 16-bit integer\n");
            err = TestReadNullableRangeRestrictedUnsigned16BitInteger_432();
            break;
        case 433:
            ChipLogProgress(
                chipTool, " ***** Test Step 433 : Write min value to a nullable range-restricted unsigned 16-bit integer\n");
            err = TestWriteMinValueToANullableRangeRestrictedUnsigned16BitInteger_433();
            break;
        case 434:
            ChipLogProgress(chipTool,
                " ***** Test Step 434 : Write just-below-range value to a nullable range-restricted unsigned 16-bit integer\n");
            err = TestWriteJustBelowRangeValueToANullableRangeRestrictedUnsigned16BitInteger_434();
            break;
        case 435:
            ChipLogProgress(chipTool,
                " ***** Test Step 435 : Write just-above-range value to a nullable range-restricted unsigned 16-bit integer\n");
            err = TestWriteJustAboveRangeValueToANullableRangeRestrictedUnsigned16BitInteger_435();
            break;
        case 436:
            ChipLogProgress(
                chipTool, " ***** Test Step 436 : Write max value to a nullable range-restricted unsigned 16-bit integer\n");
            err = TestWriteMaxValueToANullableRangeRestrictedUnsigned16BitInteger_436();
            break;
        case 437:
            ChipLogProgress(chipTool,
                " ***** Test Step 437 : Verify nullable range-restricted unsigned 16-bit integer value has not changed\n");
            err = TestVerifyNullableRangeRestrictedUnsigned16BitIntegerValueHasNotChanged_437();
            break;
        case 438:
            ChipLogProgress(
                chipTool, " ***** Test Step 438 : Write min valid value to a nullable range-restricted unsigned 16-bit integer\n");
            err = TestWriteMinValidValueToANullableRangeRestrictedUnsigned16BitInteger_438();
            break;
        case 439:
            ChipLogProgress(chipTool,
                " ***** Test Step 439 : Verify nullable range-restricted unsigned 16-bit integer value is at min valid\n");
            err = TestVerifyNullableRangeRestrictedUnsigned16BitIntegerValueIsAtMinValid_439();
            break;
        case 440:
            ChipLogProgress(
                chipTool, " ***** Test Step 440 : Write max valid value to a nullable range-restricted unsigned 16-bit integer\n");
            err = TestWriteMaxValidValueToANullableRangeRestrictedUnsigned16BitInteger_440();
            break;
        case 441:
            ChipLogProgress(chipTool,
                " ***** Test Step 441 : Verify nullable range-restricted unsigned 16-bit integer value is at max valid\n");
            err = TestVerifyNullableRangeRestrictedUnsigned16BitIntegerValueIsAtMaxValid_441();
            break;
        case 442:
            ChipLogProgress(chipTool,
                " ***** Test Step 442 : Write middle valid value to a nullable range-restricted unsigned 16-bit integer\n");
            err = TestWriteMiddleValidValueToANullableRangeRestrictedUnsigned16BitInteger_442();
            break;
        case 443:
            ChipLogProgress(chipTool,
                " ***** Test Step 443 : Verify nullable range-restricted unsigned 16-bit integer value is at mid valid\n");
            err = TestVerifyNullableRangeRestrictedUnsigned16BitIntegerValueIsAtMidValid_443();
            break;
        case 444:
            ChipLogProgress(
                chipTool, " ***** Test Step 444 : Write null value to a nullable range-restricted unsigned 16-bit integer\n");
            err = TestWriteNullValueToANullableRangeRestrictedUnsigned16BitInteger_444();
            break;
        case 445:
            ChipLogProgress(
                chipTool, " ***** Test Step 445 : Verify nullable range-restricted unsigned 16-bit integer value is null\n");
            err = TestVerifyNullableRangeRestrictedUnsigned16BitIntegerValueIsNull_445();
            break;
        case 446:
            ChipLogProgress(chipTool, " ***** Test Step 446 : Read nullable range-restricted signed 8-bit integer\n");
            err = TestReadNullableRangeRestrictedSigned8BitInteger_446();
            break;
        case 447:
            ChipLogProgress(
                chipTool, " ***** Test Step 447 : Write min value to a nullable range-restricted signed 8-bit integer\n");
            err = TestWriteMinValueToANullableRangeRestrictedSigned8BitInteger_447();
            break;
        case 448:
            ChipLogProgress(chipTool,
                " ***** Test Step 448 : Write just-below-range value to a nullable range-restricted signed 8-bit integer\n");
            err = TestWriteJustBelowRangeValueToANullableRangeRestrictedSigned8BitInteger_448();
            break;
        case 449:
            ChipLogProgress(chipTool,
                " ***** Test Step 449 : Write just-above-range value to a nullable range-restricted signed 8-bit integer\n");
            err = TestWriteJustAboveRangeValueToANullableRangeRestrictedSigned8BitInteger_449();
            break;
        case 450:
            ChipLogProgress(
                chipTool, " ***** Test Step 450 : Write max value to a nullable range-restricted signed 8-bit integer\n");
            err = TestWriteMaxValueToANullableRangeRestrictedSigned8BitInteger_450();
            break;
        case 451:
            ChipLogProgress(
                chipTool, " ***** Test Step 451 : Verify nullable range-restricted signed 8-bit integer value has not changed\n");
            err = TestVerifyNullableRangeRestrictedSigned8BitIntegerValueHasNotChanged_451();
            break;
        case 452:
            ChipLogProgress(
                chipTool, " ***** Test Step 452 : Write min valid value to a nullable range-restricted signed 8-bit integer\n");
            err = TestWriteMinValidValueToANullableRangeRestrictedSigned8BitInteger_452();
            break;
        case 453:
            ChipLogProgress(
                chipTool, " ***** Test Step 453 : Verify nullable range-restricted signed 8-bit integer value is at min valid\n");
            err = TestVerifyNullableRangeRestrictedSigned8BitIntegerValueIsAtMinValid_453();
            break;
        case 454:
            ChipLogProgress(
                chipTool, " ***** Test Step 454 : Write max valid value to a nullable range-restricted signed 8-bit integer\n");
            err = TestWriteMaxValidValueToANullableRangeRestrictedSigned8BitInteger_454();
            break;
        case 455:
            ChipLogProgress(
                chipTool, " ***** Test Step 455 : Verify nullable range-restricted signed 8-bit integer value is at max valid\n");
            err = TestVerifyNullableRangeRestrictedSigned8BitIntegerValueIsAtMaxValid_455();
            break;
        case 456:
            ChipLogProgress(
                chipTool, " ***** Test Step 456 : Write middle valid value to a nullable range-restricted signed 8-bit integer\n");
            err = TestWriteMiddleValidValueToANullableRangeRestrictedSigned8BitInteger_456();
            break;
        case 457:
            ChipLogProgress(
                chipTool, " ***** Test Step 457 : Verify nullable range-restricted signed 8-bit integer value is at mid valid\n");
            err = TestVerifyNullableRangeRestrictedSigned8BitIntegerValueIsAtMidValid_457();
            break;
        case 458:
            ChipLogProgress(
                chipTool, " ***** Test Step 458 : Write null value to a nullable range-restricted signed 8-bit integer\n");
            err = TestWriteNullValueToANullableRangeRestrictedSigned8BitInteger_458();
            break;
        case 459:
            ChipLogProgress(
                chipTool, " ***** Test Step 459 : Verify nullable range-restricted signed 8-bit integer value is at null\n");
            err = TestVerifyNullableRangeRestrictedSigned8BitIntegerValueIsAtNull_459();
            break;
        case 460:
            ChipLogProgress(chipTool, " ***** Test Step 460 : Read nullable range-restricted signed 16-bit integer\n");
            err = TestReadNullableRangeRestrictedSigned16BitInteger_460();
            break;
        case 461:
            ChipLogProgress(
                chipTool, " ***** Test Step 461 : Write min value to a nullable range-restricted signed 16-bit integer\n");
            err = TestWriteMinValueToANullableRangeRestrictedSigned16BitInteger_461();
            break;
        case 462:
            ChipLogProgress(chipTool,
                " ***** Test Step 462 : Write just-below-range value to a nullable range-restricted signed 16-bit integer\n");
            err = TestWriteJustBelowRangeValueToANullableRangeRestrictedSigned16BitInteger_462();
            break;
        case 463:
            ChipLogProgress(chipTool,
                " ***** Test Step 463 : Write just-above-range value to a nullable range-restricted signed 16-bit integer\n");
            err = TestWriteJustAboveRangeValueToANullableRangeRestrictedSigned16BitInteger_463();
            break;
        case 464:
            ChipLogProgress(
                chipTool, " ***** Test Step 464 : Write max value to a nullable range-restricted signed 16-bit integer\n");
            err = TestWriteMaxValueToANullableRangeRestrictedSigned16BitInteger_464();
            break;
        case 465:
            ChipLogProgress(
                chipTool, " ***** Test Step 465 : Verify nullable range-restricted signed 16-bit integer value has not changed\n");
            err = TestVerifyNullableRangeRestrictedSigned16BitIntegerValueHasNotChanged_465();
            break;
        case 466:
            ChipLogProgress(
                chipTool, " ***** Test Step 466 : Write min valid value to a nullable range-restricted signed 16-bit integer\n");
            err = TestWriteMinValidValueToANullableRangeRestrictedSigned16BitInteger_466();
            break;
        case 467:
            ChipLogProgress(
                chipTool, " ***** Test Step 467 : Verify nullable range-restricted signed 16-bit integer value is at min valid\n");
            err = TestVerifyNullableRangeRestrictedSigned16BitIntegerValueIsAtMinValid_467();
            break;
        case 468:
            ChipLogProgress(
                chipTool, " ***** Test Step 468 : Write max valid value to a nullable range-restricted signed 16-bit integer\n");
            err = TestWriteMaxValidValueToANullableRangeRestrictedSigned16BitInteger_468();
            break;
        case 469:
            ChipLogProgress(
                chipTool, " ***** Test Step 469 : Verify nullable range-restricted signed 16-bit integer value is at max valid\n");
            err = TestVerifyNullableRangeRestrictedSigned16BitIntegerValueIsAtMaxValid_469();
            break;
        case 470:
            ChipLogProgress(
                chipTool, " ***** Test Step 470 : Write middle valid value to a nullable range-restricted signed 16-bit integer\n");
            err = TestWriteMiddleValidValueToANullableRangeRestrictedSigned16BitInteger_470();
            break;
        case 471:
            ChipLogProgress(
                chipTool, " ***** Test Step 471 : Verify nullable range-restricted signed 16-bit integer value is at mid valid\n");
            err = TestVerifyNullableRangeRestrictedSigned16BitIntegerValueIsAtMidValid_471();
            break;
        case 472:
            ChipLogProgress(
                chipTool, " ***** Test Step 472 : Write null value to a nullable range-restricted signed 16-bit integer\n");
            err = TestWriteNullValueToANullableRangeRestrictedSigned16BitInteger_472();
            break;
        case 473:
            ChipLogProgress(
                chipTool, " ***** Test Step 473 : Verify nullable range-restricted signed 16-bit integer value is null\n");
            err = TestVerifyNullableRangeRestrictedSigned16BitIntegerValueIsNull_473();
            break;
        case 474:
            ChipLogProgress(chipTool, " ***** Test Step 474 : Write attribute that returns general status on write\n");
            err = TestWriteAttributeThatReturnsGeneralStatusOnWrite_474();
            break;
        case 475:
            ChipLogProgress(chipTool, " ***** Test Step 475 : Write attribute that returns cluster-specific status on write\n");
            err = TestWriteAttributeThatReturnsClusterSpecificStatusOnWrite_475();
            break;
        case 476:
            ChipLogProgress(chipTool, " ***** Test Step 476 : Read attribute that returns general status on read\n");
            err = TestReadAttributeThatReturnsGeneralStatusOnRead_476();
            break;
        case 477:
            ChipLogProgress(chipTool, " ***** Test Step 477 : read attribute that returns cluster-specific status on read\n");
            err = TestReadAttributeThatReturnsClusterSpecificStatusOnRead_477();
            break;
        case 478:
            ChipLogProgress(chipTool, " ***** Test Step 478 : read AcceptedCommandList attribute\n");
            err = TestReadAcceptedCommandListAttribute_478();
            break;
        case 479:
            ChipLogProgress(chipTool, " ***** Test Step 479 : read GeneratedCommandList attribute\n");
            err = TestReadGeneratedCommandListAttribute_479();
            break;
        case 480:
            ChipLogProgress(chipTool, " ***** Test Step 480 : Write struct-typed attribute\n");
            err = TestWriteStructTypedAttribute_480();
            break;
        case 481:
            ChipLogProgress(chipTool, " ***** Test Step 481 : Read struct-typed attribute\n");
            err = TestReadStructTypedAttribute_481();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 482;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSendTestCommand_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster testWithCompletionHandler:^(NSError * _Nullable err) {
            NSLog(@"Send Test Command Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSendTestNotHandledCommand_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster testNotHandledWithCompletionHandler:^(NSError * _Nullable err) {
            NSLog(@"Send Test Not Handled Command Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_INVALID_COMMAND));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSendTestSpecificCommand_3()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster testSpecificWithCompletionHandler:^(
            CHIPTestClusterClusterTestSpecificResponseParams * _Nullable values, NSError * _Nullable err) {
            NSLog(@"Send Test Specific Command Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = values.returnValue;
                VerifyOrReturn(CheckValue("returnValue", actualValue, 7));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSendTestAddArgumentsCommand_4()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPTestClusterClusterTestAddArgumentsParams alloc] init];
        params.arg1 = [NSNumber numberWithUnsignedChar:3];
        params.arg2 = [NSNumber numberWithUnsignedChar:17];
        [cluster testAddArgumentsWithParams:params
                          completionHandler:^(
                              CHIPTestClusterClusterTestAddArgumentsResponseParams * _Nullable values, NSError * _Nullable err) {
                              NSLog(@"Send Test Add Arguments Command Error: %@", err);

                              VerifyOrReturn(CheckValue("status", err, 0));

                              {
                                  id actualValue = values.returnValue;
                                  VerifyOrReturn(CheckValue("returnValue", actualValue, 20));
                              }

                              NextTest();
                          }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSendFailingTestAddArgumentsCommand_5()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPTestClusterClusterTestAddArgumentsParams alloc] init];
        params.arg1 = [NSNumber numberWithUnsignedChar:250];
        params.arg2 = [NSNumber numberWithUnsignedChar:6];
        [cluster testAddArgumentsWithParams:params
                          completionHandler:^(
                              CHIPTestClusterClusterTestAddArgumentsResponseParams * _Nullable values, NSError * _Nullable err) {
                              NSLog(@"Send failing Test Add Arguments Command Error: %@", err);

                              VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_INVALID_COMMAND));
                              NextTest();
                          }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeBooleanDefaultValue_6()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeBooleanWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute BOOLEAN Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("boolean", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeBooleanTrue_7()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id booleanArgument;
        booleanArgument = [NSNumber numberWithBool:1];
        [cluster writeAttributeBooleanWithValue:booleanArgument
                              completionHandler:^(NSError * _Nullable err) {
                                  NSLog(@"Write attribute BOOLEAN True Error: %@", err);

                                  VerifyOrReturn(CheckValue("status", err, 0));

                                  NextTest();
                              }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeBooleanTrue_8()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeBooleanWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute BOOLEAN True Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("boolean", actualValue, 1));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeBooleanFalse_9()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id booleanArgument;
        booleanArgument = [NSNumber numberWithBool:0];
        [cluster writeAttributeBooleanWithValue:booleanArgument
                              completionHandler:^(NSError * _Nullable err) {
                                  NSLog(@"Write attribute BOOLEAN False Error: %@", err);

                                  VerifyOrReturn(CheckValue("status", err, 0));

                                  NextTest();
                              }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeBooleanFalse_10()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeBooleanWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute BOOLEAN False Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("boolean", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeBitmap8DefaultValue_11()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeBitmap8WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute BITMAP8 Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("bitmap8", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeBitmap8MaxValue_12()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id bitmap8Argument;
        bitmap8Argument = [NSNumber numberWithUnsignedChar:255];
        [cluster writeAttributeBitmap8WithValue:bitmap8Argument
                              completionHandler:^(NSError * _Nullable err) {
                                  NSLog(@"Write attribute BITMAP8 Max Value Error: %@", err);

                                  VerifyOrReturn(CheckValue("status", err, 0));

                                  NextTest();
                              }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeBitmap8MaxValue_13()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeBitmap8WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute BITMAP8 Max Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("bitmap8", actualValue, 255));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeBitmap8MinValue_14()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id bitmap8Argument;
        bitmap8Argument = [NSNumber numberWithUnsignedChar:0];
        [cluster writeAttributeBitmap8WithValue:bitmap8Argument
                              completionHandler:^(NSError * _Nullable err) {
                                  NSLog(@"Write attribute BITMAP8 Min Value Error: %@", err);

                                  VerifyOrReturn(CheckValue("status", err, 0));

                                  NextTest();
                              }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeBitmap8MinValue_15()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeBitmap8WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute BITMAP8 Min Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("bitmap8", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeBitmap16DefaultValue_16()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeBitmap16WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute BITMAP16 Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("bitmap16", actualValue, 0U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeBitmap16MaxValue_17()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id bitmap16Argument;
        bitmap16Argument = [NSNumber numberWithUnsignedShort:65535U];
        [cluster writeAttributeBitmap16WithValue:bitmap16Argument
                               completionHandler:^(NSError * _Nullable err) {
                                   NSLog(@"Write attribute BITMAP16 Max Value Error: %@", err);

                                   VerifyOrReturn(CheckValue("status", err, 0));

                                   NextTest();
                               }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeBitmap16MaxValue_18()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeBitmap16WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute BITMAP16 Max Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("bitmap16", actualValue, 65535U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeBitmap16MinValue_19()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id bitmap16Argument;
        bitmap16Argument = [NSNumber numberWithUnsignedShort:0U];
        [cluster writeAttributeBitmap16WithValue:bitmap16Argument
                               completionHandler:^(NSError * _Nullable err) {
                                   NSLog(@"Write attribute BITMAP16 Min Value Error: %@", err);

                                   VerifyOrReturn(CheckValue("status", err, 0));

                                   NextTest();
                               }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeBitmap16MinValue_20()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeBitmap16WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute BITMAP16 Min Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("bitmap16", actualValue, 0U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeBitmap32DefaultValue_21()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeBitmap32WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute BITMAP32 Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("bitmap32", actualValue, 0UL));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeBitmap32MaxValue_22()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id bitmap32Argument;
        bitmap32Argument = [NSNumber numberWithUnsignedInt:4294967295UL];
        [cluster writeAttributeBitmap32WithValue:bitmap32Argument
                               completionHandler:^(NSError * _Nullable err) {
                                   NSLog(@"Write attribute BITMAP32 Max Value Error: %@", err);

                                   VerifyOrReturn(CheckValue("status", err, 0));

                                   NextTest();
                               }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeBitmap32MaxValue_23()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeBitmap32WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute BITMAP32 Max Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("bitmap32", actualValue, 4294967295UL));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeBitmap32MinValue_24()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id bitmap32Argument;
        bitmap32Argument = [NSNumber numberWithUnsignedInt:0UL];
        [cluster writeAttributeBitmap32WithValue:bitmap32Argument
                               completionHandler:^(NSError * _Nullable err) {
                                   NSLog(@"Write attribute BITMAP32 Min Value Error: %@", err);

                                   VerifyOrReturn(CheckValue("status", err, 0));

                                   NextTest();
                               }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeBitmap32MinValue_25()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeBitmap32WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute BITMAP32 Min Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("bitmap32", actualValue, 0UL));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeBitmap64DefaultValue_26()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeBitmap64WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute BITMAP64 Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("bitmap64", actualValue, 0ULL));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeBitmap64MaxValue_27()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id bitmap64Argument;
        bitmap64Argument = [NSNumber numberWithUnsignedLongLong:18446744073709551615ULL];
        [cluster writeAttributeBitmap64WithValue:bitmap64Argument
                               completionHandler:^(NSError * _Nullable err) {
                                   NSLog(@"Write attribute BITMAP64 Max Value Error: %@", err);

                                   VerifyOrReturn(CheckValue("status", err, 0));

                                   NextTest();
                               }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeBitmap64MaxValue_28()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeBitmap64WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute BITMAP64 Max Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("bitmap64", actualValue, 18446744073709551615ULL));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeBitmap64MinValue_29()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id bitmap64Argument;
        bitmap64Argument = [NSNumber numberWithUnsignedLongLong:0ULL];
        [cluster writeAttributeBitmap64WithValue:bitmap64Argument
                               completionHandler:^(NSError * _Nullable err) {
                                   NSLog(@"Write attribute BITMAP64 Min Value Error: %@", err);

                                   VerifyOrReturn(CheckValue("status", err, 0));

                                   NextTest();
                               }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeBitmap64MinValue_30()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeBitmap64WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute BITMAP64 Min Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("bitmap64", actualValue, 0ULL));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeInt8uDefaultValue_31()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeInt8uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute INT8U Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("int8u", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeInt8uMaxValue_32()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id int8uArgument;
        int8uArgument = [NSNumber numberWithUnsignedChar:255];
        [cluster writeAttributeInt8uWithValue:int8uArgument
                            completionHandler:^(NSError * _Nullable err) {
                                NSLog(@"Write attribute INT8U Max Value Error: %@", err);

                                VerifyOrReturn(CheckValue("status", err, 0));

                                NextTest();
                            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeInt8uMaxValue_33()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeInt8uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute INT8U Max Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("int8u", actualValue, 255));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeInt8uMinValue_34()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id int8uArgument;
        int8uArgument = [NSNumber numberWithUnsignedChar:0];
        [cluster writeAttributeInt8uWithValue:int8uArgument
                            completionHandler:^(NSError * _Nullable err) {
                                NSLog(@"Write attribute INT8U Min Value Error: %@", err);

                                VerifyOrReturn(CheckValue("status", err, 0));

                                NextTest();
                            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeInt8uMinValue_35()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeInt8uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute INT8U Min Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("int8u", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeInt16uDefaultValue_36()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeInt16uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute INT16U Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("int16u", actualValue, 0U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeInt16uMaxValue_37()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id int16uArgument;
        int16uArgument = [NSNumber numberWithUnsignedShort:65535U];
        [cluster writeAttributeInt16uWithValue:int16uArgument
                             completionHandler:^(NSError * _Nullable err) {
                                 NSLog(@"Write attribute INT16U Max Value Error: %@", err);

                                 VerifyOrReturn(CheckValue("status", err, 0));

                                 NextTest();
                             }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeInt16uMaxValue_38()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeInt16uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute INT16U Max Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("int16u", actualValue, 65535U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeInt16uMinValue_39()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id int16uArgument;
        int16uArgument = [NSNumber numberWithUnsignedShort:0U];
        [cluster writeAttributeInt16uWithValue:int16uArgument
                             completionHandler:^(NSError * _Nullable err) {
                                 NSLog(@"Write attribute INT16U Min Value Error: %@", err);

                                 VerifyOrReturn(CheckValue("status", err, 0));

                                 NextTest();
                             }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeInt16uMinValue_40()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeInt16uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute INT16U Min Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("int16u", actualValue, 0U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeInt32uDefaultValue_41()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeInt32uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute INT32U Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("int32u", actualValue, 0UL));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeInt32uMaxValue_42()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id int32uArgument;
        int32uArgument = [NSNumber numberWithUnsignedInt:4294967295UL];
        [cluster writeAttributeInt32uWithValue:int32uArgument
                             completionHandler:^(NSError * _Nullable err) {
                                 NSLog(@"Write attribute INT32U Max Value Error: %@", err);

                                 VerifyOrReturn(CheckValue("status", err, 0));

                                 NextTest();
                             }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeInt32uMaxValue_43()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeInt32uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute INT32U Max Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("int32u", actualValue, 4294967295UL));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeInt32uMinValue_44()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id int32uArgument;
        int32uArgument = [NSNumber numberWithUnsignedInt:0UL];
        [cluster writeAttributeInt32uWithValue:int32uArgument
                             completionHandler:^(NSError * _Nullable err) {
                                 NSLog(@"Write attribute INT32U Min Value Error: %@", err);

                                 VerifyOrReturn(CheckValue("status", err, 0));

                                 NextTest();
                             }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeInt32uMinValue_45()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeInt32uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute INT32U Min Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("int32u", actualValue, 0UL));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeInt64uDefaultValue_46()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeInt64uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute INT64U Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("int64u", actualValue, 0ULL));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeInt64uMaxValue_47()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id int64uArgument;
        int64uArgument = [NSNumber numberWithUnsignedLongLong:18446744073709551615ULL];
        [cluster writeAttributeInt64uWithValue:int64uArgument
                             completionHandler:^(NSError * _Nullable err) {
                                 NSLog(@"Write attribute INT64U Max Value Error: %@", err);

                                 VerifyOrReturn(CheckValue("status", err, 0));

                                 NextTest();
                             }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeInt64uMaxValue_48()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeInt64uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute INT64U Max Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("int64u", actualValue, 18446744073709551615ULL));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeInt64uMinValue_49()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id int64uArgument;
        int64uArgument = [NSNumber numberWithUnsignedLongLong:0ULL];
        [cluster writeAttributeInt64uWithValue:int64uArgument
                             completionHandler:^(NSError * _Nullable err) {
                                 NSLog(@"Write attribute INT64U Min Value Error: %@", err);

                                 VerifyOrReturn(CheckValue("status", err, 0));

                                 NextTest();
                             }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeInt64uMinValue_50()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeInt64uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute INT64U Min Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("int64u", actualValue, 0ULL));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeInt8sDefaultValue_51()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeInt8sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute INT8S Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("int8s", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeInt8sMaxValue_52()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id int8sArgument;
        int8sArgument = [NSNumber numberWithChar:127];
        [cluster writeAttributeInt8sWithValue:int8sArgument
                            completionHandler:^(NSError * _Nullable err) {
                                NSLog(@"Write attribute INT8S Max Value Error: %@", err);

                                VerifyOrReturn(CheckValue("status", err, 0));

                                NextTest();
                            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeInt8sMaxValue_53()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeInt8sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute INT8S Max Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("int8s", actualValue, 127));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeInt8sMinValue_54()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id int8sArgument;
        int8sArgument = [NSNumber numberWithChar:-128];
        [cluster writeAttributeInt8sWithValue:int8sArgument
                            completionHandler:^(NSError * _Nullable err) {
                                NSLog(@"Write attribute INT8S Min Value Error: %@", err);

                                VerifyOrReturn(CheckValue("status", err, 0));

                                NextTest();
                            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeInt8sMinValue_55()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeInt8sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute INT8S Min Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("int8s", actualValue, -128));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeInt8sDefaultValue_56()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id int8sArgument;
        int8sArgument = [NSNumber numberWithChar:0];
        [cluster writeAttributeInt8sWithValue:int8sArgument
                            completionHandler:^(NSError * _Nullable err) {
                                NSLog(@"Write attribute INT8S Default Value Error: %@", err);

                                VerifyOrReturn(CheckValue("status", err, 0));

                                NextTest();
                            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeInt8sDefaultValue_57()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeInt8sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute INT8S Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("int8s", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeInt16sDefaultValue_58()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeInt16sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute INT16S Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("int16s", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeInt16sMaxValue_59()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id int16sArgument;
        int16sArgument = [NSNumber numberWithShort:32767];
        [cluster writeAttributeInt16sWithValue:int16sArgument
                             completionHandler:^(NSError * _Nullable err) {
                                 NSLog(@"Write attribute INT16S Max Value Error: %@", err);

                                 VerifyOrReturn(CheckValue("status", err, 0));

                                 NextTest();
                             }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeInt16sMaxValue_60()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeInt16sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute INT16S Max Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("int16s", actualValue, 32767));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeInt16sMinValue_61()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id int16sArgument;
        int16sArgument = [NSNumber numberWithShort:-32768];
        [cluster writeAttributeInt16sWithValue:int16sArgument
                             completionHandler:^(NSError * _Nullable err) {
                                 NSLog(@"Write attribute INT16S Min Value Error: %@", err);

                                 VerifyOrReturn(CheckValue("status", err, 0));

                                 NextTest();
                             }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeInt16sMinValue_62()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeInt16sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute INT16S Min Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("int16s", actualValue, -32768));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeInt16sDefaultValue_63()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id int16sArgument;
        int16sArgument = [NSNumber numberWithShort:0];
        [cluster writeAttributeInt16sWithValue:int16sArgument
                             completionHandler:^(NSError * _Nullable err) {
                                 NSLog(@"Write attribute INT16S Default Value Error: %@", err);

                                 VerifyOrReturn(CheckValue("status", err, 0));

                                 NextTest();
                             }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeInt16sDefaultValue_64()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeInt16sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute INT16S Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("int16s", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeInt32sDefaultValue_65()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeInt32sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute INT32S Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("int32s", actualValue, 0L));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeInt32sMaxValue_66()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id int32sArgument;
        int32sArgument = [NSNumber numberWithInt:2147483647L];
        [cluster writeAttributeInt32sWithValue:int32sArgument
                             completionHandler:^(NSError * _Nullable err) {
                                 NSLog(@"Write attribute INT32S Max Value Error: %@", err);

                                 VerifyOrReturn(CheckValue("status", err, 0));

                                 NextTest();
                             }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeInt32sMaxValue_67()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeInt32sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute INT32S Max Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("int32s", actualValue, 2147483647L));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeInt32sMinValue_68()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id int32sArgument;
        int32sArgument = [NSNumber numberWithInt:-2147483648L];
        [cluster writeAttributeInt32sWithValue:int32sArgument
                             completionHandler:^(NSError * _Nullable err) {
                                 NSLog(@"Write attribute INT32S Min Value Error: %@", err);

                                 VerifyOrReturn(CheckValue("status", err, 0));

                                 NextTest();
                             }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeInt32sMinValue_69()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeInt32sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute INT32S Min Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("int32s", actualValue, -2147483648L));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeInt32sDefaultValue_70()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id int32sArgument;
        int32sArgument = [NSNumber numberWithInt:0L];
        [cluster writeAttributeInt32sWithValue:int32sArgument
                             completionHandler:^(NSError * _Nullable err) {
                                 NSLog(@"Write attribute INT32S Default Value Error: %@", err);

                                 VerifyOrReturn(CheckValue("status", err, 0));

                                 NextTest();
                             }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeInt32sDefaultValue_71()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeInt32sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute INT32S Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("int32s", actualValue, 0L));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeInt64sDefaultValue_72()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeInt64sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute INT64S Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("int64s", actualValue, 0LL));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeInt64sMaxValue_73()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id int64sArgument;
        int64sArgument = [NSNumber numberWithLongLong:9223372036854775807LL];
        [cluster writeAttributeInt64sWithValue:int64sArgument
                             completionHandler:^(NSError * _Nullable err) {
                                 NSLog(@"Write attribute INT64S Max Value Error: %@", err);

                                 VerifyOrReturn(CheckValue("status", err, 0));

                                 NextTest();
                             }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeInt64sMaxValue_74()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeInt64sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute INT64S Max Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("int64s", actualValue, 9223372036854775807LL));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeInt64sMinValue_75()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id int64sArgument;
        int64sArgument = [NSNumber numberWithLongLong:-9223372036854775807LL];
        [cluster writeAttributeInt64sWithValue:int64sArgument
                             completionHandler:^(NSError * _Nullable err) {
                                 NSLog(@"Write attribute INT64S Min Value Error: %@", err);

                                 VerifyOrReturn(CheckValue("status", err, 0));

                                 NextTest();
                             }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeInt64sMinValue_76()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeInt64sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute INT64S Min Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("int64s", actualValue, -9223372036854775807LL));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeInt64sDefaultValue_77()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id int64sArgument;
        int64sArgument = [NSNumber numberWithLongLong:0LL];
        [cluster writeAttributeInt64sWithValue:int64sArgument
                             completionHandler:^(NSError * _Nullable err) {
                                 NSLog(@"Write attribute INT64S Default Value Error: %@", err);

                                 VerifyOrReturn(CheckValue("status", err, 0));

                                 NextTest();
                             }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeInt64sDefaultValue_78()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeInt64sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute INT64S Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("int64s", actualValue, 0LL));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeSingleDefaultValue_79()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeFloatSingleWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute SINGLE Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("float_single", actualValue, 0.0f));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeSingleMediumValue_80()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id floatSingleArgument;
        floatSingleArgument = [NSNumber numberWithFloat:0.1f];
        [cluster writeAttributeFloatSingleWithValue:floatSingleArgument
                                  completionHandler:^(NSError * _Nullable err) {
                                      NSLog(@"Write attribute SINGLE medium Value Error: %@", err);

                                      VerifyOrReturn(CheckValue("status", err, 0));

                                      NextTest();
                                  }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeSingleMediumValue_81()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeFloatSingleWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute SINGLE medium Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("float_single", actualValue, 0.1f));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeSingleLargeValue_82()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id floatSingleArgument;
        floatSingleArgument = [NSNumber numberWithFloat:17000000000.0f];
        [cluster writeAttributeFloatSingleWithValue:floatSingleArgument
                                  completionHandler:^(NSError * _Nullable err) {
                                      NSLog(@"Write attribute SINGLE large Value Error: %@", err);

                                      VerifyOrReturn(CheckValue("status", err, 0));

                                      NextTest();
                                  }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeSingleLargeValue_83()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeFloatSingleWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute SINGLE large Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("float_single", actualValue, 17000000000.0f));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeSingleSmallValue_84()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id floatSingleArgument;
        floatSingleArgument = [NSNumber numberWithFloat:1.7e-10f];
        [cluster writeAttributeFloatSingleWithValue:floatSingleArgument
                                  completionHandler:^(NSError * _Nullable err) {
                                      NSLog(@"Write attribute SINGLE small Value Error: %@", err);

                                      VerifyOrReturn(CheckValue("status", err, 0));

                                      NextTest();
                                  }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeSingleSmallValue_85()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeFloatSingleWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute SINGLE small Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("float_single", actualValue, 1.7e-10f));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeSingleDefaultValue_86()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id floatSingleArgument;
        floatSingleArgument = [NSNumber numberWithFloat:0.0f];
        [cluster writeAttributeFloatSingleWithValue:floatSingleArgument
                                  completionHandler:^(NSError * _Nullable err) {
                                      NSLog(@"Write attribute SINGLE Default Value Error: %@", err);

                                      VerifyOrReturn(CheckValue("status", err, 0));

                                      NextTest();
                                  }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeSingleDefaultValue_87()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeFloatSingleWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute SINGLE Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("float_single", actualValue, 0.0f));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeDoubleDefaultValue_88()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeFloatDoubleWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute DOUBLE Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("float_double", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeDoubleMediumValue_89()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id floatDoubleArgument;
        floatDoubleArgument = [NSNumber numberWithDouble:0.1234567890123];
        [cluster writeAttributeFloatDoubleWithValue:floatDoubleArgument
                                  completionHandler:^(NSError * _Nullable err) {
                                      NSLog(@"Write attribute DOUBLE medium Value Error: %@", err);

                                      VerifyOrReturn(CheckValue("status", err, 0));

                                      NextTest();
                                  }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeDoubleMediumValue_90()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeFloatDoubleWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute DOUBLE medium Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("float_double", actualValue, 0.1234567890123));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeDoubleLargeValue_91()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id floatDoubleArgument;
        floatDoubleArgument = [NSNumber numberWithDouble:1.7e+200];
        [cluster writeAttributeFloatDoubleWithValue:floatDoubleArgument
                                  completionHandler:^(NSError * _Nullable err) {
                                      NSLog(@"Write attribute DOUBLE large Value Error: %@", err);

                                      VerifyOrReturn(CheckValue("status", err, 0));

                                      NextTest();
                                  }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeDoubleLargeValue_92()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeFloatDoubleWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute DOUBLE large Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("float_double", actualValue, 1.7e+200));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeDoubleSmallValue_93()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id floatDoubleArgument;
        floatDoubleArgument = [NSNumber numberWithDouble:1.7e-200];
        [cluster writeAttributeFloatDoubleWithValue:floatDoubleArgument
                                  completionHandler:^(NSError * _Nullable err) {
                                      NSLog(@"Write attribute DOUBLE small Value Error: %@", err);

                                      VerifyOrReturn(CheckValue("status", err, 0));

                                      NextTest();
                                  }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeDoubleSmallValue_94()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeFloatDoubleWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute DOUBLE small Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("float_double", actualValue, 1.7e-200));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeDoubleDefaultValue_95()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id floatDoubleArgument;
        floatDoubleArgument = [NSNumber numberWithDouble:0];
        [cluster writeAttributeFloatDoubleWithValue:floatDoubleArgument
                                  completionHandler:^(NSError * _Nullable err) {
                                      NSLog(@"Write attribute DOUBLE Default Value Error: %@", err);

                                      VerifyOrReturn(CheckValue("status", err, 0));

                                      NextTest();
                                  }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeDoubleDefaultValue_96()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeFloatDoubleWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute DOUBLE Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("float_double", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeEnum8DefaultValue_97()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeEnum8WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute ENUM8 Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("enum8", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeEnum8MaxValue_98()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id enum8Argument;
        enum8Argument = [NSNumber numberWithUnsignedChar:255];
        [cluster writeAttributeEnum8WithValue:enum8Argument
                            completionHandler:^(NSError * _Nullable err) {
                                NSLog(@"Write attribute ENUM8 Max Value Error: %@", err);

                                VerifyOrReturn(CheckValue("status", err, 0));

                                NextTest();
                            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeEnum8MaxValue_99()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeEnum8WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute ENUM8 Max Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("enum8", actualValue, 255));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeEnum8MinValue_100()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id enum8Argument;
        enum8Argument = [NSNumber numberWithUnsignedChar:0];
        [cluster writeAttributeEnum8WithValue:enum8Argument
                            completionHandler:^(NSError * _Nullable err) {
                                NSLog(@"Write attribute ENUM8 Min Value Error: %@", err);

                                VerifyOrReturn(CheckValue("status", err, 0));

                                NextTest();
                            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeEnum8MinValue_101()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeEnum8WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute ENUM8 Min Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("enum8", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeEnum16DefaultValue_102()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeEnum16WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute ENUM16 Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("enum16", actualValue, 0U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeEnum16MaxValue_103()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id enum16Argument;
        enum16Argument = [NSNumber numberWithUnsignedShort:65535U];
        [cluster writeAttributeEnum16WithValue:enum16Argument
                             completionHandler:^(NSError * _Nullable err) {
                                 NSLog(@"Write attribute ENUM16 Max Value Error: %@", err);

                                 VerifyOrReturn(CheckValue("status", err, 0));

                                 NextTest();
                             }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeEnum16MaxValue_104()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeEnum16WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute ENUM16 Max Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("enum16", actualValue, 65535U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeEnum16MinValue_105()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id enum16Argument;
        enum16Argument = [NSNumber numberWithUnsignedShort:0U];
        [cluster writeAttributeEnum16WithValue:enum16Argument
                             completionHandler:^(NSError * _Nullable err) {
                                 NSLog(@"Write attribute ENUM16 Min Value Error: %@", err);

                                 VerifyOrReturn(CheckValue("status", err, 0));

                                 NextTest();
                             }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeEnum16MinValue_106()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeEnum16WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute ENUM16 Min Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("enum16", actualValue, 0U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeOctetStringDefaultValue_107()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOctetStringWithCompletionHandler:^(NSData * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute OCTET_STRING Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueAsString("octet_string", actualValue, [[NSData alloc] initWithBytes:"" length:0]));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeOctetStringWithEmbeddedNull_108()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id octetStringArgument;
        octetStringArgument = [[NSData alloc] initWithBytes:"Tes\000ti\000ng" length:9];
        [cluster writeAttributeOctetStringWithValue:octetStringArgument
                                  completionHandler:^(NSError * _Nullable err) {
                                      NSLog(@"Write attribute OCTET_STRING with embedded null Error: %@", err);

                                      VerifyOrReturn(CheckValue("status", err, 0));

                                      NextTest();
                                  }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeOctetStringWithEmbeddedNull_109()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOctetStringWithCompletionHandler:^(NSData * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute OCTET_STRING with embedded null Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(
                    CheckValueAsString("octet_string", actualValue, [[NSData alloc] initWithBytes:"Tes\000ti\000ng" length:9]));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeOctetStringWithWeirdChars_110()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id octetStringArgument;
        octetStringArgument = [[NSData alloc] initWithBytes:"\015\012\377\042\240" length:5];
        [cluster writeAttributeOctetStringWithValue:octetStringArgument
                                  completionHandler:^(NSError * _Nullable err) {
                                      NSLog(@"Write attribute OCTET_STRING with weird chars Error: %@", err);

                                      VerifyOrReturn(CheckValue("status", err, 0));

                                      NextTest();
                                  }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeOctetStringWithWeirdChars_111()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOctetStringWithCompletionHandler:^(NSData * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute OCTET_STRING with weird chars Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueAsString(
                    "octet_string", actualValue, [[NSData alloc] initWithBytes:"\015\012\377\042\240" length:5]));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeOctetString_112()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id octetStringArgument;
        octetStringArgument = [[NSData alloc] initWithBytes:"TestValue" length:9];
        [cluster writeAttributeOctetStringWithValue:octetStringArgument
                                  completionHandler:^(NSError * _Nullable err) {
                                      NSLog(@"Write attribute OCTET_STRING Error: %@", err);

                                      VerifyOrReturn(CheckValue("status", err, 0));

                                      NextTest();
                                  }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeOctetString_113()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOctetStringWithCompletionHandler:^(NSData * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute OCTET_STRING Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(
                    CheckValueAsString("octet_string", actualValue, [[NSData alloc] initWithBytes:"TestValue" length:9]));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeOctetString_114()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id octetStringArgument;
        octetStringArgument = [[NSData alloc] initWithBytes:"TestValueLongerThan10" length:21];
        [cluster writeAttributeOctetStringWithValue:octetStringArgument
                                  completionHandler:^(NSError * _Nullable err) {
                                      NSLog(@"Write attribute OCTET_STRING Error: %@", err);

                                      VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
                                      NextTest();
                                  }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeOctetString_115()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOctetStringWithCompletionHandler:^(NSData * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute OCTET_STRING Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(
                    CheckValueAsString("octet_string", actualValue, [[NSData alloc] initWithBytes:"TestValue" length:9]));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeOctetString_116()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id octetStringArgument;
        octetStringArgument = [[NSData alloc] initWithBytes:"" length:0];
        [cluster writeAttributeOctetStringWithValue:octetStringArgument
                                  completionHandler:^(NSError * _Nullable err) {
                                      NSLog(@"Write attribute OCTET_STRING Error: %@", err);

                                      VerifyOrReturn(CheckValue("status", err, 0));

                                      NextTest();
                                  }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeLongOctetStringDefaultValue_117()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeLongOctetStringWithCompletionHandler:^(NSData * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute LONG_OCTET_STRING Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueAsString("long_octet_string", actualValue, [[NSData alloc] initWithBytes:"" length:0]));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeLongOctetString_118()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id longOctetStringArgument;
        longOctetStringArgument = [[NSData alloc]
            initWithBytes:"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
                          "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
                          "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
                   length:300];
        [cluster writeAttributeLongOctetStringWithValue:longOctetStringArgument
                                      completionHandler:^(NSError * _Nullable err) {
                                          NSLog(@"Write attribute LONG_OCTET_STRING Error: %@", err);

                                          VerifyOrReturn(CheckValue("status", err, 0));

                                          NextTest();
                                      }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeLongOctetString_119()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeLongOctetStringWithCompletionHandler:^(NSData * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute LONG_OCTET_STRING Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueAsString("long_octet_string", actualValue,
                    [[NSData alloc]
                        initWithBytes:
                            "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
                            "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
                            "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
                               length:300]));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeLongOctetString_120()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id longOctetStringArgument;
        longOctetStringArgument = [[NSData alloc] initWithBytes:"" length:0];
        [cluster writeAttributeLongOctetStringWithValue:longOctetStringArgument
                                      completionHandler:^(NSError * _Nullable err) {
                                          NSLog(@"Write attribute LONG_OCTET_STRING Error: %@", err);

                                          VerifyOrReturn(CheckValue("status", err, 0));

                                          NextTest();
                                      }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeCharStringDefaultValue_121()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeCharStringWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute CHAR_STRING Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueAsString("char_string", actualValue, @""));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeCharString_122()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id charStringArgument;
        charStringArgument = @"T";
        [cluster writeAttributeCharStringWithValue:charStringArgument
                                 completionHandler:^(NSError * _Nullable err) {
                                     NSLog(@"Write attribute CHAR_STRING Error: %@", err);

                                     VerifyOrReturn(CheckValue("status", err, 0));

                                     NextTest();
                                 }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeCharString_123()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeCharStringWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute CHAR_STRING Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueAsString("char_string", actualValue, @"T"));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeCharStringValueTooLong_124()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id charStringArgument;
        charStringArgument = @"TestValueLongerThan10";
        [cluster writeAttributeCharStringWithValue:charStringArgument
                                 completionHandler:^(NSError * _Nullable err) {
                                     NSLog(@"Write attribute CHAR_STRING - Value too long Error: %@", err);

                                     VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
                                     NextTest();
                                 }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeCharString_125()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeCharStringWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute CHAR_STRING Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueAsString("char_string", actualValue, @"T"));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeCharStringEmpty_126()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id charStringArgument;
        charStringArgument = @"";
        [cluster writeAttributeCharStringWithValue:charStringArgument
                                 completionHandler:^(NSError * _Nullable err) {
                                     NSLog(@"Write attribute CHAR_STRING - Empty Error: %@", err);

                                     VerifyOrReturn(CheckValue("status", err, 0));

                                     NextTest();
                                 }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeLongCharStringDefaultValue_127()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeLongCharStringWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute LONG_CHAR_STRING Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueAsString("long_char_string", actualValue, @""));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeLongCharString_128()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id longCharStringArgument;
        longCharStringArgument
            = @""
              @""
              @"";
        [cluster writeAttributeLongCharStringWithValue:longCharStringArgument
                                     completionHandler:^(NSError * _Nullable err) {
                                         NSLog(@"Write attribute LONG_CHAR_STRING Error: %@", err);

                                         VerifyOrReturn(CheckValue("status", err, 0));

                                         NextTest();
                                     }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeLongCharString_129()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeLongCharStringWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute LONG_CHAR_STRING Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueAsString("long_char_string", actualValue,
                    @""
                    @""
                    @""));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeLongCharString_130()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id longCharStringArgument;
        longCharStringArgument = @"";
        [cluster writeAttributeLongCharStringWithValue:longCharStringArgument
                                     completionHandler:^(NSError * _Nullable err) {
                                         NSLog(@"Write attribute LONG_CHAR_STRING Error: %@", err);

                                         VerifyOrReturn(CheckValue("status", err, 0));

                                         NextTest();
                                     }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeListLongOctetStringForChunkedRead_131()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeListLongOctetStringWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute LIST_LONG_OCTET_STRING (for chunked read) Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("list_long_octet_string", [actualValue count], static_cast<uint32_t>(4)));
                VerifyOrReturn(CheckValueAsString("", actualValue[0],
                    [[NSData alloc]
                        initWithBytes:"0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789ab"
                                      "cdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef01234567"
                                      "89abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123"
                                      "456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"
                                      "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789ab"
                                      "cdef0123456789abcdef0123456789abcdef0123456789abcdef"
                               length:512]));
                VerifyOrReturn(CheckValueAsString("", actualValue[1],
                    [[NSData alloc]
                        initWithBytes:"0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789ab"
                                      "cdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef01234567"
                                      "89abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123"
                                      "456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"
                                      "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789ab"
                                      "cdef0123456789abcdef0123456789abcdef0123456789abcdef"
                               length:512]));
                VerifyOrReturn(CheckValueAsString("", actualValue[2],
                    [[NSData alloc]
                        initWithBytes:"0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789ab"
                                      "cdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef01234567"
                                      "89abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123"
                                      "456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"
                                      "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789ab"
                                      "cdef0123456789abcdef0123456789abcdef0123456789abcdef"
                               length:512]));
                VerifyOrReturn(CheckValueAsString("", actualValue[3],
                    [[NSData alloc]
                        initWithBytes:"0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789ab"
                                      "cdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef01234567"
                                      "89abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123"
                                      "456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"
                                      "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789ab"
                                      "cdef0123456789abcdef0123456789abcdef0123456789abcdef"
                               length:512]));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeListLongOctetStringForChunkedWrite_132()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id listLongOctetStringArgument;
        {
            NSMutableArray * temp_0 = [[NSMutableArray alloc] init];
            temp_0[0] = [[NSData alloc]
                initWithBytes:
                    "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcd"
                    "ef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789ab"
                    "cdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789"
                    "abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef01234567"
                    "89abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"
                       length:512];
            temp_0[1] = [[NSData alloc]
                initWithBytes:
                    "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcd"
                    "ef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789ab"
                    "cdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789"
                    "abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef01234567"
                    "89abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"
                       length:512];
            temp_0[2] = [[NSData alloc]
                initWithBytes:
                    "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcd"
                    "ef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789ab"
                    "cdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789"
                    "abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef01234567"
                    "89abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"
                       length:512];
            temp_0[3] = [[NSData alloc]
                initWithBytes:
                    "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcd"
                    "ef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789ab"
                    "cdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789"
                    "abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef01234567"
                    "89abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"
                       length:512];
            temp_0[4] = [[NSData alloc]
                initWithBytes:
                    "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcd"
                    "ef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789ab"
                    "cdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789"
                    "abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef01234567"
                    "89abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"
                       length:512];
            listLongOctetStringArgument = temp_0;
        }
        [cluster writeAttributeListLongOctetStringWithValue:listLongOctetStringArgument
                                          completionHandler:^(NSError * _Nullable err) {
                                              NSLog(@"Write attribute LIST_LONG_OCTET_STRING (for chunked write) Error: %@", err);

                                              VerifyOrReturn(CheckValue("status", err, 0));

                                              NextTest();
                                          }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeListLongOctetStringForChunkedRead_133()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeListLongOctetStringWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute LIST_LONG_OCTET_STRING (for chunked read) Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("list_long_octet_string", [actualValue count], static_cast<uint32_t>(5)));
                VerifyOrReturn(CheckValueAsString("", actualValue[0],
                    [[NSData alloc]
                        initWithBytes:"0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789ab"
                                      "cdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef01234567"
                                      "89abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123"
                                      "456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"
                                      "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789ab"
                                      "cdef0123456789abcdef0123456789abcdef0123456789abcdef"
                               length:512]));
                VerifyOrReturn(CheckValueAsString("", actualValue[1],
                    [[NSData alloc]
                        initWithBytes:"0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789ab"
                                      "cdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef01234567"
                                      "89abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123"
                                      "456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"
                                      "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789ab"
                                      "cdef0123456789abcdef0123456789abcdef0123456789abcdef"
                               length:512]));
                VerifyOrReturn(CheckValueAsString("", actualValue[2],
                    [[NSData alloc]
                        initWithBytes:"0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789ab"
                                      "cdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef01234567"
                                      "89abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123"
                                      "456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"
                                      "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789ab"
                                      "cdef0123456789abcdef0123456789abcdef0123456789abcdef"
                               length:512]));
                VerifyOrReturn(CheckValueAsString("", actualValue[3],
                    [[NSData alloc]
                        initWithBytes:"0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789ab"
                                      "cdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef01234567"
                                      "89abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123"
                                      "456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"
                                      "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789ab"
                                      "cdef0123456789abcdef0123456789abcdef0123456789abcdef"
                               length:512]));
                VerifyOrReturn(CheckValueAsString("", actualValue[4],
                    [[NSData alloc]
                        initWithBytes:"0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789ab"
                                      "cdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef01234567"
                                      "89abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123"
                                      "456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"
                                      "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789ab"
                                      "cdef0123456789abcdef0123456789abcdef0123456789abcdef"
                               length:512]));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeEpochUsDefaultValue_134()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeEpochUsWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute EPOCH_US Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("epoch_us", actualValue, 0ULL));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeEpochUsMaxValue_135()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id epochUsArgument;
        epochUsArgument = [NSNumber numberWithUnsignedLongLong:18446744073709551615ULL];
        [cluster writeAttributeEpochUsWithValue:epochUsArgument
                              completionHandler:^(NSError * _Nullable err) {
                                  NSLog(@"Write attribute EPOCH_US Max Value Error: %@", err);

                                  VerifyOrReturn(CheckValue("status", err, 0));

                                  NextTest();
                              }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeEpochUsMaxValue_136()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeEpochUsWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute EPOCH_US Max Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("epoch_us", actualValue, 18446744073709551615ULL));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeEpochUsMinValue_137()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id epochUsArgument;
        epochUsArgument = [NSNumber numberWithUnsignedLongLong:0ULL];
        [cluster writeAttributeEpochUsWithValue:epochUsArgument
                              completionHandler:^(NSError * _Nullable err) {
                                  NSLog(@"Write attribute EPOCH_US Min Value Error: %@", err);

                                  VerifyOrReturn(CheckValue("status", err, 0));

                                  NextTest();
                              }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeEpochUsMinValue_138()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeEpochUsWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute EPOCH_US Min Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("epoch_us", actualValue, 0ULL));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeEpochSDefaultValue_139()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeEpochSWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute EPOCH_S Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("epoch_s", actualValue, 0UL));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeEpochSMaxValue_140()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id epochSArgument;
        epochSArgument = [NSNumber numberWithUnsignedInt:4294967295UL];
        [cluster writeAttributeEpochSWithValue:epochSArgument
                             completionHandler:^(NSError * _Nullable err) {
                                 NSLog(@"Write attribute EPOCH_S Max Value Error: %@", err);

                                 VerifyOrReturn(CheckValue("status", err, 0));

                                 NextTest();
                             }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeEpochSMaxValue_141()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeEpochSWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute EPOCH_S Max Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("epoch_s", actualValue, 4294967295UL));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeEpochSMinValue_142()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id epochSArgument;
        epochSArgument = [NSNumber numberWithUnsignedInt:0UL];
        [cluster writeAttributeEpochSWithValue:epochSArgument
                             completionHandler:^(NSError * _Nullable err) {
                                 NSLog(@"Write attribute EPOCH_S Min Value Error: %@", err);

                                 VerifyOrReturn(CheckValue("status", err, 0));

                                 NextTest();
                             }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeEpochSMinValue_143()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeEpochSWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute EPOCH_S Min Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("epoch_s", actualValue, 0UL));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeUnsupported_144()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeUnsupportedWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute UNSUPPORTED Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("unsupported", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteattributeUnsupported_145()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id unsupportedArgument;
        unsupportedArgument = [NSNumber numberWithBool:0];
        [cluster writeAttributeUnsupportedWithValue:unsupportedArgument
                                  completionHandler:^(NSError * _Nullable err) {
                                      NSLog(@"Writeattribute UNSUPPORTED Error: %@", err);

                                      if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                                          NextTest();
                                          return;
                                      }

                                      VerifyOrReturn(CheckValue("status", err, 0));

                                      NextTest();
                                  }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSendTestCommandToUnsupportedEndpoint_146()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:200 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster testWithCompletionHandler:^(NSError * _Nullable err) {
            NSLog(@"Send Test Command to unsupported endpoint Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_ENDPOINT));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSendTestCommandToUnsupportedCluster_147()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:0 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster testWithCompletionHandler:^(NSError * _Nullable err) {
            NSLog(@"Send Test Command to unsupported cluster Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_CLUSTER));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeVendorIdDefaultValue_148()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeVendorIdWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute vendor_id Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("vendor_id", actualValue, 0U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeVendorId_149()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id vendorIdArgument;
        vendorIdArgument = [NSNumber numberWithUnsignedShort:17U];
        [cluster writeAttributeVendorIdWithValue:vendorIdArgument
                               completionHandler:^(NSError * _Nullable err) {
                                   NSLog(@"Write attribute vendor_id Error: %@", err);

                                   VerifyOrReturn(CheckValue("status", err, 0));

                                   NextTest();
                               }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeVendorId_150()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeVendorIdWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute vendor_id Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("vendor_id", actualValue, 17U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestRestoreAttributeVendorId_151()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id vendorIdArgument;
        vendorIdArgument = [NSNumber numberWithUnsignedShort:0U];
        [cluster writeAttributeVendorIdWithValue:vendorIdArgument
                               completionHandler:^(NSError * _Nullable err) {
                                   NSLog(@"Restore attribute vendor_id Error: %@", err);

                                   VerifyOrReturn(CheckValue("status", err, 0));

                                   NextTest();
                               }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSendACommandWithAVendorIdAndEnum_152()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPTestClusterClusterTestEnumsRequestParams alloc] init];
        params.arg1 = [NSNumber numberWithUnsignedShort:20003U];
        params.arg2 = [NSNumber numberWithUnsignedChar:101];
        [cluster testEnumsRequestWithParams:params
                          completionHandler:^(
                              CHIPTestClusterClusterTestEnumsResponseParams * _Nullable values, NSError * _Nullable err) {
                              NSLog(@"Send a command with a vendor_id and enum Error: %@", err);

                              VerifyOrReturn(CheckValue("status", err, 0));

                              {
                                  id actualValue = values.arg1;
                                  VerifyOrReturn(CheckValue("arg1", actualValue, 20003U));
                              }

                              {
                                  id actualValue = values.arg2;
                                  VerifyOrReturn(CheckValue("arg2", actualValue, 101));
                              }

                              NextTest();
                          }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSendTestCommandWithStructArgumentAndArg1bIsTrue_153()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPTestClusterClusterTestStructArgumentRequestParams alloc] init];
        params.arg1 = [[CHIPTestClusterClusterSimpleStruct alloc] init];
        ((CHIPTestClusterClusterSimpleStruct *) params.arg1).a = [NSNumber numberWithUnsignedChar:0];
        ((CHIPTestClusterClusterSimpleStruct *) params.arg1).b = [NSNumber numberWithBool:true];
        ((CHIPTestClusterClusterSimpleStruct *) params.arg1).c = [NSNumber numberWithUnsignedChar:2];
        ((CHIPTestClusterClusterSimpleStruct *) params.arg1).d = [[NSData alloc] initWithBytes:"octet_string" length:12];
        ((CHIPTestClusterClusterSimpleStruct *) params.arg1).e = @"char_string";
        ((CHIPTestClusterClusterSimpleStruct *) params.arg1).f = [NSNumber numberWithUnsignedChar:1];
        ((CHIPTestClusterClusterSimpleStruct *) params.arg1).g = [NSNumber numberWithFloat:0.0f];
        ((CHIPTestClusterClusterSimpleStruct *) params.arg1).h = [NSNumber numberWithDouble:0];

        [cluster testStructArgumentRequestWithParams:params
                                   completionHandler:^(
                                       CHIPTestClusterClusterBooleanResponseParams * _Nullable values, NSError * _Nullable err) {
                                       NSLog(@"Send Test Command With Struct Argument and arg1.b is true Error: %@", err);

                                       VerifyOrReturn(CheckValue("status", err, 0));

                                       {
                                           id actualValue = values.value;
                                           VerifyOrReturn(CheckValue("value", actualValue, true));
                                       }

                                       NextTest();
                                   }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSendTestCommandWithStructArgumentAndArg1bIsFalse_154()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPTestClusterClusterTestStructArgumentRequestParams alloc] init];
        params.arg1 = [[CHIPTestClusterClusterSimpleStruct alloc] init];
        ((CHIPTestClusterClusterSimpleStruct *) params.arg1).a = [NSNumber numberWithUnsignedChar:0];
        ((CHIPTestClusterClusterSimpleStruct *) params.arg1).b = [NSNumber numberWithBool:false];
        ((CHIPTestClusterClusterSimpleStruct *) params.arg1).c = [NSNumber numberWithUnsignedChar:2];
        ((CHIPTestClusterClusterSimpleStruct *) params.arg1).d = [[NSData alloc] initWithBytes:"octet_string" length:12];
        ((CHIPTestClusterClusterSimpleStruct *) params.arg1).e = @"char_string";
        ((CHIPTestClusterClusterSimpleStruct *) params.arg1).f = [NSNumber numberWithUnsignedChar:1];
        ((CHIPTestClusterClusterSimpleStruct *) params.arg1).g = [NSNumber numberWithFloat:0.0f];
        ((CHIPTestClusterClusterSimpleStruct *) params.arg1).h = [NSNumber numberWithDouble:0];

        [cluster testStructArgumentRequestWithParams:params
                                   completionHandler:^(
                                       CHIPTestClusterClusterBooleanResponseParams * _Nullable values, NSError * _Nullable err) {
                                       NSLog(@"Send Test Command With Struct Argument and arg1.b is false Error: %@", err);

                                       VerifyOrReturn(CheckValue("status", err, 0));

                                       {
                                           id actualValue = values.value;
                                           VerifyOrReturn(CheckValue("value", actualValue, false));
                                       }

                                       NextTest();
                                   }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSendTestCommandWithNestedStructArgumentAndArg1cbIsTrue_155()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPTestClusterClusterTestNestedStructArgumentRequestParams alloc] init];
        params.arg1 = [[CHIPTestClusterClusterNestedStruct alloc] init];
        ((CHIPTestClusterClusterNestedStruct *) params.arg1).a = [NSNumber numberWithUnsignedChar:0];
        ((CHIPTestClusterClusterNestedStruct *) params.arg1).b = [NSNumber numberWithBool:true];
        ((CHIPTestClusterClusterNestedStruct *) params.arg1).c = [[CHIPTestClusterClusterSimpleStruct alloc] init];
        ((CHIPTestClusterClusterSimpleStruct *) ((CHIPTestClusterClusterNestedStruct *) params.arg1).c).a =
            [NSNumber numberWithUnsignedChar:0];
        ((CHIPTestClusterClusterSimpleStruct *) ((CHIPTestClusterClusterNestedStruct *) params.arg1).c).b =
            [NSNumber numberWithBool:true];
        ((CHIPTestClusterClusterSimpleStruct *) ((CHIPTestClusterClusterNestedStruct *) params.arg1).c).c =
            [NSNumber numberWithUnsignedChar:2];
        ((CHIPTestClusterClusterSimpleStruct *) ((CHIPTestClusterClusterNestedStruct *) params.arg1).c).d =
            [[NSData alloc] initWithBytes:"octet_string" length:12];
        ((CHIPTestClusterClusterSimpleStruct *) ((CHIPTestClusterClusterNestedStruct *) params.arg1).c).e = @"char_string";
        ((CHIPTestClusterClusterSimpleStruct *) ((CHIPTestClusterClusterNestedStruct *) params.arg1).c).f =
            [NSNumber numberWithUnsignedChar:1];
        ((CHIPTestClusterClusterSimpleStruct *) ((CHIPTestClusterClusterNestedStruct *) params.arg1).c).g =
            [NSNumber numberWithFloat:0.0f];
        ((CHIPTestClusterClusterSimpleStruct *) ((CHIPTestClusterClusterNestedStruct *) params.arg1).c).h =
            [NSNumber numberWithDouble:0];

        [cluster
            testNestedStructArgumentRequestWithParams:params
                                    completionHandler:^(
                                        CHIPTestClusterClusterBooleanResponseParams * _Nullable values, NSError * _Nullable err) {
                                        NSLog(@"Send Test Command With Nested Struct Argument and arg1.c.b is true Error: %@", err);

                                        VerifyOrReturn(CheckValue("status", err, 0));

                                        {
                                            id actualValue = values.value;
                                            VerifyOrReturn(CheckValue("value", actualValue, true));
                                        }

                                        NextTest();
                                    }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSendTestCommandWithNestedStructArgumentArg1cbIsFalse_156()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPTestClusterClusterTestNestedStructArgumentRequestParams alloc] init];
        params.arg1 = [[CHIPTestClusterClusterNestedStruct alloc] init];
        ((CHIPTestClusterClusterNestedStruct *) params.arg1).a = [NSNumber numberWithUnsignedChar:0];
        ((CHIPTestClusterClusterNestedStruct *) params.arg1).b = [NSNumber numberWithBool:true];
        ((CHIPTestClusterClusterNestedStruct *) params.arg1).c = [[CHIPTestClusterClusterSimpleStruct alloc] init];
        ((CHIPTestClusterClusterSimpleStruct *) ((CHIPTestClusterClusterNestedStruct *) params.arg1).c).a =
            [NSNumber numberWithUnsignedChar:0];
        ((CHIPTestClusterClusterSimpleStruct *) ((CHIPTestClusterClusterNestedStruct *) params.arg1).c).b =
            [NSNumber numberWithBool:false];
        ((CHIPTestClusterClusterSimpleStruct *) ((CHIPTestClusterClusterNestedStruct *) params.arg1).c).c =
            [NSNumber numberWithUnsignedChar:2];
        ((CHIPTestClusterClusterSimpleStruct *) ((CHIPTestClusterClusterNestedStruct *) params.arg1).c).d =
            [[NSData alloc] initWithBytes:"octet_string" length:12];
        ((CHIPTestClusterClusterSimpleStruct *) ((CHIPTestClusterClusterNestedStruct *) params.arg1).c).e = @"char_string";
        ((CHIPTestClusterClusterSimpleStruct *) ((CHIPTestClusterClusterNestedStruct *) params.arg1).c).f =
            [NSNumber numberWithUnsignedChar:1];
        ((CHIPTestClusterClusterSimpleStruct *) ((CHIPTestClusterClusterNestedStruct *) params.arg1).c).g =
            [NSNumber numberWithFloat:0.0f];
        ((CHIPTestClusterClusterSimpleStruct *) ((CHIPTestClusterClusterNestedStruct *) params.arg1).c).h =
            [NSNumber numberWithDouble:0];

        [cluster
            testNestedStructArgumentRequestWithParams:params
                                    completionHandler:^(
                                        CHIPTestClusterClusterBooleanResponseParams * _Nullable values, NSError * _Nullable err) {
                                        NSLog(@"Send Test Command With Nested Struct Argument arg1.c.b is false Error: %@", err);

                                        VerifyOrReturn(CheckValue("status", err, 0));

                                        {
                                            id actualValue = values.value;
                                            VerifyOrReturn(CheckValue("value", actualValue, false));
                                        }

                                        NextTest();
                                    }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSendTestCommandWithNestedStructListArgumentAndAllFieldsBOfArg1dAreTrue_157()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPTestClusterClusterTestNestedStructListArgumentRequestParams alloc] init];
        params.arg1 = [[CHIPTestClusterClusterNestedStructList alloc] init];
        ((CHIPTestClusterClusterNestedStructList *) params.arg1).a = [NSNumber numberWithUnsignedChar:0];
        ((CHIPTestClusterClusterNestedStructList *) params.arg1).b = [NSNumber numberWithBool:true];
        ((CHIPTestClusterClusterNestedStructList *) params.arg1).c = [[CHIPTestClusterClusterSimpleStruct alloc] init];
        ((CHIPTestClusterClusterSimpleStruct *) ((CHIPTestClusterClusterNestedStructList *) params.arg1).c).a =
            [NSNumber numberWithUnsignedChar:0];
        ((CHIPTestClusterClusterSimpleStruct *) ((CHIPTestClusterClusterNestedStructList *) params.arg1).c).b =
            [NSNumber numberWithBool:true];
        ((CHIPTestClusterClusterSimpleStruct *) ((CHIPTestClusterClusterNestedStructList *) params.arg1).c).c =
            [NSNumber numberWithUnsignedChar:2];
        ((CHIPTestClusterClusterSimpleStruct *) ((CHIPTestClusterClusterNestedStructList *) params.arg1).c).d =
            [[NSData alloc] initWithBytes:"octet_string" length:12];
        ((CHIPTestClusterClusterSimpleStruct *) ((CHIPTestClusterClusterNestedStructList *) params.arg1).c).e = @"char_string";
        ((CHIPTestClusterClusterSimpleStruct *) ((CHIPTestClusterClusterNestedStructList *) params.arg1).c).f =
            [NSNumber numberWithUnsignedChar:1];
        ((CHIPTestClusterClusterSimpleStruct *) ((CHIPTestClusterClusterNestedStructList *) params.arg1).c).g =
            [NSNumber numberWithFloat:0.0f];
        ((CHIPTestClusterClusterSimpleStruct *) ((CHIPTestClusterClusterNestedStructList *) params.arg1).c).h =
            [NSNumber numberWithDouble:0];

        {
            NSMutableArray * temp_1 = [[NSMutableArray alloc] init];
            temp_1[0] = [[CHIPTestClusterClusterSimpleStruct alloc] init];
            ((CHIPTestClusterClusterSimpleStruct *) temp_1[0]).a = [NSNumber numberWithUnsignedChar:1];
            ((CHIPTestClusterClusterSimpleStruct *) temp_1[0]).b = [NSNumber numberWithBool:true];
            ((CHIPTestClusterClusterSimpleStruct *) temp_1[0]).c = [NSNumber numberWithUnsignedChar:3];
            ((CHIPTestClusterClusterSimpleStruct *) temp_1[0]).d = [[NSData alloc] initWithBytes:"nested_octet_string" length:19];
            ((CHIPTestClusterClusterSimpleStruct *) temp_1[0]).e = @"nested_char_string";
            ((CHIPTestClusterClusterSimpleStruct *) temp_1[0]).f = [NSNumber numberWithUnsignedChar:1];
            ((CHIPTestClusterClusterSimpleStruct *) temp_1[0]).g = [NSNumber numberWithFloat:0.0f];
            ((CHIPTestClusterClusterSimpleStruct *) temp_1[0]).h = [NSNumber numberWithDouble:0];

            temp_1[1] = [[CHIPTestClusterClusterSimpleStruct alloc] init];
            ((CHIPTestClusterClusterSimpleStruct *) temp_1[1]).a = [NSNumber numberWithUnsignedChar:2];
            ((CHIPTestClusterClusterSimpleStruct *) temp_1[1]).b = [NSNumber numberWithBool:true];
            ((CHIPTestClusterClusterSimpleStruct *) temp_1[1]).c = [NSNumber numberWithUnsignedChar:3];
            ((CHIPTestClusterClusterSimpleStruct *) temp_1[1]).d = [[NSData alloc] initWithBytes:"nested_octet_string" length:19];
            ((CHIPTestClusterClusterSimpleStruct *) temp_1[1]).e = @"nested_char_string";
            ((CHIPTestClusterClusterSimpleStruct *) temp_1[1]).f = [NSNumber numberWithUnsignedChar:1];
            ((CHIPTestClusterClusterSimpleStruct *) temp_1[1]).g = [NSNumber numberWithFloat:0.0f];
            ((CHIPTestClusterClusterSimpleStruct *) temp_1[1]).h = [NSNumber numberWithDouble:0];

            ((CHIPTestClusterClusterNestedStructList *) params.arg1).d = temp_1;
        }
        {
            NSMutableArray * temp_1 = [[NSMutableArray alloc] init];
            temp_1[0] = [NSNumber numberWithUnsignedInt:1UL];
            temp_1[1] = [NSNumber numberWithUnsignedInt:2UL];
            temp_1[2] = [NSNumber numberWithUnsignedInt:3UL];
            ((CHIPTestClusterClusterNestedStructList *) params.arg1).e = temp_1;
        }
        {
            NSMutableArray * temp_1 = [[NSMutableArray alloc] init];
            temp_1[0] = [[NSData alloc] initWithBytes:"octet_string_1" length:14];
            temp_1[1] = [[NSData alloc] initWithBytes:"octect_string_2" length:15];
            temp_1[2] = [[NSData alloc] initWithBytes:"octet_string_3" length:14];
            ((CHIPTestClusterClusterNestedStructList *) params.arg1).f = temp_1;
        }
        {
            NSMutableArray * temp_1 = [[NSMutableArray alloc] init];
            temp_1[0] = [NSNumber numberWithUnsignedChar:0];
            temp_1[1] = [NSNumber numberWithUnsignedChar:255];
            ((CHIPTestClusterClusterNestedStructList *) params.arg1).g = temp_1;
        }

        [cluster testNestedStructListArgumentRequestWithParams:params
                                             completionHandler:^(CHIPTestClusterClusterBooleanResponseParams * _Nullable values,
                                                 NSError * _Nullable err) {
                                                 NSLog(@"Send Test Command With Nested Struct List Argument and all fields b of "
                                                       @"arg1.d are true Error: %@",
                                                     err);

                                                 VerifyOrReturn(CheckValue("status", err, 0));

                                                 {
                                                     id actualValue = values.value;
                                                     VerifyOrReturn(CheckValue("value", actualValue, true));
                                                 }

                                                 NextTest();
                                             }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSendTestCommandWithNestedStructListArgumentAndSomeFieldsBOfArg1dAreFalse_158()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPTestClusterClusterTestNestedStructListArgumentRequestParams alloc] init];
        params.arg1 = [[CHIPTestClusterClusterNestedStructList alloc] init];
        ((CHIPTestClusterClusterNestedStructList *) params.arg1).a = [NSNumber numberWithUnsignedChar:0];
        ((CHIPTestClusterClusterNestedStructList *) params.arg1).b = [NSNumber numberWithBool:true];
        ((CHIPTestClusterClusterNestedStructList *) params.arg1).c = [[CHIPTestClusterClusterSimpleStruct alloc] init];
        ((CHIPTestClusterClusterSimpleStruct *) ((CHIPTestClusterClusterNestedStructList *) params.arg1).c).a =
            [NSNumber numberWithUnsignedChar:0];
        ((CHIPTestClusterClusterSimpleStruct *) ((CHIPTestClusterClusterNestedStructList *) params.arg1).c).b =
            [NSNumber numberWithBool:true];
        ((CHIPTestClusterClusterSimpleStruct *) ((CHIPTestClusterClusterNestedStructList *) params.arg1).c).c =
            [NSNumber numberWithUnsignedChar:2];
        ((CHIPTestClusterClusterSimpleStruct *) ((CHIPTestClusterClusterNestedStructList *) params.arg1).c).d =
            [[NSData alloc] initWithBytes:"octet_string" length:12];
        ((CHIPTestClusterClusterSimpleStruct *) ((CHIPTestClusterClusterNestedStructList *) params.arg1).c).e = @"char_string";
        ((CHIPTestClusterClusterSimpleStruct *) ((CHIPTestClusterClusterNestedStructList *) params.arg1).c).f =
            [NSNumber numberWithUnsignedChar:1];
        ((CHIPTestClusterClusterSimpleStruct *) ((CHIPTestClusterClusterNestedStructList *) params.arg1).c).g =
            [NSNumber numberWithFloat:0.0f];
        ((CHIPTestClusterClusterSimpleStruct *) ((CHIPTestClusterClusterNestedStructList *) params.arg1).c).h =
            [NSNumber numberWithDouble:0];

        {
            NSMutableArray * temp_1 = [[NSMutableArray alloc] init];
            temp_1[0] = [[CHIPTestClusterClusterSimpleStruct alloc] init];
            ((CHIPTestClusterClusterSimpleStruct *) temp_1[0]).a = [NSNumber numberWithUnsignedChar:1];
            ((CHIPTestClusterClusterSimpleStruct *) temp_1[0]).b = [NSNumber numberWithBool:true];
            ((CHIPTestClusterClusterSimpleStruct *) temp_1[0]).c = [NSNumber numberWithUnsignedChar:3];
            ((CHIPTestClusterClusterSimpleStruct *) temp_1[0]).d = [[NSData alloc] initWithBytes:"nested_octet_string" length:19];
            ((CHIPTestClusterClusterSimpleStruct *) temp_1[0]).e = @"nested_char_string";
            ((CHIPTestClusterClusterSimpleStruct *) temp_1[0]).f = [NSNumber numberWithUnsignedChar:1];
            ((CHIPTestClusterClusterSimpleStruct *) temp_1[0]).g = [NSNumber numberWithFloat:0.0f];
            ((CHIPTestClusterClusterSimpleStruct *) temp_1[0]).h = [NSNumber numberWithDouble:0];

            temp_1[1] = [[CHIPTestClusterClusterSimpleStruct alloc] init];
            ((CHIPTestClusterClusterSimpleStruct *) temp_1[1]).a = [NSNumber numberWithUnsignedChar:2];
            ((CHIPTestClusterClusterSimpleStruct *) temp_1[1]).b = [NSNumber numberWithBool:false];
            ((CHIPTestClusterClusterSimpleStruct *) temp_1[1]).c = [NSNumber numberWithUnsignedChar:3];
            ((CHIPTestClusterClusterSimpleStruct *) temp_1[1]).d = [[NSData alloc] initWithBytes:"nested_octet_string" length:19];
            ((CHIPTestClusterClusterSimpleStruct *) temp_1[1]).e = @"nested_char_string";
            ((CHIPTestClusterClusterSimpleStruct *) temp_1[1]).f = [NSNumber numberWithUnsignedChar:1];
            ((CHIPTestClusterClusterSimpleStruct *) temp_1[1]).g = [NSNumber numberWithFloat:0.0f];
            ((CHIPTestClusterClusterSimpleStruct *) temp_1[1]).h = [NSNumber numberWithDouble:0];

            ((CHIPTestClusterClusterNestedStructList *) params.arg1).d = temp_1;
        }
        {
            NSMutableArray * temp_1 = [[NSMutableArray alloc] init];
            temp_1[0] = [NSNumber numberWithUnsignedInt:1UL];
            temp_1[1] = [NSNumber numberWithUnsignedInt:2UL];
            temp_1[2] = [NSNumber numberWithUnsignedInt:3UL];
            ((CHIPTestClusterClusterNestedStructList *) params.arg1).e = temp_1;
        }
        {
            NSMutableArray * temp_1 = [[NSMutableArray alloc] init];
            temp_1[0] = [[NSData alloc] initWithBytes:"octet_string_1" length:14];
            temp_1[1] = [[NSData alloc] initWithBytes:"octect_string_2" length:15];
            temp_1[2] = [[NSData alloc] initWithBytes:"octet_string_3" length:14];
            ((CHIPTestClusterClusterNestedStructList *) params.arg1).f = temp_1;
        }
        {
            NSMutableArray * temp_1 = [[NSMutableArray alloc] init];
            temp_1[0] = [NSNumber numberWithUnsignedChar:0];
            temp_1[1] = [NSNumber numberWithUnsignedChar:255];
            ((CHIPTestClusterClusterNestedStructList *) params.arg1).g = temp_1;
        }

        [cluster testNestedStructListArgumentRequestWithParams:params
                                             completionHandler:^(CHIPTestClusterClusterBooleanResponseParams * _Nullable values,
                                                 NSError * _Nullable err) {
                                                 NSLog(@"Send Test Command With Nested Struct List Argument and some fields b of "
                                                       @"arg1.d are false Error: %@",
                                                     err);

                                                 VerifyOrReturn(CheckValue("status", err, 0));

                                                 {
                                                     id actualValue = values.value;
                                                     VerifyOrReturn(CheckValue("value", actualValue, false));
                                                 }

                                                 NextTest();
                                             }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSendTestCommandWithStructArgumentAndSeeWhatWeGetBack_159()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPTestClusterClusterSimpleStructEchoRequestParams alloc] init];
        params.arg1 = [[CHIPTestClusterClusterSimpleStruct alloc] init];
        ((CHIPTestClusterClusterSimpleStruct *) params.arg1).a = [NSNumber numberWithUnsignedChar:17];
        ((CHIPTestClusterClusterSimpleStruct *) params.arg1).b = [NSNumber numberWithBool:false];
        ((CHIPTestClusterClusterSimpleStruct *) params.arg1).c = [NSNumber numberWithUnsignedChar:2];
        ((CHIPTestClusterClusterSimpleStruct *) params.arg1).d = [[NSData alloc] initWithBytes:"octet_string" length:12];
        ((CHIPTestClusterClusterSimpleStruct *) params.arg1).e = @"char_string";
        ((CHIPTestClusterClusterSimpleStruct *) params.arg1).f = [NSNumber numberWithUnsignedChar:1];
        ((CHIPTestClusterClusterSimpleStruct *) params.arg1).g = [NSNumber numberWithFloat:0.1f];
        ((CHIPTestClusterClusterSimpleStruct *) params.arg1).h = [NSNumber numberWithDouble:0.1];

        [cluster
            simpleStructEchoRequestWithParams:params
                            completionHandler:^(
                                CHIPTestClusterClusterSimpleStructResponseParams * _Nullable values, NSError * _Nullable err) {
                                NSLog(@"Send Test Command With Struct Argument and see what we get back Error: %@", err);

                                VerifyOrReturn(CheckValue("status", err, 0));

                                {
                                    id actualValue = values.arg1;
                                    VerifyOrReturn(CheckValue("a", ((CHIPTestClusterClusterSimpleStruct *) actualValue).a, 17));
                                    VerifyOrReturn(CheckValue("b", ((CHIPTestClusterClusterSimpleStruct *) actualValue).b, false));
                                    VerifyOrReturn(CheckValue("c", ((CHIPTestClusterClusterSimpleStruct *) actualValue).c, 2));
                                    VerifyOrReturn(CheckValueAsString("d", ((CHIPTestClusterClusterSimpleStruct *) actualValue).d,
                                        [[NSData alloc] initWithBytes:"octet_string" length:12]));
                                    VerifyOrReturn(CheckValueAsString(
                                        "e", ((CHIPTestClusterClusterSimpleStruct *) actualValue).e, @"char_string"));
                                    VerifyOrReturn(CheckValue("f", ((CHIPTestClusterClusterSimpleStruct *) actualValue).f, 1));
                                    VerifyOrReturn(CheckValue("g", ((CHIPTestClusterClusterSimpleStruct *) actualValue).g, 0.1f));
                                    VerifyOrReturn(CheckValue("h", ((CHIPTestClusterClusterSimpleStruct *) actualValue).h, 0.1));
                                }

                                NextTest();
                            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSendTestCommandWithListOfInt8uAndNoneOfThemIsSetTo0_160()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPTestClusterClusterTestListInt8UArgumentRequestParams alloc] init];
        {
            NSMutableArray * temp_0 = [[NSMutableArray alloc] init];
            temp_0[0] = [NSNumber numberWithUnsignedChar:1];
            temp_0[1] = [NSNumber numberWithUnsignedChar:2];
            temp_0[2] = [NSNumber numberWithUnsignedChar:3];
            temp_0[3] = [NSNumber numberWithUnsignedChar:4];
            temp_0[4] = [NSNumber numberWithUnsignedChar:5];
            temp_0[5] = [NSNumber numberWithUnsignedChar:6];
            temp_0[6] = [NSNumber numberWithUnsignedChar:7];
            temp_0[7] = [NSNumber numberWithUnsignedChar:8];
            temp_0[8] = [NSNumber numberWithUnsignedChar:9];
            params.arg1 = temp_0;
        }
        [cluster
            testListInt8UArgumentRequestWithParams:params
                                 completionHandler:^(
                                     CHIPTestClusterClusterBooleanResponseParams * _Nullable values, NSError * _Nullable err) {
                                     NSLog(@"Send Test Command With List of INT8U and none of them is set to 0 Error: %@", err);

                                     VerifyOrReturn(CheckValue("status", err, 0));

                                     {
                                         id actualValue = values.value;
                                         VerifyOrReturn(CheckValue("value", actualValue, true));
                                     }

                                     NextTest();
                                 }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSendTestCommandWithListOfInt8uAndOneOfThemIsSetTo0_161()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPTestClusterClusterTestListInt8UArgumentRequestParams alloc] init];
        {
            NSMutableArray * temp_0 = [[NSMutableArray alloc] init];
            temp_0[0] = [NSNumber numberWithUnsignedChar:1];
            temp_0[1] = [NSNumber numberWithUnsignedChar:2];
            temp_0[2] = [NSNumber numberWithUnsignedChar:3];
            temp_0[3] = [NSNumber numberWithUnsignedChar:4];
            temp_0[4] = [NSNumber numberWithUnsignedChar:5];
            temp_0[5] = [NSNumber numberWithUnsignedChar:6];
            temp_0[6] = [NSNumber numberWithUnsignedChar:7];
            temp_0[7] = [NSNumber numberWithUnsignedChar:8];
            temp_0[8] = [NSNumber numberWithUnsignedChar:9];
            temp_0[9] = [NSNumber numberWithUnsignedChar:0];
            params.arg1 = temp_0;
        }
        [cluster testListInt8UArgumentRequestWithParams:params
                                      completionHandler:^(
                                          CHIPTestClusterClusterBooleanResponseParams * _Nullable values, NSError * _Nullable err) {
                                          NSLog(@"Send Test Command With List of INT8U and one of them is set to 0 Error: %@", err);

                                          VerifyOrReturn(CheckValue("status", err, 0));

                                          {
                                              id actualValue = values.value;
                                              VerifyOrReturn(CheckValue("value", actualValue, false));
                                          }

                                          NextTest();
                                      }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSendTestCommandWithListOfInt8uAndGetItReversed_162()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPTestClusterClusterTestListInt8UReverseRequestParams alloc] init];
        {
            NSMutableArray * temp_0 = [[NSMutableArray alloc] init];
            temp_0[0] = [NSNumber numberWithUnsignedChar:1];
            temp_0[1] = [NSNumber numberWithUnsignedChar:2];
            temp_0[2] = [NSNumber numberWithUnsignedChar:3];
            temp_0[3] = [NSNumber numberWithUnsignedChar:4];
            temp_0[4] = [NSNumber numberWithUnsignedChar:5];
            temp_0[5] = [NSNumber numberWithUnsignedChar:6];
            temp_0[6] = [NSNumber numberWithUnsignedChar:7];
            temp_0[7] = [NSNumber numberWithUnsignedChar:8];
            temp_0[8] = [NSNumber numberWithUnsignedChar:9];
            params.arg1 = temp_0;
        }
        [cluster
            testListInt8UReverseRequestWithParams:params
                                completionHandler:^(CHIPTestClusterClusterTestListInt8UReverseResponseParams * _Nullable values,
                                    NSError * _Nullable err) {
                                    NSLog(@"Send Test Command With List of INT8U and get it reversed Error: %@", err);

                                    VerifyOrReturn(CheckValue("status", err, 0));

                                    {
                                        id actualValue = values.arg1;
                                        VerifyOrReturn(CheckValue("arg1", [actualValue count], static_cast<uint32_t>(9)));
                                        VerifyOrReturn(CheckValue("", actualValue[0], 9));
                                        VerifyOrReturn(CheckValue("", actualValue[1], 8));
                                        VerifyOrReturn(CheckValue("", actualValue[2], 7));
                                        VerifyOrReturn(CheckValue("", actualValue[3], 6));
                                        VerifyOrReturn(CheckValue("", actualValue[4], 5));
                                        VerifyOrReturn(CheckValue("", actualValue[5], 4));
                                        VerifyOrReturn(CheckValue("", actualValue[6], 3));
                                        VerifyOrReturn(CheckValue("", actualValue[7], 2));
                                        VerifyOrReturn(CheckValue("", actualValue[8], 1));
                                    }

                                    NextTest();
                                }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSendTestCommandWithEmptyListOfInt8uAndGetAnEmptyListBack_163()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPTestClusterClusterTestListInt8UReverseRequestParams alloc] init];
        {
            NSMutableArray * temp_0 = [[NSMutableArray alloc] init];
            params.arg1 = temp_0;
        }
        [cluster
            testListInt8UReverseRequestWithParams:params
                                completionHandler:^(CHIPTestClusterClusterTestListInt8UReverseResponseParams * _Nullable values,
                                    NSError * _Nullable err) {
                                    NSLog(@"Send Test Command With empty List of INT8U and get an empty list back Error: %@", err);

                                    VerifyOrReturn(CheckValue("status", err, 0));

                                    {
                                        id actualValue = values.arg1;
                                        VerifyOrReturn(CheckValue("arg1", [actualValue count], static_cast<uint32_t>(0)));
                                    }

                                    NextTest();
                                }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSendTestCommandWithListOfStructArgumentAndArg1bOfFirstItemIsTrue_164()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPTestClusterClusterTestListStructArgumentRequestParams alloc] init];
        {
            NSMutableArray * temp_0 = [[NSMutableArray alloc] init];
            temp_0[0] = [[CHIPTestClusterClusterSimpleStruct alloc] init];
            ((CHIPTestClusterClusterSimpleStruct *) temp_0[0]).a = [NSNumber numberWithUnsignedChar:0];
            ((CHIPTestClusterClusterSimpleStruct *) temp_0[0]).b = [NSNumber numberWithBool:true];
            ((CHIPTestClusterClusterSimpleStruct *) temp_0[0]).c = [NSNumber numberWithUnsignedChar:2];
            ((CHIPTestClusterClusterSimpleStruct *) temp_0[0]).d = [[NSData alloc] initWithBytes:"first_octet_string" length:18];
            ((CHIPTestClusterClusterSimpleStruct *) temp_0[0]).e = @"first_char_string";
            ((CHIPTestClusterClusterSimpleStruct *) temp_0[0]).f = [NSNumber numberWithUnsignedChar:1];
            ((CHIPTestClusterClusterSimpleStruct *) temp_0[0]).g = [NSNumber numberWithFloat:0.0f];
            ((CHIPTestClusterClusterSimpleStruct *) temp_0[0]).h = [NSNumber numberWithDouble:0];

            temp_0[1] = [[CHIPTestClusterClusterSimpleStruct alloc] init];
            ((CHIPTestClusterClusterSimpleStruct *) temp_0[1]).a = [NSNumber numberWithUnsignedChar:1];
            ((CHIPTestClusterClusterSimpleStruct *) temp_0[1]).b = [NSNumber numberWithBool:true];
            ((CHIPTestClusterClusterSimpleStruct *) temp_0[1]).c = [NSNumber numberWithUnsignedChar:3];
            ((CHIPTestClusterClusterSimpleStruct *) temp_0[1]).d = [[NSData alloc] initWithBytes:"second_octet_string" length:19];
            ((CHIPTestClusterClusterSimpleStruct *) temp_0[1]).e = @"second_char_string";
            ((CHIPTestClusterClusterSimpleStruct *) temp_0[1]).f = [NSNumber numberWithUnsignedChar:1];
            ((CHIPTestClusterClusterSimpleStruct *) temp_0[1]).g = [NSNumber numberWithFloat:0.0f];
            ((CHIPTestClusterClusterSimpleStruct *) temp_0[1]).h = [NSNumber numberWithDouble:0];

            params.arg1 = temp_0;
        }
        [cluster testListStructArgumentRequestWithParams:params
                                       completionHandler:^(CHIPTestClusterClusterBooleanResponseParams * _Nullable values,
                                           NSError * _Nullable err) {
                                           NSLog(@"Send Test Command With List of Struct Argument and arg1.b of first item is true "
                                                 @"Error: %@",
                                               err);

                                           VerifyOrReturn(CheckValue("status", err, 0));

                                           {
                                               id actualValue = values.value;
                                               VerifyOrReturn(CheckValue("value", actualValue, true));
                                           }

                                           NextTest();
                                       }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSendTestCommandWithListOfStructArgumentAndArg1bOfFirstItemIsFalse_165()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPTestClusterClusterTestListStructArgumentRequestParams alloc] init];
        {
            NSMutableArray * temp_0 = [[NSMutableArray alloc] init];
            temp_0[0] = [[CHIPTestClusterClusterSimpleStruct alloc] init];
            ((CHIPTestClusterClusterSimpleStruct *) temp_0[0]).a = [NSNumber numberWithUnsignedChar:1];
            ((CHIPTestClusterClusterSimpleStruct *) temp_0[0]).b = [NSNumber numberWithBool:true];
            ((CHIPTestClusterClusterSimpleStruct *) temp_0[0]).c = [NSNumber numberWithUnsignedChar:3];
            ((CHIPTestClusterClusterSimpleStruct *) temp_0[0]).d = [[NSData alloc] initWithBytes:"second_octet_string" length:19];
            ((CHIPTestClusterClusterSimpleStruct *) temp_0[0]).e = @"second_char_string";
            ((CHIPTestClusterClusterSimpleStruct *) temp_0[0]).f = [NSNumber numberWithUnsignedChar:1];
            ((CHIPTestClusterClusterSimpleStruct *) temp_0[0]).g = [NSNumber numberWithFloat:0.0f];
            ((CHIPTestClusterClusterSimpleStruct *) temp_0[0]).h = [NSNumber numberWithDouble:0];

            temp_0[1] = [[CHIPTestClusterClusterSimpleStruct alloc] init];
            ((CHIPTestClusterClusterSimpleStruct *) temp_0[1]).a = [NSNumber numberWithUnsignedChar:0];
            ((CHIPTestClusterClusterSimpleStruct *) temp_0[1]).b = [NSNumber numberWithBool:false];
            ((CHIPTestClusterClusterSimpleStruct *) temp_0[1]).c = [NSNumber numberWithUnsignedChar:2];
            ((CHIPTestClusterClusterSimpleStruct *) temp_0[1]).d = [[NSData alloc] initWithBytes:"first_octet_string" length:18];
            ((CHIPTestClusterClusterSimpleStruct *) temp_0[1]).e = @"first_char_string";
            ((CHIPTestClusterClusterSimpleStruct *) temp_0[1]).f = [NSNumber numberWithUnsignedChar:1];
            ((CHIPTestClusterClusterSimpleStruct *) temp_0[1]).g = [NSNumber numberWithFloat:0.0f];
            ((CHIPTestClusterClusterSimpleStruct *) temp_0[1]).h = [NSNumber numberWithDouble:0];

            params.arg1 = temp_0;
        }
        [cluster testListStructArgumentRequestWithParams:params
                                       completionHandler:^(CHIPTestClusterClusterBooleanResponseParams * _Nullable values,
                                           NSError * _Nullable err) {
                                           NSLog(@"Send Test Command With List of Struct Argument and arg1.b of first item is "
                                                 @"false Error: %@",
                                               err);

                                           VerifyOrReturn(CheckValue("status", err, 0));

                                           {
                                               id actualValue = values.value;
                                               VerifyOrReturn(CheckValue("value", actualValue, false));
                                           }

                                           NextTest();
                                       }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSendTestCommandWithListOfNestedStructListArgumentAndAllFieldsBOfElementsOfArg1dAreTrue_166()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPTestClusterClusterTestListNestedStructListArgumentRequestParams alloc] init];
        {
            NSMutableArray * temp_0 = [[NSMutableArray alloc] init];
            temp_0[0] = [[CHIPTestClusterClusterNestedStructList alloc] init];
            ((CHIPTestClusterClusterNestedStructList *) temp_0[0]).a = [NSNumber numberWithUnsignedChar:0];
            ((CHIPTestClusterClusterNestedStructList *) temp_0[0]).b = [NSNumber numberWithBool:true];
            ((CHIPTestClusterClusterNestedStructList *) temp_0[0]).c = [[CHIPTestClusterClusterSimpleStruct alloc] init];
            ((CHIPTestClusterClusterSimpleStruct *) ((CHIPTestClusterClusterNestedStructList *) temp_0[0]).c).a =
                [NSNumber numberWithUnsignedChar:0];
            ((CHIPTestClusterClusterSimpleStruct *) ((CHIPTestClusterClusterNestedStructList *) temp_0[0]).c).b =
                [NSNumber numberWithBool:true];
            ((CHIPTestClusterClusterSimpleStruct *) ((CHIPTestClusterClusterNestedStructList *) temp_0[0]).c).c =
                [NSNumber numberWithUnsignedChar:2];
            ((CHIPTestClusterClusterSimpleStruct *) ((CHIPTestClusterClusterNestedStructList *) temp_0[0]).c).d =
                [[NSData alloc] initWithBytes:"octet_string" length:12];
            ((CHIPTestClusterClusterSimpleStruct *) ((CHIPTestClusterClusterNestedStructList *) temp_0[0]).c).e = @"char_string";
            ((CHIPTestClusterClusterSimpleStruct *) ((CHIPTestClusterClusterNestedStructList *) temp_0[0]).c).f =
                [NSNumber numberWithUnsignedChar:1];
            ((CHIPTestClusterClusterSimpleStruct *) ((CHIPTestClusterClusterNestedStructList *) temp_0[0]).c).g =
                [NSNumber numberWithFloat:0.0f];
            ((CHIPTestClusterClusterSimpleStruct *) ((CHIPTestClusterClusterNestedStructList *) temp_0[0]).c).h =
                [NSNumber numberWithDouble:0];

            {
                NSMutableArray * temp_2 = [[NSMutableArray alloc] init];
                temp_2[0] = [[CHIPTestClusterClusterSimpleStruct alloc] init];
                ((CHIPTestClusterClusterSimpleStruct *) temp_2[0]).a = [NSNumber numberWithUnsignedChar:1];
                ((CHIPTestClusterClusterSimpleStruct *) temp_2[0]).b = [NSNumber numberWithBool:true];
                ((CHIPTestClusterClusterSimpleStruct *) temp_2[0]).c = [NSNumber numberWithUnsignedChar:3];
                ((CHIPTestClusterClusterSimpleStruct *) temp_2[0]).d = [[NSData alloc] initWithBytes:"nested_octet_string"
                                                                                              length:19];
                ((CHIPTestClusterClusterSimpleStruct *) temp_2[0]).e = @"nested_char_string";
                ((CHIPTestClusterClusterSimpleStruct *) temp_2[0]).f = [NSNumber numberWithUnsignedChar:1];
                ((CHIPTestClusterClusterSimpleStruct *) temp_2[0]).g = [NSNumber numberWithFloat:0.0f];
                ((CHIPTestClusterClusterSimpleStruct *) temp_2[0]).h = [NSNumber numberWithDouble:0];

                temp_2[1] = [[CHIPTestClusterClusterSimpleStruct alloc] init];
                ((CHIPTestClusterClusterSimpleStruct *) temp_2[1]).a = [NSNumber numberWithUnsignedChar:2];
                ((CHIPTestClusterClusterSimpleStruct *) temp_2[1]).b = [NSNumber numberWithBool:true];
                ((CHIPTestClusterClusterSimpleStruct *) temp_2[1]).c = [NSNumber numberWithUnsignedChar:3];
                ((CHIPTestClusterClusterSimpleStruct *) temp_2[1]).d = [[NSData alloc] initWithBytes:"nested_octet_string"
                                                                                              length:19];
                ((CHIPTestClusterClusterSimpleStruct *) temp_2[1]).e = @"nested_char_string";
                ((CHIPTestClusterClusterSimpleStruct *) temp_2[1]).f = [NSNumber numberWithUnsignedChar:1];
                ((CHIPTestClusterClusterSimpleStruct *) temp_2[1]).g = [NSNumber numberWithFloat:0.0f];
                ((CHIPTestClusterClusterSimpleStruct *) temp_2[1]).h = [NSNumber numberWithDouble:0];

                ((CHIPTestClusterClusterNestedStructList *) temp_0[0]).d = temp_2;
            }
            {
                NSMutableArray * temp_2 = [[NSMutableArray alloc] init];
                temp_2[0] = [NSNumber numberWithUnsignedInt:1UL];
                temp_2[1] = [NSNumber numberWithUnsignedInt:2UL];
                temp_2[2] = [NSNumber numberWithUnsignedInt:3UL];
                ((CHIPTestClusterClusterNestedStructList *) temp_0[0]).e = temp_2;
            }
            {
                NSMutableArray * temp_2 = [[NSMutableArray alloc] init];
                temp_2[0] = [[NSData alloc] initWithBytes:"octet_string_1" length:14];
                temp_2[1] = [[NSData alloc] initWithBytes:"octect_string_2" length:15];
                temp_2[2] = [[NSData alloc] initWithBytes:"octet_string_3" length:14];
                ((CHIPTestClusterClusterNestedStructList *) temp_0[0]).f = temp_2;
            }
            {
                NSMutableArray * temp_2 = [[NSMutableArray alloc] init];
                temp_2[0] = [NSNumber numberWithUnsignedChar:0];
                temp_2[1] = [NSNumber numberWithUnsignedChar:255];
                ((CHIPTestClusterClusterNestedStructList *) temp_0[0]).g = temp_2;
            }

            params.arg1 = temp_0;
        }
        [cluster testListNestedStructListArgumentRequestWithParams:params
                                                 completionHandler:^(CHIPTestClusterClusterBooleanResponseParams * _Nullable values,
                                                     NSError * _Nullable err) {
                                                     NSLog(@"Send Test Command With List of Nested Struct List Argument and all "
                                                           @"fields b of elements of arg1.d are true Error: %@",
                                                         err);

                                                     VerifyOrReturn(CheckValue("status", err, 0));

                                                     {
                                                         id actualValue = values.value;
                                                         VerifyOrReturn(CheckValue("value", actualValue, true));
                                                     }

                                                     NextTest();
                                                 }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSendTestCommandWithNestedStructListArgumentAndSomeFieldsBOfElementsOfArg1dAreFalse_167()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPTestClusterClusterTestListNestedStructListArgumentRequestParams alloc] init];
        {
            NSMutableArray * temp_0 = [[NSMutableArray alloc] init];
            temp_0[0] = [[CHIPTestClusterClusterNestedStructList alloc] init];
            ((CHIPTestClusterClusterNestedStructList *) temp_0[0]).a = [NSNumber numberWithUnsignedChar:0];
            ((CHIPTestClusterClusterNestedStructList *) temp_0[0]).b = [NSNumber numberWithBool:true];
            ((CHIPTestClusterClusterNestedStructList *) temp_0[0]).c = [[CHIPTestClusterClusterSimpleStruct alloc] init];
            ((CHIPTestClusterClusterSimpleStruct *) ((CHIPTestClusterClusterNestedStructList *) temp_0[0]).c).a =
                [NSNumber numberWithUnsignedChar:0];
            ((CHIPTestClusterClusterSimpleStruct *) ((CHIPTestClusterClusterNestedStructList *) temp_0[0]).c).b =
                [NSNumber numberWithBool:true];
            ((CHIPTestClusterClusterSimpleStruct *) ((CHIPTestClusterClusterNestedStructList *) temp_0[0]).c).c =
                [NSNumber numberWithUnsignedChar:2];
            ((CHIPTestClusterClusterSimpleStruct *) ((CHIPTestClusterClusterNestedStructList *) temp_0[0]).c).d =
                [[NSData alloc] initWithBytes:"octet_string" length:12];
            ((CHIPTestClusterClusterSimpleStruct *) ((CHIPTestClusterClusterNestedStructList *) temp_0[0]).c).e = @"char_string";
            ((CHIPTestClusterClusterSimpleStruct *) ((CHIPTestClusterClusterNestedStructList *) temp_0[0]).c).f =
                [NSNumber numberWithUnsignedChar:1];
            ((CHIPTestClusterClusterSimpleStruct *) ((CHIPTestClusterClusterNestedStructList *) temp_0[0]).c).g =
                [NSNumber numberWithFloat:0.0f];
            ((CHIPTestClusterClusterSimpleStruct *) ((CHIPTestClusterClusterNestedStructList *) temp_0[0]).c).h =
                [NSNumber numberWithDouble:0];

            {
                NSMutableArray * temp_2 = [[NSMutableArray alloc] init];
                temp_2[0] = [[CHIPTestClusterClusterSimpleStruct alloc] init];
                ((CHIPTestClusterClusterSimpleStruct *) temp_2[0]).a = [NSNumber numberWithUnsignedChar:1];
                ((CHIPTestClusterClusterSimpleStruct *) temp_2[0]).b = [NSNumber numberWithBool:true];
                ((CHIPTestClusterClusterSimpleStruct *) temp_2[0]).c = [NSNumber numberWithUnsignedChar:3];
                ((CHIPTestClusterClusterSimpleStruct *) temp_2[0]).d = [[NSData alloc] initWithBytes:"nested_octet_string"
                                                                                              length:19];
                ((CHIPTestClusterClusterSimpleStruct *) temp_2[0]).e = @"nested_char_string";
                ((CHIPTestClusterClusterSimpleStruct *) temp_2[0]).f = [NSNumber numberWithUnsignedChar:1];
                ((CHIPTestClusterClusterSimpleStruct *) temp_2[0]).g = [NSNumber numberWithFloat:0.0f];
                ((CHIPTestClusterClusterSimpleStruct *) temp_2[0]).h = [NSNumber numberWithDouble:0];

                temp_2[1] = [[CHIPTestClusterClusterSimpleStruct alloc] init];
                ((CHIPTestClusterClusterSimpleStruct *) temp_2[1]).a = [NSNumber numberWithUnsignedChar:2];
                ((CHIPTestClusterClusterSimpleStruct *) temp_2[1]).b = [NSNumber numberWithBool:false];
                ((CHIPTestClusterClusterSimpleStruct *) temp_2[1]).c = [NSNumber numberWithUnsignedChar:3];
                ((CHIPTestClusterClusterSimpleStruct *) temp_2[1]).d = [[NSData alloc] initWithBytes:"nested_octet_string"
                                                                                              length:19];
                ((CHIPTestClusterClusterSimpleStruct *) temp_2[1]).e = @"nested_char_string";
                ((CHIPTestClusterClusterSimpleStruct *) temp_2[1]).f = [NSNumber numberWithUnsignedChar:1];
                ((CHIPTestClusterClusterSimpleStruct *) temp_2[1]).g = [NSNumber numberWithFloat:0.0f];
                ((CHIPTestClusterClusterSimpleStruct *) temp_2[1]).h = [NSNumber numberWithDouble:0];

                ((CHIPTestClusterClusterNestedStructList *) temp_0[0]).d = temp_2;
            }
            {
                NSMutableArray * temp_2 = [[NSMutableArray alloc] init];
                temp_2[0] = [NSNumber numberWithUnsignedInt:1UL];
                temp_2[1] = [NSNumber numberWithUnsignedInt:2UL];
                temp_2[2] = [NSNumber numberWithUnsignedInt:3UL];
                ((CHIPTestClusterClusterNestedStructList *) temp_0[0]).e = temp_2;
            }
            {
                NSMutableArray * temp_2 = [[NSMutableArray alloc] init];
                temp_2[0] = [[NSData alloc] initWithBytes:"octet_string_1" length:14];
                temp_2[1] = [[NSData alloc] initWithBytes:"octect_string_2" length:15];
                temp_2[2] = [[NSData alloc] initWithBytes:"octet_string_3" length:14];
                ((CHIPTestClusterClusterNestedStructList *) temp_0[0]).f = temp_2;
            }
            {
                NSMutableArray * temp_2 = [[NSMutableArray alloc] init];
                temp_2[0] = [NSNumber numberWithUnsignedChar:0];
                temp_2[1] = [NSNumber numberWithUnsignedChar:255];
                ((CHIPTestClusterClusterNestedStructList *) temp_0[0]).g = temp_2;
            }

            params.arg1 = temp_0;
        }
        [cluster testListNestedStructListArgumentRequestWithParams:params
                                                 completionHandler:^(CHIPTestClusterClusterBooleanResponseParams * _Nullable values,
                                                     NSError * _Nullable err) {
                                                     NSLog(@"Send Test Command With Nested Struct List Argument and some fields b "
                                                           @"of elements of arg1.d are false Error: %@",
                                                         err);

                                                     VerifyOrReturn(CheckValue("status", err, 0));

                                                     {
                                                         id actualValue = values.value;
                                                         VerifyOrReturn(CheckValue("value", actualValue, false));
                                                     }

                                                     NextTest();
                                                 }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeListWithListOfInt8uAndNoneOfThemIsSetTo0_168()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id listInt8uArgument;
        {
            NSMutableArray * temp_0 = [[NSMutableArray alloc] init];
            temp_0[0] = [NSNumber numberWithUnsignedChar:1];
            temp_0[1] = [NSNumber numberWithUnsignedChar:2];
            temp_0[2] = [NSNumber numberWithUnsignedChar:3];
            temp_0[3] = [NSNumber numberWithUnsignedChar:4];
            listInt8uArgument = temp_0;
        }
        [cluster writeAttributeListInt8uWithValue:listInt8uArgument
                                completionHandler:^(NSError * _Nullable err) {
                                    NSLog(@"Write attribute LIST With List of INT8U and none of them is set to 0 Error: %@", err);

                                    VerifyOrReturn(CheckValue("status", err, 0));

                                    NextTest();
                                }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeListWithListOfInt8u_169()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeListInt8uWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute LIST With List of INT8U Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("list_int8u", [actualValue count], static_cast<uint32_t>(4)));
                VerifyOrReturn(CheckValue("", actualValue[0], 1));
                VerifyOrReturn(CheckValue("", actualValue[1], 2));
                VerifyOrReturn(CheckValue("", actualValue[2], 3));
                VerifyOrReturn(CheckValue("", actualValue[3], 4));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeListWithListOfOctetString_170()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id listOctetStringArgument;
        {
            NSMutableArray * temp_0 = [[NSMutableArray alloc] init];
            temp_0[0] = [[NSData alloc] initWithBytes:"Test0" length:5];
            temp_0[1] = [[NSData alloc] initWithBytes:"Test1" length:5];
            temp_0[2] = [[NSData alloc] initWithBytes:"Test2" length:5];
            temp_0[3] = [[NSData alloc] initWithBytes:"Test3" length:5];
            listOctetStringArgument = temp_0;
        }
        [cluster writeAttributeListOctetStringWithValue:listOctetStringArgument
                                      completionHandler:^(NSError * _Nullable err) {
                                          NSLog(@"Write attribute LIST With List of OCTET_STRING Error: %@", err);

                                          VerifyOrReturn(CheckValue("status", err, 0));

                                          NextTest();
                                      }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeListWithListOfOctetString_171()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeListOctetStringWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute LIST With List of OCTET_STRING Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("list_octet_string", [actualValue count], static_cast<uint32_t>(4)));
                VerifyOrReturn(CheckValueAsString("", actualValue[0], [[NSData alloc] initWithBytes:"Test0" length:5]));
                VerifyOrReturn(CheckValueAsString("", actualValue[1], [[NSData alloc] initWithBytes:"Test1" length:5]));
                VerifyOrReturn(CheckValueAsString("", actualValue[2], [[NSData alloc] initWithBytes:"Test2" length:5]));
                VerifyOrReturn(CheckValueAsString("", actualValue[3], [[NSData alloc] initWithBytes:"Test3" length:5]));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeListWithListOfListStructOctetString_172()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id listStructOctetStringArgument;
        {
            NSMutableArray * temp_0 = [[NSMutableArray alloc] init];
            temp_0[0] = [[CHIPTestClusterClusterTestListStructOctet alloc] init];
            ((CHIPTestClusterClusterTestListStructOctet *) temp_0[0]).fabricIndex = [NSNumber numberWithUnsignedLongLong:0ULL];
            ((CHIPTestClusterClusterTestListStructOctet *) temp_0[0]).operationalCert = [[NSData alloc] initWithBytes:"Test0"
                                                                                                               length:5];

            temp_0[1] = [[CHIPTestClusterClusterTestListStructOctet alloc] init];
            ((CHIPTestClusterClusterTestListStructOctet *) temp_0[1]).fabricIndex = [NSNumber numberWithUnsignedLongLong:1ULL];
            ((CHIPTestClusterClusterTestListStructOctet *) temp_0[1]).operationalCert = [[NSData alloc] initWithBytes:"Test1"
                                                                                                               length:5];

            temp_0[2] = [[CHIPTestClusterClusterTestListStructOctet alloc] init];
            ((CHIPTestClusterClusterTestListStructOctet *) temp_0[2]).fabricIndex = [NSNumber numberWithUnsignedLongLong:2ULL];
            ((CHIPTestClusterClusterTestListStructOctet *) temp_0[2]).operationalCert = [[NSData alloc] initWithBytes:"Test2"
                                                                                                               length:5];

            temp_0[3] = [[CHIPTestClusterClusterTestListStructOctet alloc] init];
            ((CHIPTestClusterClusterTestListStructOctet *) temp_0[3]).fabricIndex = [NSNumber numberWithUnsignedLongLong:3ULL];
            ((CHIPTestClusterClusterTestListStructOctet *) temp_0[3]).operationalCert = [[NSData alloc] initWithBytes:"Test3"
                                                                                                               length:5];

            listStructOctetStringArgument = temp_0;
        }
        [cluster writeAttributeListStructOctetStringWithValue:listStructOctetStringArgument
                                            completionHandler:^(NSError * _Nullable err) {
                                                NSLog(@"Write attribute LIST With List of LIST_STRUCT_OCTET_STRING Error: %@", err);

                                                VerifyOrReturn(CheckValue("status", err, 0));

                                                NextTest();
                                            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeListWithListOfListStructOctetString_173()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeListStructOctetStringWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute LIST With List of LIST_STRUCT_OCTET_STRING Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("list_struct_octet_string", [actualValue count], static_cast<uint32_t>(4)));
                VerifyOrReturn(
                    CheckValue("fabricIndex", ((CHIPTestClusterClusterTestListStructOctet *) actualValue[0]).fabricIndex, 0ULL));
                VerifyOrReturn(CheckValueAsString("operationalCert",
                    ((CHIPTestClusterClusterTestListStructOctet *) actualValue[0]).operationalCert,
                    [[NSData alloc] initWithBytes:"Test0" length:5]));
                VerifyOrReturn(
                    CheckValue("fabricIndex", ((CHIPTestClusterClusterTestListStructOctet *) actualValue[1]).fabricIndex, 1ULL));
                VerifyOrReturn(CheckValueAsString("operationalCert",
                    ((CHIPTestClusterClusterTestListStructOctet *) actualValue[1]).operationalCert,
                    [[NSData alloc] initWithBytes:"Test1" length:5]));
                VerifyOrReturn(
                    CheckValue("fabricIndex", ((CHIPTestClusterClusterTestListStructOctet *) actualValue[2]).fabricIndex, 2ULL));
                VerifyOrReturn(CheckValueAsString("operationalCert",
                    ((CHIPTestClusterClusterTestListStructOctet *) actualValue[2]).operationalCert,
                    [[NSData alloc] initWithBytes:"Test2" length:5]));
                VerifyOrReturn(
                    CheckValue("fabricIndex", ((CHIPTestClusterClusterTestListStructOctet *) actualValue[3]).fabricIndex, 3ULL));
                VerifyOrReturn(CheckValueAsString("operationalCert",
                    ((CHIPTestClusterClusterTestListStructOctet *) actualValue[3]).operationalCert,
                    [[NSData alloc] initWithBytes:"Test3" length:5]));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSendTestCommandWithOptionalArgSet_174()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPTestClusterClusterTestNullableOptionalRequestParams alloc] init];
        params.arg1 = [NSNumber numberWithUnsignedChar:5];
        [cluster
            testNullableOptionalRequestWithParams:params
                                completionHandler:^(CHIPTestClusterClusterTestNullableOptionalResponseParams * _Nullable values,
                                    NSError * _Nullable err) {
                                    NSLog(@"Send Test Command with optional arg set. Error: %@", err);

                                    VerifyOrReturn(CheckValue("status", err, 0));

                                    {
                                        id actualValue = values.wasPresent;
                                        VerifyOrReturn(CheckValue("wasPresent", actualValue, true));
                                    }

                                    {
                                        id actualValue = values.wasNull;
                                        VerifyOrReturn(CheckValue("wasNull", actualValue, false));
                                    }

                                    {
                                        id actualValue = values.value;
                                        VerifyOrReturn(CheckValue("value", actualValue, 5));
                                    }

                                    {
                                        id actualValue = values.originalValue;
                                        VerifyOrReturn(CheckValueNonNull("originalValue", actualValue));
                                        VerifyOrReturn(CheckValue("originalValue", actualValue, 5));
                                    }

                                    NextTest();
                                }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSendTestCommandWithoutItsOptionalArg_175()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPTestClusterClusterTestNullableOptionalRequestParams alloc] init];
        [cluster
            testNullableOptionalRequestWithParams:params
                                completionHandler:^(CHIPTestClusterClusterTestNullableOptionalResponseParams * _Nullable values,
                                    NSError * _Nullable err) {
                                    NSLog(@"Send Test Command without its optional arg. Error: %@", err);

                                    VerifyOrReturn(CheckValue("status", err, 0));

                                    {
                                        id actualValue = values.wasPresent;
                                        VerifyOrReturn(CheckValue("wasPresent", actualValue, false));
                                    }

                                    NextTest();
                                }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadListOfStructsContainingNullablesAndOptionals_176()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeListNullablesAndOptionalsStructWithCompletionHandler:^(
            NSArray * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read list of structs containing nullables and optionals Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("list_nullables_and_optionals_struct", [actualValue count], static_cast<uint32_t>(1)));
                VerifyOrReturn(CheckValueNull(
                    "NullableInt", ((CHIPTestClusterClusterNullablesAndOptionalsStruct *) actualValue[0]).nullableInt));
                VerifyOrReturn(CheckValueNull(
                    "NullableString", ((CHIPTestClusterClusterNullablesAndOptionalsStruct *) actualValue[0]).nullableString));
                VerifyOrReturn(CheckValueNull(
                    "NullableStruct", ((CHIPTestClusterClusterNullablesAndOptionalsStruct *) actualValue[0]).nullableStruct));
                VerifyOrReturn(CheckValueNull(
                    "NullableList", ((CHIPTestClusterClusterNullablesAndOptionalsStruct *) actualValue[0]).nullableList));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteListOfStructsContainingNullablesAndOptionals_177()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id listNullablesAndOptionalsStructArgument;
        {
            NSMutableArray * temp_0 = [[NSMutableArray alloc] init];
            temp_0[0] = [[CHIPTestClusterClusterNullablesAndOptionalsStruct alloc] init];
            ((CHIPTestClusterClusterNullablesAndOptionalsStruct *) temp_0[0]).nullableInt = nil;
            ((CHIPTestClusterClusterNullablesAndOptionalsStruct *) temp_0[0]).nullableString = nil;
            ((CHIPTestClusterClusterNullablesAndOptionalsStruct *) temp_0[0]).nullableStruct = nil;
            {
                NSMutableArray * temp_3 = [[NSMutableArray alloc] init];
                temp_3[0] = [NSNumber numberWithUnsignedChar:1];
                temp_3[1] = [NSNumber numberWithUnsignedChar:2];
                ((CHIPTestClusterClusterNullablesAndOptionalsStruct *) temp_0[0]).nullableList = temp_3;
            }

            listNullablesAndOptionalsStructArgument = temp_0;
        }
        [cluster
            writeAttributeListNullablesAndOptionalsStructWithValue:listNullablesAndOptionalsStructArgument
                                                 completionHandler:^(NSError * _Nullable err) {
                                                     NSLog(@"Write list of structs containing nullables and optionals Error: %@",
                                                         err);

                                                     VerifyOrReturn(CheckValue("status", err, 0));

                                                     NextTest();
                                                 }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadListOfStructsContainingNullablesAndOptionalsAfterWriting_178()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeListNullablesAndOptionalsStructWithCompletionHandler:^(
            NSArray * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read list of structs containing nullables and optionals after writing Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("list_nullables_and_optionals_struct", [actualValue count], static_cast<uint32_t>(1)));
                VerifyOrReturn(CheckValueNull(
                    "NullableInt", ((CHIPTestClusterClusterNullablesAndOptionalsStruct *) actualValue[0]).nullableInt));
                VerifyOrReturn(CheckValueNull(
                    "NullableString", ((CHIPTestClusterClusterNullablesAndOptionalsStruct *) actualValue[0]).nullableString));
                VerifyOrReturn(CheckValueNull(
                    "NullableStruct", ((CHIPTestClusterClusterNullablesAndOptionalsStruct *) actualValue[0]).nullableStruct));
                VerifyOrReturn(CheckValueNonNull(
                    "NullableList", ((CHIPTestClusterClusterNullablesAndOptionalsStruct *) actualValue[0]).nullableList));
                VerifyOrReturn(CheckValue("NullableList",
                    [((CHIPTestClusterClusterNullablesAndOptionalsStruct *) actualValue[0]).nullableList count],
                    static_cast<uint32_t>(2)));
                VerifyOrReturn(
                    CheckValue("", ((CHIPTestClusterClusterNullablesAndOptionalsStruct *) actualValue[0]).nullableList[0], 1));
                VerifyOrReturn(
                    CheckValue("", ((CHIPTestClusterClusterNullablesAndOptionalsStruct *) actualValue[0]).nullableList[1], 2));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeNullableBooleanNull_179()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableBooleanArgument;
        nullableBooleanArgument = nil;
        [cluster writeAttributeNullableBooleanWithValue:nullableBooleanArgument
                                      completionHandler:^(NSError * _Nullable err) {
                                          NSLog(@"Write attribute NULLABLE_BOOLEAN null Error: %@", err);

                                          VerifyOrReturn(CheckValue("status", err, 0));

                                          NextTest();
                                      }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableBooleanNull_180()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableBooleanWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_BOOLEAN null Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNull("nullable_boolean", actualValue));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeNullableBooleanTrue_181()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableBooleanArgument;
        nullableBooleanArgument = [NSNumber numberWithBool:true];
        [cluster writeAttributeNullableBooleanWithValue:nullableBooleanArgument
                                      completionHandler:^(NSError * _Nullable err) {
                                          NSLog(@"Write attribute NULLABLE_BOOLEAN True Error: %@", err);

                                          VerifyOrReturn(CheckValue("status", err, 0));

                                          NextTest();
                                      }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableBooleanTrue_182()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableBooleanWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_BOOLEAN True Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNonNull("nullable_boolean", actualValue));
                VerifyOrReturn(CheckValue("nullable_boolean", actualValue, true));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeNullableBitmap8MaxValue_183()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableBitmap8Argument;
        nullableBitmap8Argument = [NSNumber numberWithUnsignedChar:254];
        [cluster writeAttributeNullableBitmap8WithValue:nullableBitmap8Argument
                                      completionHandler:^(NSError * _Nullable err) {
                                          NSLog(@"Write attribute NULLABLE_BITMAP8 Max Value Error: %@", err);

                                          VerifyOrReturn(CheckValue("status", err, 0));

                                          NextTest();
                                      }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableBitmap8MaxValue_184()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableBitmap8WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_BITMAP8 Max Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNonNull("nullable_bitmap8", actualValue));
                VerifyOrReturn(CheckValue("nullable_bitmap8", actualValue, 254));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeNullableBitmap8InvalidValue_185()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableBitmap8Argument;
        nullableBitmap8Argument = [NSNumber numberWithUnsignedChar:255];
        [cluster writeAttributeNullableBitmap8WithValue:nullableBitmap8Argument
                                      completionHandler:^(NSError * _Nullable err) {
                                          NSLog(@"Write attribute NULLABLE_BITMAP8 Invalid Value Error: %@", err);

                                          VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
                                          NextTest();
                                      }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableBitmap8UnchangedValue_186()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableBitmap8WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_BITMAP8 unchanged Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNonNull("nullable_bitmap8", actualValue));
                VerifyOrReturn(CheckValue("nullable_bitmap8", actualValue, 254));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeNullableBitmap8NullValue_187()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableBitmap8Argument;
        nullableBitmap8Argument = nil;
        [cluster writeAttributeNullableBitmap8WithValue:nullableBitmap8Argument
                                      completionHandler:^(NSError * _Nullable err) {
                                          NSLog(@"Write attribute NULLABLE_BITMAP8 null Value Error: %@", err);

                                          VerifyOrReturn(CheckValue("status", err, 0));

                                          NextTest();
                                      }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableBitmap8NullValue_188()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableBitmap8WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_BITMAP8 null Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNull("nullable_bitmap8", actualValue));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeNullableBitmap16MaxValue_189()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableBitmap16Argument;
        nullableBitmap16Argument = [NSNumber numberWithUnsignedShort:65534U];
        [cluster writeAttributeNullableBitmap16WithValue:nullableBitmap16Argument
                                       completionHandler:^(NSError * _Nullable err) {
                                           NSLog(@"Write attribute NULLABLE_BITMAP16 Max Value Error: %@", err);

                                           VerifyOrReturn(CheckValue("status", err, 0));

                                           NextTest();
                                       }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableBitmap16MaxValue_190()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableBitmap16WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_BITMAP16 Max Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNonNull("nullable_bitmap16", actualValue));
                VerifyOrReturn(CheckValue("nullable_bitmap16", actualValue, 65534U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeNullableBitmap16InvalidValue_191()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableBitmap16Argument;
        nullableBitmap16Argument = [NSNumber numberWithUnsignedShort:65535U];
        [cluster writeAttributeNullableBitmap16WithValue:nullableBitmap16Argument
                                       completionHandler:^(NSError * _Nullable err) {
                                           NSLog(@"Write attribute NULLABLE_BITMAP16 Invalid Value Error: %@", err);

                                           VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
                                           NextTest();
                                       }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableBitmap16UnchangedValue_192()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableBitmap16WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_BITMAP16 unchanged Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNonNull("nullable_bitmap16", actualValue));
                VerifyOrReturn(CheckValue("nullable_bitmap16", actualValue, 65534U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeNullableBitmap16NullValue_193()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableBitmap16Argument;
        nullableBitmap16Argument = nil;
        [cluster writeAttributeNullableBitmap16WithValue:nullableBitmap16Argument
                                       completionHandler:^(NSError * _Nullable err) {
                                           NSLog(@"Write attribute NULLABLE_BITMAP16 null Value Error: %@", err);

                                           VerifyOrReturn(CheckValue("status", err, 0));

                                           NextTest();
                                       }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableBitmap16NullValue_194()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableBitmap16WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_BITMAP16 null Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNull("nullable_bitmap16", actualValue));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeNullableBitmap32MaxValue_195()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableBitmap32Argument;
        nullableBitmap32Argument = [NSNumber numberWithUnsignedInt:4294967294UL];
        [cluster writeAttributeNullableBitmap32WithValue:nullableBitmap32Argument
                                       completionHandler:^(NSError * _Nullable err) {
                                           NSLog(@"Write attribute NULLABLE_BITMAP32 Max Value Error: %@", err);

                                           VerifyOrReturn(CheckValue("status", err, 0));

                                           NextTest();
                                       }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableBitmap32MaxValue_196()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableBitmap32WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_BITMAP32 Max Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNonNull("nullable_bitmap32", actualValue));
                VerifyOrReturn(CheckValue("nullable_bitmap32", actualValue, 4294967294UL));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeNullableBitmap32InvalidValue_197()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableBitmap32Argument;
        nullableBitmap32Argument = [NSNumber numberWithUnsignedInt:4294967295UL];
        [cluster writeAttributeNullableBitmap32WithValue:nullableBitmap32Argument
                                       completionHandler:^(NSError * _Nullable err) {
                                           NSLog(@"Write attribute NULLABLE_BITMAP32 Invalid Value Error: %@", err);

                                           VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
                                           NextTest();
                                       }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableBitmap32UnchangedValue_198()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableBitmap32WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_BITMAP32 unchanged Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNonNull("nullable_bitmap32", actualValue));
                VerifyOrReturn(CheckValue("nullable_bitmap32", actualValue, 4294967294UL));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeNullableBitmap32NullValue_199()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableBitmap32Argument;
        nullableBitmap32Argument = nil;
        [cluster writeAttributeNullableBitmap32WithValue:nullableBitmap32Argument
                                       completionHandler:^(NSError * _Nullable err) {
                                           NSLog(@"Write attribute NULLABLE_BITMAP32 null Value Error: %@", err);

                                           VerifyOrReturn(CheckValue("status", err, 0));

                                           NextTest();
                                       }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableBitmap32NullValue_200()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableBitmap32WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_BITMAP32 null Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNull("nullable_bitmap32", actualValue));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeNullableBitmap64MaxValue_201()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableBitmap64Argument;
        nullableBitmap64Argument = [NSNumber numberWithUnsignedLongLong:18446744073709551614ULL];
        [cluster writeAttributeNullableBitmap64WithValue:nullableBitmap64Argument
                                       completionHandler:^(NSError * _Nullable err) {
                                           NSLog(@"Write attribute NULLABLE_BITMAP64 Max Value Error: %@", err);

                                           VerifyOrReturn(CheckValue("status", err, 0));

                                           NextTest();
                                       }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableBitmap64MaxValue_202()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableBitmap64WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_BITMAP64 Max Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNonNull("nullable_bitmap64", actualValue));
                VerifyOrReturn(CheckValue("nullable_bitmap64", actualValue, 18446744073709551614ULL));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeNullableBitmap64InvalidValue_203()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableBitmap64Argument;
        nullableBitmap64Argument = [NSNumber numberWithUnsignedLongLong:18446744073709551615ULL];
        [cluster writeAttributeNullableBitmap64WithValue:nullableBitmap64Argument
                                       completionHandler:^(NSError * _Nullable err) {
                                           NSLog(@"Write attribute NULLABLE_BITMAP64 Invalid Value Error: %@", err);

                                           VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
                                           NextTest();
                                       }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableBitmap64UnchangedValue_204()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableBitmap64WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_BITMAP64 unchanged Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNonNull("nullable_bitmap64", actualValue));
                VerifyOrReturn(CheckValue("nullable_bitmap64", actualValue, 18446744073709551614ULL));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeNullableBitmap64NullValue_205()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableBitmap64Argument;
        nullableBitmap64Argument = nil;
        [cluster writeAttributeNullableBitmap64WithValue:nullableBitmap64Argument
                                       completionHandler:^(NSError * _Nullable err) {
                                           NSLog(@"Write attribute NULLABLE_BITMAP64 null Value Error: %@", err);

                                           VerifyOrReturn(CheckValue("status", err, 0));

                                           NextTest();
                                       }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableBitmap64NullValue_206()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableBitmap64WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_BITMAP64 null Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNull("nullable_bitmap64", actualValue));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeNullableInt8uMinValue_207()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableInt8uArgument;
        nullableInt8uArgument = [NSNumber numberWithUnsignedChar:0];
        [cluster writeAttributeNullableInt8uWithValue:nullableInt8uArgument
                                    completionHandler:^(NSError * _Nullable err) {
                                        NSLog(@"Write attribute NULLABLE_INT8U Min Value Error: %@", err);

                                        VerifyOrReturn(CheckValue("status", err, 0));

                                        NextTest();
                                    }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableInt8uMinValue_208()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableInt8uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_INT8U Min Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNonNull("nullable_int8u", actualValue));
                VerifyOrReturn(CheckValue("nullable_int8u", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeNullableInt8uMaxValue_209()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableInt8uArgument;
        nullableInt8uArgument = [NSNumber numberWithUnsignedChar:254];
        [cluster writeAttributeNullableInt8uWithValue:nullableInt8uArgument
                                    completionHandler:^(NSError * _Nullable err) {
                                        NSLog(@"Write attribute NULLABLE_INT8U Max Value Error: %@", err);

                                        VerifyOrReturn(CheckValue("status", err, 0));

                                        NextTest();
                                    }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableInt8uMaxValue_210()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableInt8uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_INT8U Max Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNonNull("nullable_int8u", actualValue));
                VerifyOrReturn(CheckValue("nullable_int8u", actualValue, 254));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeNullableInt8uInvalidValue_211()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableInt8uArgument;
        nullableInt8uArgument = [NSNumber numberWithUnsignedChar:255];
        [cluster writeAttributeNullableInt8uWithValue:nullableInt8uArgument
                                    completionHandler:^(NSError * _Nullable err) {
                                        NSLog(@"Write attribute NULLABLE_INT8U Invalid Value Error: %@", err);

                                        VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
                                        NextTest();
                                    }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableInt8uUnchangedValue_212()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableInt8uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_INT8U unchanged Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNonNull("nullable_int8u", actualValue));
                VerifyOrReturn(CheckValue("nullable_int8u", actualValue, 254));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableInt8uUnchangedValueWithConstraint_213()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableInt8uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_INT8U unchanged Value with constraint Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckValueNonNull("nullableInt8u", value));

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeNullableInt8uNullValue_214()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableInt8uArgument;
        nullableInt8uArgument = nil;
        [cluster writeAttributeNullableInt8uWithValue:nullableInt8uArgument
                                    completionHandler:^(NSError * _Nullable err) {
                                        NSLog(@"Write attribute NULLABLE_INT8U null Value Error: %@", err);

                                        VerifyOrReturn(CheckValue("status", err, 0));

                                        NextTest();
                                    }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableInt8uNullValue_215()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableInt8uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_INT8U null Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNull("nullable_int8u", actualValue));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableInt8uNullValueRange_216()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableInt8uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_INT8U null Value & range Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<uint8_t>("nullableInt8u", [value unsignedCharValue], 0));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("nullableInt8u", [value unsignedCharValue], 254));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableInt8uNullValueNot_217()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableInt8uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_INT8U null Value & not Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            if (value != nil) {
                VerifyOrReturn(CheckConstraintNotValue("nullableInt8u", value, 254));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeNullableInt8uValue_218()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableInt8uArgument;
        nullableInt8uArgument = [NSNumber numberWithUnsignedChar:128];
        [cluster writeAttributeNullableInt8uWithValue:nullableInt8uArgument
                                    completionHandler:^(NSError * _Nullable err) {
                                        NSLog(@"Write attribute NULLABLE_INT8U Value Error: %@", err);

                                        VerifyOrReturn(CheckValue("status", err, 0));

                                        NextTest();
                                    }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableInt8uValueInRange_219()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableInt8uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_INT8U Value in range Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<uint8_t>("nullableInt8u", [value unsignedCharValue], 0));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("nullableInt8u", [value unsignedCharValue], 254));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableInt8uNotValueOk_220()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableInt8uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_INT8U notValue OK Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            if (value != nil) {
                VerifyOrReturn(CheckConstraintNotValue("nullableInt8u", value, 129));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeNullableInt16uMinValue_221()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableInt16uArgument;
        nullableInt16uArgument = [NSNumber numberWithUnsignedShort:0U];
        [cluster writeAttributeNullableInt16uWithValue:nullableInt16uArgument
                                     completionHandler:^(NSError * _Nullable err) {
                                         NSLog(@"Write attribute NULLABLE_INT16U Min Value Error: %@", err);

                                         VerifyOrReturn(CheckValue("status", err, 0));

                                         NextTest();
                                     }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableInt16uMinValue_222()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableInt16uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_INT16U Min Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNonNull("nullable_int16u", actualValue));
                VerifyOrReturn(CheckValue("nullable_int16u", actualValue, 0U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeNullableInt16uMaxValue_223()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableInt16uArgument;
        nullableInt16uArgument = [NSNumber numberWithUnsignedShort:65534U];
        [cluster writeAttributeNullableInt16uWithValue:nullableInt16uArgument
                                     completionHandler:^(NSError * _Nullable err) {
                                         NSLog(@"Write attribute NULLABLE_INT16U Max Value Error: %@", err);

                                         VerifyOrReturn(CheckValue("status", err, 0));

                                         NextTest();
                                     }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableInt16uMaxValue_224()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableInt16uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_INT16U Max Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNonNull("nullable_int16u", actualValue));
                VerifyOrReturn(CheckValue("nullable_int16u", actualValue, 65534U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeNullableInt16uInvalidValue_225()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableInt16uArgument;
        nullableInt16uArgument = [NSNumber numberWithUnsignedShort:65535U];
        [cluster writeAttributeNullableInt16uWithValue:nullableInt16uArgument
                                     completionHandler:^(NSError * _Nullable err) {
                                         NSLog(@"Write attribute NULLABLE_INT16U Invalid Value Error: %@", err);

                                         VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
                                         NextTest();
                                     }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableInt16uUnchangedValue_226()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableInt16uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_INT16U unchanged Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNonNull("nullable_int16u", actualValue));
                VerifyOrReturn(CheckValue("nullable_int16u", actualValue, 65534U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeNullableInt16uNullValue_227()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableInt16uArgument;
        nullableInt16uArgument = nil;
        [cluster writeAttributeNullableInt16uWithValue:nullableInt16uArgument
                                     completionHandler:^(NSError * _Nullable err) {
                                         NSLog(@"Write attribute NULLABLE_INT16U null Value Error: %@", err);

                                         VerifyOrReturn(CheckValue("status", err, 0));

                                         NextTest();
                                     }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableInt16uNullValue_228()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableInt16uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_INT16U null Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNull("nullable_int16u", actualValue));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableInt16uNullValueRange_229()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableInt16uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_INT16U null Value & range Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("nullableInt16u", [value unsignedShortValue], 0U));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("nullableInt16u", [value unsignedShortValue], 65534U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableInt16uNullValueNot_230()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableInt16uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_INT16U null Value & not Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            if (value != nil) {
                VerifyOrReturn(CheckConstraintNotValue("nullableInt16u", value, 65534U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeNullableInt16uValue_231()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableInt16uArgument;
        nullableInt16uArgument = [NSNumber numberWithUnsignedShort:32000U];
        [cluster writeAttributeNullableInt16uWithValue:nullableInt16uArgument
                                     completionHandler:^(NSError * _Nullable err) {
                                         NSLog(@"Write attribute NULLABLE_INT16U Value Error: %@", err);

                                         VerifyOrReturn(CheckValue("status", err, 0));

                                         NextTest();
                                     }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableInt16uValueInRange_232()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableInt16uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_INT16U Value in range Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("nullableInt16u", [value unsignedShortValue], 0U));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("nullableInt16u", [value unsignedShortValue], 65534U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableInt16uNotValueOk_233()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableInt16uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_INT16U notValue OK Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            if (value != nil) {
                VerifyOrReturn(CheckConstraintNotValue("nullableInt16u", value, 32001U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeNullableInt32uMinValue_234()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableInt32uArgument;
        nullableInt32uArgument = [NSNumber numberWithUnsignedInt:0UL];
        [cluster writeAttributeNullableInt32uWithValue:nullableInt32uArgument
                                     completionHandler:^(NSError * _Nullable err) {
                                         NSLog(@"Write attribute NULLABLE_INT32U Min Value Error: %@", err);

                                         VerifyOrReturn(CheckValue("status", err, 0));

                                         NextTest();
                                     }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableInt32uMinValue_235()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableInt32uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_INT32U Min Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNonNull("nullable_int32u", actualValue));
                VerifyOrReturn(CheckValue("nullable_int32u", actualValue, 0UL));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeNullableInt32uMaxValue_236()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableInt32uArgument;
        nullableInt32uArgument = [NSNumber numberWithUnsignedInt:4294967294UL];
        [cluster writeAttributeNullableInt32uWithValue:nullableInt32uArgument
                                     completionHandler:^(NSError * _Nullable err) {
                                         NSLog(@"Write attribute NULLABLE_INT32U Max Value Error: %@", err);

                                         VerifyOrReturn(CheckValue("status", err, 0));

                                         NextTest();
                                     }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableInt32uMaxValue_237()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableInt32uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_INT32U Max Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNonNull("nullable_int32u", actualValue));
                VerifyOrReturn(CheckValue("nullable_int32u", actualValue, 4294967294UL));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeNullableInt32uInvalidValue_238()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableInt32uArgument;
        nullableInt32uArgument = [NSNumber numberWithUnsignedInt:4294967295UL];
        [cluster writeAttributeNullableInt32uWithValue:nullableInt32uArgument
                                     completionHandler:^(NSError * _Nullable err) {
                                         NSLog(@"Write attribute NULLABLE_INT32U Invalid Value Error: %@", err);

                                         VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
                                         NextTest();
                                     }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableInt32uUnchangedValue_239()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableInt32uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_INT32U unchanged Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNonNull("nullable_int32u", actualValue));
                VerifyOrReturn(CheckValue("nullable_int32u", actualValue, 4294967294UL));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeNullableInt32uNullValue_240()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableInt32uArgument;
        nullableInt32uArgument = nil;
        [cluster writeAttributeNullableInt32uWithValue:nullableInt32uArgument
                                     completionHandler:^(NSError * _Nullable err) {
                                         NSLog(@"Write attribute NULLABLE_INT32U null Value Error: %@", err);

                                         VerifyOrReturn(CheckValue("status", err, 0));

                                         NextTest();
                                     }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableInt32uNullValue_241()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableInt32uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_INT32U null Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNull("nullable_int32u", actualValue));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableInt32uNullValueRange_242()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableInt32uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_INT32U null Value & range Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<uint32_t>("nullableInt32u", [value unsignedIntValue], 0UL));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<uint32_t>("nullableInt32u", [value unsignedIntValue], 4294967294UL));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableInt32uNullValueNot_243()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableInt32uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_INT32U null Value & not Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            if (value != nil) {
                VerifyOrReturn(CheckConstraintNotValue("nullableInt32u", value, 4294967294UL));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeNullableInt32uValue_244()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableInt32uArgument;
        nullableInt32uArgument = [NSNumber numberWithUnsignedInt:2147483647UL];
        [cluster writeAttributeNullableInt32uWithValue:nullableInt32uArgument
                                     completionHandler:^(NSError * _Nullable err) {
                                         NSLog(@"Write attribute NULLABLE_INT32U Value Error: %@", err);

                                         VerifyOrReturn(CheckValue("status", err, 0));

                                         NextTest();
                                     }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableInt32uValueInRange_245()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableInt32uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_INT32U Value in range Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<uint32_t>("nullableInt32u", [value unsignedIntValue], 0UL));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<uint32_t>("nullableInt32u", [value unsignedIntValue], 4294967294UL));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableInt32uNotValueOk_246()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableInt32uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_INT32U notValue OK Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            if (value != nil) {
                VerifyOrReturn(CheckConstraintNotValue("nullableInt32u", value, 2147483648UL));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeNullableInt64uMinValue_247()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableInt64uArgument;
        nullableInt64uArgument = [NSNumber numberWithUnsignedLongLong:0ULL];
        [cluster writeAttributeNullableInt64uWithValue:nullableInt64uArgument
                                     completionHandler:^(NSError * _Nullable err) {
                                         NSLog(@"Write attribute NULLABLE_INT64U Min Value Error: %@", err);

                                         VerifyOrReturn(CheckValue("status", err, 0));

                                         NextTest();
                                     }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableInt64uMinValue_248()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableInt64uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_INT64U Min Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNonNull("nullable_int64u", actualValue));
                VerifyOrReturn(CheckValue("nullable_int64u", actualValue, 0ULL));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeNullableInt64uMaxValue_249()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableInt64uArgument;
        nullableInt64uArgument = [NSNumber numberWithUnsignedLongLong:18446744073709551614ULL];
        [cluster writeAttributeNullableInt64uWithValue:nullableInt64uArgument
                                     completionHandler:^(NSError * _Nullable err) {
                                         NSLog(@"Write attribute NULLABLE_INT64U Max Value Error: %@", err);

                                         VerifyOrReturn(CheckValue("status", err, 0));

                                         NextTest();
                                     }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableInt64uMaxValue_250()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableInt64uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_INT64U Max Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNonNull("nullable_int64u", actualValue));
                VerifyOrReturn(CheckValue("nullable_int64u", actualValue, 18446744073709551614ULL));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeNullableInt64uInvalidValue_251()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableInt64uArgument;
        nullableInt64uArgument = [NSNumber numberWithUnsignedLongLong:18446744073709551615ULL];
        [cluster writeAttributeNullableInt64uWithValue:nullableInt64uArgument
                                     completionHandler:^(NSError * _Nullable err) {
                                         NSLog(@"Write attribute NULLABLE_INT64U Invalid Value Error: %@", err);

                                         VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
                                         NextTest();
                                     }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableInt64uUnchangedValue_252()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableInt64uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_INT64U unchanged Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNonNull("nullable_int64u", actualValue));
                VerifyOrReturn(CheckValue("nullable_int64u", actualValue, 18446744073709551614ULL));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeNullableInt64uNullValue_253()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableInt64uArgument;
        nullableInt64uArgument = nil;
        [cluster writeAttributeNullableInt64uWithValue:nullableInt64uArgument
                                     completionHandler:^(NSError * _Nullable err) {
                                         NSLog(@"Write attribute NULLABLE_INT64U null Value Error: %@", err);

                                         VerifyOrReturn(CheckValue("status", err, 0));

                                         NextTest();
                                     }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableInt64uNullValue_254()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableInt64uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_INT64U null Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNull("nullable_int64u", actualValue));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableInt64uNullValueRange_255()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableInt64uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_INT64U null Value & range Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<uint64_t>("nullableInt64u", [value unsignedLongLongValue], 0ULL));
            }
            if (value != nil) {
                VerifyOrReturn(
                    CheckConstraintMaxValue<uint64_t>("nullableInt64u", [value unsignedLongLongValue], 18446744073709551614ULL));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableInt64uNullValueNot_256()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableInt64uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_INT64U null Value & not Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            if (value != nil) {
                VerifyOrReturn(CheckConstraintNotValue("nullableInt64u", value, 18446744073709551614ULL));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeNullableInt64uValue_257()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableInt64uArgument;
        nullableInt64uArgument = [NSNumber numberWithUnsignedLongLong:18000000000000000000ULL];
        [cluster writeAttributeNullableInt64uWithValue:nullableInt64uArgument
                                     completionHandler:^(NSError * _Nullable err) {
                                         NSLog(@"Write attribute NULLABLE_INT64U Value Error: %@", err);

                                         VerifyOrReturn(CheckValue("status", err, 0));

                                         NextTest();
                                     }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableInt64uValueInRange_258()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableInt64uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_INT64U Value in range Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<uint64_t>("nullableInt64u", [value unsignedLongLongValue], 0ULL));
            }
            if (value != nil) {
                VerifyOrReturn(
                    CheckConstraintMaxValue<uint64_t>("nullableInt64u", [value unsignedLongLongValue], 18446744073709551614ULL));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableInt64uNotValueOk_259()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableInt64uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_INT64U notValue OK Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            if (value != nil) {
                VerifyOrReturn(CheckConstraintNotValue("nullableInt64u", value, 18000000000000000001ULL));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeNullableInt8sMinValue_260()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableInt8sArgument;
        nullableInt8sArgument = [NSNumber numberWithChar:-127];
        [cluster writeAttributeNullableInt8sWithValue:nullableInt8sArgument
                                    completionHandler:^(NSError * _Nullable err) {
                                        NSLog(@"Write attribute NULLABLE_INT8S Min Value Error: %@", err);

                                        VerifyOrReturn(CheckValue("status", err, 0));

                                        NextTest();
                                    }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableInt8sMinValue_261()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableInt8sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_INT8S Min Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNonNull("nullable_int8s", actualValue));
                VerifyOrReturn(CheckValue("nullable_int8s", actualValue, -127));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeNullableInt8sInvalidValue_262()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableInt8sArgument;
        nullableInt8sArgument = [NSNumber numberWithChar:-128];
        [cluster writeAttributeNullableInt8sWithValue:nullableInt8sArgument
                                    completionHandler:^(NSError * _Nullable err) {
                                        NSLog(@"Write attribute NULLABLE_INT8S Invalid Value Error: %@", err);

                                        VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
                                        NextTest();
                                    }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableInt8sUnchangedValue_263()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableInt8sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_INT8S unchanged Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNonNull("nullable_int8s", actualValue));
                VerifyOrReturn(CheckValue("nullable_int8s", actualValue, -127));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeNullableInt8sNullValue_264()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableInt8sArgument;
        nullableInt8sArgument = nil;
        [cluster writeAttributeNullableInt8sWithValue:nullableInt8sArgument
                                    completionHandler:^(NSError * _Nullable err) {
                                        NSLog(@"Write attribute NULLABLE_INT8S null Value Error: %@", err);

                                        VerifyOrReturn(CheckValue("status", err, 0));

                                        NextTest();
                                    }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableInt8sNullValue_265()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableInt8sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_INT8S null Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNull("nullable_int8s", actualValue));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableInt8sNullValueRange_266()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableInt8sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_INT8S null Value & range Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<int8_t>("nullableInt8s", [value charValue], -127));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<int8_t>("nullableInt8s", [value charValue], 127));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableInt8sNullValueNot_267()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableInt8sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_INT8S null Value & not Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            if (value != nil) {
                VerifyOrReturn(CheckConstraintNotValue("nullableInt8s", value, -127));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeNullableInt8sValue_268()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableInt8sArgument;
        nullableInt8sArgument = [NSNumber numberWithChar:-127];
        [cluster writeAttributeNullableInt8sWithValue:nullableInt8sArgument
                                    completionHandler:^(NSError * _Nullable err) {
                                        NSLog(@"Write attribute NULLABLE_INT8S Value Error: %@", err);

                                        VerifyOrReturn(CheckValue("status", err, 0));

                                        NextTest();
                                    }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableInt8sValueInRange_269()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableInt8sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_INT8S Value in range Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<int8_t>("nullableInt8s", [value charValue], -127));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<int8_t>("nullableInt8s", [value charValue], 127));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableInt8sNotValueOk_270()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableInt8sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_INT8S notValue OK Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            if (value != nil) {
                VerifyOrReturn(CheckConstraintNotValue("nullableInt8s", value, -126));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeNullableInt16sMinValue_271()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableInt16sArgument;
        nullableInt16sArgument = [NSNumber numberWithShort:-32767];
        [cluster writeAttributeNullableInt16sWithValue:nullableInt16sArgument
                                     completionHandler:^(NSError * _Nullable err) {
                                         NSLog(@"Write attribute NULLABLE_INT16S Min Value Error: %@", err);

                                         VerifyOrReturn(CheckValue("status", err, 0));

                                         NextTest();
                                     }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableInt16sMinValue_272()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableInt16sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_INT16S Min Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNonNull("nullable_int16s", actualValue));
                VerifyOrReturn(CheckValue("nullable_int16s", actualValue, -32767));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeNullableInt16sInvalidValue_273()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableInt16sArgument;
        nullableInt16sArgument = [NSNumber numberWithShort:-32768];
        [cluster writeAttributeNullableInt16sWithValue:nullableInt16sArgument
                                     completionHandler:^(NSError * _Nullable err) {
                                         NSLog(@"Write attribute NULLABLE_INT16S Invalid Value Error: %@", err);

                                         VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
                                         NextTest();
                                     }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableInt16sUnchangedValue_274()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableInt16sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_INT16S unchanged Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNonNull("nullable_int16s", actualValue));
                VerifyOrReturn(CheckValue("nullable_int16s", actualValue, -32767));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeNullableInt16sNullValue_275()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableInt16sArgument;
        nullableInt16sArgument = nil;
        [cluster writeAttributeNullableInt16sWithValue:nullableInt16sArgument
                                     completionHandler:^(NSError * _Nullable err) {
                                         NSLog(@"Write attribute NULLABLE_INT16S null Value Error: %@", err);

                                         VerifyOrReturn(CheckValue("status", err, 0));

                                         NextTest();
                                     }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableInt16sNullValue_276()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableInt16sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_INT16S null Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNull("nullable_int16s", actualValue));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableInt16sNullValueRange_277()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableInt16sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_INT16S null Value & range Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<int16_t>("nullableInt16s", [value shortValue], -32767));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<int16_t>("nullableInt16s", [value shortValue], 32767));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableInt16sNullValueNot_278()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableInt16sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_INT16S null Value & not Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            if (value != nil) {
                VerifyOrReturn(CheckConstraintNotValue("nullableInt16s", value, -32767));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeNullableInt16sValue_279()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableInt16sArgument;
        nullableInt16sArgument = [NSNumber numberWithShort:-32767];
        [cluster writeAttributeNullableInt16sWithValue:nullableInt16sArgument
                                     completionHandler:^(NSError * _Nullable err) {
                                         NSLog(@"Write attribute NULLABLE_INT16S Value Error: %@", err);

                                         VerifyOrReturn(CheckValue("status", err, 0));

                                         NextTest();
                                     }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableInt16sValueInRange_280()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableInt16sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_INT16S Value in range Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<int16_t>("nullableInt16s", [value shortValue], -32767));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<int16_t>("nullableInt16s", [value shortValue], 32767));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableInt16sNotValueOk_281()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableInt16sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_INT16S notValue OK Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            if (value != nil) {
                VerifyOrReturn(CheckConstraintNotValue("nullableInt16s", value, -32766));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeNullableInt32sMinValue_282()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableInt32sArgument;
        nullableInt32sArgument = [NSNumber numberWithInt:-2147483647L];
        [cluster writeAttributeNullableInt32sWithValue:nullableInt32sArgument
                                     completionHandler:^(NSError * _Nullable err) {
                                         NSLog(@"Write attribute NULLABLE_INT32S Min Value Error: %@", err);

                                         VerifyOrReturn(CheckValue("status", err, 0));

                                         NextTest();
                                     }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableInt32sMinValue_283()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableInt32sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_INT32S Min Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNonNull("nullable_int32s", actualValue));
                VerifyOrReturn(CheckValue("nullable_int32s", actualValue, -2147483647L));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeNullableInt32sInvalidValue_284()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableInt32sArgument;
        nullableInt32sArgument = [NSNumber numberWithInt:-2147483648L];
        [cluster writeAttributeNullableInt32sWithValue:nullableInt32sArgument
                                     completionHandler:^(NSError * _Nullable err) {
                                         NSLog(@"Write attribute NULLABLE_INT32S Invalid Value Error: %@", err);

                                         VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
                                         NextTest();
                                     }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableInt32sUnchangedValue_285()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableInt32sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_INT32S unchanged Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNonNull("nullable_int32s", actualValue));
                VerifyOrReturn(CheckValue("nullable_int32s", actualValue, -2147483647L));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeNullableInt32sNullValue_286()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableInt32sArgument;
        nullableInt32sArgument = nil;
        [cluster writeAttributeNullableInt32sWithValue:nullableInt32sArgument
                                     completionHandler:^(NSError * _Nullable err) {
                                         NSLog(@"Write attribute NULLABLE_INT32S null Value Error: %@", err);

                                         VerifyOrReturn(CheckValue("status", err, 0));

                                         NextTest();
                                     }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableInt32sNullValue_287()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableInt32sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_INT32S null Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNull("nullable_int32s", actualValue));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableInt32sNullValueRange_288()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableInt32sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_INT32S null Value & range Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<int32_t>("nullableInt32s", [value intValue], -2147483647L));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<int32_t>("nullableInt32s", [value intValue], 2147483647L));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableInt32sNullValueNot_289()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableInt32sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_INT32S null Value & not Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            if (value != nil) {
                VerifyOrReturn(CheckConstraintNotValue("nullableInt32s", value, -2147483647L));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeNullableInt32sValue_290()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableInt32sArgument;
        nullableInt32sArgument = [NSNumber numberWithInt:-2147483647L];
        [cluster writeAttributeNullableInt32sWithValue:nullableInt32sArgument
                                     completionHandler:^(NSError * _Nullable err) {
                                         NSLog(@"Write attribute NULLABLE_INT32S Value Error: %@", err);

                                         VerifyOrReturn(CheckValue("status", err, 0));

                                         NextTest();
                                     }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableInt32sValueInRange_291()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableInt32sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_INT32S Value in range Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<int32_t>("nullableInt32s", [value intValue], -2147483647L));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<int32_t>("nullableInt32s", [value intValue], 2147483647L));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableInt32sNotValueOk_292()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableInt32sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_INT32S notValue OK Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            if (value != nil) {
                VerifyOrReturn(CheckConstraintNotValue("nullableInt32s", value, -2147483646L));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeNullableInt64sMinValue_293()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableInt64sArgument;
        nullableInt64sArgument = [NSNumber numberWithLongLong:-9223372036854775807LL];
        [cluster writeAttributeNullableInt64sWithValue:nullableInt64sArgument
                                     completionHandler:^(NSError * _Nullable err) {
                                         NSLog(@"Write attribute NULLABLE_INT64S Min Value Error: %@", err);

                                         VerifyOrReturn(CheckValue("status", err, 0));

                                         NextTest();
                                     }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableInt64sMinValue_294()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableInt64sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_INT64S Min Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNonNull("nullable_int64s", actualValue));
                VerifyOrReturn(CheckValue("nullable_int64s", actualValue, -9223372036854775807LL));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeNullableInt64sInvalidValue_295()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableInt64sArgument;
        nullableInt64sArgument = [NSNumber numberWithLongLong:-9223372036854775807LL - 1];
        [cluster writeAttributeNullableInt64sWithValue:nullableInt64sArgument
                                     completionHandler:^(NSError * _Nullable err) {
                                         NSLog(@"Write attribute NULLABLE_INT64S Invalid Value Error: %@", err);

                                         VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
                                         NextTest();
                                     }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableInt64sUnchangedValue_296()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableInt64sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_INT64S unchanged Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNonNull("nullable_int64s", actualValue));
                VerifyOrReturn(CheckValue("nullable_int64s", actualValue, -9223372036854775807LL));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeNullableInt64sNullValue_297()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableInt64sArgument;
        nullableInt64sArgument = nil;
        [cluster writeAttributeNullableInt64sWithValue:nullableInt64sArgument
                                     completionHandler:^(NSError * _Nullable err) {
                                         NSLog(@"Write attribute NULLABLE_INT64S null Value Error: %@", err);

                                         VerifyOrReturn(CheckValue("status", err, 0));

                                         NextTest();
                                     }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableInt64sNullValue_298()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableInt64sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_INT64S null Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNull("nullable_int64s", actualValue));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableInt64sNullValueRange_299()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableInt64sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_INT64S null Value & range Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<int64_t>("nullableInt64s", [value longLongValue], -9223372036854775807LL));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<int64_t>("nullableInt64s", [value longLongValue], 9223372036854775807LL));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableInt64sNullValueNot_300()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableInt64sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_INT64S null Value & not Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            if (value != nil) {
                VerifyOrReturn(CheckConstraintNotValue("nullableInt64s", value, -9223372036854775807LL));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeNullableInt64sValue_301()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableInt64sArgument;
        nullableInt64sArgument = [NSNumber numberWithLongLong:-9223372036854775807LL];
        [cluster writeAttributeNullableInt64sWithValue:nullableInt64sArgument
                                     completionHandler:^(NSError * _Nullable err) {
                                         NSLog(@"Write attribute NULLABLE_INT64S Value Error: %@", err);

                                         VerifyOrReturn(CheckValue("status", err, 0));

                                         NextTest();
                                     }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableInt64sValueInRange_302()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableInt64sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_INT64S Value in range Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<int64_t>("nullableInt64s", [value longLongValue], -9223372036854775807LL));
            }
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<int64_t>("nullableInt64s", [value longLongValue], 9223372036854775807LL));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableInt64sNotValueOk_303()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableInt64sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_INT64S notValue OK Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            if (value != nil) {
                VerifyOrReturn(CheckConstraintNotValue("nullableInt64s", value, -9223372036854775806LL));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeNullableSingleMediumValue_304()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableFloatSingleArgument;
        nullableFloatSingleArgument = [NSNumber numberWithFloat:0.1f];
        [cluster writeAttributeNullableFloatSingleWithValue:nullableFloatSingleArgument
                                          completionHandler:^(NSError * _Nullable err) {
                                              NSLog(@"Write attribute NULLABLE_SINGLE medium Value Error: %@", err);

                                              VerifyOrReturn(CheckValue("status", err, 0));

                                              NextTest();
                                          }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableSingleMediumValue_305()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableFloatSingleWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_SINGLE medium Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNonNull("nullable_float_single", actualValue));
                VerifyOrReturn(CheckValue("nullable_float_single", actualValue, 0.1f));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeNullableSingleLargestValue_306()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableFloatSingleArgument;
        nullableFloatSingleArgument = [NSNumber numberWithFloat:INFINITY];
        [cluster writeAttributeNullableFloatSingleWithValue:nullableFloatSingleArgument
                                          completionHandler:^(NSError * _Nullable err) {
                                              NSLog(@"Write attribute NULLABLE_SINGLE largest Value Error: %@", err);

                                              VerifyOrReturn(CheckValue("status", err, 0));

                                              NextTest();
                                          }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableSingleLargestValue_307()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableFloatSingleWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_SINGLE largest Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNonNull("nullable_float_single", actualValue));
                VerifyOrReturn(CheckValue("nullable_float_single", actualValue, INFINITY));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeNullableSingleSmallestValue_308()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableFloatSingleArgument;
        nullableFloatSingleArgument = [NSNumber numberWithFloat:-INFINITY];
        [cluster writeAttributeNullableFloatSingleWithValue:nullableFloatSingleArgument
                                          completionHandler:^(NSError * _Nullable err) {
                                              NSLog(@"Write attribute NULLABLE_SINGLE smallest Value Error: %@", err);

                                              VerifyOrReturn(CheckValue("status", err, 0));

                                              NextTest();
                                          }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableSingleSmallestValue_309()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableFloatSingleWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_SINGLE smallest Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNonNull("nullable_float_single", actualValue));
                VerifyOrReturn(CheckValue("nullable_float_single", actualValue, -INFINITY));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeNullableSingleNullValue_310()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableFloatSingleArgument;
        nullableFloatSingleArgument = nil;
        [cluster writeAttributeNullableFloatSingleWithValue:nullableFloatSingleArgument
                                          completionHandler:^(NSError * _Nullable err) {
                                              NSLog(@"Write attribute NULLABLE_SINGLE null Value Error: %@", err);

                                              VerifyOrReturn(CheckValue("status", err, 0));

                                              NextTest();
                                          }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableSingleNullValue_311()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableFloatSingleWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_SINGLE null Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNull("nullable_float_single", actualValue));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeNullableSingle0Value_312()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableFloatSingleArgument;
        nullableFloatSingleArgument = [NSNumber numberWithFloat:0.0f];
        [cluster writeAttributeNullableFloatSingleWithValue:nullableFloatSingleArgument
                                          completionHandler:^(NSError * _Nullable err) {
                                              NSLog(@"Write attribute NULLABLE_SINGLE 0 Value Error: %@", err);

                                              VerifyOrReturn(CheckValue("status", err, 0));

                                              NextTest();
                                          }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableSingle0Value_313()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableFloatSingleWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_SINGLE 0 Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNonNull("nullable_float_single", actualValue));
                VerifyOrReturn(CheckValue("nullable_float_single", actualValue, 0.0f));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeNullableDoubleMediumValue_314()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableFloatDoubleArgument;
        nullableFloatDoubleArgument = [NSNumber numberWithDouble:0.1234567890123];
        [cluster writeAttributeNullableFloatDoubleWithValue:nullableFloatDoubleArgument
                                          completionHandler:^(NSError * _Nullable err) {
                                              NSLog(@"Write attribute NULLABLE_DOUBLE medium Value Error: %@", err);

                                              VerifyOrReturn(CheckValue("status", err, 0));

                                              NextTest();
                                          }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableDoubleMediumValue_315()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableFloatDoubleWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_DOUBLE medium Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNonNull("nullable_float_double", actualValue));
                VerifyOrReturn(CheckValue("nullable_float_double", actualValue, 0.1234567890123));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeNullableDoubleLargestValue_316()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableFloatDoubleArgument;
        nullableFloatDoubleArgument = [NSNumber numberWithDouble:INFINITY];
        [cluster writeAttributeNullableFloatDoubleWithValue:nullableFloatDoubleArgument
                                          completionHandler:^(NSError * _Nullable err) {
                                              NSLog(@"Write attribute NULLABLE_DOUBLE largest Value Error: %@", err);

                                              VerifyOrReturn(CheckValue("status", err, 0));

                                              NextTest();
                                          }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableDoubleLargestValue_317()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableFloatDoubleWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_DOUBLE largest Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNonNull("nullable_float_double", actualValue));
                VerifyOrReturn(CheckValue("nullable_float_double", actualValue, INFINITY));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeNullableDoubleSmallestValue_318()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableFloatDoubleArgument;
        nullableFloatDoubleArgument = [NSNumber numberWithDouble:-INFINITY];
        [cluster writeAttributeNullableFloatDoubleWithValue:nullableFloatDoubleArgument
                                          completionHandler:^(NSError * _Nullable err) {
                                              NSLog(@"Write attribute NULLABLE_DOUBLE smallest Value Error: %@", err);

                                              VerifyOrReturn(CheckValue("status", err, 0));

                                              NextTest();
                                          }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableDoubleSmallestValue_319()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableFloatDoubleWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_DOUBLE smallest Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNonNull("nullable_float_double", actualValue));
                VerifyOrReturn(CheckValue("nullable_float_double", actualValue, -INFINITY));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeNullableDoubleNullValue_320()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableFloatDoubleArgument;
        nullableFloatDoubleArgument = nil;
        [cluster writeAttributeNullableFloatDoubleWithValue:nullableFloatDoubleArgument
                                          completionHandler:^(NSError * _Nullable err) {
                                              NSLog(@"Write attribute NULLABLE_DOUBLE null Value Error: %@", err);

                                              VerifyOrReturn(CheckValue("status", err, 0));

                                              NextTest();
                                          }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableDoubleNullValue_321()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableFloatDoubleWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_DOUBLE null Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNull("nullable_float_double", actualValue));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeNullableDouble0Value_322()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableFloatDoubleArgument;
        nullableFloatDoubleArgument = [NSNumber numberWithDouble:0];
        [cluster writeAttributeNullableFloatDoubleWithValue:nullableFloatDoubleArgument
                                          completionHandler:^(NSError * _Nullable err) {
                                              NSLog(@"Write attribute NULLABLE_DOUBLE 0 Value Error: %@", err);

                                              VerifyOrReturn(CheckValue("status", err, 0));

                                              NextTest();
                                          }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableDouble0Value_323()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableFloatDoubleWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_DOUBLE 0 Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNonNull("nullable_float_double", actualValue));
                VerifyOrReturn(CheckValue("nullable_float_double", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeNullableEnum8MinValue_324()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableEnum8Argument;
        nullableEnum8Argument = [NSNumber numberWithUnsignedChar:0];
        [cluster writeAttributeNullableEnum8WithValue:nullableEnum8Argument
                                    completionHandler:^(NSError * _Nullable err) {
                                        NSLog(@"Write attribute NULLABLE_ENUM8 Min Value Error: %@", err);

                                        VerifyOrReturn(CheckValue("status", err, 0));

                                        NextTest();
                                    }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableEnum8MinValue_325()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableEnum8WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_ENUM8 Min Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNonNull("nullable_enum8", actualValue));
                VerifyOrReturn(CheckValue("nullable_enum8", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeNullableEnum8MaxValue_326()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableEnum8Argument;
        nullableEnum8Argument = [NSNumber numberWithUnsignedChar:254];
        [cluster writeAttributeNullableEnum8WithValue:nullableEnum8Argument
                                    completionHandler:^(NSError * _Nullable err) {
                                        NSLog(@"Write attribute NULLABLE_ENUM8 Max Value Error: %@", err);

                                        VerifyOrReturn(CheckValue("status", err, 0));

                                        NextTest();
                                    }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableEnum8MaxValue_327()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableEnum8WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_ENUM8 Max Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNonNull("nullable_enum8", actualValue));
                VerifyOrReturn(CheckValue("nullable_enum8", actualValue, 254));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeNullableEnum8InvalidValue_328()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableEnum8Argument;
        nullableEnum8Argument = [NSNumber numberWithUnsignedChar:255];
        [cluster writeAttributeNullableEnum8WithValue:nullableEnum8Argument
                                    completionHandler:^(NSError * _Nullable err) {
                                        NSLog(@"Write attribute NULLABLE_ENUM8 Invalid Value Error: %@", err);

                                        VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
                                        NextTest();
                                    }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableEnum8UnchangedValue_329()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableEnum8WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_ENUM8 unchanged Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNonNull("nullable_enum8", actualValue));
                VerifyOrReturn(CheckValue("nullable_enum8", actualValue, 254));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeNullableEnum8NullValue_330()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableEnum8Argument;
        nullableEnum8Argument = nil;
        [cluster writeAttributeNullableEnum8WithValue:nullableEnum8Argument
                                    completionHandler:^(NSError * _Nullable err) {
                                        NSLog(@"Write attribute NULLABLE_ENUM8 null Value Error: %@", err);

                                        VerifyOrReturn(CheckValue("status", err, 0));

                                        NextTest();
                                    }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableEnum8NullValue_331()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableEnum8WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_ENUM8 null Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNull("nullable_enum8", actualValue));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeNullableEnum16MinValue_332()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableEnum16Argument;
        nullableEnum16Argument = [NSNumber numberWithUnsignedShort:0U];
        [cluster writeAttributeNullableEnum16WithValue:nullableEnum16Argument
                                     completionHandler:^(NSError * _Nullable err) {
                                         NSLog(@"Write attribute NULLABLE_ENUM16 Min Value Error: %@", err);

                                         VerifyOrReturn(CheckValue("status", err, 0));

                                         NextTest();
                                     }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableEnum16MinValue_333()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableEnum16WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_ENUM16 Min Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNonNull("nullable_enum16", actualValue));
                VerifyOrReturn(CheckValue("nullable_enum16", actualValue, 0U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeNullableEnum16MaxValue_334()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableEnum16Argument;
        nullableEnum16Argument = [NSNumber numberWithUnsignedShort:65534U];
        [cluster writeAttributeNullableEnum16WithValue:nullableEnum16Argument
                                     completionHandler:^(NSError * _Nullable err) {
                                         NSLog(@"Write attribute NULLABLE_ENUM16 Max Value Error: %@", err);

                                         VerifyOrReturn(CheckValue("status", err, 0));

                                         NextTest();
                                     }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableEnum16MaxValue_335()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableEnum16WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_ENUM16 Max Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNonNull("nullable_enum16", actualValue));
                VerifyOrReturn(CheckValue("nullable_enum16", actualValue, 65534U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeNullableEnum16InvalidValue_336()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableEnum16Argument;
        nullableEnum16Argument = [NSNumber numberWithUnsignedShort:65535U];
        [cluster writeAttributeNullableEnum16WithValue:nullableEnum16Argument
                                     completionHandler:^(NSError * _Nullable err) {
                                         NSLog(@"Write attribute NULLABLE_ENUM16 Invalid Value Error: %@", err);

                                         VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
                                         NextTest();
                                     }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableEnum16UnchangedValue_337()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableEnum16WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_ENUM16 unchanged Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNonNull("nullable_enum16", actualValue));
                VerifyOrReturn(CheckValue("nullable_enum16", actualValue, 65534U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeNullableEnum16NullValue_338()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableEnum16Argument;
        nullableEnum16Argument = nil;
        [cluster writeAttributeNullableEnum16WithValue:nullableEnum16Argument
                                     completionHandler:^(NSError * _Nullable err) {
                                         NSLog(@"Write attribute NULLABLE_ENUM16 null Value Error: %@", err);

                                         VerifyOrReturn(CheckValue("status", err, 0));

                                         NextTest();
                                     }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableEnum16NullValue_339()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableEnum16WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_ENUM16 null Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNull("nullable_enum16", actualValue));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeNullableSimpleEnumMinValue_340()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableEnumAttrArgument;
        nullableEnumAttrArgument = [NSNumber numberWithUnsignedChar:0];
        [cluster writeAttributeNullableEnumAttrWithValue:nullableEnumAttrArgument
                                       completionHandler:^(NSError * _Nullable err) {
                                           NSLog(@"Write attribute NULLABLE_SIMPLE_ENUM Min Value Error: %@", err);

                                           VerifyOrReturn(CheckValue("status", err, 0));

                                           NextTest();
                                       }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableSimpleEnumMinValue_341()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableEnumAttrWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_SIMPLE_ENUM Min Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNonNull("nullable_enum_attr", actualValue));
                VerifyOrReturn(CheckValue("nullable_enum_attr", actualValue, 0));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeNullableSimpleEnumMaxValue_342()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableEnumAttrArgument;
        nullableEnumAttrArgument = [NSNumber numberWithUnsignedChar:254];
        [cluster writeAttributeNullableEnumAttrWithValue:nullableEnumAttrArgument
                                       completionHandler:^(NSError * _Nullable err) {
                                           NSLog(@"Write attribute NULLABLE_SIMPLE_ENUM Max Value Error: %@", err);

                                           VerifyOrReturn(CheckValue("status", err, 0));

                                           NextTest();
                                       }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableSimpleEnumMaxValue_343()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableEnumAttrWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_SIMPLE_ENUM Max Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNonNull("nullable_enum_attr", actualValue));
                VerifyOrReturn(CheckValue("nullable_enum_attr", actualValue, 254));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeNullableSimpleEnumInvalidValue_344()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableEnumAttrArgument;
        nullableEnumAttrArgument = [NSNumber numberWithUnsignedChar:255];
        [cluster writeAttributeNullableEnumAttrWithValue:nullableEnumAttrArgument
                                       completionHandler:^(NSError * _Nullable err) {
                                           NSLog(@"Write attribute NULLABLE_SIMPLE_ENUM Invalid Value Error: %@", err);

                                           VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
                                           NextTest();
                                       }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableSimpleEnumUnchangedValue_345()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableEnumAttrWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_SIMPLE_ENUM unchanged Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNonNull("nullable_enum_attr", actualValue));
                VerifyOrReturn(CheckValue("nullable_enum_attr", actualValue, 254));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeNullableSimpleEnumNullValue_346()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableEnumAttrArgument;
        nullableEnumAttrArgument = nil;
        [cluster writeAttributeNullableEnumAttrWithValue:nullableEnumAttrArgument
                                       completionHandler:^(NSError * _Nullable err) {
                                           NSLog(@"Write attribute NULLABLE_SIMPLE_ENUM null Value Error: %@", err);

                                           VerifyOrReturn(CheckValue("status", err, 0));

                                           NextTest();
                                       }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableSimpleEnumNullValue_347()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableEnumAttrWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_SIMPLE_ENUM null Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNull("nullable_enum_attr", actualValue));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableOctetStringDefaultValue_348()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableOctetStringWithCompletionHandler:^(NSData * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_OCTET_STRING Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNonNull("nullable_octet_string", actualValue));
                VerifyOrReturn(
                    CheckValueAsString("nullable_octet_string", actualValue, [[NSData alloc] initWithBytes:"" length:0]));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeNullableOctetString_349()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableOctetStringArgument;
        nullableOctetStringArgument = [[NSData alloc] initWithBytes:"TestValue" length:9];
        [cluster writeAttributeNullableOctetStringWithValue:nullableOctetStringArgument
                                          completionHandler:^(NSError * _Nullable err) {
                                              NSLog(@"Write attribute NULLABLE_OCTET_STRING Error: %@", err);

                                              VerifyOrReturn(CheckValue("status", err, 0));

                                              NextTest();
                                          }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableOctetString_350()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableOctetStringWithCompletionHandler:^(NSData * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_OCTET_STRING Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNonNull("nullable_octet_string", actualValue));
                VerifyOrReturn(
                    CheckValueAsString("nullable_octet_string", actualValue, [[NSData alloc] initWithBytes:"TestValue" length:9]));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeNullableOctetString_351()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableOctetStringArgument;
        nullableOctetStringArgument = nil;
        [cluster writeAttributeNullableOctetStringWithValue:nullableOctetStringArgument
                                          completionHandler:^(NSError * _Nullable err) {
                                              NSLog(@"Write attribute NULLABLE_OCTET_STRING Error: %@", err);

                                              VerifyOrReturn(CheckValue("status", err, 0));

                                              NextTest();
                                          }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableOctetString_352()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableOctetStringWithCompletionHandler:^(NSData * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_OCTET_STRING Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNull("nullable_octet_string", actualValue));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeNullableOctetString_353()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableOctetStringArgument;
        nullableOctetStringArgument = [[NSData alloc] initWithBytes:"" length:0];
        [cluster writeAttributeNullableOctetStringWithValue:nullableOctetStringArgument
                                          completionHandler:^(NSError * _Nullable err) {
                                              NSLog(@"Write attribute NULLABLE_OCTET_STRING Error: %@", err);

                                              VerifyOrReturn(CheckValue("status", err, 0));

                                              NextTest();
                                          }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableOctetString_354()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableOctetStringWithCompletionHandler:^(NSData * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_OCTET_STRING Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNonNull("nullable_octet_string", actualValue));
                VerifyOrReturn(
                    CheckValueAsString("nullable_octet_string", actualValue, [[NSData alloc] initWithBytes:"" length:0]));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableCharStringDefaultValue_355()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableCharStringWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_CHAR_STRING Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNonNull("nullable_char_string", actualValue));
                VerifyOrReturn(CheckValueAsString("nullable_char_string", actualValue, @""));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeNullableCharString_356()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableCharStringArgument;
        nullableCharStringArgument = @"T";
        [cluster writeAttributeNullableCharStringWithValue:nullableCharStringArgument
                                         completionHandler:^(NSError * _Nullable err) {
                                             NSLog(@"Write attribute NULLABLE_CHAR_STRING Error: %@", err);

                                             VerifyOrReturn(CheckValue("status", err, 0));

                                             NextTest();
                                         }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableCharString_357()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableCharStringWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_CHAR_STRING Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNonNull("nullable_char_string", actualValue));
                VerifyOrReturn(CheckValueAsString("nullable_char_string", actualValue, @"T"));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeNullableCharStringValueTooLong_358()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableCharStringArgument;
        nullableCharStringArgument = nil;
        [cluster writeAttributeNullableCharStringWithValue:nullableCharStringArgument
                                         completionHandler:^(NSError * _Nullable err) {
                                             NSLog(@"Write attribute NULLABLE_CHAR_STRING - Value too long Error: %@", err);

                                             VerifyOrReturn(CheckValue("status", err, 0));

                                             NextTest();
                                         }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableCharString_359()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableCharStringWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_CHAR_STRING Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNull("nullable_char_string", actualValue));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeNullableCharStringEmpty_360()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableCharStringArgument;
        nullableCharStringArgument = @"";
        [cluster writeAttributeNullableCharStringWithValue:nullableCharStringArgument
                                         completionHandler:^(NSError * _Nullable err) {
                                             NSLog(@"Write attribute NULLABLE_CHAR_STRING - Empty Error: %@", err);

                                             VerifyOrReturn(CheckValue("status", err, 0));

                                             NextTest();
                                         }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeNullableCharString_361()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeNullableCharStringWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute NULLABLE_CHAR_STRING Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueNonNull("nullable_char_string", actualValue));
                VerifyOrReturn(CheckValueAsString("nullable_char_string", actualValue, @""));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeFromNonexistentEndpoint_362()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:200 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeListInt8uWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute from nonexistent endpoint. Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_ENDPOINT));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeFromNonexistentCluster_363()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:0 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeListInt8uWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute from nonexistent cluster. Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_UNSUPPORTED_CLUSTER));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSendACommandThatTakesAnOptionalParameterButDoNotSetIt_364()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPTestClusterClusterTestSimpleOptionalArgumentRequestParams alloc] init];
        [cluster
            testSimpleOptionalArgumentRequestWithParams:params
                                      completionHandler:^(NSError * _Nullable err) {
                                          NSLog(
                                              @"Send a command that takes an optional parameter but do not set it. Error: %@", err);

                                          VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_INVALID_VALUE));
                                          NextTest();
                                      }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSendACommandThatTakesAnOptionalParameterButDoNotSetIt_365()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPTestClusterClusterTestSimpleOptionalArgumentRequestParams alloc] init];
        params.arg1 = [NSNumber numberWithBool:1];
        [cluster
            testSimpleOptionalArgumentRequestWithParams:params
                                      completionHandler:^(NSError * _Nullable err) {
                                          NSLog(
                                              @"Send a command that takes an optional parameter but do not set it. Error: %@", err);

                                          VerifyOrReturn(CheckValue("status", err, 0));

                                          NextTest();
                                      }];

        return CHIP_NO_ERROR;
    }
    bool testSendClusterTestCluster_000366_WaitForReport_Fulfilled = false;
    ResponseHandler _Nullable test_TestCluster_list_int8u_Reported = nil;

    CHIP_ERROR TestReportSubscribeToListAttribute_366()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        test_TestCluster_list_int8u_Reported = ^(NSArray * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Report: Subscribe to list attribute Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("list_int8u", [actualValue count], static_cast<uint32_t>(4)));
                VerifyOrReturn(CheckValue("", actualValue[0], 1));
                VerifyOrReturn(CheckValue("", actualValue[1], 2));
                VerifyOrReturn(CheckValue("", actualValue[2], 3));
                VerifyOrReturn(CheckValue("", actualValue[3], 4));
            }

            testSendClusterTestCluster_000366_WaitForReport_Fulfilled = true;
        };

        NextTest();
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSubscribeToListAttribute_367()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        uint16_t minIntervalArgument = 2U;
        uint16_t maxIntervalArgument = 5U;
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeListInt8uWithMinInterval:[NSNumber numberWithUnsignedInt:minIntervalArgument]
            maxInterval:[NSNumber numberWithUnsignedInt:maxIntervalArgument]
            params:params
            subscriptionEstablished:^{
                VerifyOrReturn(
                    testSendClusterTestCluster_000366_WaitForReport_Fulfilled, SetCommandExitStatus(CHIP_ERROR_INCORRECT_STATE));
                NextTest();
            }
            reportHandler:^(NSArray * _Nullable value, NSError * _Nullable err) {
                NSLog(@"Subscribe to list attribute Error: %@", err);

                VerifyOrReturn(CheckValue("status", err, 0));
                if (test_TestCluster_list_int8u_Reported != nil) {
                    ResponseHandler callback = test_TestCluster_list_int8u_Reported;
                    test_TestCluster_list_int8u_Reported = nil;
                    callback(value, err);
                }
            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteSubscribedToListAttribute_368()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id listInt8uArgument;
        {
            NSMutableArray * temp_0 = [[NSMutableArray alloc] init];
            temp_0[0] = [NSNumber numberWithUnsignedChar:5];
            temp_0[1] = [NSNumber numberWithUnsignedChar:6];
            temp_0[2] = [NSNumber numberWithUnsignedChar:7];
            temp_0[3] = [NSNumber numberWithUnsignedChar:8];
            listInt8uArgument = temp_0;
        }
        [cluster writeAttributeListInt8uWithValue:listInt8uArgument
                                completionHandler:^(NSError * _Nullable err) {
                                    NSLog(@"Write subscribed-to list attribute Error: %@", err);

                                    VerifyOrReturn(CheckValue("status", err, 0));

                                    NextTest();
                                }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestCheckForListAttributeReport_369()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        test_TestCluster_list_int8u_Reported = ^(NSArray * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Check for list attribute report Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("list_int8u", [actualValue count], static_cast<uint32_t>(4)));
                VerifyOrReturn(CheckValue("", actualValue[0], 5));
                VerifyOrReturn(CheckValue("", actualValue[1], 6));
                VerifyOrReturn(CheckValue("", actualValue[2], 7));
                VerifyOrReturn(CheckValue("", actualValue[3], 8));
            }

            NextTest();
        };

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadRangeRestrictedUnsigned8BitInteger_370()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeRangeRestrictedInt8uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read range-restricted unsigned 8-bit integer Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("range_restricted_int8u", actualValue, 70));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteMinValueToARangeRestrictedUnsigned8BitInteger_371()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id rangeRestrictedInt8uArgument;
        rangeRestrictedInt8uArgument = [NSNumber numberWithUnsignedChar:0];
        [cluster
            writeAttributeRangeRestrictedInt8uWithValue:rangeRestrictedInt8uArgument
                                      completionHandler:^(NSError * _Nullable err) {
                                          NSLog(@"Write min value to a range-restricted unsigned 8-bit integer Error: %@", err);

                                          VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
                                          NextTest();
                                      }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteJustBelowRangeValueToARangeRestrictedUnsigned8BitInteger_372()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id rangeRestrictedInt8uArgument;
        rangeRestrictedInt8uArgument = [NSNumber numberWithUnsignedChar:19];
        [cluster writeAttributeRangeRestrictedInt8uWithValue:rangeRestrictedInt8uArgument
                                           completionHandler:^(NSError * _Nullable err) {
                                               NSLog(@"Write just-below-range value to a range-restricted unsigned 8-bit integer "
                                                     @"Error: %@",
                                                   err);

                                               VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
                                               NextTest();
                                           }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteJustAboveRangeValueToARangeRestrictedUnsigned8BitInteger_373()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id rangeRestrictedInt8uArgument;
        rangeRestrictedInt8uArgument = [NSNumber numberWithUnsignedChar:101];
        [cluster writeAttributeRangeRestrictedInt8uWithValue:rangeRestrictedInt8uArgument
                                           completionHandler:^(NSError * _Nullable err) {
                                               NSLog(@"Write just-above-range value to a range-restricted unsigned 8-bit integer "
                                                     @"Error: %@",
                                                   err);

                                               VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
                                               NextTest();
                                           }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteMaxValueToARangeRestrictedUnsigned8BitInteger_374()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id rangeRestrictedInt8uArgument;
        rangeRestrictedInt8uArgument = [NSNumber numberWithUnsignedChar:255];
        [cluster
            writeAttributeRangeRestrictedInt8uWithValue:rangeRestrictedInt8uArgument
                                      completionHandler:^(NSError * _Nullable err) {
                                          NSLog(@"Write max value to a range-restricted unsigned 8-bit integer Error: %@", err);

                                          VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
                                          NextTest();
                                      }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestVerifyRangeRestrictedUnsigned8BitIntegerValueHasNotChanged_375()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeRangeRestrictedInt8uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Verify range-restricted unsigned 8-bit integer value has not changed Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("range_restricted_int8u", actualValue, 70));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteMinValidValueToARangeRestrictedUnsigned8BitInteger_376()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id rangeRestrictedInt8uArgument;
        rangeRestrictedInt8uArgument = [NSNumber numberWithUnsignedChar:20];
        [cluster
            writeAttributeRangeRestrictedInt8uWithValue:rangeRestrictedInt8uArgument
                                      completionHandler:^(NSError * _Nullable err) {
                                          NSLog(
                                              @"Write min valid value to a range-restricted unsigned 8-bit integer Error: %@", err);

                                          VerifyOrReturn(CheckValue("status", err, 0));

                                          NextTest();
                                      }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestVerifyRangeRestrictedUnsigned8BitIntegerValueIsAtMinValid_377()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeRangeRestrictedInt8uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Verify range-restricted unsigned 8-bit integer value is at min valid Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("range_restricted_int8u", actualValue, 20));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteMaxValidValueToARangeRestrictedUnsigned8BitInteger_378()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id rangeRestrictedInt8uArgument;
        rangeRestrictedInt8uArgument = [NSNumber numberWithUnsignedChar:100];
        [cluster
            writeAttributeRangeRestrictedInt8uWithValue:rangeRestrictedInt8uArgument
                                      completionHandler:^(NSError * _Nullable err) {
                                          NSLog(
                                              @"Write max valid value to a range-restricted unsigned 8-bit integer Error: %@", err);

                                          VerifyOrReturn(CheckValue("status", err, 0));

                                          NextTest();
                                      }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestVerifyRangeRestrictedUnsigned8BitIntegerValueIsAtMaxValid_379()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeRangeRestrictedInt8uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Verify range-restricted unsigned 8-bit integer value is at max valid Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("range_restricted_int8u", actualValue, 100));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteMiddleValidValueToARangeRestrictedUnsigned8BitInteger_380()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id rangeRestrictedInt8uArgument;
        rangeRestrictedInt8uArgument = [NSNumber numberWithUnsignedChar:50];
        [cluster
            writeAttributeRangeRestrictedInt8uWithValue:rangeRestrictedInt8uArgument
                                      completionHandler:^(NSError * _Nullable err) {
                                          NSLog(@"Write middle valid value to a range-restricted unsigned 8-bit integer Error: %@",
                                              err);

                                          VerifyOrReturn(CheckValue("status", err, 0));

                                          NextTest();
                                      }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestVerifyRangeRestrictedUnsigned8BitIntegerValueIsAtMidValid_381()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeRangeRestrictedInt8uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Verify range-restricted unsigned 8-bit integer value is at mid valid Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("range_restricted_int8u", actualValue, 50));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadRangeRestrictedUnsigned16BitInteger_382()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeRangeRestrictedInt16uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read range-restricted unsigned 16-bit integer Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("range_restricted_int16u", actualValue, 200U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteMinValueToARangeRestrictedUnsigned16BitInteger_383()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id rangeRestrictedInt16uArgument;
        rangeRestrictedInt16uArgument = [NSNumber numberWithUnsignedShort:0U];
        [cluster
            writeAttributeRangeRestrictedInt16uWithValue:rangeRestrictedInt16uArgument
                                       completionHandler:^(NSError * _Nullable err) {
                                           NSLog(@"Write min value to a range-restricted unsigned 16-bit integer Error: %@", err);

                                           VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
                                           NextTest();
                                       }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteJustBelowRangeValueToARangeRestrictedUnsigned16BitInteger_384()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id rangeRestrictedInt16uArgument;
        rangeRestrictedInt16uArgument = [NSNumber numberWithUnsignedShort:99U];
        [cluster writeAttributeRangeRestrictedInt16uWithValue:rangeRestrictedInt16uArgument
                                            completionHandler:^(NSError * _Nullable err) {
                                                NSLog(@"Write just-below-range value to a range-restricted unsigned 16-bit integer "
                                                      @"Error: %@",
                                                    err);

                                                VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
                                                NextTest();
                                            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteJustAboveRangeValueToARangeRestrictedUnsigned16BitInteger_385()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id rangeRestrictedInt16uArgument;
        rangeRestrictedInt16uArgument = [NSNumber numberWithUnsignedShort:1001U];
        [cluster writeAttributeRangeRestrictedInt16uWithValue:rangeRestrictedInt16uArgument
                                            completionHandler:^(NSError * _Nullable err) {
                                                NSLog(@"Write just-above-range value to a range-restricted unsigned 16-bit integer "
                                                      @"Error: %@",
                                                    err);

                                                VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
                                                NextTest();
                                            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteMaxValueToARangeRestrictedUnsigned16BitInteger_386()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id rangeRestrictedInt16uArgument;
        rangeRestrictedInt16uArgument = [NSNumber numberWithUnsignedShort:65535U];
        [cluster
            writeAttributeRangeRestrictedInt16uWithValue:rangeRestrictedInt16uArgument
                                       completionHandler:^(NSError * _Nullable err) {
                                           NSLog(@"Write max value to a range-restricted unsigned 16-bit integer Error: %@", err);

                                           VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
                                           NextTest();
                                       }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestVerifyRangeRestrictedUnsigned16BitIntegerValueHasNotChanged_387()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeRangeRestrictedInt16uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Verify range-restricted unsigned 16-bit integer value has not changed Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("range_restricted_int16u", actualValue, 200U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteMinValidValueToARangeRestrictedUnsigned16BitInteger_388()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id rangeRestrictedInt16uArgument;
        rangeRestrictedInt16uArgument = [NSNumber numberWithUnsignedShort:100U];
        [cluster
            writeAttributeRangeRestrictedInt16uWithValue:rangeRestrictedInt16uArgument
                                       completionHandler:^(NSError * _Nullable err) {
                                           NSLog(@"Write min valid value to a range-restricted unsigned 16-bit integer Error: %@",
                                               err);

                                           VerifyOrReturn(CheckValue("status", err, 0));

                                           NextTest();
                                       }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestVerifyRangeRestrictedUnsigned16BitIntegerValueIsAtMinValid_389()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeRangeRestrictedInt16uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Verify range-restricted unsigned 16-bit integer value is at min valid Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("range_restricted_int16u", actualValue, 100U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteMaxValidValueToARangeRestrictedUnsigned16BitInteger_390()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id rangeRestrictedInt16uArgument;
        rangeRestrictedInt16uArgument = [NSNumber numberWithUnsignedShort:1000U];
        [cluster
            writeAttributeRangeRestrictedInt16uWithValue:rangeRestrictedInt16uArgument
                                       completionHandler:^(NSError * _Nullable err) {
                                           NSLog(@"Write max valid value to a range-restricted unsigned 16-bit integer Error: %@",
                                               err);

                                           VerifyOrReturn(CheckValue("status", err, 0));

                                           NextTest();
                                       }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestVerifyRangeRestrictedUnsigned16BitIntegerValueIsAtMaxValid_391()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeRangeRestrictedInt16uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Verify range-restricted unsigned 16-bit integer value is at max valid Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("range_restricted_int16u", actualValue, 1000U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteMiddleValidValueToARangeRestrictedUnsigned16BitInteger_392()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id rangeRestrictedInt16uArgument;
        rangeRestrictedInt16uArgument = [NSNumber numberWithUnsignedShort:500U];
        [cluster
            writeAttributeRangeRestrictedInt16uWithValue:rangeRestrictedInt16uArgument
                                       completionHandler:^(NSError * _Nullable err) {
                                           NSLog(
                                               @"Write middle valid value to a range-restricted unsigned 16-bit integer Error: %@",
                                               err);

                                           VerifyOrReturn(CheckValue("status", err, 0));

                                           NextTest();
                                       }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestVerifyRangeRestrictedUnsigned16BitIntegerValueIsAtMidValid_393()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeRangeRestrictedInt16uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Verify range-restricted unsigned 16-bit integer value is at mid valid Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("range_restricted_int16u", actualValue, 500U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadRangeRestrictedSigned8BitInteger_394()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeRangeRestrictedInt8sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read range-restricted signed 8-bit integer Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("range_restricted_int8s", actualValue, -20));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteMinValueToARangeRestrictedSigned8BitInteger_395()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id rangeRestrictedInt8sArgument;
        rangeRestrictedInt8sArgument = [NSNumber numberWithChar:-128];
        [cluster writeAttributeRangeRestrictedInt8sWithValue:rangeRestrictedInt8sArgument
                                           completionHandler:^(NSError * _Nullable err) {
                                               NSLog(@"Write min value to a range-restricted signed 8-bit integer Error: %@", err);

                                               VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
                                               NextTest();
                                           }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteJustBelowRangeValueToARangeRestrictedSigned8BitInteger_396()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id rangeRestrictedInt8sArgument;
        rangeRestrictedInt8sArgument = [NSNumber numberWithChar:-41];
        [cluster
            writeAttributeRangeRestrictedInt8sWithValue:rangeRestrictedInt8sArgument
                                      completionHandler:^(NSError * _Nullable err) {
                                          NSLog(
                                              @"Write just-below-range value to a range-restricted signed 8-bit integer Error: %@",
                                              err);

                                          VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
                                          NextTest();
                                      }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteJustAboveRangeValueToARangeRestrictedSigned8BitInteger_397()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id rangeRestrictedInt8sArgument;
        rangeRestrictedInt8sArgument = [NSNumber numberWithChar:51];
        [cluster
            writeAttributeRangeRestrictedInt8sWithValue:rangeRestrictedInt8sArgument
                                      completionHandler:^(NSError * _Nullable err) {
                                          NSLog(
                                              @"Write just-above-range value to a range-restricted signed 8-bit integer Error: %@",
                                              err);

                                          VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
                                          NextTest();
                                      }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteMaxValueToARangeRestrictedSigned8BitInteger_398()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id rangeRestrictedInt8sArgument;
        rangeRestrictedInt8sArgument = [NSNumber numberWithChar:127];
        [cluster writeAttributeRangeRestrictedInt8sWithValue:rangeRestrictedInt8sArgument
                                           completionHandler:^(NSError * _Nullable err) {
                                               NSLog(@"Write max value to a range-restricted signed 8-bit integer Error: %@", err);

                                               VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
                                               NextTest();
                                           }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestVerifyRangeRestrictedSigned8BitIntegerValueHasNotChanged_399()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeRangeRestrictedInt8sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Verify range-restricted signed 8-bit integer value has not changed Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("range_restricted_int8s", actualValue, -20));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteMinValidValueToARangeRestrictedSigned8BitInteger_400()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id rangeRestrictedInt8sArgument;
        rangeRestrictedInt8sArgument = [NSNumber numberWithChar:-40];
        [cluster
            writeAttributeRangeRestrictedInt8sWithValue:rangeRestrictedInt8sArgument
                                      completionHandler:^(NSError * _Nullable err) {
                                          NSLog(@"Write min valid value to a range-restricted signed 8-bit integer Error: %@", err);

                                          VerifyOrReturn(CheckValue("status", err, 0));

                                          NextTest();
                                      }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestVerifyRangeRestrictedSigned8BitIntegerValueIsAtMinValid_401()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeRangeRestrictedInt8sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Verify range-restricted signed 8-bit integer value is at min valid Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("range_restricted_int8s", actualValue, -40));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteMaxValidValueToARangeRestrictedSigned8BitInteger_402()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id rangeRestrictedInt8sArgument;
        rangeRestrictedInt8sArgument = [NSNumber numberWithChar:50];
        [cluster
            writeAttributeRangeRestrictedInt8sWithValue:rangeRestrictedInt8sArgument
                                      completionHandler:^(NSError * _Nullable err) {
                                          NSLog(@"Write max valid value to a range-restricted signed 8-bit integer Error: %@", err);

                                          VerifyOrReturn(CheckValue("status", err, 0));

                                          NextTest();
                                      }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestVerifyRangeRestrictedSigned8BitIntegerValueIsAtMaxValid_403()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeRangeRestrictedInt8sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Verify range-restricted signed 8-bit integer value is at max valid Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("range_restricted_int8s", actualValue, 50));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteMiddleValidValueToARangeRestrictedSigned8BitInteger_404()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id rangeRestrictedInt8sArgument;
        rangeRestrictedInt8sArgument = [NSNumber numberWithChar:6];
        [cluster
            writeAttributeRangeRestrictedInt8sWithValue:rangeRestrictedInt8sArgument
                                      completionHandler:^(NSError * _Nullable err) {
                                          NSLog(@"Write middle valid value to a range-restricted signed 8-bit integer Error: %@",
                                              err);

                                          VerifyOrReturn(CheckValue("status", err, 0));

                                          NextTest();
                                      }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestVerifyRangeRestrictedSigned8BitIntegerValueIsAtMidValid_405()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeRangeRestrictedInt8sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Verify range-restricted signed 8-bit integer value is at mid valid Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("range_restricted_int8s", actualValue, 6));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadRangeRestrictedSigned16BitInteger_406()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeRangeRestrictedInt16sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read range-restricted signed 16-bit integer Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("range_restricted_int16s", actualValue, -100));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteMinValueToARangeRestrictedSigned16BitInteger_407()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id rangeRestrictedInt16sArgument;
        rangeRestrictedInt16sArgument = [NSNumber numberWithShort:-32768];
        [cluster
            writeAttributeRangeRestrictedInt16sWithValue:rangeRestrictedInt16sArgument
                                       completionHandler:^(NSError * _Nullable err) {
                                           NSLog(@"Write min value to a range-restricted signed 16-bit integer Error: %@", err);

                                           VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
                                           NextTest();
                                       }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteJustBelowRangeValueToARangeRestrictedSigned16BitInteger_408()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id rangeRestrictedInt16sArgument;
        rangeRestrictedInt16sArgument = [NSNumber numberWithShort:-151];
        [cluster writeAttributeRangeRestrictedInt16sWithValue:rangeRestrictedInt16sArgument
                                            completionHandler:^(NSError * _Nullable err) {
                                                NSLog(@"Write just-below-range value to a range-restricted signed 16-bit integer "
                                                      @"Error: %@",
                                                    err);

                                                VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
                                                NextTest();
                                            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteJustAboveRangeValueToARangeRestrictedSigned16BitInteger_409()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id rangeRestrictedInt16sArgument;
        rangeRestrictedInt16sArgument = [NSNumber numberWithShort:201];
        [cluster writeAttributeRangeRestrictedInt16sWithValue:rangeRestrictedInt16sArgument
                                            completionHandler:^(NSError * _Nullable err) {
                                                NSLog(@"Write just-above-range value to a range-restricted signed 16-bit integer "
                                                      @"Error: %@",
                                                    err);

                                                VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
                                                NextTest();
                                            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteMaxValueToARangeRestrictedSigned16BitInteger_410()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id rangeRestrictedInt16sArgument;
        rangeRestrictedInt16sArgument = [NSNumber numberWithShort:32767];
        [cluster
            writeAttributeRangeRestrictedInt16sWithValue:rangeRestrictedInt16sArgument
                                       completionHandler:^(NSError * _Nullable err) {
                                           NSLog(@"Write max value to a range-restricted signed 16-bit integer Error: %@", err);

                                           VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
                                           NextTest();
                                       }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestVerifyRangeRestrictedSigned16BitIntegerValueHasNotChanged_411()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeRangeRestrictedInt16sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Verify range-restricted signed 16-bit integer value has not changed Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("range_restricted_int16s", actualValue, -100));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteMinValidValueToARangeRestrictedSigned16BitInteger_412()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id rangeRestrictedInt16sArgument;
        rangeRestrictedInt16sArgument = [NSNumber numberWithShort:-150];
        [cluster
            writeAttributeRangeRestrictedInt16sWithValue:rangeRestrictedInt16sArgument
                                       completionHandler:^(NSError * _Nullable err) {
                                           NSLog(
                                               @"Write min valid value to a range-restricted signed 16-bit integer Error: %@", err);

                                           VerifyOrReturn(CheckValue("status", err, 0));

                                           NextTest();
                                       }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestVerifyRangeRestrictedSigned16BitIntegerValueIsAtMinValid_413()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeRangeRestrictedInt16sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Verify range-restricted signed 16-bit integer value is at min valid Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("range_restricted_int16s", actualValue, -150));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteMaxValidValueToARangeRestrictedSigned16BitInteger_414()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id rangeRestrictedInt16sArgument;
        rangeRestrictedInt16sArgument = [NSNumber numberWithShort:200];
        [cluster
            writeAttributeRangeRestrictedInt16sWithValue:rangeRestrictedInt16sArgument
                                       completionHandler:^(NSError * _Nullable err) {
                                           NSLog(
                                               @"Write max valid value to a range-restricted signed 16-bit integer Error: %@", err);

                                           VerifyOrReturn(CheckValue("status", err, 0));

                                           NextTest();
                                       }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestVerifyRangeRestrictedSigned16BitIntegerValueIsAtMaxValid_415()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeRangeRestrictedInt16sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Verify range-restricted signed 16-bit integer value is at max valid Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("range_restricted_int16s", actualValue, 200));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteMiddleValidValueToARangeRestrictedSigned16BitInteger_416()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id rangeRestrictedInt16sArgument;
        rangeRestrictedInt16sArgument = [NSNumber numberWithShort:7];
        [cluster
            writeAttributeRangeRestrictedInt16sWithValue:rangeRestrictedInt16sArgument
                                       completionHandler:^(NSError * _Nullable err) {
                                           NSLog(@"Write middle valid value to a range-restricted signed 16-bit integer Error: %@",
                                               err);

                                           VerifyOrReturn(CheckValue("status", err, 0));

                                           NextTest();
                                       }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestVerifyRangeRestrictedSigned16BitIntegerValueIsAtMidValid_417()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeRangeRestrictedInt16sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Verify range-restricted signed 16-bit integer value is at mid valid Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("range_restricted_int16s", actualValue, 7));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadNullableRangeRestrictedUnsigned8BitInteger_418()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster
            readAttributeNullableRangeRestrictedInt8uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
                NSLog(@"Read nullable range-restricted unsigned 8-bit integer Error: %@", err);

                VerifyOrReturn(CheckValue("status", err, 0));

                {
                    id actualValue = value;
                    VerifyOrReturn(CheckValueNonNull("nullable_range_restricted_int8u", actualValue));
                    VerifyOrReturn(CheckValue("nullable_range_restricted_int8u", actualValue, 70));
                }

                NextTest();
            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteMinValueToANullableRangeRestrictedUnsigned8BitInteger_419()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableRangeRestrictedInt8uArgument;
        nullableRangeRestrictedInt8uArgument = [NSNumber numberWithUnsignedChar:0];
        [cluster writeAttributeNullableRangeRestrictedInt8uWithValue:nullableRangeRestrictedInt8uArgument
                                                   completionHandler:^(NSError * _Nullable err) {
                                                       NSLog(@"Write min value to a nullable range-restricted unsigned 8-bit "
                                                             @"integer Error: %@",
                                                           err);

                                                       VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
                                                       NextTest();
                                                   }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteJustBelowRangeValueToANullableRangeRestrictedUnsigned8BitInteger_420()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableRangeRestrictedInt8uArgument;
        nullableRangeRestrictedInt8uArgument = [NSNumber numberWithUnsignedChar:19];
        [cluster writeAttributeNullableRangeRestrictedInt8uWithValue:nullableRangeRestrictedInt8uArgument
                                                   completionHandler:^(NSError * _Nullable err) {
                                                       NSLog(@"Write just-below-range value to a nullable range-restricted "
                                                             @"unsigned 8-bit integer Error: %@",
                                                           err);

                                                       VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
                                                       NextTest();
                                                   }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteJustAboveRangeValueToANullableRangeRestrictedUnsigned8BitInteger_421()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableRangeRestrictedInt8uArgument;
        nullableRangeRestrictedInt8uArgument = [NSNumber numberWithUnsignedChar:101];
        [cluster writeAttributeNullableRangeRestrictedInt8uWithValue:nullableRangeRestrictedInt8uArgument
                                                   completionHandler:^(NSError * _Nullable err) {
                                                       NSLog(@"Write just-above-range value to a nullable range-restricted "
                                                             @"unsigned 8-bit integer Error: %@",
                                                           err);

                                                       VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
                                                       NextTest();
                                                   }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteMaxValueToANullableRangeRestrictedUnsigned8BitInteger_422()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableRangeRestrictedInt8uArgument;
        nullableRangeRestrictedInt8uArgument = [NSNumber numberWithUnsignedChar:254];
        [cluster writeAttributeNullableRangeRestrictedInt8uWithValue:nullableRangeRestrictedInt8uArgument
                                                   completionHandler:^(NSError * _Nullable err) {
                                                       NSLog(@"Write max value to a nullable range-restricted unsigned 8-bit "
                                                             @"integer Error: %@",
                                                           err);

                                                       VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
                                                       NextTest();
                                                   }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestVerifyNullableRangeRestrictedUnsigned8BitIntegerValueHasNotChanged_423()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster
            readAttributeNullableRangeRestrictedInt8uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
                NSLog(@"Verify nullable range-restricted unsigned 8-bit integer value has not changed Error: %@", err);

                VerifyOrReturn(CheckValue("status", err, 0));

                {
                    id actualValue = value;
                    VerifyOrReturn(CheckValueNonNull("nullable_range_restricted_int8u", actualValue));
                    VerifyOrReturn(CheckValue("nullable_range_restricted_int8u", actualValue, 70));
                }

                NextTest();
            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteMinValidValueToANullableRangeRestrictedUnsigned8BitInteger_424()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableRangeRestrictedInt8uArgument;
        nullableRangeRestrictedInt8uArgument = [NSNumber numberWithUnsignedChar:20];
        [cluster writeAttributeNullableRangeRestrictedInt8uWithValue:nullableRangeRestrictedInt8uArgument
                                                   completionHandler:^(NSError * _Nullable err) {
                                                       NSLog(@"Write min valid value to a nullable range-restricted unsigned 8-bit "
                                                             @"integer Error: %@",
                                                           err);

                                                       VerifyOrReturn(CheckValue("status", err, 0));

                                                       NextTest();
                                                   }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestVerifyNullableRangeRestrictedUnsigned8BitIntegerValueIsAtMinValid_425()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster
            readAttributeNullableRangeRestrictedInt8uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
                NSLog(@"Verify nullable range-restricted unsigned 8-bit integer value is at min valid Error: %@", err);

                VerifyOrReturn(CheckValue("status", err, 0));

                {
                    id actualValue = value;
                    VerifyOrReturn(CheckValueNonNull("nullable_range_restricted_int8u", actualValue));
                    VerifyOrReturn(CheckValue("nullable_range_restricted_int8u", actualValue, 20));
                }

                NextTest();
            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteMaxValidValueToANullableRangeRestrictedUnsigned8BitInteger_426()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableRangeRestrictedInt8uArgument;
        nullableRangeRestrictedInt8uArgument = [NSNumber numberWithUnsignedChar:100];
        [cluster writeAttributeNullableRangeRestrictedInt8uWithValue:nullableRangeRestrictedInt8uArgument
                                                   completionHandler:^(NSError * _Nullable err) {
                                                       NSLog(@"Write max valid value to a nullable range-restricted unsigned 8-bit "
                                                             @"integer Error: %@",
                                                           err);

                                                       VerifyOrReturn(CheckValue("status", err, 0));

                                                       NextTest();
                                                   }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestVerifyNullableRangeRestrictedUnsigned8BitIntegerValueIsAtMaxValid_427()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster
            readAttributeNullableRangeRestrictedInt8uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
                NSLog(@"Verify nullable range-restricted unsigned 8-bit integer value is at max valid Error: %@", err);

                VerifyOrReturn(CheckValue("status", err, 0));

                {
                    id actualValue = value;
                    VerifyOrReturn(CheckValueNonNull("nullable_range_restricted_int8u", actualValue));
                    VerifyOrReturn(CheckValue("nullable_range_restricted_int8u", actualValue, 100));
                }

                NextTest();
            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteMiddleValidValueToANullableRangeRestrictedUnsigned8BitInteger_428()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableRangeRestrictedInt8uArgument;
        nullableRangeRestrictedInt8uArgument = [NSNumber numberWithUnsignedChar:50];
        [cluster writeAttributeNullableRangeRestrictedInt8uWithValue:nullableRangeRestrictedInt8uArgument
                                                   completionHandler:^(NSError * _Nullable err) {
                                                       NSLog(@"Write middle valid value to a nullable range-restricted unsigned "
                                                             @"8-bit integer Error: %@",
                                                           err);

                                                       VerifyOrReturn(CheckValue("status", err, 0));

                                                       NextTest();
                                                   }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestVerifyNullableRangeRestrictedUnsigned8BitIntegerValueIsAtMidValid_429()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster
            readAttributeNullableRangeRestrictedInt8uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
                NSLog(@"Verify nullable range-restricted unsigned 8-bit integer value is at mid valid Error: %@", err);

                VerifyOrReturn(CheckValue("status", err, 0));

                {
                    id actualValue = value;
                    VerifyOrReturn(CheckValueNonNull("nullable_range_restricted_int8u", actualValue));
                    VerifyOrReturn(CheckValue("nullable_range_restricted_int8u", actualValue, 50));
                }

                NextTest();
            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteNullValueToANullableRangeRestrictedUnsigned8BitInteger_430()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableRangeRestrictedInt8uArgument;
        nullableRangeRestrictedInt8uArgument = nil;
        [cluster writeAttributeNullableRangeRestrictedInt8uWithValue:nullableRangeRestrictedInt8uArgument
                                                   completionHandler:^(NSError * _Nullable err) {
                                                       NSLog(@"Write null value to a nullable range-restricted unsigned 8-bit "
                                                             @"integer Error: %@",
                                                           err);

                                                       VerifyOrReturn(CheckValue("status", err, 0));

                                                       NextTest();
                                                   }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestVerifyNullableRangeRestrictedUnsigned8BitIntegerValueIsNull_431()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster
            readAttributeNullableRangeRestrictedInt8uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
                NSLog(@"Verify nullable range-restricted unsigned 8-bit integer value is null Error: %@", err);

                VerifyOrReturn(CheckValue("status", err, 0));

                {
                    id actualValue = value;
                    VerifyOrReturn(CheckValueNull("nullable_range_restricted_int8u", actualValue));
                }

                NextTest();
            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadNullableRangeRestrictedUnsigned16BitInteger_432()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster
            readAttributeNullableRangeRestrictedInt16uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
                NSLog(@"Read nullable range-restricted unsigned 16-bit integer Error: %@", err);

                VerifyOrReturn(CheckValue("status", err, 0));

                {
                    id actualValue = value;
                    VerifyOrReturn(CheckValueNonNull("nullable_range_restricted_int16u", actualValue));
                    VerifyOrReturn(CheckValue("nullable_range_restricted_int16u", actualValue, 200U));
                }

                NextTest();
            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteMinValueToANullableRangeRestrictedUnsigned16BitInteger_433()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableRangeRestrictedInt16uArgument;
        nullableRangeRestrictedInt16uArgument = [NSNumber numberWithUnsignedShort:0U];
        [cluster
            writeAttributeNullableRangeRestrictedInt16uWithValue:nullableRangeRestrictedInt16uArgument
                                               completionHandler:^(NSError * _Nullable err) {
                                                   NSLog(@"Write min value to a nullable range-restricted unsigned 16-bit integer "
                                                         @"Error: %@",
                                                       err);

                                                   VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
                                                   NextTest();
                                               }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteJustBelowRangeValueToANullableRangeRestrictedUnsigned16BitInteger_434()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableRangeRestrictedInt16uArgument;
        nullableRangeRestrictedInt16uArgument = [NSNumber numberWithUnsignedShort:99U];
        [cluster
            writeAttributeNullableRangeRestrictedInt16uWithValue:nullableRangeRestrictedInt16uArgument
                                               completionHandler:^(NSError * _Nullable err) {
                                                   NSLog(@"Write just-below-range value to a nullable range-restricted unsigned "
                                                         @"16-bit integer Error: %@",
                                                       err);

                                                   VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
                                                   NextTest();
                                               }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteJustAboveRangeValueToANullableRangeRestrictedUnsigned16BitInteger_435()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableRangeRestrictedInt16uArgument;
        nullableRangeRestrictedInt16uArgument = [NSNumber numberWithUnsignedShort:1001U];
        [cluster
            writeAttributeNullableRangeRestrictedInt16uWithValue:nullableRangeRestrictedInt16uArgument
                                               completionHandler:^(NSError * _Nullable err) {
                                                   NSLog(@"Write just-above-range value to a nullable range-restricted unsigned "
                                                         @"16-bit integer Error: %@",
                                                       err);

                                                   VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
                                                   NextTest();
                                               }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteMaxValueToANullableRangeRestrictedUnsigned16BitInteger_436()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableRangeRestrictedInt16uArgument;
        nullableRangeRestrictedInt16uArgument = [NSNumber numberWithUnsignedShort:65534U];
        [cluster
            writeAttributeNullableRangeRestrictedInt16uWithValue:nullableRangeRestrictedInt16uArgument
                                               completionHandler:^(NSError * _Nullable err) {
                                                   NSLog(@"Write max value to a nullable range-restricted unsigned 16-bit integer "
                                                         @"Error: %@",
                                                       err);

                                                   VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
                                                   NextTest();
                                               }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestVerifyNullableRangeRestrictedUnsigned16BitIntegerValueHasNotChanged_437()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster
            readAttributeNullableRangeRestrictedInt16uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
                NSLog(@"Verify nullable range-restricted unsigned 16-bit integer value has not changed Error: %@", err);

                VerifyOrReturn(CheckValue("status", err, 0));

                {
                    id actualValue = value;
                    VerifyOrReturn(CheckValueNonNull("nullable_range_restricted_int16u", actualValue));
                    VerifyOrReturn(CheckValue("nullable_range_restricted_int16u", actualValue, 200U));
                }

                NextTest();
            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteMinValidValueToANullableRangeRestrictedUnsigned16BitInteger_438()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableRangeRestrictedInt16uArgument;
        nullableRangeRestrictedInt16uArgument = [NSNumber numberWithUnsignedShort:100U];
        [cluster writeAttributeNullableRangeRestrictedInt16uWithValue:nullableRangeRestrictedInt16uArgument
                                                    completionHandler:^(NSError * _Nullable err) {
                                                        NSLog(@"Write min valid value to a nullable range-restricted unsigned "
                                                              @"16-bit integer Error: %@",
                                                            err);

                                                        VerifyOrReturn(CheckValue("status", err, 0));

                                                        NextTest();
                                                    }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestVerifyNullableRangeRestrictedUnsigned16BitIntegerValueIsAtMinValid_439()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster
            readAttributeNullableRangeRestrictedInt16uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
                NSLog(@"Verify nullable range-restricted unsigned 16-bit integer value is at min valid Error: %@", err);

                VerifyOrReturn(CheckValue("status", err, 0));

                {
                    id actualValue = value;
                    VerifyOrReturn(CheckValueNonNull("nullable_range_restricted_int16u", actualValue));
                    VerifyOrReturn(CheckValue("nullable_range_restricted_int16u", actualValue, 100U));
                }

                NextTest();
            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteMaxValidValueToANullableRangeRestrictedUnsigned16BitInteger_440()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableRangeRestrictedInt16uArgument;
        nullableRangeRestrictedInt16uArgument = [NSNumber numberWithUnsignedShort:1000U];
        [cluster writeAttributeNullableRangeRestrictedInt16uWithValue:nullableRangeRestrictedInt16uArgument
                                                    completionHandler:^(NSError * _Nullable err) {
                                                        NSLog(@"Write max valid value to a nullable range-restricted unsigned "
                                                              @"16-bit integer Error: %@",
                                                            err);

                                                        VerifyOrReturn(CheckValue("status", err, 0));

                                                        NextTest();
                                                    }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestVerifyNullableRangeRestrictedUnsigned16BitIntegerValueIsAtMaxValid_441()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster
            readAttributeNullableRangeRestrictedInt16uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
                NSLog(@"Verify nullable range-restricted unsigned 16-bit integer value is at max valid Error: %@", err);

                VerifyOrReturn(CheckValue("status", err, 0));

                {
                    id actualValue = value;
                    VerifyOrReturn(CheckValueNonNull("nullable_range_restricted_int16u", actualValue));
                    VerifyOrReturn(CheckValue("nullable_range_restricted_int16u", actualValue, 1000U));
                }

                NextTest();
            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteMiddleValidValueToANullableRangeRestrictedUnsigned16BitInteger_442()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableRangeRestrictedInt16uArgument;
        nullableRangeRestrictedInt16uArgument = [NSNumber numberWithUnsignedShort:500U];
        [cluster writeAttributeNullableRangeRestrictedInt16uWithValue:nullableRangeRestrictedInt16uArgument
                                                    completionHandler:^(NSError * _Nullable err) {
                                                        NSLog(@"Write middle valid value to a nullable range-restricted unsigned "
                                                              @"16-bit integer Error: %@",
                                                            err);

                                                        VerifyOrReturn(CheckValue("status", err, 0));

                                                        NextTest();
                                                    }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestVerifyNullableRangeRestrictedUnsigned16BitIntegerValueIsAtMidValid_443()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster
            readAttributeNullableRangeRestrictedInt16uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
                NSLog(@"Verify nullable range-restricted unsigned 16-bit integer value is at mid valid Error: %@", err);

                VerifyOrReturn(CheckValue("status", err, 0));

                {
                    id actualValue = value;
                    VerifyOrReturn(CheckValueNonNull("nullable_range_restricted_int16u", actualValue));
                    VerifyOrReturn(CheckValue("nullable_range_restricted_int16u", actualValue, 500U));
                }

                NextTest();
            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteNullValueToANullableRangeRestrictedUnsigned16BitInteger_444()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableRangeRestrictedInt16uArgument;
        nullableRangeRestrictedInt16uArgument = nil;
        [cluster writeAttributeNullableRangeRestrictedInt16uWithValue:nullableRangeRestrictedInt16uArgument
                                                    completionHandler:^(NSError * _Nullable err) {
                                                        NSLog(@"Write null value to a nullable range-restricted unsigned 16-bit "
                                                              @"integer Error: %@",
                                                            err);

                                                        VerifyOrReturn(CheckValue("status", err, 0));

                                                        NextTest();
                                                    }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestVerifyNullableRangeRestrictedUnsigned16BitIntegerValueIsNull_445()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster
            readAttributeNullableRangeRestrictedInt16uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
                NSLog(@"Verify nullable range-restricted unsigned 16-bit integer value is null Error: %@", err);

                VerifyOrReturn(CheckValue("status", err, 0));

                {
                    id actualValue = value;
                    VerifyOrReturn(CheckValueNull("nullable_range_restricted_int16u", actualValue));
                }

                NextTest();
            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadNullableRangeRestrictedSigned8BitInteger_446()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster
            readAttributeNullableRangeRestrictedInt8sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
                NSLog(@"Read nullable range-restricted signed 8-bit integer Error: %@", err);

                VerifyOrReturn(CheckValue("status", err, 0));

                {
                    id actualValue = value;
                    VerifyOrReturn(CheckValueNonNull("nullable_range_restricted_int8s", actualValue));
                    VerifyOrReturn(CheckValue("nullable_range_restricted_int8s", actualValue, -20));
                }

                NextTest();
            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteMinValueToANullableRangeRestrictedSigned8BitInteger_447()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableRangeRestrictedInt8sArgument;
        nullableRangeRestrictedInt8sArgument = [NSNumber numberWithChar:-127];
        [cluster writeAttributeNullableRangeRestrictedInt8sWithValue:nullableRangeRestrictedInt8sArgument
                                                   completionHandler:^(NSError * _Nullable err) {
                                                       NSLog(@"Write min value to a nullable range-restricted signed 8-bit integer "
                                                             @"Error: %@",
                                                           err);

                                                       VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
                                                       NextTest();
                                                   }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteJustBelowRangeValueToANullableRangeRestrictedSigned8BitInteger_448()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableRangeRestrictedInt8sArgument;
        nullableRangeRestrictedInt8sArgument = [NSNumber numberWithChar:-41];
        [cluster writeAttributeNullableRangeRestrictedInt8sWithValue:nullableRangeRestrictedInt8sArgument
                                                   completionHandler:^(NSError * _Nullable err) {
                                                       NSLog(@"Write just-below-range value to a nullable range-restricted signed "
                                                             @"8-bit integer Error: %@",
                                                           err);

                                                       VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
                                                       NextTest();
                                                   }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteJustAboveRangeValueToANullableRangeRestrictedSigned8BitInteger_449()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableRangeRestrictedInt8sArgument;
        nullableRangeRestrictedInt8sArgument = [NSNumber numberWithChar:51];
        [cluster writeAttributeNullableRangeRestrictedInt8sWithValue:nullableRangeRestrictedInt8sArgument
                                                   completionHandler:^(NSError * _Nullable err) {
                                                       NSLog(@"Write just-above-range value to a nullable range-restricted signed "
                                                             @"8-bit integer Error: %@",
                                                           err);

                                                       VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
                                                       NextTest();
                                                   }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteMaxValueToANullableRangeRestrictedSigned8BitInteger_450()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableRangeRestrictedInt8sArgument;
        nullableRangeRestrictedInt8sArgument = [NSNumber numberWithChar:127];
        [cluster writeAttributeNullableRangeRestrictedInt8sWithValue:nullableRangeRestrictedInt8sArgument
                                                   completionHandler:^(NSError * _Nullable err) {
                                                       NSLog(@"Write max value to a nullable range-restricted signed 8-bit integer "
                                                             @"Error: %@",
                                                           err);

                                                       VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
                                                       NextTest();
                                                   }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestVerifyNullableRangeRestrictedSigned8BitIntegerValueHasNotChanged_451()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster
            readAttributeNullableRangeRestrictedInt8sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
                NSLog(@"Verify nullable range-restricted signed 8-bit integer value has not changed Error: %@", err);

                VerifyOrReturn(CheckValue("status", err, 0));

                {
                    id actualValue = value;
                    VerifyOrReturn(CheckValueNonNull("nullable_range_restricted_int8s", actualValue));
                    VerifyOrReturn(CheckValue("nullable_range_restricted_int8s", actualValue, -20));
                }

                NextTest();
            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteMinValidValueToANullableRangeRestrictedSigned8BitInteger_452()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableRangeRestrictedInt8sArgument;
        nullableRangeRestrictedInt8sArgument = [NSNumber numberWithChar:-40];
        [cluster writeAttributeNullableRangeRestrictedInt8sWithValue:nullableRangeRestrictedInt8sArgument
                                                   completionHandler:^(NSError * _Nullable err) {
                                                       NSLog(@"Write min valid value to a nullable range-restricted signed 8-bit "
                                                             @"integer Error: %@",
                                                           err);

                                                       VerifyOrReturn(CheckValue("status", err, 0));

                                                       NextTest();
                                                   }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestVerifyNullableRangeRestrictedSigned8BitIntegerValueIsAtMinValid_453()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster
            readAttributeNullableRangeRestrictedInt8sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
                NSLog(@"Verify nullable range-restricted signed 8-bit integer value is at min valid Error: %@", err);

                VerifyOrReturn(CheckValue("status", err, 0));

                {
                    id actualValue = value;
                    VerifyOrReturn(CheckValueNonNull("nullable_range_restricted_int8s", actualValue));
                    VerifyOrReturn(CheckValue("nullable_range_restricted_int8s", actualValue, -40));
                }

                NextTest();
            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteMaxValidValueToANullableRangeRestrictedSigned8BitInteger_454()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableRangeRestrictedInt8sArgument;
        nullableRangeRestrictedInt8sArgument = [NSNumber numberWithChar:50];
        [cluster writeAttributeNullableRangeRestrictedInt8sWithValue:nullableRangeRestrictedInt8sArgument
                                                   completionHandler:^(NSError * _Nullable err) {
                                                       NSLog(@"Write max valid value to a nullable range-restricted signed 8-bit "
                                                             @"integer Error: %@",
                                                           err);

                                                       VerifyOrReturn(CheckValue("status", err, 0));

                                                       NextTest();
                                                   }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestVerifyNullableRangeRestrictedSigned8BitIntegerValueIsAtMaxValid_455()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster
            readAttributeNullableRangeRestrictedInt8sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
                NSLog(@"Verify nullable range-restricted signed 8-bit integer value is at max valid Error: %@", err);

                VerifyOrReturn(CheckValue("status", err, 0));

                {
                    id actualValue = value;
                    VerifyOrReturn(CheckValueNonNull("nullable_range_restricted_int8s", actualValue));
                    VerifyOrReturn(CheckValue("nullable_range_restricted_int8s", actualValue, 50));
                }

                NextTest();
            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteMiddleValidValueToANullableRangeRestrictedSigned8BitInteger_456()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableRangeRestrictedInt8sArgument;
        nullableRangeRestrictedInt8sArgument = [NSNumber numberWithChar:6];
        [cluster writeAttributeNullableRangeRestrictedInt8sWithValue:nullableRangeRestrictedInt8sArgument
                                                   completionHandler:^(NSError * _Nullable err) {
                                                       NSLog(@"Write middle valid value to a nullable range-restricted signed "
                                                             @"8-bit integer Error: %@",
                                                           err);

                                                       VerifyOrReturn(CheckValue("status", err, 0));

                                                       NextTest();
                                                   }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestVerifyNullableRangeRestrictedSigned8BitIntegerValueIsAtMidValid_457()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster
            readAttributeNullableRangeRestrictedInt8sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
                NSLog(@"Verify nullable range-restricted signed 8-bit integer value is at mid valid Error: %@", err);

                VerifyOrReturn(CheckValue("status", err, 0));

                {
                    id actualValue = value;
                    VerifyOrReturn(CheckValueNonNull("nullable_range_restricted_int8s", actualValue));
                    VerifyOrReturn(CheckValue("nullable_range_restricted_int8s", actualValue, 6));
                }

                NextTest();
            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteNullValueToANullableRangeRestrictedSigned8BitInteger_458()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableRangeRestrictedInt8sArgument;
        nullableRangeRestrictedInt8sArgument = nil;
        [cluster writeAttributeNullableRangeRestrictedInt8sWithValue:nullableRangeRestrictedInt8sArgument
                                                   completionHandler:^(NSError * _Nullable err) {
                                                       NSLog(@"Write null value to a nullable range-restricted signed 8-bit "
                                                             @"integer Error: %@",
                                                           err);

                                                       VerifyOrReturn(CheckValue("status", err, 0));

                                                       NextTest();
                                                   }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestVerifyNullableRangeRestrictedSigned8BitIntegerValueIsAtNull_459()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster
            readAttributeNullableRangeRestrictedInt8sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
                NSLog(@"Verify nullable range-restricted signed 8-bit integer value is at null Error: %@", err);

                VerifyOrReturn(CheckValue("status", err, 0));

                {
                    id actualValue = value;
                    VerifyOrReturn(CheckValueNull("nullable_range_restricted_int8s", actualValue));
                }

                NextTest();
            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadNullableRangeRestrictedSigned16BitInteger_460()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster
            readAttributeNullableRangeRestrictedInt16sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
                NSLog(@"Read nullable range-restricted signed 16-bit integer Error: %@", err);

                VerifyOrReturn(CheckValue("status", err, 0));

                {
                    id actualValue = value;
                    VerifyOrReturn(CheckValueNonNull("nullable_range_restricted_int16s", actualValue));
                    VerifyOrReturn(CheckValue("nullable_range_restricted_int16s", actualValue, -100));
                }

                NextTest();
            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteMinValueToANullableRangeRestrictedSigned16BitInteger_461()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableRangeRestrictedInt16sArgument;
        nullableRangeRestrictedInt16sArgument = [NSNumber numberWithShort:-32767];
        [cluster
            writeAttributeNullableRangeRestrictedInt16sWithValue:nullableRangeRestrictedInt16sArgument
                                               completionHandler:^(NSError * _Nullable err) {
                                                   NSLog(@"Write min value to a nullable range-restricted signed 16-bit integer "
                                                         @"Error: %@",
                                                       err);

                                                   VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
                                                   NextTest();
                                               }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteJustBelowRangeValueToANullableRangeRestrictedSigned16BitInteger_462()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableRangeRestrictedInt16sArgument;
        nullableRangeRestrictedInt16sArgument = [NSNumber numberWithShort:-151];
        [cluster
            writeAttributeNullableRangeRestrictedInt16sWithValue:nullableRangeRestrictedInt16sArgument
                                               completionHandler:^(NSError * _Nullable err) {
                                                   NSLog(@"Write just-below-range value to a nullable range-restricted signed "
                                                         @"16-bit integer Error: %@",
                                                       err);

                                                   VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
                                                   NextTest();
                                               }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteJustAboveRangeValueToANullableRangeRestrictedSigned16BitInteger_463()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableRangeRestrictedInt16sArgument;
        nullableRangeRestrictedInt16sArgument = [NSNumber numberWithShort:201];
        [cluster
            writeAttributeNullableRangeRestrictedInt16sWithValue:nullableRangeRestrictedInt16sArgument
                                               completionHandler:^(NSError * _Nullable err) {
                                                   NSLog(@"Write just-above-range value to a nullable range-restricted signed "
                                                         @"16-bit integer Error: %@",
                                                       err);

                                                   VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
                                                   NextTest();
                                               }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteMaxValueToANullableRangeRestrictedSigned16BitInteger_464()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableRangeRestrictedInt16sArgument;
        nullableRangeRestrictedInt16sArgument = [NSNumber numberWithShort:32767];
        [cluster
            writeAttributeNullableRangeRestrictedInt16sWithValue:nullableRangeRestrictedInt16sArgument
                                               completionHandler:^(NSError * _Nullable err) {
                                                   NSLog(@"Write max value to a nullable range-restricted signed 16-bit integer "
                                                         @"Error: %@",
                                                       err);

                                                   VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
                                                   NextTest();
                                               }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestVerifyNullableRangeRestrictedSigned16BitIntegerValueHasNotChanged_465()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster
            readAttributeNullableRangeRestrictedInt16sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
                NSLog(@"Verify nullable range-restricted signed 16-bit integer value has not changed Error: %@", err);

                VerifyOrReturn(CheckValue("status", err, 0));

                {
                    id actualValue = value;
                    VerifyOrReturn(CheckValueNonNull("nullable_range_restricted_int16s", actualValue));
                    VerifyOrReturn(CheckValue("nullable_range_restricted_int16s", actualValue, -100));
                }

                NextTest();
            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteMinValidValueToANullableRangeRestrictedSigned16BitInteger_466()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableRangeRestrictedInt16sArgument;
        nullableRangeRestrictedInt16sArgument = [NSNumber numberWithShort:-150];
        [cluster writeAttributeNullableRangeRestrictedInt16sWithValue:nullableRangeRestrictedInt16sArgument
                                                    completionHandler:^(NSError * _Nullable err) {
                                                        NSLog(@"Write min valid value to a nullable range-restricted signed 16-bit "
                                                              @"integer Error: %@",
                                                            err);

                                                        VerifyOrReturn(CheckValue("status", err, 0));

                                                        NextTest();
                                                    }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestVerifyNullableRangeRestrictedSigned16BitIntegerValueIsAtMinValid_467()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster
            readAttributeNullableRangeRestrictedInt16sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
                NSLog(@"Verify nullable range-restricted signed 16-bit integer value is at min valid Error: %@", err);

                VerifyOrReturn(CheckValue("status", err, 0));

                {
                    id actualValue = value;
                    VerifyOrReturn(CheckValueNonNull("nullable_range_restricted_int16s", actualValue));
                    VerifyOrReturn(CheckValue("nullable_range_restricted_int16s", actualValue, -150));
                }

                NextTest();
            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteMaxValidValueToANullableRangeRestrictedSigned16BitInteger_468()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableRangeRestrictedInt16sArgument;
        nullableRangeRestrictedInt16sArgument = [NSNumber numberWithShort:200];
        [cluster writeAttributeNullableRangeRestrictedInt16sWithValue:nullableRangeRestrictedInt16sArgument
                                                    completionHandler:^(NSError * _Nullable err) {
                                                        NSLog(@"Write max valid value to a nullable range-restricted signed 16-bit "
                                                              @"integer Error: %@",
                                                            err);

                                                        VerifyOrReturn(CheckValue("status", err, 0));

                                                        NextTest();
                                                    }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestVerifyNullableRangeRestrictedSigned16BitIntegerValueIsAtMaxValid_469()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster
            readAttributeNullableRangeRestrictedInt16sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
                NSLog(@"Verify nullable range-restricted signed 16-bit integer value is at max valid Error: %@", err);

                VerifyOrReturn(CheckValue("status", err, 0));

                {
                    id actualValue = value;
                    VerifyOrReturn(CheckValueNonNull("nullable_range_restricted_int16s", actualValue));
                    VerifyOrReturn(CheckValue("nullable_range_restricted_int16s", actualValue, 200));
                }

                NextTest();
            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteMiddleValidValueToANullableRangeRestrictedSigned16BitInteger_470()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableRangeRestrictedInt16sArgument;
        nullableRangeRestrictedInt16sArgument = [NSNumber numberWithShort:7];
        [cluster writeAttributeNullableRangeRestrictedInt16sWithValue:nullableRangeRestrictedInt16sArgument
                                                    completionHandler:^(NSError * _Nullable err) {
                                                        NSLog(@"Write middle valid value to a nullable range-restricted signed "
                                                              @"16-bit integer Error: %@",
                                                            err);

                                                        VerifyOrReturn(CheckValue("status", err, 0));

                                                        NextTest();
                                                    }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestVerifyNullableRangeRestrictedSigned16BitIntegerValueIsAtMidValid_471()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster
            readAttributeNullableRangeRestrictedInt16sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
                NSLog(@"Verify nullable range-restricted signed 16-bit integer value is at mid valid Error: %@", err);

                VerifyOrReturn(CheckValue("status", err, 0));

                {
                    id actualValue = value;
                    VerifyOrReturn(CheckValueNonNull("nullable_range_restricted_int16s", actualValue));
                    VerifyOrReturn(CheckValue("nullable_range_restricted_int16s", actualValue, 7));
                }

                NextTest();
            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteNullValueToANullableRangeRestrictedSigned16BitInteger_472()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id nullableRangeRestrictedInt16sArgument;
        nullableRangeRestrictedInt16sArgument = nil;
        [cluster writeAttributeNullableRangeRestrictedInt16sWithValue:nullableRangeRestrictedInt16sArgument
                                                    completionHandler:^(NSError * _Nullable err) {
                                                        NSLog(@"Write null value to a nullable range-restricted signed 16-bit "
                                                              @"integer Error: %@",
                                                            err);

                                                        VerifyOrReturn(CheckValue("status", err, 0));

                                                        NextTest();
                                                    }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestVerifyNullableRangeRestrictedSigned16BitIntegerValueIsNull_473()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster
            readAttributeNullableRangeRestrictedInt16sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
                NSLog(@"Verify nullable range-restricted signed 16-bit integer value is null Error: %@", err);

                VerifyOrReturn(CheckValue("status", err, 0));

                {
                    id actualValue = value;
                    VerifyOrReturn(CheckValueNull("nullable_range_restricted_int16s", actualValue));
                }

                NextTest();
            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeThatReturnsGeneralStatusOnWrite_474()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id generalErrorBooleanArgument;
        generalErrorBooleanArgument = [NSNumber numberWithBool:false];
        [cluster writeAttributeGeneralErrorBooleanWithValue:generalErrorBooleanArgument
                                          completionHandler:^(NSError * _Nullable err) {
                                              NSLog(@"Write attribute that returns general status on write Error: %@", err);

                                              VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_INVALID_DATA_TYPE));
                                              NextTest();
                                          }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeThatReturnsClusterSpecificStatusOnWrite_475()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id clusterErrorBooleanArgument;
        clusterErrorBooleanArgument = [NSNumber numberWithBool:false];
        [cluster
            writeAttributeClusterErrorBooleanWithValue:clusterErrorBooleanArgument
                                     completionHandler:^(NSError * _Nullable err) {
                                         NSLog(@"Write attribute that returns cluster-specific status on write Error: %@", err);

                                         VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_FAILURE));
                                         NextTest();
                                     }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeThatReturnsGeneralStatusOnRead_476()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeGeneralErrorBooleanWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute that returns general status on read Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_INVALID_DATA_TYPE));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeThatReturnsClusterSpecificStatusOnRead_477()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeClusterErrorBooleanWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read attribute that returns cluster-specific status on read Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_FAILURE));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAcceptedCommandListAttribute_478()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeAcceptedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read AcceptedCommandList attribute Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("AcceptedCommandList", [actualValue count], static_cast<uint32_t>(18)));
                VerifyOrReturn(CheckValue("", actualValue[0], 0UL));
                VerifyOrReturn(CheckValue("", actualValue[1], 1UL));
                VerifyOrReturn(CheckValue("", actualValue[2], 2UL));
                VerifyOrReturn(CheckValue("", actualValue[3], 4UL));
                VerifyOrReturn(CheckValue("", actualValue[4], 7UL));
                VerifyOrReturn(CheckValue("", actualValue[5], 8UL));
                VerifyOrReturn(CheckValue("", actualValue[6], 9UL));
                VerifyOrReturn(CheckValue("", actualValue[7], 10UL));
                VerifyOrReturn(CheckValue("", actualValue[8], 11UL));
                VerifyOrReturn(CheckValue("", actualValue[9], 12UL));
                VerifyOrReturn(CheckValue("", actualValue[10], 13UL));
                VerifyOrReturn(CheckValue("", actualValue[11], 14UL));
                VerifyOrReturn(CheckValue("", actualValue[12], 15UL));
                VerifyOrReturn(CheckValue("", actualValue[13], 17UL));
                VerifyOrReturn(CheckValue("", actualValue[14], 18UL));
                VerifyOrReturn(CheckValue("", actualValue[15], 19UL));
                VerifyOrReturn(CheckValue("", actualValue[16], 20UL));
                VerifyOrReturn(CheckValue("", actualValue[17], 21UL));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadGeneratedCommandListAttribute_479()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable err) {
            NSLog(@"read GeneratedCommandList attribute Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("GeneratedCommandList", [actualValue count], static_cast<uint32_t>(8)));
                VerifyOrReturn(CheckValue("", actualValue[0], 0UL));
                VerifyOrReturn(CheckValue("", actualValue[1], 1UL));
                VerifyOrReturn(CheckValue("", actualValue[2], 4UL));
                VerifyOrReturn(CheckValue("", actualValue[3], 5UL));
                VerifyOrReturn(CheckValue("", actualValue[4], 6UL));
                VerifyOrReturn(CheckValue("", actualValue[5], 9UL));
                VerifyOrReturn(CheckValue("", actualValue[6], 10UL));
                VerifyOrReturn(CheckValue("", actualValue[7], 11UL));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteStructTypedAttribute_480()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id structAttrArgument;
        structAttrArgument = [[CHIPTestClusterClusterSimpleStruct alloc] init];
        ((CHIPTestClusterClusterSimpleStruct *) structAttrArgument).a = [NSNumber numberWithUnsignedChar:5];
        ((CHIPTestClusterClusterSimpleStruct *) structAttrArgument).b = [NSNumber numberWithBool:true];
        ((CHIPTestClusterClusterSimpleStruct *) structAttrArgument).c = [NSNumber numberWithUnsignedChar:2];
        ((CHIPTestClusterClusterSimpleStruct *) structAttrArgument).d = [[NSData alloc] initWithBytes:"abc" length:3];
        ((CHIPTestClusterClusterSimpleStruct *) structAttrArgument).e = @"";
        ((CHIPTestClusterClusterSimpleStruct *) structAttrArgument).f = [NSNumber numberWithUnsignedChar:17];
        ((CHIPTestClusterClusterSimpleStruct *) structAttrArgument).g = [NSNumber numberWithFloat:1.5f];
        ((CHIPTestClusterClusterSimpleStruct *) structAttrArgument).h = [NSNumber numberWithDouble:3.14159265358979];

        [cluster writeAttributeStructAttrWithValue:structAttrArgument
                                 completionHandler:^(NSError * _Nullable err) {
                                     NSLog(@"Write struct-typed attribute Error: %@", err);

                                     VerifyOrReturn(CheckValue("status", err, 0));

                                     NextTest();
                                 }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadStructTypedAttribute_481()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeStructAttrWithCompletionHandler:^(
            CHIPTestClusterClusterSimpleStruct * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read struct-typed attribute Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("a", ((CHIPTestClusterClusterSimpleStruct *) actualValue).a, 5));
                VerifyOrReturn(CheckValue("b", ((CHIPTestClusterClusterSimpleStruct *) actualValue).b, true));
                VerifyOrReturn(CheckValue("c", ((CHIPTestClusterClusterSimpleStruct *) actualValue).c, 2));
                VerifyOrReturn(CheckValueAsString(
                    "d", ((CHIPTestClusterClusterSimpleStruct *) actualValue).d, [[NSData alloc] initWithBytes:"abc" length:3]));
                VerifyOrReturn(CheckValueAsString("e", ((CHIPTestClusterClusterSimpleStruct *) actualValue).e, @""));
                VerifyOrReturn(CheckValue("f", ((CHIPTestClusterClusterSimpleStruct *) actualValue).f, 17));
                VerifyOrReturn(CheckValue("g", ((CHIPTestClusterClusterSimpleStruct *) actualValue).g, 1.5f));
                VerifyOrReturn(CheckValue("h", ((CHIPTestClusterClusterSimpleStruct *) actualValue).h, 3.14159265358979));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
};

class TestSaveAs : public TestCommandBridge {
public:
    TestSaveAs()
        : TestCommandBridge("TestSaveAs")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~TestSaveAs() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: TestSaveAs\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: TestSaveAs\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Send Test Add Arguments Command\n");
            err = TestSendTestAddArgumentsCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Send Test Add Arguments Command\n");
            err = TestSendTestAddArgumentsCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Send Test Add Arguments Command\n");
            err = TestSendTestAddArgumentsCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Read attribute BOOLEAN Default Value\n");
            err = TestReadAttributeBooleanDefaultValue_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Write attribute BOOLEAN Not Default Value\n");
            err = TestWriteAttributeBooleanNotDefaultValue_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Read attribute BOOLEAN Not Default Value\n");
            err = TestReadAttributeBooleanNotDefaultValue_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Write attribute BOOLEAN DefaultValue\n");
            err = TestWriteAttributeBooleanDefaultValue_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Read attribute BOOLEAN False\n");
            err = TestReadAttributeBooleanFalse_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Read attribute BITMAP8 Default Value\n");
            err = TestReadAttributeBitmap8DefaultValue_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Write attribute BITMAP8 Not Default Value\n");
            err = TestWriteAttributeBitmap8NotDefaultValue_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : Read attribute BITMAP8 Not Default Value\n");
            err = TestReadAttributeBitmap8NotDefaultValue_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : Write attribute BITMAP8 Default Value\n");
            err = TestWriteAttributeBitmap8DefaultValue_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : Read attribute BITMAP8 Default Value\n");
            err = TestReadAttributeBitmap8DefaultValue_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : Read attribute BITMAP16 Default Value\n");
            err = TestReadAttributeBitmap16DefaultValue_14();
            break;
        case 15:
            ChipLogProgress(chipTool, " ***** Test Step 15 : Write attribute BITMAP16 Not Default Value\n");
            err = TestWriteAttributeBitmap16NotDefaultValue_15();
            break;
        case 16:
            ChipLogProgress(chipTool, " ***** Test Step 16 : Read attribute BITMAP16 Not Default Value\n");
            err = TestReadAttributeBitmap16NotDefaultValue_16();
            break;
        case 17:
            ChipLogProgress(chipTool, " ***** Test Step 17 : Write attribute BITMAP16 Default Value\n");
            err = TestWriteAttributeBitmap16DefaultValue_17();
            break;
        case 18:
            ChipLogProgress(chipTool, " ***** Test Step 18 : Read attribute BITMAP16 Default Value\n");
            err = TestReadAttributeBitmap16DefaultValue_18();
            break;
        case 19:
            ChipLogProgress(chipTool, " ***** Test Step 19 : Read attribute BITMAP32 Default Value\n");
            err = TestReadAttributeBitmap32DefaultValue_19();
            break;
        case 20:
            ChipLogProgress(chipTool, " ***** Test Step 20 : Write attribute BITMAP32 Not Default Value\n");
            err = TestWriteAttributeBitmap32NotDefaultValue_20();
            break;
        case 21:
            ChipLogProgress(chipTool, " ***** Test Step 21 : Read attribute BITMAP32 Not Default Value\n");
            err = TestReadAttributeBitmap32NotDefaultValue_21();
            break;
        case 22:
            ChipLogProgress(chipTool, " ***** Test Step 22 : Write attribute BITMAP32 Default Value\n");
            err = TestWriteAttributeBitmap32DefaultValue_22();
            break;
        case 23:
            ChipLogProgress(chipTool, " ***** Test Step 23 : Read attribute BITMAP32 Default Value\n");
            err = TestReadAttributeBitmap32DefaultValue_23();
            break;
        case 24:
            ChipLogProgress(chipTool, " ***** Test Step 24 : Read attribute BITMAP64 Default Value\n");
            err = TestReadAttributeBitmap64DefaultValue_24();
            break;
        case 25:
            ChipLogProgress(chipTool, " ***** Test Step 25 : Write attribute BITMAP64 Not Default Value\n");
            err = TestWriteAttributeBitmap64NotDefaultValue_25();
            break;
        case 26:
            ChipLogProgress(chipTool, " ***** Test Step 26 : Read attribute BITMAP64 Default Value\n");
            err = TestReadAttributeBitmap64DefaultValue_26();
            break;
        case 27:
            ChipLogProgress(chipTool, " ***** Test Step 27 : Write attribute BITMAP64 Default Value\n");
            err = TestWriteAttributeBitmap64DefaultValue_27();
            break;
        case 28:
            ChipLogProgress(chipTool, " ***** Test Step 28 : Read attribute BITMAP64 Default Value\n");
            err = TestReadAttributeBitmap64DefaultValue_28();
            break;
        case 29:
            ChipLogProgress(chipTool, " ***** Test Step 29 : Read attribute INT8U Default Value\n");
            err = TestReadAttributeInt8uDefaultValue_29();
            break;
        case 30:
            ChipLogProgress(chipTool, " ***** Test Step 30 : Write attribute INT8U Not Default Value\n");
            err = TestWriteAttributeInt8uNotDefaultValue_30();
            break;
        case 31:
            ChipLogProgress(chipTool, " ***** Test Step 31 : Read attribute INT8U Not Default Value\n");
            err = TestReadAttributeInt8uNotDefaultValue_31();
            break;
        case 32:
            ChipLogProgress(chipTool, " ***** Test Step 32 : Write attribute INT8U Default Value\n");
            err = TestWriteAttributeInt8uDefaultValue_32();
            break;
        case 33:
            ChipLogProgress(chipTool, " ***** Test Step 33 : Read attribute INT8U Default Value\n");
            err = TestReadAttributeInt8uDefaultValue_33();
            break;
        case 34:
            ChipLogProgress(chipTool, " ***** Test Step 34 : Read attribute INT16U Default Value\n");
            err = TestReadAttributeInt16uDefaultValue_34();
            break;
        case 35:
            ChipLogProgress(chipTool, " ***** Test Step 35 : Write attribute INT16U Not Default Value\n");
            err = TestWriteAttributeInt16uNotDefaultValue_35();
            break;
        case 36:
            ChipLogProgress(chipTool, " ***** Test Step 36 : Read attribute INT16U Not Default Value\n");
            err = TestReadAttributeInt16uNotDefaultValue_36();
            break;
        case 37:
            ChipLogProgress(chipTool, " ***** Test Step 37 : Write attribute INT16U Default Value\n");
            err = TestWriteAttributeInt16uDefaultValue_37();
            break;
        case 38:
            ChipLogProgress(chipTool, " ***** Test Step 38 : Read attribute INT16U Default Value\n");
            err = TestReadAttributeInt16uDefaultValue_38();
            break;
        case 39:
            ChipLogProgress(chipTool, " ***** Test Step 39 : Read attribute INT32U Default Value\n");
            err = TestReadAttributeInt32uDefaultValue_39();
            break;
        case 40:
            ChipLogProgress(chipTool, " ***** Test Step 40 : Write attribute INT32U Not Default Value\n");
            err = TestWriteAttributeInt32uNotDefaultValue_40();
            break;
        case 41:
            ChipLogProgress(chipTool, " ***** Test Step 41 : Read attribute INT32U Not Default Value\n");
            err = TestReadAttributeInt32uNotDefaultValue_41();
            break;
        case 42:
            ChipLogProgress(chipTool, " ***** Test Step 42 : Write attribute INT32U Default Value\n");
            err = TestWriteAttributeInt32uDefaultValue_42();
            break;
        case 43:
            ChipLogProgress(chipTool, " ***** Test Step 43 : Read attribute INT32U Default Value\n");
            err = TestReadAttributeInt32uDefaultValue_43();
            break;
        case 44:
            ChipLogProgress(chipTool, " ***** Test Step 44 : Read attribute INT64U Default Value\n");
            err = TestReadAttributeInt64uDefaultValue_44();
            break;
        case 45:
            ChipLogProgress(chipTool, " ***** Test Step 45 : Write attribute INT64U Not Default Value\n");
            err = TestWriteAttributeInt64uNotDefaultValue_45();
            break;
        case 46:
            ChipLogProgress(chipTool, " ***** Test Step 46 : Read attribute INT64U Not Default Value\n");
            err = TestReadAttributeInt64uNotDefaultValue_46();
            break;
        case 47:
            ChipLogProgress(chipTool, " ***** Test Step 47 : Write attribute INT64U Default Value\n");
            err = TestWriteAttributeInt64uDefaultValue_47();
            break;
        case 48:
            ChipLogProgress(chipTool, " ***** Test Step 48 : Read attribute INT64U Default Value\n");
            err = TestReadAttributeInt64uDefaultValue_48();
            break;
        case 49:
            ChipLogProgress(chipTool, " ***** Test Step 49 : Read attribute INT8S Default Value\n");
            err = TestReadAttributeInt8sDefaultValue_49();
            break;
        case 50:
            ChipLogProgress(chipTool, " ***** Test Step 50 : Write attribute INT8S Not Default Value\n");
            err = TestWriteAttributeInt8sNotDefaultValue_50();
            break;
        case 51:
            ChipLogProgress(chipTool, " ***** Test Step 51 : Read attribute INT8S Not Default Value\n");
            err = TestReadAttributeInt8sNotDefaultValue_51();
            break;
        case 52:
            ChipLogProgress(chipTool, " ***** Test Step 52 : Write attribute INT8S Default Value\n");
            err = TestWriteAttributeInt8sDefaultValue_52();
            break;
        case 53:
            ChipLogProgress(chipTool, " ***** Test Step 53 : Read attribute INT8S Default Value\n");
            err = TestReadAttributeInt8sDefaultValue_53();
            break;
        case 54:
            ChipLogProgress(chipTool, " ***** Test Step 54 : Read attribute INT16S Default Value\n");
            err = TestReadAttributeInt16sDefaultValue_54();
            break;
        case 55:
            ChipLogProgress(chipTool, " ***** Test Step 55 : Write attribute INT16S Not Default Value\n");
            err = TestWriteAttributeInt16sNotDefaultValue_55();
            break;
        case 56:
            ChipLogProgress(chipTool, " ***** Test Step 56 : Read attribute INT16S Not Default Value\n");
            err = TestReadAttributeInt16sNotDefaultValue_56();
            break;
        case 57:
            ChipLogProgress(chipTool, " ***** Test Step 57 : Write attribute INT16S Default Value\n");
            err = TestWriteAttributeInt16sDefaultValue_57();
            break;
        case 58:
            ChipLogProgress(chipTool, " ***** Test Step 58 : Read attribute INT16S Default Value\n");
            err = TestReadAttributeInt16sDefaultValue_58();
            break;
        case 59:
            ChipLogProgress(chipTool, " ***** Test Step 59 : Read attribute INT32S Default Value\n");
            err = TestReadAttributeInt32sDefaultValue_59();
            break;
        case 60:
            ChipLogProgress(chipTool, " ***** Test Step 60 : Write attribute INT32S Not Default Value\n");
            err = TestWriteAttributeInt32sNotDefaultValue_60();
            break;
        case 61:
            ChipLogProgress(chipTool, " ***** Test Step 61 : Read attribute INT32S Not Default Value\n");
            err = TestReadAttributeInt32sNotDefaultValue_61();
            break;
        case 62:
            ChipLogProgress(chipTool, " ***** Test Step 62 : Write attribute INT32S Default Value\n");
            err = TestWriteAttributeInt32sDefaultValue_62();
            break;
        case 63:
            ChipLogProgress(chipTool, " ***** Test Step 63 : Read attribute INT32S Default Value\n");
            err = TestReadAttributeInt32sDefaultValue_63();
            break;
        case 64:
            ChipLogProgress(chipTool, " ***** Test Step 64 : Read attribute INT64S Default Value\n");
            err = TestReadAttributeInt64sDefaultValue_64();
            break;
        case 65:
            ChipLogProgress(chipTool, " ***** Test Step 65 : Write attribute INTS Not Default Value\n");
            err = TestWriteAttributeIntsNotDefaultValue_65();
            break;
        case 66:
            ChipLogProgress(chipTool, " ***** Test Step 66 : Read attribute INT64S Not Default Value\n");
            err = TestReadAttributeInt64sNotDefaultValue_66();
            break;
        case 67:
            ChipLogProgress(chipTool, " ***** Test Step 67 : Write attribute INT64S Default Value\n");
            err = TestWriteAttributeInt64sDefaultValue_67();
            break;
        case 68:
            ChipLogProgress(chipTool, " ***** Test Step 68 : Read attribute INT64S Default Value\n");
            err = TestReadAttributeInt64sDefaultValue_68();
            break;
        case 69:
            ChipLogProgress(chipTool, " ***** Test Step 69 : Read attribute ENUM8 Default Value\n");
            err = TestReadAttributeEnum8DefaultValue_69();
            break;
        case 70:
            ChipLogProgress(chipTool, " ***** Test Step 70 : Write attribute ENUM8 Not Default Value\n");
            err = TestWriteAttributeEnum8NotDefaultValue_70();
            break;
        case 71:
            ChipLogProgress(chipTool, " ***** Test Step 71 : Read attribute ENUM8 Not Default Value\n");
            err = TestReadAttributeEnum8NotDefaultValue_71();
            break;
        case 72:
            ChipLogProgress(chipTool, " ***** Test Step 72 : Write attribute ENUM8 Default Value\n");
            err = TestWriteAttributeEnum8DefaultValue_72();
            break;
        case 73:
            ChipLogProgress(chipTool, " ***** Test Step 73 : Read attribute ENUM8 Default Value\n");
            err = TestReadAttributeEnum8DefaultValue_73();
            break;
        case 74:
            ChipLogProgress(chipTool, " ***** Test Step 74 : Read attribute ENUM16 Default Value\n");
            err = TestReadAttributeEnum16DefaultValue_74();
            break;
        case 75:
            ChipLogProgress(chipTool, " ***** Test Step 75 : Write attribute ENUM16 Not Default Value\n");
            err = TestWriteAttributeEnum16NotDefaultValue_75();
            break;
        case 76:
            ChipLogProgress(chipTool, " ***** Test Step 76 : Read attribute ENUM16 Not Default Value\n");
            err = TestReadAttributeEnum16NotDefaultValue_76();
            break;
        case 77:
            ChipLogProgress(chipTool, " ***** Test Step 77 : Write attribute ENUM16 Default Value\n");
            err = TestWriteAttributeEnum16DefaultValue_77();
            break;
        case 78:
            ChipLogProgress(chipTool, " ***** Test Step 78 : Read attribute ENUM16 Default Value\n");
            err = TestReadAttributeEnum16DefaultValue_78();
            break;
        case 79:
            ChipLogProgress(chipTool, " ***** Test Step 79 : Read attribute EPOCH_US Default Value\n");
            err = TestReadAttributeEpochUsDefaultValue_79();
            break;
        case 80:
            ChipLogProgress(chipTool, " ***** Test Step 80 : Write attribute EPOCH_US Not Default Value\n");
            err = TestWriteAttributeEpochUsNotDefaultValue_80();
            break;
        case 81:
            ChipLogProgress(chipTool, " ***** Test Step 81 : Read attribute EPOCH_US Not Default Value\n");
            err = TestReadAttributeEpochUsNotDefaultValue_81();
            break;
        case 82:
            ChipLogProgress(chipTool, " ***** Test Step 82 : Write attribute EPOCH_US Default Value\n");
            err = TestWriteAttributeEpochUsDefaultValue_82();
            break;
        case 83:
            ChipLogProgress(chipTool, " ***** Test Step 83 : Read attribute EPOCH_US Default Value\n");
            err = TestReadAttributeEpochUsDefaultValue_83();
            break;
        case 84:
            ChipLogProgress(chipTool, " ***** Test Step 84 : Read attribute EPOCH_S Default Value\n");
            err = TestReadAttributeEpochSDefaultValue_84();
            break;
        case 85:
            ChipLogProgress(chipTool, " ***** Test Step 85 : Write attribute EPOCH_S Not Default Value\n");
            err = TestWriteAttributeEpochSNotDefaultValue_85();
            break;
        case 86:
            ChipLogProgress(chipTool, " ***** Test Step 86 : Read attribute EPOCH_S Not Default Value\n");
            err = TestReadAttributeEpochSNotDefaultValue_86();
            break;
        case 87:
            ChipLogProgress(chipTool, " ***** Test Step 87 : Write attribute EPOCH_S Default Value\n");
            err = TestWriteAttributeEpochSDefaultValue_87();
            break;
        case 88:
            ChipLogProgress(chipTool, " ***** Test Step 88 : Read attribute EPOCH_S Default Value\n");
            err = TestReadAttributeEpochSDefaultValue_88();
            break;
        case 89:
            ChipLogProgress(chipTool, " ***** Test Step 89 : Read attribute vendor_id Default Value\n");
            err = TestReadAttributeVendorIdDefaultValue_89();
            break;
        case 90:
            ChipLogProgress(chipTool, " ***** Test Step 90 : Write attribute vendor_id Not Default Value\n");
            err = TestWriteAttributeVendorIdNotDefaultValue_90();
            break;
        case 91:
            ChipLogProgress(chipTool, " ***** Test Step 91 : Read attribute vendor_id Not Default Value\n");
            err = TestReadAttributeVendorIdNotDefaultValue_91();
            break;
        case 92:
            ChipLogProgress(chipTool, " ***** Test Step 92 : Write attribute vendor_id Default Value\n");
            err = TestWriteAttributeVendorIdDefaultValue_92();
            break;
        case 93:
            ChipLogProgress(chipTool, " ***** Test Step 93 : Read attribute vendor_id Default Value\n");
            err = TestReadAttributeVendorIdDefaultValue_93();
            break;
        case 94:
            ChipLogProgress(chipTool, " ***** Test Step 94 : Read attribute char_string Default Value\n");
            err = TestReadAttributeCharStringDefaultValue_94();
            break;
        case 95:
            ChipLogProgress(
                chipTool, " ***** Test Step 95 : Read attribute char_string Default Value and compare to saved value\n");
            err = TestReadAttributeCharStringDefaultValueAndCompareToSavedValue_95();
            break;
        case 96:
            ChipLogProgress(chipTool, " ***** Test Step 96 : Write attribute char_string Not Default Value\n");
            err = TestWriteAttributeCharStringNotDefaultValue_96();
            break;
        case 97:
            ChipLogProgress(chipTool, " ***** Test Step 97 : Read attribute char_string Not Default Value\n");
            err = TestReadAttributeCharStringNotDefaultValue_97();
            break;
        case 98:
            ChipLogProgress(
                chipTool, " ***** Test Step 98 : Read attribute char_string Not Default Value and compare to saved value\n");
            err = TestReadAttributeCharStringNotDefaultValueAndCompareToSavedValue_98();
            break;
        case 99:
            ChipLogProgress(chipTool, " ***** Test Step 99 : Write attribute char_string Not Default Value from saved value\n");
            err = TestWriteAttributeCharStringNotDefaultValueFromSavedValue_99();
            break;
        case 100:
            ChipLogProgress(
                chipTool, " ***** Test Step 100 : Read attribute char_string Not Default Value and compare to expected value\n");
            err = TestReadAttributeCharStringNotDefaultValueAndCompareToExpectedValue_100();
            break;
        case 101:
            ChipLogProgress(chipTool, " ***** Test Step 101 : Write attribute char_string Default Value\n");
            err = TestWriteAttributeCharStringDefaultValue_101();
            break;
        case 102:
            ChipLogProgress(chipTool, " ***** Test Step 102 : Read attribute octet_string Default Value\n");
            err = TestReadAttributeOctetStringDefaultValue_102();
            break;
        case 103:
            ChipLogProgress(
                chipTool, " ***** Test Step 103 : Read attribute octet_string Default Value and compare to saved value\n");
            err = TestReadAttributeOctetStringDefaultValueAndCompareToSavedValue_103();
            break;
        case 104:
            ChipLogProgress(chipTool, " ***** Test Step 104 : Write attribute octet_string Not Default Value\n");
            err = TestWriteAttributeOctetStringNotDefaultValue_104();
            break;
        case 105:
            ChipLogProgress(chipTool, " ***** Test Step 105 : Read attribute octet_string Not Default Value\n");
            err = TestReadAttributeOctetStringNotDefaultValue_105();
            break;
        case 106:
            ChipLogProgress(
                chipTool, " ***** Test Step 106 : Read attribute octet_string Not Default Value and compare to saved value\n");
            err = TestReadAttributeOctetStringNotDefaultValueAndCompareToSavedValue_106();
            break;
        case 107:
            ChipLogProgress(chipTool, " ***** Test Step 107 : Write attribute octet_string Not Default Value from saved value\n");
            err = TestWriteAttributeOctetStringNotDefaultValueFromSavedValue_107();
            break;
        case 108:
            ChipLogProgress(
                chipTool, " ***** Test Step 108 : Read attribute octet_string Not Default Value and compare to expected value\n");
            err = TestReadAttributeOctetStringNotDefaultValueAndCompareToExpectedValue_108();
            break;
        case 109:
            ChipLogProgress(chipTool, " ***** Test Step 109 : Write attribute octet_string Default Value\n");
            err = TestWriteAttributeOctetStringDefaultValue_109();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 110;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }
    NSNumber * _Nonnull TestAddArgumentDefaultValue;

    CHIP_ERROR TestSendTestAddArgumentsCommand_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPTestClusterClusterTestAddArgumentsParams alloc] init];
        params.arg1 = [NSNumber numberWithUnsignedChar:3];
        params.arg2 = [NSNumber numberWithUnsignedChar:17];
        [cluster testAddArgumentsWithParams:params
                          completionHandler:^(
                              CHIPTestClusterClusterTestAddArgumentsResponseParams * _Nullable values, NSError * _Nullable err) {
                              NSLog(@"Send Test Add Arguments Command Error: %@", err);

                              VerifyOrReturn(CheckValue("status", err, 0));

                              {
                                  id actualValue = values.returnValue;
                                  VerifyOrReturn(CheckValue("returnValue", actualValue, 20));
                              }
                              {
                                  TestAddArgumentDefaultValue = values.returnValue;
                              }

                              NextTest();
                          }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSendTestAddArgumentsCommand_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPTestClusterClusterTestAddArgumentsParams alloc] init];
        params.arg1 = [NSNumber numberWithUnsignedChar:3];
        params.arg2 = [NSNumber numberWithUnsignedChar:17];
        [cluster testAddArgumentsWithParams:params
                          completionHandler:^(
                              CHIPTestClusterClusterTestAddArgumentsResponseParams * _Nullable values, NSError * _Nullable err) {
                              NSLog(@"Send Test Add Arguments Command Error: %@", err);

                              VerifyOrReturn(CheckValue("status", err, 0));

                              {
                                  id actualValue = values.returnValue;
                                  VerifyOrReturn(CheckValue("returnValue", actualValue, TestAddArgumentDefaultValue));
                              }

                              NextTest();
                          }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSendTestAddArgumentsCommand_3()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPTestClusterClusterTestAddArgumentsParams alloc] init];
        params.arg1 = [NSNumber numberWithUnsignedChar:3];
        params.arg2 = [TestAddArgumentDefaultValue copy];
        [cluster testAddArgumentsWithParams:params
                          completionHandler:^(
                              CHIPTestClusterClusterTestAddArgumentsResponseParams * _Nullable values, NSError * _Nullable err) {
                              NSLog(@"Send Test Add Arguments Command Error: %@", err);

                              VerifyOrReturn(CheckValue("status", err, 0));

                              if (values.returnValue != nil) {
                                  VerifyOrReturn(
                                      CheckConstraintNotValue("returnValue", values.returnValue, TestAddArgumentDefaultValue));
                              }

                              NextTest();
                          }];

        return CHIP_NO_ERROR;
    }
    NSNumber * _Nonnull readAttributeBooleanDefaultValue;

    CHIP_ERROR TestReadAttributeBooleanDefaultValue_4()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeBooleanWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute BOOLEAN Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("boolean", actualValue, 0));
            }
            {
                readAttributeBooleanDefaultValue = value;
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeBooleanNotDefaultValue_5()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id booleanArgument;
        booleanArgument = [NSNumber numberWithBool:1];
        [cluster writeAttributeBooleanWithValue:booleanArgument
                              completionHandler:^(NSError * _Nullable err) {
                                  NSLog(@"Write attribute BOOLEAN Not Default Value Error: %@", err);

                                  VerifyOrReturn(CheckValue("status", err, 0));

                                  NextTest();
                              }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeBooleanNotDefaultValue_6()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeBooleanWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute BOOLEAN Not Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            if (value != nil) {
                VerifyOrReturn(CheckConstraintNotValue("boolean", value, readAttributeBooleanDefaultValue));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeBooleanDefaultValue_7()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id booleanArgument;
        booleanArgument = [readAttributeBooleanDefaultValue copy];
        [cluster writeAttributeBooleanWithValue:booleanArgument
                              completionHandler:^(NSError * _Nullable err) {
                                  NSLog(@"Write attribute BOOLEAN DefaultValue Error: %@", err);

                                  VerifyOrReturn(CheckValue("status", err, 0));

                                  NextTest();
                              }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeBooleanFalse_8()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeBooleanWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute BOOLEAN False Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("boolean", actualValue, readAttributeBooleanDefaultValue));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
    NSNumber * _Nonnull readAttributeBitmap8DefaultValue;

    CHIP_ERROR TestReadAttributeBitmap8DefaultValue_9()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeBitmap8WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute BITMAP8 Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("bitmap8", actualValue, 0));
            }
            {
                readAttributeBitmap8DefaultValue = value;
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeBitmap8NotDefaultValue_10()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id bitmap8Argument;
        bitmap8Argument = [NSNumber numberWithUnsignedChar:1];
        [cluster writeAttributeBitmap8WithValue:bitmap8Argument
                              completionHandler:^(NSError * _Nullable err) {
                                  NSLog(@"Write attribute BITMAP8 Not Default Value Error: %@", err);

                                  VerifyOrReturn(CheckValue("status", err, 0));

                                  NextTest();
                              }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeBitmap8NotDefaultValue_11()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeBitmap8WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute BITMAP8 Not Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            if (value != nil) {
                VerifyOrReturn(CheckConstraintNotValue("bitmap8", value, readAttributeBitmap8DefaultValue));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeBitmap8DefaultValue_12()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id bitmap8Argument;
        bitmap8Argument = [readAttributeBitmap8DefaultValue copy];
        [cluster writeAttributeBitmap8WithValue:bitmap8Argument
                              completionHandler:^(NSError * _Nullable err) {
                                  NSLog(@"Write attribute BITMAP8 Default Value Error: %@", err);

                                  VerifyOrReturn(CheckValue("status", err, 0));

                                  NextTest();
                              }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeBitmap8DefaultValue_13()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeBitmap8WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute BITMAP8 Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("bitmap8", actualValue, readAttributeBitmap8DefaultValue));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
    NSNumber * _Nonnull readAttributeBitmap16DefaultValue;

    CHIP_ERROR TestReadAttributeBitmap16DefaultValue_14()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeBitmap16WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute BITMAP16 Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("bitmap16", actualValue, 0U));
            }
            {
                readAttributeBitmap16DefaultValue = value;
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeBitmap16NotDefaultValue_15()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id bitmap16Argument;
        bitmap16Argument = [NSNumber numberWithUnsignedShort:1U];
        [cluster writeAttributeBitmap16WithValue:bitmap16Argument
                               completionHandler:^(NSError * _Nullable err) {
                                   NSLog(@"Write attribute BITMAP16 Not Default Value Error: %@", err);

                                   VerifyOrReturn(CheckValue("status", err, 0));

                                   NextTest();
                               }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeBitmap16NotDefaultValue_16()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeBitmap16WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute BITMAP16 Not Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            if (value != nil) {
                VerifyOrReturn(CheckConstraintNotValue("bitmap16", value, readAttributeBitmap16DefaultValue));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeBitmap16DefaultValue_17()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id bitmap16Argument;
        bitmap16Argument = [readAttributeBitmap16DefaultValue copy];
        [cluster writeAttributeBitmap16WithValue:bitmap16Argument
                               completionHandler:^(NSError * _Nullable err) {
                                   NSLog(@"Write attribute BITMAP16 Default Value Error: %@", err);

                                   VerifyOrReturn(CheckValue("status", err, 0));

                                   NextTest();
                               }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeBitmap16DefaultValue_18()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeBitmap16WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute BITMAP16 Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("bitmap16", actualValue, readAttributeBitmap16DefaultValue));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
    NSNumber * _Nonnull readAttributeBitmap32DefaultValue;

    CHIP_ERROR TestReadAttributeBitmap32DefaultValue_19()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeBitmap32WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute BITMAP32 Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("bitmap32", actualValue, 0UL));
            }
            {
                readAttributeBitmap32DefaultValue = value;
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeBitmap32NotDefaultValue_20()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id bitmap32Argument;
        bitmap32Argument = [NSNumber numberWithUnsignedInt:1UL];
        [cluster writeAttributeBitmap32WithValue:bitmap32Argument
                               completionHandler:^(NSError * _Nullable err) {
                                   NSLog(@"Write attribute BITMAP32 Not Default Value Error: %@", err);

                                   VerifyOrReturn(CheckValue("status", err, 0));

                                   NextTest();
                               }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeBitmap32NotDefaultValue_21()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeBitmap32WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute BITMAP32 Not Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            if (value != nil) {
                VerifyOrReturn(CheckConstraintNotValue("bitmap32", value, readAttributeBitmap32DefaultValue));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeBitmap32DefaultValue_22()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id bitmap32Argument;
        bitmap32Argument = [readAttributeBitmap32DefaultValue copy];
        [cluster writeAttributeBitmap32WithValue:bitmap32Argument
                               completionHandler:^(NSError * _Nullable err) {
                                   NSLog(@"Write attribute BITMAP32 Default Value Error: %@", err);

                                   VerifyOrReturn(CheckValue("status", err, 0));

                                   NextTest();
                               }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeBitmap32DefaultValue_23()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeBitmap32WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute BITMAP32 Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("bitmap32", actualValue, readAttributeBitmap32DefaultValue));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
    NSNumber * _Nonnull readAttributeBitmap64DefaultValue;

    CHIP_ERROR TestReadAttributeBitmap64DefaultValue_24()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeBitmap64WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute BITMAP64 Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("bitmap64", actualValue, 0ULL));
            }
            {
                readAttributeBitmap64DefaultValue = value;
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeBitmap64NotDefaultValue_25()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id bitmap64Argument;
        bitmap64Argument = [NSNumber numberWithUnsignedLongLong:1ULL];
        [cluster writeAttributeBitmap64WithValue:bitmap64Argument
                               completionHandler:^(NSError * _Nullable err) {
                                   NSLog(@"Write attribute BITMAP64 Not Default Value Error: %@", err);

                                   VerifyOrReturn(CheckValue("status", err, 0));

                                   NextTest();
                               }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeBitmap64DefaultValue_26()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeBitmap64WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute BITMAP64 Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            if (value != nil) {
                VerifyOrReturn(CheckConstraintNotValue("bitmap64", value, readAttributeBitmap64DefaultValue));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeBitmap64DefaultValue_27()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id bitmap64Argument;
        bitmap64Argument = [readAttributeBitmap64DefaultValue copy];
        [cluster writeAttributeBitmap64WithValue:bitmap64Argument
                               completionHandler:^(NSError * _Nullable err) {
                                   NSLog(@"Write attribute BITMAP64 Default Value Error: %@", err);

                                   VerifyOrReturn(CheckValue("status", err, 0));

                                   NextTest();
                               }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeBitmap64DefaultValue_28()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeBitmap64WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute BITMAP64 Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("bitmap64", actualValue, readAttributeBitmap64DefaultValue));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
    NSNumber * _Nonnull readAttributeInt8uDefaultValue;

    CHIP_ERROR TestReadAttributeInt8uDefaultValue_29()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeInt8uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute INT8U Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("int8u", actualValue, 0));
            }
            {
                readAttributeInt8uDefaultValue = value;
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeInt8uNotDefaultValue_30()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id int8uArgument;
        int8uArgument = [NSNumber numberWithUnsignedChar:1];
        [cluster writeAttributeInt8uWithValue:int8uArgument
                            completionHandler:^(NSError * _Nullable err) {
                                NSLog(@"Write attribute INT8U Not Default Value Error: %@", err);

                                VerifyOrReturn(CheckValue("status", err, 0));

                                NextTest();
                            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeInt8uNotDefaultValue_31()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeInt8uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute INT8U Not Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            if (value != nil) {
                VerifyOrReturn(CheckConstraintNotValue("int8u", value, readAttributeInt8uDefaultValue));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeInt8uDefaultValue_32()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id int8uArgument;
        int8uArgument = [readAttributeInt8uDefaultValue copy];
        [cluster writeAttributeInt8uWithValue:int8uArgument
                            completionHandler:^(NSError * _Nullable err) {
                                NSLog(@"Write attribute INT8U Default Value Error: %@", err);

                                VerifyOrReturn(CheckValue("status", err, 0));

                                NextTest();
                            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeInt8uDefaultValue_33()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeInt8uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute INT8U Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("int8u", actualValue, readAttributeInt8uDefaultValue));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
    NSNumber * _Nonnull readAttributeInt16uDefaultValue;

    CHIP_ERROR TestReadAttributeInt16uDefaultValue_34()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeInt16uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute INT16U Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("int16u", actualValue, 0U));
            }
            {
                readAttributeInt16uDefaultValue = value;
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeInt16uNotDefaultValue_35()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id int16uArgument;
        int16uArgument = [NSNumber numberWithUnsignedShort:1U];
        [cluster writeAttributeInt16uWithValue:int16uArgument
                             completionHandler:^(NSError * _Nullable err) {
                                 NSLog(@"Write attribute INT16U Not Default Value Error: %@", err);

                                 VerifyOrReturn(CheckValue("status", err, 0));

                                 NextTest();
                             }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeInt16uNotDefaultValue_36()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeInt16uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute INT16U Not Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            if (value != nil) {
                VerifyOrReturn(CheckConstraintNotValue("int16u", value, readAttributeInt16uDefaultValue));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeInt16uDefaultValue_37()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id int16uArgument;
        int16uArgument = [readAttributeInt16uDefaultValue copy];
        [cluster writeAttributeInt16uWithValue:int16uArgument
                             completionHandler:^(NSError * _Nullable err) {
                                 NSLog(@"Write attribute INT16U Default Value Error: %@", err);

                                 VerifyOrReturn(CheckValue("status", err, 0));

                                 NextTest();
                             }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeInt16uDefaultValue_38()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeInt16uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute INT16U Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("int16u", actualValue, readAttributeInt16uDefaultValue));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
    NSNumber * _Nonnull readAttributeInt32uDefaultValue;

    CHIP_ERROR TestReadAttributeInt32uDefaultValue_39()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeInt32uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute INT32U Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("int32u", actualValue, 0UL));
            }
            {
                readAttributeInt32uDefaultValue = value;
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeInt32uNotDefaultValue_40()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id int32uArgument;
        int32uArgument = [NSNumber numberWithUnsignedInt:1UL];
        [cluster writeAttributeInt32uWithValue:int32uArgument
                             completionHandler:^(NSError * _Nullable err) {
                                 NSLog(@"Write attribute INT32U Not Default Value Error: %@", err);

                                 VerifyOrReturn(CheckValue("status", err, 0));

                                 NextTest();
                             }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeInt32uNotDefaultValue_41()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeInt32uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute INT32U Not Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            if (value != nil) {
                VerifyOrReturn(CheckConstraintNotValue("int32u", value, readAttributeInt32uDefaultValue));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeInt32uDefaultValue_42()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id int32uArgument;
        int32uArgument = [readAttributeInt32uDefaultValue copy];
        [cluster writeAttributeInt32uWithValue:int32uArgument
                             completionHandler:^(NSError * _Nullable err) {
                                 NSLog(@"Write attribute INT32U Default Value Error: %@", err);

                                 VerifyOrReturn(CheckValue("status", err, 0));

                                 NextTest();
                             }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeInt32uDefaultValue_43()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeInt32uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute INT32U Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("int32u", actualValue, readAttributeInt32uDefaultValue));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
    NSNumber * _Nonnull readAttributeInt64uDefaultValue;

    CHIP_ERROR TestReadAttributeInt64uDefaultValue_44()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeInt64uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute INT64U Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("int64u", actualValue, 0ULL));
            }
            {
                readAttributeInt64uDefaultValue = value;
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeInt64uNotDefaultValue_45()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id int64uArgument;
        int64uArgument = [NSNumber numberWithUnsignedLongLong:1ULL];
        [cluster writeAttributeInt64uWithValue:int64uArgument
                             completionHandler:^(NSError * _Nullable err) {
                                 NSLog(@"Write attribute INT64U Not Default Value Error: %@", err);

                                 VerifyOrReturn(CheckValue("status", err, 0));

                                 NextTest();
                             }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeInt64uNotDefaultValue_46()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeInt64uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute INT64U Not Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            if (value != nil) {
                VerifyOrReturn(CheckConstraintNotValue("int64u", value, readAttributeInt64uDefaultValue));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeInt64uDefaultValue_47()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id int64uArgument;
        int64uArgument = [readAttributeInt64uDefaultValue copy];
        [cluster writeAttributeInt64uWithValue:int64uArgument
                             completionHandler:^(NSError * _Nullable err) {
                                 NSLog(@"Write attribute INT64U Default Value Error: %@", err);

                                 VerifyOrReturn(CheckValue("status", err, 0));

                                 NextTest();
                             }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeInt64uDefaultValue_48()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeInt64uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute INT64U Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("int64u", actualValue, readAttributeInt64uDefaultValue));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
    NSNumber * _Nonnull readAttributeInt8sDefaultValue;

    CHIP_ERROR TestReadAttributeInt8sDefaultValue_49()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeInt8sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute INT8S Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("int8s", actualValue, 0));
            }
            {
                readAttributeInt8sDefaultValue = value;
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeInt8sNotDefaultValue_50()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id int8sArgument;
        int8sArgument = [NSNumber numberWithChar:1];
        [cluster writeAttributeInt8sWithValue:int8sArgument
                            completionHandler:^(NSError * _Nullable err) {
                                NSLog(@"Write attribute INT8S Not Default Value Error: %@", err);

                                VerifyOrReturn(CheckValue("status", err, 0));

                                NextTest();
                            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeInt8sNotDefaultValue_51()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeInt8sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute INT8S Not Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            if (value != nil) {
                VerifyOrReturn(CheckConstraintNotValue("int8s", value, readAttributeInt8sDefaultValue));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeInt8sDefaultValue_52()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id int8sArgument;
        int8sArgument = [readAttributeInt8sDefaultValue copy];
        [cluster writeAttributeInt8sWithValue:int8sArgument
                            completionHandler:^(NSError * _Nullable err) {
                                NSLog(@"Write attribute INT8S Default Value Error: %@", err);

                                VerifyOrReturn(CheckValue("status", err, 0));

                                NextTest();
                            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeInt8sDefaultValue_53()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeInt8sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute INT8S Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("int8s", actualValue, readAttributeInt8sDefaultValue));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
    NSNumber * _Nonnull readAttributeInt16sDefaultValue;

    CHIP_ERROR TestReadAttributeInt16sDefaultValue_54()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeInt16sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute INT16S Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("int16s", actualValue, 0));
            }
            {
                readAttributeInt16sDefaultValue = value;
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeInt16sNotDefaultValue_55()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id int16sArgument;
        int16sArgument = [NSNumber numberWithShort:1];
        [cluster writeAttributeInt16sWithValue:int16sArgument
                             completionHandler:^(NSError * _Nullable err) {
                                 NSLog(@"Write attribute INT16S Not Default Value Error: %@", err);

                                 VerifyOrReturn(CheckValue("status", err, 0));

                                 NextTest();
                             }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeInt16sNotDefaultValue_56()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeInt16sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute INT16S Not Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            if (value != nil) {
                VerifyOrReturn(CheckConstraintNotValue("int16s", value, readAttributeInt16sDefaultValue));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeInt16sDefaultValue_57()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id int16sArgument;
        int16sArgument = [readAttributeInt16sDefaultValue copy];
        [cluster writeAttributeInt16sWithValue:int16sArgument
                             completionHandler:^(NSError * _Nullable err) {
                                 NSLog(@"Write attribute INT16S Default Value Error: %@", err);

                                 VerifyOrReturn(CheckValue("status", err, 0));

                                 NextTest();
                             }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeInt16sDefaultValue_58()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeInt16sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute INT16S Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("int16s", actualValue, readAttributeInt16sDefaultValue));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
    NSNumber * _Nonnull readAttributeInt32sDefaultValue;

    CHIP_ERROR TestReadAttributeInt32sDefaultValue_59()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeInt32sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute INT32S Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("int32s", actualValue, 0L));
            }
            {
                readAttributeInt32sDefaultValue = value;
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeInt32sNotDefaultValue_60()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id int32sArgument;
        int32sArgument = [NSNumber numberWithInt:1L];
        [cluster writeAttributeInt32sWithValue:int32sArgument
                             completionHandler:^(NSError * _Nullable err) {
                                 NSLog(@"Write attribute INT32S Not Default Value Error: %@", err);

                                 VerifyOrReturn(CheckValue("status", err, 0));

                                 NextTest();
                             }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeInt32sNotDefaultValue_61()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeInt32sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute INT32S Not Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            if (value != nil) {
                VerifyOrReturn(CheckConstraintNotValue("int32s", value, readAttributeInt32sDefaultValue));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeInt32sDefaultValue_62()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id int32sArgument;
        int32sArgument = [readAttributeInt32sDefaultValue copy];
        [cluster writeAttributeInt32sWithValue:int32sArgument
                             completionHandler:^(NSError * _Nullable err) {
                                 NSLog(@"Write attribute INT32S Default Value Error: %@", err);

                                 VerifyOrReturn(CheckValue("status", err, 0));

                                 NextTest();
                             }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeInt32sDefaultValue_63()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeInt32sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute INT32S Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("int32s", actualValue, readAttributeInt32sDefaultValue));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
    NSNumber * _Nonnull readAttributeInt64sDefaultValue;

    CHIP_ERROR TestReadAttributeInt64sDefaultValue_64()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeInt64sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute INT64S Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("int64s", actualValue, 0LL));
            }
            {
                readAttributeInt64sDefaultValue = value;
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeIntsNotDefaultValue_65()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id int64sArgument;
        int64sArgument = [NSNumber numberWithLongLong:1LL];
        [cluster writeAttributeInt64sWithValue:int64sArgument
                             completionHandler:^(NSError * _Nullable err) {
                                 NSLog(@"Write attribute INTS Not Default Value Error: %@", err);

                                 VerifyOrReturn(CheckValue("status", err, 0));

                                 NextTest();
                             }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeInt64sNotDefaultValue_66()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeInt64sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute INT64S Not Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            if (value != nil) {
                VerifyOrReturn(CheckConstraintNotValue("int64s", value, readAttributeInt64sDefaultValue));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeInt64sDefaultValue_67()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id int64sArgument;
        int64sArgument = [readAttributeInt64sDefaultValue copy];
        [cluster writeAttributeInt64sWithValue:int64sArgument
                             completionHandler:^(NSError * _Nullable err) {
                                 NSLog(@"Write attribute INT64S Default Value Error: %@", err);

                                 VerifyOrReturn(CheckValue("status", err, 0));

                                 NextTest();
                             }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeInt64sDefaultValue_68()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeInt64sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute INT64S Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("int64s", actualValue, readAttributeInt64sDefaultValue));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
    NSNumber * _Nonnull readAttributeEnum8DefaultValue;

    CHIP_ERROR TestReadAttributeEnum8DefaultValue_69()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeEnum8WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute ENUM8 Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("enum8", actualValue, 0));
            }
            {
                readAttributeEnum8DefaultValue = value;
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeEnum8NotDefaultValue_70()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id enum8Argument;
        enum8Argument = [NSNumber numberWithUnsignedChar:1];
        [cluster writeAttributeEnum8WithValue:enum8Argument
                            completionHandler:^(NSError * _Nullable err) {
                                NSLog(@"Write attribute ENUM8 Not Default Value Error: %@", err);

                                VerifyOrReturn(CheckValue("status", err, 0));

                                NextTest();
                            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeEnum8NotDefaultValue_71()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeEnum8WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute ENUM8 Not Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            if (value != nil) {
                VerifyOrReturn(CheckConstraintNotValue("enum8", value, readAttributeEnum8DefaultValue));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeEnum8DefaultValue_72()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id enum8Argument;
        enum8Argument = [readAttributeEnum8DefaultValue copy];
        [cluster writeAttributeEnum8WithValue:enum8Argument
                            completionHandler:^(NSError * _Nullable err) {
                                NSLog(@"Write attribute ENUM8 Default Value Error: %@", err);

                                VerifyOrReturn(CheckValue("status", err, 0));

                                NextTest();
                            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeEnum8DefaultValue_73()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeEnum8WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute ENUM8 Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("enum8", actualValue, readAttributeEnum8DefaultValue));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
    NSNumber * _Nonnull readAttributeEnum16DefaultValue;

    CHIP_ERROR TestReadAttributeEnum16DefaultValue_74()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeEnum16WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute ENUM16 Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("enum16", actualValue, 0U));
            }
            {
                readAttributeEnum16DefaultValue = value;
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeEnum16NotDefaultValue_75()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id enum16Argument;
        enum16Argument = [NSNumber numberWithUnsignedShort:1U];
        [cluster writeAttributeEnum16WithValue:enum16Argument
                             completionHandler:^(NSError * _Nullable err) {
                                 NSLog(@"Write attribute ENUM16 Not Default Value Error: %@", err);

                                 VerifyOrReturn(CheckValue("status", err, 0));

                                 NextTest();
                             }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeEnum16NotDefaultValue_76()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeEnum16WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute ENUM16 Not Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            if (value != nil) {
                VerifyOrReturn(CheckConstraintNotValue("enum16", value, readAttributeEnum16DefaultValue));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeEnum16DefaultValue_77()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id enum16Argument;
        enum16Argument = [readAttributeEnum16DefaultValue copy];
        [cluster writeAttributeEnum16WithValue:enum16Argument
                             completionHandler:^(NSError * _Nullable err) {
                                 NSLog(@"Write attribute ENUM16 Default Value Error: %@", err);

                                 VerifyOrReturn(CheckValue("status", err, 0));

                                 NextTest();
                             }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeEnum16DefaultValue_78()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeEnum16WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute ENUM16 Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("enum16", actualValue, readAttributeEnum16DefaultValue));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
    NSNumber * _Nonnull readAttributeEpochUSDefaultValue;

    CHIP_ERROR TestReadAttributeEpochUsDefaultValue_79()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeEpochUsWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute EPOCH_US Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("epoch_us", actualValue, 0ULL));
            }
            {
                readAttributeEpochUSDefaultValue = value;
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeEpochUsNotDefaultValue_80()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id epochUsArgument;
        epochUsArgument = [NSNumber numberWithUnsignedLongLong:1ULL];
        [cluster writeAttributeEpochUsWithValue:epochUsArgument
                              completionHandler:^(NSError * _Nullable err) {
                                  NSLog(@"Write attribute EPOCH_US Not Default Value Error: %@", err);

                                  VerifyOrReturn(CheckValue("status", err, 0));

                                  NextTest();
                              }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeEpochUsNotDefaultValue_81()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeEpochUsWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute EPOCH_US Not Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            if (value != nil) {
                VerifyOrReturn(CheckConstraintNotValue("epochUs", value, readAttributeEpochUSDefaultValue));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeEpochUsDefaultValue_82()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id epochUsArgument;
        epochUsArgument = [readAttributeEpochUSDefaultValue copy];
        [cluster writeAttributeEpochUsWithValue:epochUsArgument
                              completionHandler:^(NSError * _Nullable err) {
                                  NSLog(@"Write attribute EPOCH_US Default Value Error: %@", err);

                                  VerifyOrReturn(CheckValue("status", err, 0));

                                  NextTest();
                              }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeEpochUsDefaultValue_83()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeEpochUsWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute EPOCH_US Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("epoch_us", actualValue, readAttributeEpochUSDefaultValue));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
    NSNumber * _Nonnull readAttributeEpochSDefaultValue;

    CHIP_ERROR TestReadAttributeEpochSDefaultValue_84()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeEpochSWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute EPOCH_S Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("epoch_s", actualValue, 0UL));
            }
            {
                readAttributeEpochSDefaultValue = value;
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeEpochSNotDefaultValue_85()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id epochSArgument;
        epochSArgument = [NSNumber numberWithUnsignedInt:1UL];
        [cluster writeAttributeEpochSWithValue:epochSArgument
                             completionHandler:^(NSError * _Nullable err) {
                                 NSLog(@"Write attribute EPOCH_S Not Default Value Error: %@", err);

                                 VerifyOrReturn(CheckValue("status", err, 0));

                                 NextTest();
                             }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeEpochSNotDefaultValue_86()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeEpochSWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute EPOCH_S Not Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            if (value != nil) {
                VerifyOrReturn(CheckConstraintNotValue("epochS", value, readAttributeEpochSDefaultValue));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeEpochSDefaultValue_87()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id epochSArgument;
        epochSArgument = [readAttributeEpochSDefaultValue copy];
        [cluster writeAttributeEpochSWithValue:epochSArgument
                             completionHandler:^(NSError * _Nullable err) {
                                 NSLog(@"Write attribute EPOCH_S Default Value Error: %@", err);

                                 VerifyOrReturn(CheckValue("status", err, 0));

                                 NextTest();
                             }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeEpochSDefaultValue_88()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeEpochSWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute EPOCH_S Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("epoch_s", actualValue, readAttributeEpochSDefaultValue));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
    NSNumber * _Nonnull readAttributeVendorIdDefaultValue;

    CHIP_ERROR TestReadAttributeVendorIdDefaultValue_89()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeVendorIdWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute vendor_id Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("vendor_id", actualValue, 0U));
            }
            {
                readAttributeVendorIdDefaultValue = value;
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeVendorIdNotDefaultValue_90()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id vendorIdArgument;
        vendorIdArgument = [NSNumber numberWithUnsignedShort:1U];
        [cluster writeAttributeVendorIdWithValue:vendorIdArgument
                               completionHandler:^(NSError * _Nullable err) {
                                   NSLog(@"Write attribute vendor_id Not Default Value Error: %@", err);

                                   VerifyOrReturn(CheckValue("status", err, 0));

                                   NextTest();
                               }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeVendorIdNotDefaultValue_91()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeVendorIdWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute vendor_id Not Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            if (value != nil) {
                VerifyOrReturn(CheckConstraintNotValue("vendorId", value, readAttributeVendorIdDefaultValue));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeVendorIdDefaultValue_92()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id vendorIdArgument;
        vendorIdArgument = [readAttributeVendorIdDefaultValue copy];
        [cluster writeAttributeVendorIdWithValue:vendorIdArgument
                               completionHandler:^(NSError * _Nullable err) {
                                   NSLog(@"Write attribute vendor_id Default Value Error: %@", err);

                                   VerifyOrReturn(CheckValue("status", err, 0));

                                   NextTest();
                               }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeVendorIdDefaultValue_93()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeVendorIdWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute vendor_id Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("vendor_id", actualValue, readAttributeVendorIdDefaultValue));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
    NSString * _Nonnull readAttributeCharStringDefaultValue;

    CHIP_ERROR TestReadAttributeCharStringDefaultValue_94()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeCharStringWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute char_string Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueAsString("char_string", actualValue, @""));
            }
            {
                readAttributeCharStringDefaultValue = value;
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeCharStringDefaultValueAndCompareToSavedValue_95()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeCharStringWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute char_string Default Value and compare to saved value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueAsString("char_string", actualValue, readAttributeCharStringDefaultValue));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeCharStringNotDefaultValue_96()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id charStringArgument;
        charStringArgument = @"NotDefault";
        [cluster writeAttributeCharStringWithValue:charStringArgument
                                 completionHandler:^(NSError * _Nullable err) {
                                     NSLog(@"Write attribute char_string Not Default Value Error: %@", err);

                                     VerifyOrReturn(CheckValue("status", err, 0));

                                     NextTest();
                                 }];

        return CHIP_NO_ERROR;
    }
    NSString * _Nonnull readAttributeCharStringNotDefaultValue;

    CHIP_ERROR TestReadAttributeCharStringNotDefaultValue_97()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeCharStringWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute char_string Not Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueAsString("char_string", actualValue, @"NotDefault"));
            }

            if (value != nil) {
                VerifyOrReturn(CheckConstraintNotValue("charString", value, readAttributeCharStringDefaultValue));
            }
            {
                readAttributeCharStringNotDefaultValue = value;
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeCharStringNotDefaultValueAndCompareToSavedValue_98()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeCharStringWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute char_string Not Default Value and compare to saved value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueAsString("char_string", actualValue, readAttributeCharStringNotDefaultValue));
            }

            if (value != nil) {
                VerifyOrReturn(CheckConstraintNotValue("charString", value, readAttributeCharStringDefaultValue));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeCharStringNotDefaultValueFromSavedValue_99()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id charStringArgument;
        charStringArgument = [readAttributeCharStringNotDefaultValue copy];
        [cluster writeAttributeCharStringWithValue:charStringArgument
                                 completionHandler:^(NSError * _Nullable err) {
                                     NSLog(@"Write attribute char_string Not Default Value from saved value Error: %@", err);

                                     VerifyOrReturn(CheckValue("status", err, 0));

                                     NextTest();
                                 }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeCharStringNotDefaultValueAndCompareToExpectedValue_100()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeCharStringWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute char_string Not Default Value and compare to expected value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueAsString("char_string", actualValue, @"NotDefault"));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeCharStringDefaultValue_101()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id charStringArgument;
        charStringArgument = [readAttributeCharStringDefaultValue copy];
        [cluster writeAttributeCharStringWithValue:charStringArgument
                                 completionHandler:^(NSError * _Nullable err) {
                                     NSLog(@"Write attribute char_string Default Value Error: %@", err);

                                     VerifyOrReturn(CheckValue("status", err, 0));

                                     NextTest();
                                 }];

        return CHIP_NO_ERROR;
    }
    NSData * _Nonnull readAttributeOctetStringDefaultValue;

    CHIP_ERROR TestReadAttributeOctetStringDefaultValue_102()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOctetStringWithCompletionHandler:^(NSData * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute octet_string Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueAsString("octet_string", actualValue, [[NSData alloc] initWithBytes:"" length:0]));
            }
            {
                readAttributeOctetStringDefaultValue = value;
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeOctetStringDefaultValueAndCompareToSavedValue_103()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOctetStringWithCompletionHandler:^(NSData * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute octet_string Default Value and compare to saved value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueAsString("octet_string", actualValue, readAttributeOctetStringDefaultValue));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeOctetStringNotDefaultValue_104()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id octetStringArgument;
        octetStringArgument = [[NSData alloc] initWithBytes:"NotDefault" length:10];
        [cluster writeAttributeOctetStringWithValue:octetStringArgument
                                  completionHandler:^(NSError * _Nullable err) {
                                      NSLog(@"Write attribute octet_string Not Default Value Error: %@", err);

                                      VerifyOrReturn(CheckValue("status", err, 0));

                                      NextTest();
                                  }];

        return CHIP_NO_ERROR;
    }
    NSData * _Nonnull readAttributeOctetStringNotDefaultValue;

    CHIP_ERROR TestReadAttributeOctetStringNotDefaultValue_105()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOctetStringWithCompletionHandler:^(NSData * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute octet_string Not Default Value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(
                    CheckValueAsString("octet_string", actualValue, [[NSData alloc] initWithBytes:"NotDefault" length:10]));
            }

            if (value != nil) {
                VerifyOrReturn(CheckConstraintNotValue("octetString", value, readAttributeOctetStringDefaultValue));
            }
            {
                readAttributeOctetStringNotDefaultValue = value;
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeOctetStringNotDefaultValueAndCompareToSavedValue_106()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOctetStringWithCompletionHandler:^(NSData * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute octet_string Not Default Value and compare to saved value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueAsString("octet_string", actualValue, readAttributeOctetStringNotDefaultValue));
            }

            if (value != nil) {
                VerifyOrReturn(CheckConstraintNotValue("octetString", value, readAttributeOctetStringDefaultValue));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeOctetStringNotDefaultValueFromSavedValue_107()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id octetStringArgument;
        octetStringArgument = [readAttributeOctetStringNotDefaultValue copy];
        [cluster writeAttributeOctetStringWithValue:octetStringArgument
                                  completionHandler:^(NSError * _Nullable err) {
                                      NSLog(@"Write attribute octet_string Not Default Value from saved value Error: %@", err);

                                      VerifyOrReturn(CheckValue("status", err, 0));

                                      NextTest();
                                  }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeOctetStringNotDefaultValueAndCompareToExpectedValue_108()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeOctetStringWithCompletionHandler:^(NSData * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute octet_string Not Default Value and compare to expected value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(
                    CheckValueAsString("octet_string", actualValue, [[NSData alloc] initWithBytes:"NotDefault" length:10]));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeOctetStringDefaultValue_109()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id octetStringArgument;
        octetStringArgument = [readAttributeOctetStringDefaultValue copy];
        [cluster writeAttributeOctetStringWithValue:octetStringArgument
                                  completionHandler:^(NSError * _Nullable err) {
                                      NSLog(@"Write attribute octet_string Default Value Error: %@", err);

                                      VerifyOrReturn(CheckValue("status", err, 0));

                                      NextTest();
                                  }];

        return CHIP_NO_ERROR;
    }
};

class TestConstraints : public TestCommandBridge {
public:
    TestConstraints()
        : TestCommandBridge("TestConstraints")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~TestConstraints() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: TestConstraints\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: TestConstraints\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Write attribute INT32U Value\n");
            err = TestWriteAttributeInt32uValue_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read attribute INT32U Value MinValue Constraints\n");
            err = TestReadAttributeInt32uValueMinValueConstraints_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read attribute INT32U Value MaxValue Constraints\n");
            err = TestReadAttributeInt32uValueMaxValueConstraints_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Read attribute INT32U Value NotValue Constraints\n");
            err = TestReadAttributeInt32uValueNotValueConstraints_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Write attribute INT32U Value Back to Default Value\n");
            err = TestWriteAttributeInt32uValueBackToDefaultValue_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Write attribute CHAR_STRING Value\n");
            err = TestWriteAttributeCharStringValue_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Read attribute CHAR_STRING Value MinLength Constraints\n");
            err = TestReadAttributeCharStringValueMinLengthConstraints_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Read attribute CHAR_STRING Value MaxLength Constraints\n");
            err = TestReadAttributeCharStringValueMaxLengthConstraints_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Read attribute CHAR_STRING Value StartsWith Constraints\n");
            err = TestReadAttributeCharStringValueStartsWithConstraints_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Read attribute CHAR_STRING Value EndsWith Constraints\n");
            err = TestReadAttributeCharStringValueEndsWithConstraints_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : Write attribute CHAR_STRING Value\n");
            err = TestWriteAttributeCharStringValue_11();
            break;
        case 12:
            ChipLogProgress(
                chipTool, " ***** Test Step 12 : Read attribute CHAR_STRING Value isLowerCase/isUpperCase Constraints\n");
            err = TestReadAttributeCharStringValueIsLowerCaseIsUpperCaseConstraints_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : Write attribute CHAR_STRING Value\n");
            err = TestWriteAttributeCharStringValue_13();
            break;
        case 14:
            ChipLogProgress(
                chipTool, " ***** Test Step 14 : Read attribute CHAR_STRING Value isLowerCase/isUpperCase Constraints\n");
            err = TestReadAttributeCharStringValueIsLowerCaseIsUpperCaseConstraints_14();
            break;
        case 15:
            ChipLogProgress(chipTool, " ***** Test Step 15 : Write attribute CHAR_STRING Value\n");
            err = TestWriteAttributeCharStringValue_15();
            break;
        case 16:
            ChipLogProgress(
                chipTool, " ***** Test Step 16 : Read attribute CHAR_STRING Value isLowerCase/isUpperCase Constraints\n");
            err = TestReadAttributeCharStringValueIsLowerCaseIsUpperCaseConstraints_16();
            break;
        case 17:
            ChipLogProgress(chipTool, " ***** Test Step 17 : Write attribute CHAR_STRING Value\n");
            err = TestWriteAttributeCharStringValue_17();
            break;
        case 18:
            ChipLogProgress(chipTool, " ***** Test Step 18 : Read attribute CHAR_STRING Value isHexString Constraints\n");
            err = TestReadAttributeCharStringValueIsHexStringConstraints_18();
            break;
        case 19:
            ChipLogProgress(chipTool, " ***** Test Step 19 : Write attribute CHAR_STRING Value\n");
            err = TestWriteAttributeCharStringValue_19();
            break;
        case 20:
            ChipLogProgress(chipTool, " ***** Test Step 20 : Read attribute CHAR_STRING Value isHexString Constraints\n");
            err = TestReadAttributeCharStringValueIsHexStringConstraints_20();
            break;
        case 21:
            ChipLogProgress(chipTool, " ***** Test Step 21 : Write attribute CHAR_STRING Value Back to Default Value\n");
            err = TestWriteAttributeCharStringValueBackToDefaultValue_21();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 22;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeInt32uValue_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id int32uArgument;
        int32uArgument = [NSNumber numberWithUnsignedInt:5UL];
        [cluster writeAttributeInt32uWithValue:int32uArgument
                             completionHandler:^(NSError * _Nullable err) {
                                 NSLog(@"Write attribute INT32U Value Error: %@", err);

                                 VerifyOrReturn(CheckValue("status", err, 0));

                                 NextTest();
                             }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeInt32uValueMinValueConstraints_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeInt32uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute INT32U Value MinValue Constraints Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<uint32_t>("int32u", [value unsignedIntValue], 5UL));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeInt32uValueMaxValueConstraints_3()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeInt32uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute INT32U Value MaxValue Constraints Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            if (value != nil) {
                VerifyOrReturn(CheckConstraintMaxValue<uint32_t>("int32u", [value unsignedIntValue], 5UL));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeInt32uValueNotValueConstraints_4()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeInt32uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute INT32U Value NotValue Constraints Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            if (value != nil) {
                VerifyOrReturn(CheckConstraintNotValue("int32u", value, 6UL));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeInt32uValueBackToDefaultValue_5()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id int32uArgument;
        int32uArgument = [NSNumber numberWithUnsignedInt:0UL];
        [cluster writeAttributeInt32uWithValue:int32uArgument
                             completionHandler:^(NSError * _Nullable err) {
                                 NSLog(@"Write attribute INT32U Value Back to Default Value Error: %@", err);

                                 VerifyOrReturn(CheckValue("status", err, 0));

                                 NextTest();
                             }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeCharStringValue_6()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id charStringArgument;
        charStringArgument = @"** Test **";
        [cluster writeAttributeCharStringWithValue:charStringArgument
                                 completionHandler:^(NSError * _Nullable err) {
                                     NSLog(@"Write attribute CHAR_STRING Value Error: %@", err);

                                     VerifyOrReturn(CheckValue("status", err, 0));

                                     NextTest();
                                 }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeCharStringValueMinLengthConstraints_7()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeCharStringWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute CHAR_STRING Value MinLength Constraints Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintMinLength("charString", [value length], 5));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeCharStringValueMaxLengthConstraints_8()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeCharStringWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute CHAR_STRING Value MaxLength Constraints Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintMaxLength("charString", [value length], 20));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeCharStringValueStartsWithConstraints_9()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeCharStringWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute CHAR_STRING Value StartsWith Constraints Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintStartsWith("charString", value, "**"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeCharStringValueEndsWithConstraints_10()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeCharStringWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute CHAR_STRING Value EndsWith Constraints Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintEndsWith("charString", value, "**"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeCharStringValue_11()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id charStringArgument;
        charStringArgument = @"lowercase";
        [cluster writeAttributeCharStringWithValue:charStringArgument
                                 completionHandler:^(NSError * _Nullable err) {
                                     NSLog(@"Write attribute CHAR_STRING Value Error: %@", err);

                                     VerifyOrReturn(CheckValue("status", err, 0));

                                     NextTest();
                                 }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeCharStringValueIsLowerCaseIsUpperCaseConstraints_12()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeCharStringWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute CHAR_STRING Value isLowerCase/isUpperCase Constraints Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintIsUpperCase("charString", value, false));
            VerifyOrReturn(CheckConstraintIsLowerCase("charString", value, true));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeCharStringValue_13()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id charStringArgument;
        charStringArgument = @"UPPERCASE";
        [cluster writeAttributeCharStringWithValue:charStringArgument
                                 completionHandler:^(NSError * _Nullable err) {
                                     NSLog(@"Write attribute CHAR_STRING Value Error: %@", err);

                                     VerifyOrReturn(CheckValue("status", err, 0));

                                     NextTest();
                                 }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeCharStringValueIsLowerCaseIsUpperCaseConstraints_14()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeCharStringWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute CHAR_STRING Value isLowerCase/isUpperCase Constraints Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintIsUpperCase("charString", value, true));
            VerifyOrReturn(CheckConstraintIsLowerCase("charString", value, false));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeCharStringValue_15()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id charStringArgument;
        charStringArgument = @"lowUPPER";
        [cluster writeAttributeCharStringWithValue:charStringArgument
                                 completionHandler:^(NSError * _Nullable err) {
                                     NSLog(@"Write attribute CHAR_STRING Value Error: %@", err);

                                     VerifyOrReturn(CheckValue("status", err, 0));

                                     NextTest();
                                 }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeCharStringValueIsLowerCaseIsUpperCaseConstraints_16()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeCharStringWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute CHAR_STRING Value isLowerCase/isUpperCase Constraints Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintIsUpperCase("charString", value, false));
            VerifyOrReturn(CheckConstraintIsLowerCase("charString", value, false));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeCharStringValue_17()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id charStringArgument;
        charStringArgument = @"ABCDEF012V";
        [cluster writeAttributeCharStringWithValue:charStringArgument
                                 completionHandler:^(NSError * _Nullable err) {
                                     NSLog(@"Write attribute CHAR_STRING Value Error: %@", err);

                                     VerifyOrReturn(CheckValue("status", err, 0));

                                     NextTest();
                                 }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeCharStringValueIsHexStringConstraints_18()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeCharStringWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute CHAR_STRING Value isHexString Constraints Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintIsHexString("charString", value, false));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeCharStringValue_19()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id charStringArgument;
        charStringArgument = @"ABCDEF0123";
        [cluster writeAttributeCharStringWithValue:charStringArgument
                                 completionHandler:^(NSError * _Nullable err) {
                                     NSLog(@"Write attribute CHAR_STRING Value Error: %@", err);

                                     VerifyOrReturn(CheckValue("status", err, 0));

                                     NextTest();
                                 }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeCharStringValueIsHexStringConstraints_20()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeCharStringWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute CHAR_STRING Value isHexString Constraints Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintIsHexString("charString", value, true));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteAttributeCharStringValueBackToDefaultValue_21()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestTestCluster * cluster = [[CHIPTestTestCluster alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id charStringArgument;
        charStringArgument = @"";
        [cluster writeAttributeCharStringWithValue:charStringArgument
                                 completionHandler:^(NSError * _Nullable err) {
                                     NSLog(@"Write attribute CHAR_STRING Value Back to Default Value Error: %@", err);

                                     VerifyOrReturn(CheckValue("status", err, 0));

                                     NextTest();
                                 }];

        return CHIP_NO_ERROR;
    }
};

class TestDelayCommands : public TestCommandBridge {
public:
    TestDelayCommands()
        : TestCommandBridge("TestDelayCommands")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~TestDelayCommands() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: TestDelayCommands\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: TestDelayCommands\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Wait 100ms\n");
            err = TestWait100ms_1();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 2;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWait100ms_1()
    {
        WaitForMs(100);
        return CHIP_NO_ERROR;
    }
};

class TestDescriptorCluster : public TestCommandBridge {
public:
    TestDescriptorCluster()
        : TestCommandBridge("TestDescriptorCluster")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~TestDescriptorCluster() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: TestDescriptorCluster\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: TestDescriptorCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read attribute Device list\n");
            err = TestReadAttributeDeviceList_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read attribute Server list\n");
            err = TestReadAttributeServerList_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read attribute Client list\n");
            err = TestReadAttributeClientList_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Read attribute Parts list\n");
            err = TestReadAttributePartsList_4();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 5;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeDeviceList_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestDescriptor * cluster = [[CHIPTestDescriptor alloc] initWithDevice:device endpoint:0 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeDeviceListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute Device list Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("device list", [actualValue count], static_cast<uint32_t>(1)));
                VerifyOrReturn(CheckValue("type", ((CHIPDescriptorClusterDeviceType *) actualValue[0]).type, 22UL));
                VerifyOrReturn(CheckValue("revision", ((CHIPDescriptorClusterDeviceType *) actualValue[0]).revision, 1U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeServerList_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestDescriptor * cluster = [[CHIPTestDescriptor alloc] initWithDevice:device endpoint:0 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeServerListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute Server list Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("server list", [actualValue count], static_cast<uint32_t>(25)));
                VerifyOrReturn(CheckValue("", actualValue[0], 3UL));
                VerifyOrReturn(CheckValue("", actualValue[1], 4UL));
                VerifyOrReturn(CheckValue("", actualValue[2], 29UL));
                VerifyOrReturn(CheckValue("", actualValue[3], 30UL));
                VerifyOrReturn(CheckValue("", actualValue[4], 31UL));
                VerifyOrReturn(CheckValue("", actualValue[5], 40UL));
                VerifyOrReturn(CheckValue("", actualValue[6], 42UL));
                VerifyOrReturn(CheckValue("", actualValue[7], 43UL));
                VerifyOrReturn(CheckValue("", actualValue[8], 44UL));
                VerifyOrReturn(CheckValue("", actualValue[9], 45UL));
                VerifyOrReturn(CheckValue("", actualValue[10], 46UL));
                VerifyOrReturn(CheckValue("", actualValue[11], 48UL));
                VerifyOrReturn(CheckValue("", actualValue[12], 49UL));
                VerifyOrReturn(CheckValue("", actualValue[13], 50UL));
                VerifyOrReturn(CheckValue("", actualValue[14], 51UL));
                VerifyOrReturn(CheckValue("", actualValue[15], 52UL));
                VerifyOrReturn(CheckValue("", actualValue[16], 53UL));
                VerifyOrReturn(CheckValue("", actualValue[17], 54UL));
                VerifyOrReturn(CheckValue("", actualValue[18], 55UL));
                VerifyOrReturn(CheckValue("", actualValue[19], 60UL));
                VerifyOrReturn(CheckValue("", actualValue[20], 62UL));
                VerifyOrReturn(CheckValue("", actualValue[21], 63UL));
                VerifyOrReturn(CheckValue("", actualValue[22], 64UL));
                VerifyOrReturn(CheckValue("", actualValue[23], 65UL));
                VerifyOrReturn(CheckValue("", actualValue[24], 1029UL));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeClientList_3()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestDescriptor * cluster = [[CHIPTestDescriptor alloc] initWithDevice:device endpoint:0 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeClientListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute Client list Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("client list", [actualValue count], static_cast<uint32_t>(1)));
                VerifyOrReturn(CheckValue("", actualValue[0], 41UL));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributePartsList_4()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestDescriptor * cluster = [[CHIPTestDescriptor alloc] initWithDevice:device endpoint:0 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributePartsListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read attribute Parts list Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("parts list", [actualValue count], static_cast<uint32_t>(2)));
                VerifyOrReturn(CheckValue("", actualValue[0], 1U));
                VerifyOrReturn(CheckValue("", actualValue[1], 2U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
};

class TestBasicInformation : public TestCommandBridge {
public:
    TestBasicInformation()
        : TestCommandBridge("TestBasicInformation")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~TestBasicInformation() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: TestBasicInformation\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: TestBasicInformation\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read location\n");
            err = TestReadLocation_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Write location\n");
            err = TestWriteLocation_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read back location\n");
            err = TestReadBackLocation_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Restore initial location value\n");
            err = TestRestoreInitialLocationValue_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Read AttributeList value\n");
            err = TestReadAttributeListValue_5();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 6;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadLocation_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestBasic * cluster = [[CHIPTestBasic alloc] initWithDevice:device endpoint:0 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeLocationWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read location Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueAsString("Location", actualValue, @"XX"));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteLocation_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestBasic * cluster = [[CHIPTestBasic alloc] initWithDevice:device endpoint:0 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id locationArgument;
        locationArgument = @"US";
        [cluster writeAttributeLocationWithValue:locationArgument
                               completionHandler:^(NSError * _Nullable err) {
                                   NSLog(@"Write location Error: %@", err);

                                   VerifyOrReturn(CheckValue("status", err, 0));

                                   NextTest();
                               }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadBackLocation_3()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestBasic * cluster = [[CHIPTestBasic alloc] initWithDevice:device endpoint:0 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeLocationWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read back location Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValueAsString("Location", actualValue, @"US"));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestRestoreInitialLocationValue_4()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestBasic * cluster = [[CHIPTestBasic alloc] initWithDevice:device endpoint:0 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id locationArgument;
        locationArgument = @"XX";
        [cluster writeAttributeLocationWithValue:locationArgument
                               completionHandler:^(NSError * _Nullable err) {
                                   NSLog(@"Restore initial location value Error: %@", err);

                                   VerifyOrReturn(CheckValue("status", err, 0));

                                   NextTest();
                               }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadAttributeListValue_5()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestBasic * cluster = [[CHIPTestBasic alloc] initWithDevice:device endpoint:0 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read AttributeList value Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("AttributeList", [actualValue count], static_cast<uint32_t>(23)));
                VerifyOrReturn(CheckValue("", actualValue[0], 0UL));
                VerifyOrReturn(CheckValue("", actualValue[1], 1UL));
                VerifyOrReturn(CheckValue("", actualValue[2], 2UL));
                VerifyOrReturn(CheckValue("", actualValue[3], 3UL));
                VerifyOrReturn(CheckValue("", actualValue[4], 4UL));
                VerifyOrReturn(CheckValue("", actualValue[5], 5UL));
                VerifyOrReturn(CheckValue("", actualValue[6], 6UL));
                VerifyOrReturn(CheckValue("", actualValue[7], 7UL));
                VerifyOrReturn(CheckValue("", actualValue[8], 8UL));
                VerifyOrReturn(CheckValue("", actualValue[9], 9UL));
                VerifyOrReturn(CheckValue("", actualValue[10], 10UL));
                VerifyOrReturn(CheckValue("", actualValue[11], 11UL));
                VerifyOrReturn(CheckValue("", actualValue[12], 12UL));
                VerifyOrReturn(CheckValue("", actualValue[13], 13UL));
                VerifyOrReturn(CheckValue("", actualValue[14], 14UL));
                VerifyOrReturn(CheckValue("", actualValue[15], 15UL));
                VerifyOrReturn(CheckValue("", actualValue[16], 16UL));
                VerifyOrReturn(CheckValue("", actualValue[17], 17UL));
                VerifyOrReturn(CheckValue("", actualValue[18], 18UL));
                VerifyOrReturn(CheckValue("", actualValue[19], 65528UL));
                VerifyOrReturn(CheckValue("", actualValue[20], 65529UL));
                VerifyOrReturn(CheckValue("", actualValue[21], 65531UL));
                VerifyOrReturn(CheckValue("", actualValue[22], 65533UL));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
};

class TestGroupsCluster : public TestCommandBridge {
public:
    TestGroupsCluster()
        : TestCommandBridge("TestGroupsCluster")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~TestGroupsCluster() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: TestGroupsCluster\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: TestGroupsCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : View Group 0 (invalid)\n");
            err = TestViewGroup0Invalid_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : View Group 1 (not found)\n");
            err = TestViewGroup1NotFound_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Add Group 1 (new)\n");
            err = TestAddGroup1New_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : View Group 1 (new)\n");
            err = TestViewGroup1New_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : View Group 2 (not found)\n");
            err = TestViewGroup2NotFound_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Get Group Membership 1 (all)\n");
            err = TestGetGroupMembership1All_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : View Group 3 (not found)\n");
            err = TestViewGroup3NotFound_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : View Group 1 (existing)\n");
            err = TestViewGroup1Existing_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Remove Group 0 (invalid)\n");
            err = TestRemoveGroup0Invalid_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Remove Group 4 (not found)\n");
            err = TestRemoveGroup4NotFound_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : View Group 1 (not removed)\n");
            err = TestViewGroup1NotRemoved_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : View Group 2 (removed)\n");
            err = TestViewGroup2Removed_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : Get Group Membership 3\n");
            err = TestGetGroupMembership3_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : Remove All\n");
            err = TestRemoveAll_14();
            break;
        case 15:
            ChipLogProgress(chipTool, " ***** Test Step 15 : View Group 1 (removed)\n");
            err = TestViewGroup1Removed_15();
            break;
        case 16:
            ChipLogProgress(chipTool, " ***** Test Step 16 : View Group 2 (still removed)\n");
            err = TestViewGroup2StillRemoved_16();
            break;
        case 17:
            ChipLogProgress(chipTool, " ***** Test Step 17 : View Group 3 (removed)\n");
            err = TestViewGroup3Removed_17();
            break;
        case 18:
            ChipLogProgress(chipTool, " ***** Test Step 18 : Get Group Membership 4\n");
            err = TestGetGroupMembership4_18();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 19;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestViewGroup0Invalid_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestGroups * cluster = [[CHIPTestGroups alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPGroupsClusterViewGroupParams alloc] init];
        params.groupId = [NSNumber numberWithUnsignedShort:0U];
        [cluster viewGroupWithParams:params
                   completionHandler:^(CHIPGroupsClusterViewGroupResponseParams * _Nullable values, NSError * _Nullable err) {
                       NSLog(@"View Group 0 (invalid) Error: %@", err);

                       VerifyOrReturn(CheckValue("status", err, 0));

                       {
                           id actualValue = values.status;
                           VerifyOrReturn(CheckValue("status", actualValue, 135));
                       }

                       {
                           id actualValue = values.groupId;
                           VerifyOrReturn(CheckValue("groupId", actualValue, 0U));
                       }

                       NextTest();
                   }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestViewGroup1NotFound_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestGroups * cluster = [[CHIPTestGroups alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPGroupsClusterViewGroupParams alloc] init];
        params.groupId = [NSNumber numberWithUnsignedShort:1U];
        [cluster viewGroupWithParams:params
                   completionHandler:^(CHIPGroupsClusterViewGroupResponseParams * _Nullable values, NSError * _Nullable err) {
                       NSLog(@"View Group 1 (not found) Error: %@", err);

                       VerifyOrReturn(CheckValue("status", err, 0));

                       {
                           id actualValue = values.status;
                           VerifyOrReturn(CheckValue("status", actualValue, 139));
                       }

                       {
                           id actualValue = values.groupId;
                           VerifyOrReturn(CheckValue("groupId", actualValue, 1U));
                       }

                       NextTest();
                   }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestAddGroup1New_3()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestGroups * cluster = [[CHIPTestGroups alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPGroupsClusterAddGroupParams alloc] init];
        params.groupId = [NSNumber numberWithUnsignedShort:1U];
        params.groupName = @"Group #1";
        [cluster addGroupWithParams:params
                  completionHandler:^(CHIPGroupsClusterAddGroupResponseParams * _Nullable values, NSError * _Nullable err) {
                      NSLog(@"Add Group 1 (new) Error: %@", err);

                      VerifyOrReturn(CheckValue("status", err, 0));

                      {
                          id actualValue = values.status;
                          VerifyOrReturn(CheckValue("status", actualValue, 0));
                      }

                      {
                          id actualValue = values.groupId;
                          VerifyOrReturn(CheckValue("groupId", actualValue, 1U));
                      }

                      NextTest();
                  }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestViewGroup1New_4()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestGroups * cluster = [[CHIPTestGroups alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPGroupsClusterViewGroupParams alloc] init];
        params.groupId = [NSNumber numberWithUnsignedShort:1U];
        [cluster viewGroupWithParams:params
                   completionHandler:^(CHIPGroupsClusterViewGroupResponseParams * _Nullable values, NSError * _Nullable err) {
                       NSLog(@"View Group 1 (new) Error: %@", err);

                       VerifyOrReturn(CheckValue("status", err, 0));

                       {
                           id actualValue = values.status;
                           VerifyOrReturn(CheckValue("status", actualValue, 0));
                       }

                       {
                           id actualValue = values.groupId;
                           VerifyOrReturn(CheckValue("groupId", actualValue, 1U));
                       }

                       {
                           id actualValue = values.groupName;
                           VerifyOrReturn(CheckValueAsString("groupName", actualValue, @"Group #1"));
                       }

                       NextTest();
                   }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestViewGroup2NotFound_5()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestGroups * cluster = [[CHIPTestGroups alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPGroupsClusterViewGroupParams alloc] init];
        params.groupId = [NSNumber numberWithUnsignedShort:4369U];
        [cluster viewGroupWithParams:params
                   completionHandler:^(CHIPGroupsClusterViewGroupResponseParams * _Nullable values, NSError * _Nullable err) {
                       NSLog(@"View Group 2 (not found) Error: %@", err);

                       VerifyOrReturn(CheckValue("status", err, 0));

                       {
                           id actualValue = values.status;
                           VerifyOrReturn(CheckValue("status", actualValue, 139));
                       }

                       {
                           id actualValue = values.groupId;
                           VerifyOrReturn(CheckValue("groupId", actualValue, 4369U));
                       }

                       NextTest();
                   }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestGetGroupMembership1All_6()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestGroups * cluster = [[CHIPTestGroups alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPGroupsClusterGetGroupMembershipParams alloc] init];
        {
            NSMutableArray * temp_0 = [[NSMutableArray alloc] init];
            params.groupList = temp_0;
        }
        [cluster getGroupMembershipWithParams:params
                            completionHandler:^(
                                CHIPGroupsClusterGetGroupMembershipResponseParams * _Nullable values, NSError * _Nullable err) {
                                NSLog(@"Get Group Membership 1 (all) Error: %@", err);

                                VerifyOrReturn(CheckValue("status", err, 0));

                                {
                                    id actualValue = values.capacity;
                                    VerifyOrReturn(CheckValueNull("capacity", actualValue));
                                }

                                {
                                    id actualValue = values.groupList;
                                    VerifyOrReturn(CheckValue("groupList", [actualValue count], static_cast<uint32_t>(1)));
                                    VerifyOrReturn(CheckValue("", actualValue[0], 1U));
                                }

                                NextTest();
                            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestViewGroup3NotFound_7()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestGroups * cluster = [[CHIPTestGroups alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPGroupsClusterViewGroupParams alloc] init];
        params.groupId = [NSNumber numberWithUnsignedShort:32767U];
        [cluster viewGroupWithParams:params
                   completionHandler:^(CHIPGroupsClusterViewGroupResponseParams * _Nullable values, NSError * _Nullable err) {
                       NSLog(@"View Group 3 (not found) Error: %@", err);

                       VerifyOrReturn(CheckValue("status", err, 0));

                       {
                           id actualValue = values.status;
                           VerifyOrReturn(CheckValue("status", actualValue, 139));
                       }

                       {
                           id actualValue = values.groupId;
                           VerifyOrReturn(CheckValue("groupId", actualValue, 32767U));
                       }

                       NextTest();
                   }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestViewGroup1Existing_8()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestGroups * cluster = [[CHIPTestGroups alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPGroupsClusterViewGroupParams alloc] init];
        params.groupId = [NSNumber numberWithUnsignedShort:1U];
        [cluster viewGroupWithParams:params
                   completionHandler:^(CHIPGroupsClusterViewGroupResponseParams * _Nullable values, NSError * _Nullable err) {
                       NSLog(@"View Group 1 (existing) Error: %@", err);

                       VerifyOrReturn(CheckValue("status", err, 0));

                       {
                           id actualValue = values.status;
                           VerifyOrReturn(CheckValue("status", actualValue, 0));
                       }

                       {
                           id actualValue = values.groupId;
                           VerifyOrReturn(CheckValue("groupId", actualValue, 1U));
                       }

                       {
                           id actualValue = values.groupName;
                           VerifyOrReturn(CheckValueAsString("groupName", actualValue, @"Group #1"));
                       }

                       NextTest();
                   }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestRemoveGroup0Invalid_9()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestGroups * cluster = [[CHIPTestGroups alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPGroupsClusterRemoveGroupParams alloc] init];
        params.groupId = [NSNumber numberWithUnsignedShort:0U];
        [cluster removeGroupWithParams:params
                     completionHandler:^(CHIPGroupsClusterRemoveGroupResponseParams * _Nullable values, NSError * _Nullable err) {
                         NSLog(@"Remove Group 0 (invalid) Error: %@", err);

                         VerifyOrReturn(CheckValue("status", err, 0));

                         {
                             id actualValue = values.status;
                             VerifyOrReturn(CheckValue("status", actualValue, 135));
                         }

                         {
                             id actualValue = values.groupId;
                             VerifyOrReturn(CheckValue("groupId", actualValue, 0U));
                         }

                         NextTest();
                     }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestRemoveGroup4NotFound_10()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestGroups * cluster = [[CHIPTestGroups alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPGroupsClusterRemoveGroupParams alloc] init];
        params.groupId = [NSNumber numberWithUnsignedShort:4U];
        [cluster removeGroupWithParams:params
                     completionHandler:^(CHIPGroupsClusterRemoveGroupResponseParams * _Nullable values, NSError * _Nullable err) {
                         NSLog(@"Remove Group 4 (not found) Error: %@", err);

                         VerifyOrReturn(CheckValue("status", err, 0));

                         {
                             id actualValue = values.status;
                             VerifyOrReturn(CheckValue("status", actualValue, 139));
                         }

                         {
                             id actualValue = values.groupId;
                             VerifyOrReturn(CheckValue("groupId", actualValue, 4U));
                         }

                         NextTest();
                     }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestViewGroup1NotRemoved_11()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestGroups * cluster = [[CHIPTestGroups alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPGroupsClusterViewGroupParams alloc] init];
        params.groupId = [NSNumber numberWithUnsignedShort:1U];
        [cluster viewGroupWithParams:params
                   completionHandler:^(CHIPGroupsClusterViewGroupResponseParams * _Nullable values, NSError * _Nullable err) {
                       NSLog(@"View Group 1 (not removed) Error: %@", err);

                       VerifyOrReturn(CheckValue("status", err, 0));

                       {
                           id actualValue = values.status;
                           VerifyOrReturn(CheckValue("status", actualValue, 0));
                       }

                       {
                           id actualValue = values.groupId;
                           VerifyOrReturn(CheckValue("groupId", actualValue, 1U));
                       }

                       {
                           id actualValue = values.groupName;
                           VerifyOrReturn(CheckValueAsString("groupName", actualValue, @"Group #1"));
                       }

                       NextTest();
                   }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestViewGroup2Removed_12()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestGroups * cluster = [[CHIPTestGroups alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPGroupsClusterViewGroupParams alloc] init];
        params.groupId = [NSNumber numberWithUnsignedShort:4369U];
        [cluster viewGroupWithParams:params
                   completionHandler:^(CHIPGroupsClusterViewGroupResponseParams * _Nullable values, NSError * _Nullable err) {
                       NSLog(@"View Group 2 (removed) Error: %@", err);

                       VerifyOrReturn(CheckValue("status", err, 0));

                       {
                           id actualValue = values.status;
                           VerifyOrReturn(CheckValue("status", actualValue, 139));
                       }

                       {
                           id actualValue = values.groupId;
                           VerifyOrReturn(CheckValue("groupId", actualValue, 4369U));
                       }

                       NextTest();
                   }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestGetGroupMembership3_13()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestGroups * cluster = [[CHIPTestGroups alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPGroupsClusterGetGroupMembershipParams alloc] init];
        {
            NSMutableArray * temp_0 = [[NSMutableArray alloc] init];
            temp_0[0] = [NSNumber numberWithUnsignedShort:1U];
            temp_0[1] = [NSNumber numberWithUnsignedShort:2U];
            temp_0[2] = [NSNumber numberWithUnsignedShort:4369U];
            temp_0[3] = [NSNumber numberWithUnsignedShort:3U];
            params.groupList = temp_0;
        }
        [cluster getGroupMembershipWithParams:params
                            completionHandler:^(
                                CHIPGroupsClusterGetGroupMembershipResponseParams * _Nullable values, NSError * _Nullable err) {
                                NSLog(@"Get Group Membership 3 Error: %@", err);

                                VerifyOrReturn(CheckValue("status", err, 0));

                                {
                                    id actualValue = values.capacity;
                                    VerifyOrReturn(CheckValueNull("capacity", actualValue));
                                }

                                {
                                    id actualValue = values.groupList;
                                    VerifyOrReturn(CheckValue("groupList", [actualValue count], static_cast<uint32_t>(1)));
                                    VerifyOrReturn(CheckValue("", actualValue[0], 1U));
                                }

                                NextTest();
                            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestRemoveAll_14()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestGroups * cluster = [[CHIPTestGroups alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster removeAllGroupsWithCompletionHandler:^(NSError * _Nullable err) {
            NSLog(@"Remove All Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestViewGroup1Removed_15()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestGroups * cluster = [[CHIPTestGroups alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPGroupsClusterViewGroupParams alloc] init];
        params.groupId = [NSNumber numberWithUnsignedShort:1U];
        [cluster viewGroupWithParams:params
                   completionHandler:^(CHIPGroupsClusterViewGroupResponseParams * _Nullable values, NSError * _Nullable err) {
                       NSLog(@"View Group 1 (removed) Error: %@", err);

                       VerifyOrReturn(CheckValue("status", err, 0));

                       {
                           id actualValue = values.status;
                           VerifyOrReturn(CheckValue("status", actualValue, 139));
                       }

                       {
                           id actualValue = values.groupId;
                           VerifyOrReturn(CheckValue("groupId", actualValue, 1U));
                       }

                       NextTest();
                   }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestViewGroup2StillRemoved_16()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestGroups * cluster = [[CHIPTestGroups alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPGroupsClusterViewGroupParams alloc] init];
        params.groupId = [NSNumber numberWithUnsignedShort:4369U];
        [cluster viewGroupWithParams:params
                   completionHandler:^(CHIPGroupsClusterViewGroupResponseParams * _Nullable values, NSError * _Nullable err) {
                       NSLog(@"View Group 2 (still removed) Error: %@", err);

                       VerifyOrReturn(CheckValue("status", err, 0));

                       {
                           id actualValue = values.status;
                           VerifyOrReturn(CheckValue("status", actualValue, 139));
                       }

                       {
                           id actualValue = values.groupId;
                           VerifyOrReturn(CheckValue("groupId", actualValue, 4369U));
                       }

                       NextTest();
                   }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestViewGroup3Removed_17()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestGroups * cluster = [[CHIPTestGroups alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPGroupsClusterViewGroupParams alloc] init];
        params.groupId = [NSNumber numberWithUnsignedShort:32767U];
        [cluster viewGroupWithParams:params
                   completionHandler:^(CHIPGroupsClusterViewGroupResponseParams * _Nullable values, NSError * _Nullable err) {
                       NSLog(@"View Group 3 (removed) Error: %@", err);

                       VerifyOrReturn(CheckValue("status", err, 0));

                       {
                           id actualValue = values.status;
                           VerifyOrReturn(CheckValue("status", actualValue, 139));
                       }

                       {
                           id actualValue = values.groupId;
                           VerifyOrReturn(CheckValue("groupId", actualValue, 32767U));
                       }

                       NextTest();
                   }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestGetGroupMembership4_18()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestGroups * cluster = [[CHIPTestGroups alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPGroupsClusterGetGroupMembershipParams alloc] init];
        {
            NSMutableArray * temp_0 = [[NSMutableArray alloc] init];
            temp_0[0] = [NSNumber numberWithUnsignedShort:1U];
            temp_0[1] = [NSNumber numberWithUnsignedShort:2U];
            temp_0[2] = [NSNumber numberWithUnsignedShort:4369U];
            temp_0[3] = [NSNumber numberWithUnsignedShort:3U];
            temp_0[4] = [NSNumber numberWithUnsignedShort:32767U];
            params.groupList = temp_0;
        }
        [cluster getGroupMembershipWithParams:params
                            completionHandler:^(
                                CHIPGroupsClusterGetGroupMembershipResponseParams * _Nullable values, NSError * _Nullable err) {
                                NSLog(@"Get Group Membership 4 Error: %@", err);

                                VerifyOrReturn(CheckValue("status", err, 0));

                                {
                                    id actualValue = values.capacity;
                                    VerifyOrReturn(CheckValueNull("capacity", actualValue));
                                }

                                {
                                    id actualValue = values.groupList;
                                    VerifyOrReturn(CheckValue("groupList", [actualValue count], static_cast<uint32_t>(0)));
                                }

                                NextTest();
                            }];

        return CHIP_NO_ERROR;
    }
};

class TestGroupKeyManagementCluster : public TestCommandBridge {
public:
    TestGroupKeyManagementCluster()
        : TestCommandBridge("TestGroupKeyManagementCluster")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~TestGroupKeyManagementCluster() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: TestGroupKeyManagementCluster\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: TestGroupKeyManagementCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read maxGroupsPerFabric\n");
            err = TestReadMaxGroupsPerFabric_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read maxGroupKeysPerFabric\n");
            err = TestReadMaxGroupKeysPerFabric_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Add Group 1\n");
            err = TestAddGroup1_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Add Group 2\n");
            err = TestAddGroup2_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : KeySet Write 1\n");
            err = TestKeySetWrite1_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : KeySet Write 2\n");
            err = TestKeySetWrite2_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : KeySet Read\n");
            err = TestKeySetRead_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Write Group Keys\n");
            err = TestWriteGroupKeys_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Read Group Keys\n");
            err = TestReadGroupKeys_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Read GroupTable\n");
            err = TestReadGroupTable_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : KeySet Remove 1\n");
            err = TestKeySetRemove1_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : KeySet Read (removed)\n");
            err = TestKeySetReadRemoved_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : KeySet Read (not removed)\n");
            err = TestKeySetReadNotRemoved_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : Remove All\n");
            err = TestRemoveAll_14();
            break;
        case 15:
            ChipLogProgress(chipTool, " ***** Test Step 15 : KeySet Remove 2\n");
            err = TestKeySetRemove2_15();
            break;
        case 16:
            ChipLogProgress(chipTool, " ***** Test Step 16 : KeySet Read (also removed)\n");
            err = TestKeySetReadAlsoRemoved_16();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 17;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadMaxGroupsPerFabric_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestGroupKeyManagement * cluster = [[CHIPTestGroupKeyManagement alloc] initWithDevice:device
                                                                                         endpoint:0
                                                                                            queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeMaxGroupsPerFabricWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read maxGroupsPerFabric Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<uint16_t>("maxGroupsPerFabric", [value unsignedShortValue], 2U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadMaxGroupKeysPerFabric_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestGroupKeyManagement * cluster = [[CHIPTestGroupKeyManagement alloc] initWithDevice:device
                                                                                         endpoint:0
                                                                                            queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeMaxGroupKeysPerFabricWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read maxGroupKeysPerFabric Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("MaxGroupKeysPerFabric", actualValue, 2U));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestAddGroup1_3()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestGroups * cluster = [[CHIPTestGroups alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPGroupsClusterAddGroupParams alloc] init];
        params.groupId = [NSNumber numberWithUnsignedShort:257U];
        params.groupName = @"Group #1";
        [cluster addGroupWithParams:params
                  completionHandler:^(CHIPGroupsClusterAddGroupResponseParams * _Nullable values, NSError * _Nullable err) {
                      NSLog(@"Add Group 1 Error: %@", err);

                      VerifyOrReturn(CheckValue("status", err, 0));

                      {
                          id actualValue = values.status;
                          VerifyOrReturn(CheckValue("status", actualValue, 0));
                      }

                      {
                          id actualValue = values.groupId;
                          VerifyOrReturn(CheckValue("groupId", actualValue, 257U));
                      }

                      NextTest();
                  }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestAddGroup2_4()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestGroups * cluster = [[CHIPTestGroups alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPGroupsClusterAddGroupParams alloc] init];
        params.groupId = [NSNumber numberWithUnsignedShort:258U];
        params.groupName = @"Group #2";
        [cluster addGroupWithParams:params
                  completionHandler:^(CHIPGroupsClusterAddGroupResponseParams * _Nullable values, NSError * _Nullable err) {
                      NSLog(@"Add Group 2 Error: %@", err);

                      VerifyOrReturn(CheckValue("status", err, 0));

                      {
                          id actualValue = values.status;
                          VerifyOrReturn(CheckValue("status", actualValue, 0));
                      }

                      {
                          id actualValue = values.groupId;
                          VerifyOrReturn(CheckValue("groupId", actualValue, 258U));
                      }

                      NextTest();
                  }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestKeySetWrite1_5()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestGroupKeyManagement * cluster = [[CHIPTestGroupKeyManagement alloc] initWithDevice:device
                                                                                         endpoint:0
                                                                                            queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPGroupKeyManagementClusterKeySetWriteParams alloc] init];
        params.groupKeySet = [[CHIPGroupKeyManagementClusterGroupKeySetStruct alloc] init];
        ((CHIPGroupKeyManagementClusterGroupKeySetStruct *) params.groupKeySet).groupKeySetID =
            [NSNumber numberWithUnsignedShort:417U];
        ((CHIPGroupKeyManagementClusterGroupKeySetStruct *) params.groupKeySet).groupKeySecurityPolicy =
            [NSNumber numberWithUnsignedChar:0];
        ((CHIPGroupKeyManagementClusterGroupKeySetStruct *) params.groupKeySet).epochKey0 =
            [[NSData alloc] initWithBytes:"\240\241\242\243\244\245\246\247\250\251\252\253\254\255\256\257" length:16];
        ((CHIPGroupKeyManagementClusterGroupKeySetStruct *) params.groupKeySet).epochStartTime0 =
            [NSNumber numberWithUnsignedLongLong:1110000ULL];
        ((CHIPGroupKeyManagementClusterGroupKeySetStruct *) params.groupKeySet).epochKey1 =
            [[NSData alloc] initWithBytes:"\260\261\262\263\264\265\266\267\270\271\272\273\274\275\276\277" length:16];
        ((CHIPGroupKeyManagementClusterGroupKeySetStruct *) params.groupKeySet).epochStartTime1 =
            [NSNumber numberWithUnsignedLongLong:1110001ULL];
        ((CHIPGroupKeyManagementClusterGroupKeySetStruct *) params.groupKeySet).epochKey2 =
            [[NSData alloc] initWithBytes:"\300\301\302\303\304\305\306\307\310\311\312\313\314\315\316\317" length:16];
        ((CHIPGroupKeyManagementClusterGroupKeySetStruct *) params.groupKeySet).epochStartTime2 =
            [NSNumber numberWithUnsignedLongLong:1110002ULL];

        [cluster keySetWriteWithParams:params
                     completionHandler:^(NSError * _Nullable err) {
                         NSLog(@"KeySet Write 1 Error: %@", err);

                         VerifyOrReturn(CheckValue("status", err, 0));

                         NextTest();
                     }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestKeySetWrite2_6()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestGroupKeyManagement * cluster = [[CHIPTestGroupKeyManagement alloc] initWithDevice:device
                                                                                         endpoint:0
                                                                                            queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPGroupKeyManagementClusterKeySetWriteParams alloc] init];
        params.groupKeySet = [[CHIPGroupKeyManagementClusterGroupKeySetStruct alloc] init];
        ((CHIPGroupKeyManagementClusterGroupKeySetStruct *) params.groupKeySet).groupKeySetID =
            [NSNumber numberWithUnsignedShort:418U];
        ((CHIPGroupKeyManagementClusterGroupKeySetStruct *) params.groupKeySet).groupKeySecurityPolicy =
            [NSNumber numberWithUnsignedChar:1];
        ((CHIPGroupKeyManagementClusterGroupKeySetStruct *) params.groupKeySet).epochKey0 =
            [[NSData alloc] initWithBytes:"\320\321\322\323\324\325\326\327\330\331\332\333\334\335\336\337" length:16];
        ((CHIPGroupKeyManagementClusterGroupKeySetStruct *) params.groupKeySet).epochStartTime0 =
            [NSNumber numberWithUnsignedLongLong:2110000ULL];
        ((CHIPGroupKeyManagementClusterGroupKeySetStruct *) params.groupKeySet).epochKey1 =
            [[NSData alloc] initWithBytes:"\340\341\342\343\344\345\346\347\350\351\352\353\354\355\356\357" length:16];
        ((CHIPGroupKeyManagementClusterGroupKeySetStruct *) params.groupKeySet).epochStartTime1 =
            [NSNumber numberWithUnsignedLongLong:2110001ULL];
        ((CHIPGroupKeyManagementClusterGroupKeySetStruct *) params.groupKeySet).epochKey2 =
            [[NSData alloc] initWithBytes:"\360\361\362\363\364\365\366\367\370\371\372\373\374\375\376\377" length:16];
        ((CHIPGroupKeyManagementClusterGroupKeySetStruct *) params.groupKeySet).epochStartTime2 =
            [NSNumber numberWithUnsignedLongLong:2110002ULL];

        [cluster keySetWriteWithParams:params
                     completionHandler:^(NSError * _Nullable err) {
                         NSLog(@"KeySet Write 2 Error: %@", err);

                         VerifyOrReturn(CheckValue("status", err, 0));

                         NextTest();
                     }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestKeySetRead_7()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestGroupKeyManagement * cluster = [[CHIPTestGroupKeyManagement alloc] initWithDevice:device
                                                                                         endpoint:0
                                                                                            queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPGroupKeyManagementClusterKeySetReadParams alloc] init];
        params.groupKeySetID = [NSNumber numberWithUnsignedShort:417U];
        [cluster
            keySetReadWithParams:params
               completionHandler:^(
                   CHIPGroupKeyManagementClusterKeySetReadResponseParams * _Nullable values, NSError * _Nullable err) {
                   NSLog(@"KeySet Read Error: %@", err);

                   VerifyOrReturn(CheckValue("status", err, 0));

                   {
                       id actualValue = values.groupKeySet;
                       VerifyOrReturn(CheckValue(
                           "GroupKeySetID", ((CHIPGroupKeyManagementClusterGroupKeySetStruct *) actualValue).groupKeySetID, 417U));
                       VerifyOrReturn(CheckValue("GroupKeySecurityPolicy",
                           ((CHIPGroupKeyManagementClusterGroupKeySetStruct *) actualValue).groupKeySecurityPolicy, 0));
                       VerifyOrReturn(
                           CheckValueNull("EpochKey0", ((CHIPGroupKeyManagementClusterGroupKeySetStruct *) actualValue).epochKey0));
                       VerifyOrReturn(CheckValueNonNull(
                           "EpochStartTime0", ((CHIPGroupKeyManagementClusterGroupKeySetStruct *) actualValue).epochStartTime0));
                       VerifyOrReturn(CheckValue("EpochStartTime0",
                           ((CHIPGroupKeyManagementClusterGroupKeySetStruct *) actualValue).epochStartTime0, 1110000ULL));
                       VerifyOrReturn(
                           CheckValueNull("EpochKey1", ((CHIPGroupKeyManagementClusterGroupKeySetStruct *) actualValue).epochKey1));
                       VerifyOrReturn(CheckValueNonNull(
                           "EpochStartTime1", ((CHIPGroupKeyManagementClusterGroupKeySetStruct *) actualValue).epochStartTime1));
                       VerifyOrReturn(CheckValue("EpochStartTime1",
                           ((CHIPGroupKeyManagementClusterGroupKeySetStruct *) actualValue).epochStartTime1, 1110001ULL));
                       VerifyOrReturn(
                           CheckValueNull("EpochKey2", ((CHIPGroupKeyManagementClusterGroupKeySetStruct *) actualValue).epochKey2));
                       VerifyOrReturn(CheckValueNonNull(
                           "EpochStartTime2", ((CHIPGroupKeyManagementClusterGroupKeySetStruct *) actualValue).epochStartTime2));
                       VerifyOrReturn(CheckValue("EpochStartTime2",
                           ((CHIPGroupKeyManagementClusterGroupKeySetStruct *) actualValue).epochStartTime2, 1110002ULL));
                   }

                   NextTest();
               }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteGroupKeys_8()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestGroupKeyManagement * cluster = [[CHIPTestGroupKeyManagement alloc] initWithDevice:device
                                                                                         endpoint:0
                                                                                            queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id groupKeyMapArgument;
        {
            NSMutableArray * temp_0 = [[NSMutableArray alloc] init];
            temp_0[0] = [[CHIPGroupKeyManagementClusterGroupKeyMapStruct alloc] init];
            ((CHIPGroupKeyManagementClusterGroupKeyMapStruct *) temp_0[0]).groupId = [NSNumber numberWithUnsignedShort:257U];
            ((CHIPGroupKeyManagementClusterGroupKeyMapStruct *) temp_0[0]).groupKeySetID = [NSNumber numberWithUnsignedShort:417U];
            ((CHIPGroupKeyManagementClusterGroupKeyMapStruct *) temp_0[0]).fabricIndex = [NSNumber numberWithUnsignedChar:1];

            temp_0[1] = [[CHIPGroupKeyManagementClusterGroupKeyMapStruct alloc] init];
            ((CHIPGroupKeyManagementClusterGroupKeyMapStruct *) temp_0[1]).groupId = [NSNumber numberWithUnsignedShort:258U];
            ((CHIPGroupKeyManagementClusterGroupKeyMapStruct *) temp_0[1]).groupKeySetID = [NSNumber numberWithUnsignedShort:418U];
            ((CHIPGroupKeyManagementClusterGroupKeyMapStruct *) temp_0[1]).fabricIndex = [NSNumber numberWithUnsignedChar:1];

            groupKeyMapArgument = temp_0;
        }
        [cluster writeAttributeGroupKeyMapWithValue:groupKeyMapArgument
                                  completionHandler:^(NSError * _Nullable err) {
                                      NSLog(@"Write Group Keys Error: %@", err);

                                      VerifyOrReturn(CheckValue("status", err, 0));

                                      NextTest();
                                  }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadGroupKeys_9()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestGroupKeyManagement * cluster = [[CHIPTestGroupKeyManagement alloc] initWithDevice:device
                                                                                         endpoint:0
                                                                                            queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        CHIPReadParams * params = [[CHIPReadParams alloc] init];
        params.fabricFiltered = [NSNumber numberWithBool:true];
        [cluster
            readAttributeGroupKeyMapWithParams:params
                             completionHandler:^(NSArray * _Nullable value, NSError * _Nullable err) {
                                 NSLog(@"Read Group Keys Error: %@", err);

                                 VerifyOrReturn(CheckValue("status", err, 0));

                                 {
                                     id actualValue = value;
                                     VerifyOrReturn(CheckValue("GroupKeyMap", [actualValue count], static_cast<uint32_t>(2)));
                                     VerifyOrReturn(CheckValue("GroupId",
                                         ((CHIPGroupKeyManagementClusterGroupKeyMapStruct *) actualValue[0]).groupId, 257U));
                                     VerifyOrReturn(CheckValue("GroupKeySetID",
                                         ((CHIPGroupKeyManagementClusterGroupKeyMapStruct *) actualValue[0]).groupKeySetID, 417U));
                                     VerifyOrReturn(CheckValue("FabricIndex",
                                         ((CHIPGroupKeyManagementClusterGroupKeyMapStruct *) actualValue[0]).fabricIndex, 1));
                                     VerifyOrReturn(CheckValue("GroupId",
                                         ((CHIPGroupKeyManagementClusterGroupKeyMapStruct *) actualValue[1]).groupId, 258U));
                                     VerifyOrReturn(CheckValue("GroupKeySetID",
                                         ((CHIPGroupKeyManagementClusterGroupKeyMapStruct *) actualValue[1]).groupKeySetID, 418U));
                                     VerifyOrReturn(CheckValue("FabricIndex",
                                         ((CHIPGroupKeyManagementClusterGroupKeyMapStruct *) actualValue[1]).fabricIndex, 1));
                                 }

                                 NextTest();
                             }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadGroupTable_10()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestGroupKeyManagement * cluster = [[CHIPTestGroupKeyManagement alloc] initWithDevice:device
                                                                                         endpoint:0
                                                                                            queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        CHIPReadParams * params = [[CHIPReadParams alloc] init];
        params.fabricFiltered = [NSNumber numberWithBool:true];
        [cluster readAttributeGroupTableWithParams:params
                                 completionHandler:^(NSArray * _Nullable value, NSError * _Nullable err) {
                                     NSLog(@"Read GroupTable Error: %@", err);

                                     VerifyOrReturn(CheckValue("status", err, 0));

                                     {
                                         id actualValue = value;
                                         VerifyOrReturn(CheckValue("GroupTable", [actualValue count], static_cast<uint32_t>(2)));
                                         VerifyOrReturn(CheckValue("GroupId",
                                             ((CHIPGroupKeyManagementClusterGroupInfoMapStruct *) actualValue[0]).groupId, 257U));
                                         VerifyOrReturn(CheckValueAsString("GroupName",
                                             ((CHIPGroupKeyManagementClusterGroupInfoMapStruct *) actualValue[0]).groupName,
                                             @"Group #1"));
                                         VerifyOrReturn(CheckValue("FabricIndex",
                                             ((CHIPGroupKeyManagementClusterGroupInfoMapStruct *) actualValue[0]).fabricIndex, 1));
                                         VerifyOrReturn(CheckValue("GroupId",
                                             ((CHIPGroupKeyManagementClusterGroupInfoMapStruct *) actualValue[1]).groupId, 258U));
                                         VerifyOrReturn(CheckValueAsString("GroupName",
                                             ((CHIPGroupKeyManagementClusterGroupInfoMapStruct *) actualValue[1]).groupName,
                                             @"Group #2"));
                                         VerifyOrReturn(CheckValue("FabricIndex",
                                             ((CHIPGroupKeyManagementClusterGroupInfoMapStruct *) actualValue[1]).fabricIndex, 1));
                                     }

                                     NextTest();
                                 }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestKeySetRemove1_11()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestGroupKeyManagement * cluster = [[CHIPTestGroupKeyManagement alloc] initWithDevice:device
                                                                                         endpoint:0
                                                                                            queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPGroupKeyManagementClusterKeySetRemoveParams alloc] init];
        params.groupKeySetID = [NSNumber numberWithUnsignedShort:417U];
        [cluster keySetRemoveWithParams:params
                      completionHandler:^(NSError * _Nullable err) {
                          NSLog(@"KeySet Remove 1 Error: %@", err);

                          VerifyOrReturn(CheckValue("status", err, 0));

                          NextTest();
                      }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestKeySetReadRemoved_12()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestGroupKeyManagement * cluster = [[CHIPTestGroupKeyManagement alloc] initWithDevice:device
                                                                                         endpoint:0
                                                                                            queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPGroupKeyManagementClusterKeySetReadParams alloc] init];
        params.groupKeySetID = [NSNumber numberWithUnsignedShort:417U];
        [cluster keySetReadWithParams:params
                    completionHandler:^(
                        CHIPGroupKeyManagementClusterKeySetReadResponseParams * _Nullable values, NSError * _Nullable err) {
                        NSLog(@"KeySet Read (removed) Error: %@", err);

                        VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_NOT_FOUND));
                        NextTest();
                    }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestKeySetReadNotRemoved_13()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestGroupKeyManagement * cluster = [[CHIPTestGroupKeyManagement alloc] initWithDevice:device
                                                                                         endpoint:0
                                                                                            queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPGroupKeyManagementClusterKeySetReadParams alloc] init];
        params.groupKeySetID = [NSNumber numberWithUnsignedShort:418U];
        [cluster
            keySetReadWithParams:params
               completionHandler:^(
                   CHIPGroupKeyManagementClusterKeySetReadResponseParams * _Nullable values, NSError * _Nullable err) {
                   NSLog(@"KeySet Read (not removed) Error: %@", err);

                   VerifyOrReturn(CheckValue("status", err, 0));

                   {
                       id actualValue = values.groupKeySet;
                       VerifyOrReturn(CheckValue(
                           "GroupKeySetID", ((CHIPGroupKeyManagementClusterGroupKeySetStruct *) actualValue).groupKeySetID, 418U));
                       VerifyOrReturn(CheckValue("GroupKeySecurityPolicy",
                           ((CHIPGroupKeyManagementClusterGroupKeySetStruct *) actualValue).groupKeySecurityPolicy, 1));
                       VerifyOrReturn(
                           CheckValueNull("EpochKey0", ((CHIPGroupKeyManagementClusterGroupKeySetStruct *) actualValue).epochKey0));
                       VerifyOrReturn(CheckValueNonNull(
                           "EpochStartTime0", ((CHIPGroupKeyManagementClusterGroupKeySetStruct *) actualValue).epochStartTime0));
                       VerifyOrReturn(CheckValue("EpochStartTime0",
                           ((CHIPGroupKeyManagementClusterGroupKeySetStruct *) actualValue).epochStartTime0, 2110000ULL));
                       VerifyOrReturn(
                           CheckValueNull("EpochKey1", ((CHIPGroupKeyManagementClusterGroupKeySetStruct *) actualValue).epochKey1));
                       VerifyOrReturn(CheckValueNonNull(
                           "EpochStartTime1", ((CHIPGroupKeyManagementClusterGroupKeySetStruct *) actualValue).epochStartTime1));
                       VerifyOrReturn(CheckValue("EpochStartTime1",
                           ((CHIPGroupKeyManagementClusterGroupKeySetStruct *) actualValue).epochStartTime1, 2110001ULL));
                       VerifyOrReturn(
                           CheckValueNull("EpochKey2", ((CHIPGroupKeyManagementClusterGroupKeySetStruct *) actualValue).epochKey2));
                       VerifyOrReturn(CheckValueNonNull(
                           "EpochStartTime2", ((CHIPGroupKeyManagementClusterGroupKeySetStruct *) actualValue).epochStartTime2));
                       VerifyOrReturn(CheckValue("EpochStartTime2",
                           ((CHIPGroupKeyManagementClusterGroupKeySetStruct *) actualValue).epochStartTime2, 2110002ULL));
                   }

                   NextTest();
               }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestRemoveAll_14()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestGroups * cluster = [[CHIPTestGroups alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster removeAllGroupsWithCompletionHandler:^(NSError * _Nullable err) {
            NSLog(@"Remove All Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestKeySetRemove2_15()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestGroupKeyManagement * cluster = [[CHIPTestGroupKeyManagement alloc] initWithDevice:device
                                                                                         endpoint:0
                                                                                            queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPGroupKeyManagementClusterKeySetRemoveParams alloc] init];
        params.groupKeySetID = [NSNumber numberWithUnsignedShort:418U];
        [cluster keySetRemoveWithParams:params
                      completionHandler:^(NSError * _Nullable err) {
                          NSLog(@"KeySet Remove 2 Error: %@", err);

                          VerifyOrReturn(CheckValue("status", err, 0));

                          NextTest();
                      }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestKeySetReadAlsoRemoved_16()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestGroupKeyManagement * cluster = [[CHIPTestGroupKeyManagement alloc] initWithDevice:device
                                                                                         endpoint:0
                                                                                            queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPGroupKeyManagementClusterKeySetReadParams alloc] init];
        params.groupKeySetID = [NSNumber numberWithUnsignedShort:418U];
        [cluster keySetReadWithParams:params
                    completionHandler:^(
                        CHIPGroupKeyManagementClusterKeySetReadResponseParams * _Nullable values, NSError * _Nullable err) {
                        NSLog(@"KeySet Read (also removed) Error: %@", err);

                        VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_NOT_FOUND));
                        NextTest();
                    }];

        return CHIP_NO_ERROR;
    }
};

class TestIdentifyCluster : public TestCommandBridge {
public:
    TestIdentifyCluster()
        : TestCommandBridge("TestIdentifyCluster")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~TestIdentifyCluster() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: TestIdentifyCluster\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: TestIdentifyCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Send Identify command and expect success response\n");
            err = TestSendIdentifyCommandAndExpectSuccessResponse_1();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 2;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSendIdentifyCommandAndExpectSuccessResponse_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestIdentify * cluster = [[CHIPTestIdentify alloc] initWithDevice:device endpoint:0 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPIdentifyClusterIdentifyParams alloc] init];
        params.identifyTime = [NSNumber numberWithUnsignedShort:0U];
        [cluster identifyWithParams:params
                  completionHandler:^(NSError * _Nullable err) {
                      NSLog(@"Send Identify command and expect success response Error: %@", err);

                      VerifyOrReturn(CheckValue("status", err, 0));

                      NextTest();
                  }];

        return CHIP_NO_ERROR;
    }
};

class TestLogCommands : public TestCommandBridge {
public:
    TestLogCommands()
        : TestCommandBridge("TestLogCommands")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~TestLogCommands() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: TestLogCommands\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: TestLogCommands\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Log a simple message\n");
            err = TestLogASimpleMessage_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Do a simple user prompt message\n");
            err = TestDoASimpleUserPromptMessage_2();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 3;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestLogASimpleMessage_1()
    {
        Log(@"This is a simple message");
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestDoASimpleUserPromptMessage_2()
    {
        UserPrompt(@"This is a simple message");
        return CHIP_NO_ERROR;
    }
};

class TestOperationalCredentialsCluster : public TestCommandBridge {
public:
    TestOperationalCredentialsCluster()
        : TestCommandBridge("TestOperationalCredentialsCluster")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~TestOperationalCredentialsCluster() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: TestOperationalCredentialsCluster\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: TestOperationalCredentialsCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read number of supported fabrics\n");
            err = TestReadNumberOfSupportedFabrics_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read number of commissioned fabrics\n");
            err = TestReadNumberOfCommissionedFabrics_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read current fabric index\n");
            err = TestReadCurrentFabricIndex_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Remove nonexistent fabric\n");
            err = TestRemoveNonexistentFabric_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Read fabric list before setting label\n");
            err = TestReadFabricListBeforeSettingLabel_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Set the fabric label\n");
            err = TestSetTheFabricLabel_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Read fabric list after setting label\n");
            err = TestReadFabricListAfterSettingLabel_7();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 8;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadNumberOfSupportedFabrics_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOperationalCredentials * cluster = [[CHIPTestOperationalCredentials alloc] initWithDevice:device
                                                                                                 endpoint:0
                                                                                                    queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeSupportedFabricsWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read number of supported fabrics Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("supportedFabrics", "", "uint8"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<uint8_t>("supportedFabrics", [value unsignedCharValue], 4));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadNumberOfCommissionedFabrics_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOperationalCredentials * cluster = [[CHIPTestOperationalCredentials alloc] initWithDevice:device
                                                                                                 endpoint:0
                                                                                                    queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeCommissionedFabricsWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read number of commissioned fabrics Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("commissionedFabrics", "", "uint8"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<uint8_t>("commissionedFabrics", [value unsignedCharValue], 1));
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
    NSNumber * _Nonnull ourFabricIndex;

    CHIP_ERROR TestReadCurrentFabricIndex_3()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOperationalCredentials * cluster = [[CHIPTestOperationalCredentials alloc] initWithDevice:device
                                                                                                 endpoint:0
                                                                                                    queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeCurrentFabricIndexWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Read current fabric index Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("currentFabricIndex", "", "uint8"));
            if (value != nil) {
                VerifyOrReturn(CheckConstraintMinValue<chip::FabricIndex>("currentFabricIndex", [value unsignedCharValue], 1));
            }
            {
                ourFabricIndex = value;
            }

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestRemoveNonexistentFabric_4()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOperationalCredentials * cluster = [[CHIPTestOperationalCredentials alloc] initWithDevice:device
                                                                                                 endpoint:0
                                                                                                    queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPOperationalCredentialsClusterRemoveFabricParams alloc] init];
        params.fabricIndex = [NSNumber numberWithUnsignedChar:243];
        [cluster removeFabricWithParams:params
                      completionHandler:^(
                          CHIPOperationalCredentialsClusterNOCResponseParams * _Nullable values, NSError * _Nullable err) {
                          NSLog(@"Remove nonexistent fabric Error: %@", err);

                          VerifyOrReturn(CheckValue("status", err, 0));

                          {
                              id actualValue = values.statusCode;
                              VerifyOrReturn(CheckValue("StatusCode", actualValue, 11));
                          }

                          NextTest();
                      }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadFabricListBeforeSettingLabel_5()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOperationalCredentials * cluster = [[CHIPTestOperationalCredentials alloc] initWithDevice:device
                                                                                                 endpoint:0
                                                                                                    queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        CHIPReadParams * params = [[CHIPReadParams alloc] init];
        params.fabricFiltered = [NSNumber numberWithBool:true];
        [cluster readAttributeFabricsWithParams:params
                              completionHandler:^(NSArray * _Nullable value, NSError * _Nullable err) {
                                  NSLog(@"Read fabric list before setting label Error: %@", err);

                                  VerifyOrReturn(CheckValue("status", err, 0));

                                  {
                                      id actualValue = value;
                                      VerifyOrReturn(CheckValue("Fabrics", [actualValue count], static_cast<uint32_t>(1)));
                                      VerifyOrReturn(CheckValueAsString("Label",
                                          ((CHIPOperationalCredentialsClusterFabricDescriptor *) actualValue[0]).label, @""));
                                      VerifyOrReturn(CheckValue("FabricIndex",
                                          ((CHIPOperationalCredentialsClusterFabricDescriptor *) actualValue[0]).fabricIndex,
                                          ourFabricIndex));
                                  }

                                  NextTest();
                              }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSetTheFabricLabel_6()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOperationalCredentials * cluster = [[CHIPTestOperationalCredentials alloc] initWithDevice:device
                                                                                                 endpoint:0
                                                                                                    queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        __auto_type * params = [[CHIPOperationalCredentialsClusterUpdateFabricLabelParams alloc] init];
        params.label = @"Batcave";
        [cluster updateFabricLabelWithParams:params
                           completionHandler:^(
                               CHIPOperationalCredentialsClusterNOCResponseParams * _Nullable values, NSError * _Nullable err) {
                               NSLog(@"Set the fabric label Error: %@", err);

                               VerifyOrReturn(CheckValue("status", err, 0));

                               {
                                   id actualValue = values.statusCode;
                                   VerifyOrReturn(CheckValue("StatusCode", actualValue, 0));
                               }

                               {
                                   id actualValue = values.fabricIndex;
                                   VerifyOrReturn(CheckValue("FabricIndex", actualValue, ourFabricIndex));
                               }

                               NextTest();
                           }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadFabricListAfterSettingLabel_7()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOperationalCredentials * cluster = [[CHIPTestOperationalCredentials alloc] initWithDevice:device
                                                                                                 endpoint:0
                                                                                                    queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        CHIPReadParams * params = [[CHIPReadParams alloc] init];
        params.fabricFiltered = [NSNumber numberWithBool:true];
        [cluster
            readAttributeFabricsWithParams:params
                         completionHandler:^(NSArray * _Nullable value, NSError * _Nullable err) {
                             NSLog(@"Read fabric list after setting label Error: %@", err);

                             VerifyOrReturn(CheckValue("status", err, 0));

                             {
                                 id actualValue = value;
                                 VerifyOrReturn(CheckValue("Fabrics", [actualValue count], static_cast<uint32_t>(1)));
                                 VerifyOrReturn(CheckValueAsString("Label",
                                     ((CHIPOperationalCredentialsClusterFabricDescriptor *) actualValue[0]).label, @"Batcave"));
                                 VerifyOrReturn(CheckValue("FabricIndex",
                                     ((CHIPOperationalCredentialsClusterFabricDescriptor *) actualValue[0]).fabricIndex,
                                     ourFabricIndex));
                             }

                             NextTest();
                         }];

        return CHIP_NO_ERROR;
    }
};

class TestBinding : public TestCommandBridge {
public:
    TestBinding()
        : TestCommandBridge("TestBinding")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~TestBinding() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: TestBinding\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: TestBinding\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Write empty binding table\n");
            err = TestWriteEmptyBindingTable_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read empty binding table\n");
            err = TestReadEmptyBindingTable_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Write invalid binding table\n");
            err = TestWriteInvalidBindingTable_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Write binding table (endpoint 1)\n");
            err = TestWriteBindingTableEndpoint1_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Read binding table (endpoint 1)\n");
            err = TestReadBindingTableEndpoint1_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Write binding table (endpoint 0)\n");
            err = TestWriteBindingTableEndpoint0_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Read binding table (endpoint 0)\n");
            err = TestReadBindingTableEndpoint0_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Verify endpoint 1 not changed\n");
            err = TestVerifyEndpoint1NotChanged_8();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 9;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteEmptyBindingTable_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestBinding * cluster = [[CHIPTestBinding alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id bindingArgument;
        {
            NSMutableArray * temp_0 = [[NSMutableArray alloc] init];
            bindingArgument = temp_0;
        }
        [cluster writeAttributeBindingWithValue:bindingArgument
                              completionHandler:^(NSError * _Nullable err) {
                                  NSLog(@"Write empty binding table Error: %@", err);

                                  VerifyOrReturn(CheckValue("status", err, 0));

                                  NextTest();
                              }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadEmptyBindingTable_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestBinding * cluster = [[CHIPTestBinding alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        CHIPReadParams * params = [[CHIPReadParams alloc] init];
        params.fabricFiltered = [NSNumber numberWithBool:true];
        [cluster readAttributeBindingWithParams:params
                              completionHandler:^(NSArray * _Nullable value, NSError * _Nullable err) {
                                  NSLog(@"Read empty binding table Error: %@", err);

                                  VerifyOrReturn(CheckValue("status", err, 0));

                                  {
                                      id actualValue = value;
                                      VerifyOrReturn(CheckValue("Binding", [actualValue count], static_cast<uint32_t>(0)));
                                  }

                                  NextTest();
                              }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteInvalidBindingTable_3()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestBinding * cluster = [[CHIPTestBinding alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id bindingArgument;
        {
            NSMutableArray * temp_0 = [[NSMutableArray alloc] init];
            temp_0[0] = [[CHIPBindingClusterTargetStruct alloc] init];
            ((CHIPBindingClusterTargetStruct *) temp_0[0]).fabricIndex = [NSNumber numberWithUnsignedChar:0];

            temp_0[1] = [[CHIPBindingClusterTargetStruct alloc] init];
            ((CHIPBindingClusterTargetStruct *) temp_0[1]).node = [NSNumber numberWithUnsignedLongLong:1ULL];
            ((CHIPBindingClusterTargetStruct *) temp_0[1]).group = [NSNumber numberWithUnsignedShort:1U];
            ((CHIPBindingClusterTargetStruct *) temp_0[1]).endpoint = [NSNumber numberWithUnsignedShort:1U];
            ((CHIPBindingClusterTargetStruct *) temp_0[1]).cluster = [NSNumber numberWithUnsignedInt:6UL];
            ((CHIPBindingClusterTargetStruct *) temp_0[1]).fabricIndex = [NSNumber numberWithUnsignedChar:0];

            bindingArgument = temp_0;
        }
        [cluster writeAttributeBindingWithValue:bindingArgument
                              completionHandler:^(NSError * _Nullable err) {
                                  NSLog(@"Write invalid binding table Error: %@", err);

                                  VerifyOrReturn(CheckValue("status", err, EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
                                  NextTest();
                              }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteBindingTableEndpoint1_4()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestBinding * cluster = [[CHIPTestBinding alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id bindingArgument;
        {
            NSMutableArray * temp_0 = [[NSMutableArray alloc] init];
            temp_0[0] = [[CHIPBindingClusterTargetStruct alloc] init];
            ((CHIPBindingClusterTargetStruct *) temp_0[0]).group = [NSNumber numberWithUnsignedShort:1U];
            ((CHIPBindingClusterTargetStruct *) temp_0[0]).fabricIndex = [NSNumber numberWithUnsignedChar:0];

            temp_0[1] = [[CHIPBindingClusterTargetStruct alloc] init];
            ((CHIPBindingClusterTargetStruct *) temp_0[1]).node = [NSNumber numberWithUnsignedLongLong:1ULL];
            ((CHIPBindingClusterTargetStruct *) temp_0[1]).endpoint = [NSNumber numberWithUnsignedShort:1U];
            ((CHIPBindingClusterTargetStruct *) temp_0[1]).cluster = [NSNumber numberWithUnsignedInt:6UL];
            ((CHIPBindingClusterTargetStruct *) temp_0[1]).fabricIndex = [NSNumber numberWithUnsignedChar:0];

            temp_0[2] = [[CHIPBindingClusterTargetStruct alloc] init];
            ((CHIPBindingClusterTargetStruct *) temp_0[2]).node = [NSNumber numberWithUnsignedLongLong:2ULL];
            ((CHIPBindingClusterTargetStruct *) temp_0[2]).endpoint = [NSNumber numberWithUnsignedShort:1U];
            ((CHIPBindingClusterTargetStruct *) temp_0[2]).fabricIndex = [NSNumber numberWithUnsignedChar:0];

            bindingArgument = temp_0;
        }
        [cluster writeAttributeBindingWithValue:bindingArgument
                              completionHandler:^(NSError * _Nullable err) {
                                  NSLog(@"Write binding table (endpoint 1) Error: %@", err);

                                  VerifyOrReturn(CheckValue("status", err, 0));

                                  NextTest();
                              }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadBindingTableEndpoint1_5()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestBinding * cluster = [[CHIPTestBinding alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        CHIPReadParams * params = [[CHIPReadParams alloc] init];
        params.fabricFiltered = [NSNumber numberWithBool:true];
        [cluster
            readAttributeBindingWithParams:params
                         completionHandler:^(NSArray * _Nullable value, NSError * _Nullable err) {
                             NSLog(@"Read binding table (endpoint 1) Error: %@", err);

                             VerifyOrReturn(CheckValue("status", err, 0));

                             {
                                 id actualValue = value;
                                 VerifyOrReturn(CheckValue("Binding", [actualValue count], static_cast<uint32_t>(3)));
                                 VerifyOrReturn(CheckValue("Group", ((CHIPBindingClusterTargetStruct *) actualValue[0]).group, 1U));
                                 VerifyOrReturn(
                                     CheckValue("FabricIndex", ((CHIPBindingClusterTargetStruct *) actualValue[0]).fabricIndex, 1));
                                 VerifyOrReturn(CheckValue("Node", ((CHIPBindingClusterTargetStruct *) actualValue[1]).node, 1ULL));
                                 VerifyOrReturn(
                                     CheckValue("Endpoint", ((CHIPBindingClusterTargetStruct *) actualValue[1]).endpoint, 1U));
                                 VerifyOrReturn(
                                     CheckValue("Cluster", ((CHIPBindingClusterTargetStruct *) actualValue[1]).cluster, 6UL));
                                 VerifyOrReturn(
                                     CheckValue("FabricIndex", ((CHIPBindingClusterTargetStruct *) actualValue[1]).fabricIndex, 1));
                                 VerifyOrReturn(CheckValue("Node", ((CHIPBindingClusterTargetStruct *) actualValue[2]).node, 2ULL));
                                 VerifyOrReturn(
                                     CheckValue("Endpoint", ((CHIPBindingClusterTargetStruct *) actualValue[2]).endpoint, 1U));
                                 VerifyOrReturn(
                                     CheckValue("FabricIndex", ((CHIPBindingClusterTargetStruct *) actualValue[2]).fabricIndex, 1));
                             }

                             NextTest();
                         }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestWriteBindingTableEndpoint0_6()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestBinding * cluster = [[CHIPTestBinding alloc] initWithDevice:device endpoint:0 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        id bindingArgument;
        {
            NSMutableArray * temp_0 = [[NSMutableArray alloc] init];
            temp_0[0] = [[CHIPBindingClusterTargetStruct alloc] init];
            ((CHIPBindingClusterTargetStruct *) temp_0[0]).node = [NSNumber numberWithUnsignedLongLong:3ULL];
            ((CHIPBindingClusterTargetStruct *) temp_0[0]).endpoint = [NSNumber numberWithUnsignedShort:1U];
            ((CHIPBindingClusterTargetStruct *) temp_0[0]).fabricIndex = [NSNumber numberWithUnsignedChar:0];

            bindingArgument = temp_0;
        }
        [cluster writeAttributeBindingWithValue:bindingArgument
                              completionHandler:^(NSError * _Nullable err) {
                                  NSLog(@"Write binding table (endpoint 0) Error: %@", err);

                                  VerifyOrReturn(CheckValue("status", err, 0));

                                  NextTest();
                              }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadBindingTableEndpoint0_7()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestBinding * cluster = [[CHIPTestBinding alloc] initWithDevice:device endpoint:0 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        CHIPReadParams * params = [[CHIPReadParams alloc] init];
        params.fabricFiltered = [NSNumber numberWithBool:true];
        [cluster
            readAttributeBindingWithParams:params
                         completionHandler:^(NSArray * _Nullable value, NSError * _Nullable err) {
                             NSLog(@"Read binding table (endpoint 0) Error: %@", err);

                             VerifyOrReturn(CheckValue("status", err, 0));

                             {
                                 id actualValue = value;
                                 VerifyOrReturn(CheckValue("Binding", [actualValue count], static_cast<uint32_t>(1)));
                                 VerifyOrReturn(CheckValue("Node", ((CHIPBindingClusterTargetStruct *) actualValue[0]).node, 3ULL));
                                 VerifyOrReturn(
                                     CheckValue("Endpoint", ((CHIPBindingClusterTargetStruct *) actualValue[0]).endpoint, 1U));
                                 VerifyOrReturn(
                                     CheckValue("FabricIndex", ((CHIPBindingClusterTargetStruct *) actualValue[0]).fabricIndex, 1));
                             }

                             NextTest();
                         }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestVerifyEndpoint1NotChanged_8()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestBinding * cluster = [[CHIPTestBinding alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        CHIPReadParams * params = [[CHIPReadParams alloc] init];
        params.fabricFiltered = [NSNumber numberWithBool:true];
        [cluster
            readAttributeBindingWithParams:params
                         completionHandler:^(NSArray * _Nullable value, NSError * _Nullable err) {
                             NSLog(@"Verify endpoint 1 not changed Error: %@", err);

                             VerifyOrReturn(CheckValue("status", err, 0));

                             {
                                 id actualValue = value;
                                 VerifyOrReturn(CheckValue("Binding", [actualValue count], static_cast<uint32_t>(3)));
                                 VerifyOrReturn(CheckValue("Group", ((CHIPBindingClusterTargetStruct *) actualValue[0]).group, 1U));
                                 VerifyOrReturn(
                                     CheckValue("FabricIndex", ((CHIPBindingClusterTargetStruct *) actualValue[0]).fabricIndex, 1));
                                 VerifyOrReturn(CheckValue("Node", ((CHIPBindingClusterTargetStruct *) actualValue[1]).node, 1ULL));
                                 VerifyOrReturn(
                                     CheckValue("Endpoint", ((CHIPBindingClusterTargetStruct *) actualValue[1]).endpoint, 1U));
                                 VerifyOrReturn(
                                     CheckValue("Cluster", ((CHIPBindingClusterTargetStruct *) actualValue[1]).cluster, 6UL));
                                 VerifyOrReturn(
                                     CheckValue("FabricIndex", ((CHIPBindingClusterTargetStruct *) actualValue[1]).fabricIndex, 1));
                                 VerifyOrReturn(CheckValue("Node", ((CHIPBindingClusterTargetStruct *) actualValue[2]).node, 2ULL));
                                 VerifyOrReturn(
                                     CheckValue("Endpoint", ((CHIPBindingClusterTargetStruct *) actualValue[2]).endpoint, 1U));
                                 VerifyOrReturn(
                                     CheckValue("FabricIndex", ((CHIPBindingClusterTargetStruct *) actualValue[2]).fabricIndex, 1));
                             }

                             NextTest();
                         }];

        return CHIP_NO_ERROR;
    }
};

class Test_TC_SWDIAG_1_1 : public TestCommandBridge {
public:
    Test_TC_SWDIAG_1_1()
        : TestCommandBridge("Test_TC_SWDIAG_1_1")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_SWDIAG_1_1() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_SWDIAG_1_1\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_SWDIAG_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Reads a list of ThreadMetrics struct non-global attribute from DUT.\n");
            if (ShouldSkip("A_THREADMETRICS")) {
                NextTest();
                return;
            }
            err = TestReadsAListOfThreadMetricsStructNonGlobalAttributeFromDut_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Reads CurrentHeapFree non-global attribute value from DUT\n");
            err = TestReadsCurrentHeapFreeNonGlobalAttributeValueFromDut_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Reads CurrentHeapUsed non-global attribute value from DUT\n");
            if (ShouldSkip("A_CURRENTHEAPUSED")) {
                NextTest();
                return;
            }
            err = TestReadsCurrentHeapUsedNonGlobalAttributeValueFromDut_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Reads CurrentHeapHighWaterMark non-global attribute value from DUT\n");
            if (ShouldSkip("A_CURRENTHEAPHIGHWATERMARK")) {
                NextTest();
                return;
            }
            err = TestReadsCurrentHeapHighWaterMarkNonGlobalAttributeValueFromDut_4();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 5;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsAListOfThreadMetricsStructNonGlobalAttributeFromDut_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestSoftwareDiagnostics * cluster = [[CHIPTestSoftwareDiagnostics alloc] initWithDevice:device
                                                                                           endpoint:0
                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeThreadMetricsWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads a list of ThreadMetrics struct non-global attribute from DUT. Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("threadMetrics", "", "list"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsCurrentHeapFreeNonGlobalAttributeValueFromDut_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestSoftwareDiagnostics * cluster = [[CHIPTestSoftwareDiagnostics alloc] initWithDevice:device
                                                                                           endpoint:0
                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeCurrentHeapFreeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads CurrentHeapFree non-global attribute value from DUT Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("currentHeapFree", "", "uint64"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsCurrentHeapUsedNonGlobalAttributeValueFromDut_3()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestSoftwareDiagnostics * cluster = [[CHIPTestSoftwareDiagnostics alloc] initWithDevice:device
                                                                                           endpoint:0
                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeCurrentHeapUsedWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads CurrentHeapUsed non-global attribute value from DUT Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("currentHeapUsed", "", "uint64"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsCurrentHeapHighWaterMarkNonGlobalAttributeValueFromDut_4()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestSoftwareDiagnostics * cluster = [[CHIPTestSoftwareDiagnostics alloc] initWithDevice:device
                                                                                           endpoint:0
                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeCurrentHeapHighWatermarkWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads CurrentHeapHighWaterMark non-global attribute value from DUT Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("currentHeapHighWatermark", "", "uint64"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
};

class Test_TC_SWDIAG_2_1 : public TestCommandBridge {
public:
    Test_TC_SWDIAG_2_1()
        : TestCommandBridge("Test_TC_SWDIAG_2_1")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_SWDIAG_2_1() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_SWDIAG_2_1\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_SWDIAG_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;
};

class Test_TC_SWDIAG_3_1 : public TestCommandBridge {
public:
    Test_TC_SWDIAG_3_1()
        : TestCommandBridge("Test_TC_SWDIAG_3_1")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_SWDIAG_3_1() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_SWDIAG_3_1\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_SWDIAG_3_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Sends ResetWatermarks to DUT\n");
            if (ShouldSkip("CR_RESETWATERMARKS")) {
                NextTest();
                return;
            }
            err = TestSendsResetWatermarksToDut_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Reads CurrentHeapUsed attribute value from DUT\n");
            if (ShouldSkip("A_CURRENTHEAPUSED")) {
                NextTest();
                return;
            }
            err = TestReadsCurrentHeapUsedAttributeValueFromDut_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Reads CurrentHeapHighWaterMark attribute value from DUT\n");
            if (ShouldSkip("A_CURRENTHEAPHIGHWATERMARK")) {
                NextTest();
                return;
            }
            err = TestReadsCurrentHeapHighWaterMarkAttributeValueFromDut_3();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 4;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSendsResetWatermarksToDut_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestSoftwareDiagnostics * cluster = [[CHIPTestSoftwareDiagnostics alloc] initWithDevice:device
                                                                                           endpoint:0
                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster resetWatermarksWithCompletionHandler:^(NSError * _Nullable err) {
            NSLog(@"Sends ResetWatermarks to DUT Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsCurrentHeapUsedAttributeValueFromDut_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestSoftwareDiagnostics * cluster = [[CHIPTestSoftwareDiagnostics alloc] initWithDevice:device
                                                                                           endpoint:0
                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeCurrentHeapUsedWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads CurrentHeapUsed attribute value from DUT Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("currentHeapUsed", "", "uint64"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestReadsCurrentHeapHighWaterMarkAttributeValueFromDut_3()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestSoftwareDiagnostics * cluster = [[CHIPTestSoftwareDiagnostics alloc] initWithDevice:device
                                                                                           endpoint:0
                                                                                              queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster readAttributeCurrentHeapHighWatermarkWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Reads CurrentHeapHighWaterMark attribute value from DUT Error: %@", err);

            if (err.code == MatterInteractionErrorCodeUnsupportedAttribute) {
                NextTest();
                return;
            }

            VerifyOrReturn(CheckValue("status", err, 0));

            VerifyOrReturn(CheckConstraintType("currentHeapHighWatermark", "", "uint64"));
            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
};

class TestSubscribe_OnOff : public TestCommandBridge {
public:
    TestSubscribe_OnOff()
        : TestCommandBridge("TestSubscribe_OnOff")
        , mTestIndex(0)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~TestSubscribe_OnOff() {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Start: TestSubscribe_OnOff\n");
        }

        if (mTestCount == mTestIndex) {
            ChipLogProgress(chipTool, " **** Test Complete: TestSubscribe_OnOff\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++) {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Set OnOff Attribute to false\n");
            err = TestSetOnOffAttributeToFalse_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Report: Subscribe OnOff Attribute\n");
            err = TestReportSubscribeOnOffAttribute_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Subscribe OnOff Attribute\n");
            err = TestSubscribeOnOffAttribute_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Turn On the light to see attribute change\n");
            err = TestTurnOnTheLightToSeeAttributeChange_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Check for attribute report\n");
            err = TestCheckForAttributeReport_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Turn Off the light to see attribute change\n");
            err = TestTurnOffTheLightToSeeAttributeChange_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Check for attribute report\n");
            err = TestCheckForAttributeReport_7();
            break;
        }

        if (CHIP_NO_ERROR != err) {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 8;

    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSetOnOffAttributeToFalse_1()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster offWithCompletionHandler:^(NSError * _Nullable err) {
            NSLog(@"Set OnOff Attribute to false Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }
    bool testSendClusterTestSubscribe_OnOff_000002_WaitForReport_Fulfilled = false;
    ResponseHandler _Nullable test_TestSubscribe_OnOff_OnOff_Reported = nil;

    CHIP_ERROR TestReportSubscribeOnOffAttribute_2()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        test_TestSubscribe_OnOff_OnOff_Reported = ^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Report: Subscribe OnOff Attribute Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("OnOff", actualValue, false));
            }

            testSendClusterTestSubscribe_OnOff_000002_WaitForReport_Fulfilled = true;
        };

        NextTest();
        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestSubscribeOnOffAttribute_3()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        uint16_t minIntervalArgument = 2U;
        uint16_t maxIntervalArgument = 5U;
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeOnOffWithMinInterval:[NSNumber numberWithUnsignedInt:minIntervalArgument]
            maxInterval:[NSNumber numberWithUnsignedInt:maxIntervalArgument]
            params:params
            subscriptionEstablished:^{
                VerifyOrReturn(testSendClusterTestSubscribe_OnOff_000002_WaitForReport_Fulfilled,
                    SetCommandExitStatus(CHIP_ERROR_INCORRECT_STATE));
                NextTest();
            }
            reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable err) {
                NSLog(@"Subscribe OnOff Attribute Error: %@", err);

                VerifyOrReturn(CheckValue("status", err, 0));
                if (test_TestSubscribe_OnOff_OnOff_Reported != nil) {
                    ResponseHandler callback = test_TestSubscribe_OnOff_OnOff_Reported;
                    test_TestSubscribe_OnOff_OnOff_Reported = nil;
                    callback(value, err);
                }
            }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestTurnOnTheLightToSeeAttributeChange_4()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster onWithCompletionHandler:^(NSError * _Nullable err) {
            NSLog(@"Turn On the light to see attribute change Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestCheckForAttributeReport_5()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        test_TestSubscribe_OnOff_OnOff_Reported = ^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Check for attribute report Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("OnOff", actualValue, true));
            }

            NextTest();
        };

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestTurnOffTheLightToSeeAttributeChange_6()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        [cluster offWithCompletionHandler:^(NSError * _Nullable err) {
            NSLog(@"Turn Off the light to see attribute change Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            NextTest();
        }];

        return CHIP_NO_ERROR;
    }

    CHIP_ERROR TestCheckForAttributeReport_7()
    {
        CHIPDevice * device = GetConnectedDevice();
        CHIPTestOnOff * cluster = [[CHIPTestOnOff alloc] initWithDevice:device endpoint:1 queue:mCallbackQueue];
        VerifyOrReturnError(cluster != nil, CHIP_ERROR_INCORRECT_STATE);

        test_TestSubscribe_OnOff_OnOff_Reported = ^(NSNumber * _Nullable value, NSError * _Nullable err) {
            NSLog(@"Check for attribute report Error: %@", err);

            VerifyOrReturn(CheckValue("status", err, 0));

            {
                id actualValue = value;
                VerifyOrReturn(CheckValue("OnOff", actualValue, false));
            }

            NextTest();
        };

        return CHIP_NO_ERROR;
    }
};

void registerCommandsTests(Commands & commands)
{
    const char * clusterName = "Tests";

    commands_list clusterCommands = {
        make_unique<TestList>(),
        make_unique<ManualTestList>(),
        make_unique<TestAccessControlCluster>(),
        make_unique<Test_TC_BI_1_1>(),
        make_unique<Test_TC_BI_2_1>(),
        make_unique<Test_TC_BI_2_2>(),
        make_unique<Test_TC_BOOL_1_1>(),
        make_unique<Test_TC_BOOL_2_1>(),
        make_unique<Test_TC_BRAC_1_1>(),
        make_unique<Test_TC_CC_1_1>(),
        make_unique<Test_TC_CC_2_1>(),
        make_unique<Test_TC_CC_3_1>(),
        make_unique<Test_TC_CC_3_2>(),
        make_unique<Test_TC_CC_3_3>(),
        make_unique<Test_TC_CC_4_1>(),
        make_unique<Test_TC_CC_4_2>(),
        make_unique<Test_TC_CC_4_3>(),
        make_unique<Test_TC_CC_4_4>(),
        make_unique<Test_TC_CC_5_1>(),
        make_unique<Test_TC_CC_5_2>(),
        make_unique<Test_TC_CC_5_3>(),
        make_unique<Test_TC_CC_6_1>(),
        make_unique<Test_TC_CC_6_2>(),
        make_unique<Test_TC_CC_6_3>(),
        make_unique<Test_TC_CC_7_1>(),
        make_unique<Test_TC_CC_7_2>(),
        make_unique<Test_TC_CC_7_3>(),
        make_unique<Test_TC_CC_7_4>(),
        make_unique<Test_TC_CC_8_1>(),
        make_unique<Test_TC_CC_9_1>(),
        make_unique<Test_TC_CC_9_2>(),
        make_unique<Test_TC_CC_9_3>(),
        make_unique<Test_TC_DD_1_5>(),
        make_unique<Test_TC_DD_1_6>(),
        make_unique<Test_TC_DD_1_7>(),
        make_unique<Test_TC_DD_1_8>(),
        make_unique<Test_TC_DD_1_9>(),
        make_unique<Test_TC_DM_1_1>(),
        make_unique<Test_TC_DM_3_1>(),
        make_unique<Test_TC_EMR_1_1>(),
        make_unique<Test_TC_ETHDIAG_1_1>(),
        make_unique<Test_TC_ETHDIAG_2_1>(),
        make_unique<Test_TC_FLW_1_1>(),
        make_unique<Test_TC_FLW_2_1>(),
        make_unique<Test_TC_FLW_2_2>(),
        make_unique<Test_TC_ILL_1_1>(),
        make_unique<Test_TC_LVL_1_1>(),
        make_unique<Test_TC_LVL_2_1>(),
        make_unique<Test_TC_LVL_2_2>(),
        make_unique<Test_TC_LVL_3_1>(),
        make_unique<Test_TC_LVL_4_1>(),
        make_unique<Test_TC_LVL_5_1>(),
        make_unique<Test_TC_LVL_6_1>(),
        make_unique<Test_TC_MC_1_1>(),
        make_unique<Test_TC_MC_2_1>(),
        make_unique<Test_TC_MC_3_1>(),
        make_unique<Test_TC_MC_3_2>(),
        make_unique<Test_TC_MC_3_3>(),
        make_unique<Test_TC_MC_3_4>(),
        make_unique<Test_TC_MC_3_5>(),
        make_unique<Test_TC_MC_3_6>(),
        make_unique<Test_TC_MC_3_7>(),
        make_unique<Test_TC_MC_3_8>(),
        make_unique<Test_TC_MC_3_9>(),
        make_unique<Test_TC_MC_3_10>(),
        make_unique<Test_TC_MC_3_11>(),
        make_unique<Test_TC_MC_5_1>(),
        make_unique<Test_TC_MC_5_2>(),
        make_unique<Test_TC_MC_5_3>(),
        make_unique<Test_TC_MC_6_1>(),
        make_unique<Test_TC_MC_6_2>(),
        make_unique<Test_TC_MC_6_3>(),
        make_unique<Test_TC_MC_6_4>(),
        make_unique<Test_TC_MC_7_1>(),
        make_unique<Test_TC_MC_7_2>(),
        make_unique<Test_TC_MC_8_1>(),
        make_unique<Test_TC_MC_9_1>(),
        make_unique<Test_TC_OCC_1_1>(),
        make_unique<Test_TC_OCC_2_1>(),
        make_unique<Test_TC_OCC_2_2>(),
        make_unique<Test_TC_OO_1_1>(),
        make_unique<Test_TC_OO_2_1>(),
        make_unique<Test_TC_OO_2_2>(),
        make_unique<Test_TC_OO_2_3>(),
        make_unique<Test_TC_PS_1_1>(),
        make_unique<Test_TC_PRS_1_1>(),
        make_unique<Test_TC_PRS_2_1>(),
        make_unique<Test_TC_PCC_1_1>(),
        make_unique<Test_TC_PCC_2_1>(),
        make_unique<Test_TC_PCC_2_2>(),
        make_unique<Test_TC_PCC_2_3>(),
        make_unique<Test_TC_RH_1_1>(),
        make_unique<Test_TC_RH_2_1>(),
        make_unique<Test_TC_RH_2_2>(),
        make_unique<Test_TC_SWTCH_2_1>(),
        make_unique<Test_TC_SWTCH_2_2>(),
        make_unique<Test_TC_TM_1_1>(),
        make_unique<Test_TC_TM_2_1>(),
        make_unique<Test_TC_TM_2_2>(),
        make_unique<Test_TC_TSTAT_1_1>(),
        make_unique<Test_TC_TSTAT_2_1>(),
        make_unique<Test_TC_TSTAT_2_2>(),
        make_unique<Test_TC_TSUIC_1_1>(),
        make_unique<Test_TC_TSUIC_2_1>(),
        make_unique<Test_TC_TSUIC_2_2>(),
        make_unique<Test_TC_DIAG_TH_NW_1_1>(),
        make_unique<Test_TC_WIFIDIAG_1_1>(),
        make_unique<Test_TC_WIFIDIAG_3_1>(),
        make_unique<Test_TC_WNCV_1_1>(),
        make_unique<Test_TC_WNCV_2_1>(),
        make_unique<Test_TC_WNCV_2_2>(),
        make_unique<Test_TC_WNCV_2_4>(),
        make_unique<Test_TC_WNCV_2_5>(),
        make_unique<Test_TC_WNCV_3_4>(),
        make_unique<Test_TC_WNCV_3_5>(),
        make_unique<Test_TC_WNCV_4_3>(),
        make_unique<Test_TC_WNCV_4_4>(),
        make_unique<TestCluster>(),
        make_unique<TestSaveAs>(),
        make_unique<TestConstraints>(),
        make_unique<TestDelayCommands>(),
        make_unique<TestDescriptorCluster>(),
        make_unique<TestBasicInformation>(),
        make_unique<TestGroupsCluster>(),
        make_unique<TestGroupKeyManagementCluster>(),
        make_unique<TestIdentifyCluster>(),
        make_unique<TestLogCommands>(),
        make_unique<TestOperationalCredentialsCluster>(),
        make_unique<TestBinding>(),
        make_unique<Test_TC_SWDIAG_1_1>(),
        make_unique<Test_TC_SWDIAG_2_1>(),
        make_unique<Test_TC_SWDIAG_3_1>(),
        make_unique<TestSubscribe_OnOff>(),
    };

    commands.Register(clusterName, clusterCommands);
}
